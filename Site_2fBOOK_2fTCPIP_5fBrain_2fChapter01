#title 뇌를 자극하는 TCP/IP 장별 노트 - 1장

[[TableOfContents]]
 * 2011/3/21일
이 위키는 '''뇌를 자극하는 TCP/IP 소켓 프로그래밍'''에서 다루지 못한 이야기들을 정리하기 위해서 만들고 있습니다. 각 장별로 꾸준히 유지해 나갈 생각입니다. 궁금한 것은 아래 사이트로 피드백 해주시면 됩니다.
   1. 이 문서 제일 밑에 있는 소셜 댓글 시스템
   1. http://ask.joinc.co.kr : Joinc QA사이트
   1. http://www.facebook.com/home.php?sk=group_148794635169144&ap=1 : Joinc Face Book (공개)그룹
   1. http://www.facebook.com/home.php?sk=group_173384652709664&ap=1 : 뇌를 자극 하는 TCP/IP 소켓 프로그래밍 (공개)그룹 
피드백 내용은 지속적으로 문서에 반영하도록 하겠습니다. 많은 참여 부탁드립니다.

== 소개 ==
1장에서는 컴퓨터 네트워크와 인터넷에 대해서 개략적으로 다룹니다. 핵심은 인류 문명의 역사는 네트워크와 함께 하고 있다는 것입니다. 그 중 가장 최근에 등장한 것이 인터넷 네트워크라는 식으로 이야기를 이끌어 나가고 있습니다.

그리고 인터넷 프로토콜에 대해서 간단히 설명하고 있는데요. 말그대로 맛만 보여주고 있는데요. 그대로 넘어가기에는 좀 아쉬움이 많이 남습니다. 그래서 지면 관계상 대략 설명하고 넘어간 부분들에 대해서 참고할 만한 텍스트를 소개할까 합니다.

== 인터넷의 역사 ==
인터넷의 역사는 [wiki:man/12/internet 인터넷의 작은 역사를 참고하시기 바랍니다. 책에서 설명하지 못한 인터넷의 비하인드 스토리를 읽을 수 있습니다. 군사/상업/연구분야에서 독자적으로 개발되던 인터넷의 개념들이 하나로 묶여서 현대적인 인터넷이 만들어지게 된 과정을 동영상과 함께 이해하기 쉽게 설명하고 있습니다.

== OSI 7계층과 TCP/IP 4계층 ==
인터넷은 OSI7계층과 TCP/IP 4계층을 빼놓고는 생각할 수가 없습니다. 네트워크 프로그래밍 영역 뿐만 아니라 시스템/네트워크 관리에서도 반드시 필요한 개념이죠. 실제 현업에서는 '''L7 프로토콜, L4 스위치, 그 소프트웨어는 L2 레벨에서 작동하므로 이러이러한 일을 할 수 있다.'''와 같은 대화가 일상적으로 오갑니다. L은 Layer 즉 계층의 줄임말로 OSI 7Layer의 각 계층의 줄임말입니다. L2는 OSI 7계층에서 2계층을 의미하는 줄임말이죠.

때때로 '''용어'''가 뭐 그리 중요하냐. 전문적인 용어 쓰면 왠지 있어보이는 것 같아서 쓸데 업이 쓰는 것에 지나지 않는다라고 평가절하하기도 합니다. 확실히 그렇기는 합니다. 그냥 원래 용어대로 쓰면 될건데, 왠 출처가 불명확한 줄임말이 그리 많은지..

하지만 반드시 알아둬야 할 것들도 있죠. 바로 OSI7, TCP/IP4 계층입니다. 책에서는 TCP/IP4계층을 위주로 설명하고 있는데요. 업무현장에서는 OSI7 계층을 가지고 커뮤니케이션 합니다. 

=== OSI 7 상세 프로토콜들 ===
책에서는 OSI 7이 있다는 정도만 소개했는데요. 각 계층별 프로토콜들의 자세한 목록을 정리했습니다. TCP/IP 스위트 부분을 유심히 보시면 됩니다.
|| '''계층''' || 계층 이름  || '''기타'''     || '''TCP/IP 스위트'''                          ||
|| 1 계층 || 물리 || RS-232, V.35, V.34, ISDN, SONET      ||                      ||
|| 2 계층 || 데이터링크 || 이더넷, 토큰링, FDDI, PPP, HDLC, ATM  ||                    ||
|| 3 계층 || 네트워크 || NetBEUI, Q.931     || IP(:12), ICMP(:12), IPSec, ARP(:12), RIP(:12), BGP        ||
|| 4 계층 || 전송 || NetBEUI              || TCP(:12), UDP(:12), RTP, SCTP                 ||
|| 5 계층 || 세션 || FIFO, NetBIOS, SAP   || TCP의 세션관리 부분                 ||
|| 6 계층 || 표현 || TDI, ASCII, EBCDIC, MIDI, MPEG || XDR, SSL, TLS             ||
|| 7 계층 || 응용 || HL7, Modbus, SIP  || HTTP(:12), SMTP(:12), SNMP, FTP, TELNET, NFS ... ||
  1. HTTP, FTP, TELNET는 다들 아실테구요. NFS는 유닉스에서 파일 시스템 공유를 위해 사용하는 프로토콜입니다. SMTP는 이메일을 위해서, SNMP(:12)는 시스템 관리를 위해서 사용하는 프로토콜이고요.
  1. ASCII(:12)는 인터넷 상에서 텍스트 파일을 표현하기 위한 표준형식입니다. EBCDIC도 ASCII와 처럼 알파벳 숫자를 표현하기 위한 형식인데요. IBM에서 개발한 프로토콜입니다. MIDI와 MPEG는 아시죠 ? MIDI는 사운드 카드에서 녹음과 재생을 위한 프로토콜, MPEG는 디지털 비디오와 오디오 압축을 위한 표준 프로토콜입니다. SSL(:12), TLS는 암호화 통신을 위해서 사용하는 프로토콜이고요.
  1. TCP의 세션 관리 부분이 여기에 포함됩니다. 
  1. 익숙한 TCP, UDP가 등장하네요. 
  1. IP가 있습니다. ICMP(:12)는 원격 컴퓨터의 네트워크 상태를 체크하기 위한 프로토콜입니다. ping(:12) 프로그램이 사용하는 프로토콜이죠. IPSec은 VPN에서 보안 터널을 뚫기 위해서 사용하는 프로토콜이고요. ARP와 RIP은 문서에서 자세히 다루도록 하겠습니다. 
  1. 이더넷, 토큰링, ATM 
  1. 여기는 물리적인 인터페이스를 정의합니다. 컴퓨터 전공이거나 혹은 컴퓨터 하드웨어 가지고 놀기 좋아하시는 분이라면 RS-232 많이들 들어봤을 겁니다. PC와 모뎀, 음향, 프린터등을 접속하기 위해서 사용하는 직렬포트죠. 보통 직렬포트라고 부르는데요. USB로 대체되는 추세입니다. 

RS-232 직렬포트
{{{#!html
<table style="width:auto;"><tr><td><a href="https://picasaweb.google.com/lh/photo/wuEKvOzFA_BoIdBoXXkkBQ?feat=embedwebsite"><img src="https://lh4.googleusercontent.com/_Os5qf5urx_A/TYi4YRm-1MI/AAAAAAAABtM/TSqwLdf0DXM/s288/USB_to_RS232_cable.jpg" height="288" width="288" /></a></td></tr><tr><td style="font-family:arial,sans-serif; font-size:11px; text-align:right">보낸 사람 <a href="https://picasaweb.google.com/yundream/Linux?feat=embedwebsite">Linux</a></td></tr></table>
}}}

=== 인터넷을 통한 데이터 전송 자세히 살펴보기 ===
==== GateWay로 패킷 보내기 ====
책에서는 아주 간단하게 설명하고 있는데요. 좀 더 자세히 설명해볼까 합니다.

먼저 패킷이 인터넷으로 나가기 전까지의 과정을 좀 더 자세히 살펴 보겠습니다. OSI7계층을 거치면서 완전한 패킷이 만들어졌다고 가정하겠습니다. 이제 이 패킷은 두 개의 삶중 하나를 선택하게 됩니다.
   1. 지역 네트워크의 다른 컴퓨터로 향한다. 
   1. 외부 네트워크로 향한다.
그럼 패킷을 외부로 보낼지 아니면 내부의 다른 컴퓨터로 보낼지를 어떻게 결정할 수 있을까요 ? 이 작업은 역시 경로 배정기 즉 라우터가 담당하게 됩니다. 일단 패킷이 만들어 지면, 이 패킷은 gateway 컴퓨터로 보내지게 되는데요. 보통 gateway 컴퓨터는 소형 라우터인 경우가 많습니다.  

물론 그냥 gateway 컴퓨터로 패킷이 보내지는 건 아니죠. 컴퓨터는 말 그대로 깡통입니다. 컴퓨터 바깥으로 나간 패킷을 gateway 컴퓨터로 보내라고 "경로 설정"을 해줘야 합니다. 이 경로 설정 테이블을 '''routing table'''이라고 합니다. '''route'''라는 프로그램을 이용해서 경로를 설정하고, 설정된 경로의 내용을 확인할 수 있습니다. 지금 route 명령을 실행시켜 보세요. 대략 다음과 같은 결과를 확인할 수 있을 겁니다.
{{{#!plain
# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
218.234.19.0    *               255.255.255.0   U     0      0        0 eth0
169.254.0.0     *               255.255.0.0     U     0      0        0 eth0
127.0.0.0       *               255.0.0.0       U     0      0        0 lo
default         218.234.19.1    0.0.0.0         UG    0      0        0 eth0
}}}
제일 마지막에 보면 '''default  218.234.19.1'''이 보일 겁니다. 이게 default gateway 입니다. 컴퓨터 바깥으로 나간 패킷은 218.234.19.1 주소를 가지는 GateWay 컴퓨터로 향합니다. 이때 사용하는 인터페이스는 "eth0"이구요. 이 라우팅 테이블은 제 개인 컴퓨터에서 확인한 겁니다. 일반적으로 개인 컴퓨터는 하나의 인터페이스만을 가지기 때문에 위에서 처럼 간단한 라우팅 테이블을 가지지만, 라우터는 여러개의 인터페이스를 가지며 복잡한 라우팅 테이블을 가집니다.  

Gateway 컴퓨터는 경로를 설정하기 위한 소프트웨어를 탑재하고 있습니다. 이 소프트웨어는 패킷의 IP 주소 정보를 읽어서, 내부로 보내야 할지 아니면 외부로 보내야 할지를 결정합니다. IP 주소가 218.234.19.xxx 이라면 내부로 그렇지 않으면 외부로 보내겠죠 ? 

gateway 컴퓨터 역시, 라우팅 테이블로 패킷의 방향을 결정합니다. 

덤으로 route 명령을 사용하는 방법입니다.
{{{#!plain
// 192.168.0.x 네트워크의 라우트 경로를 eth0에 추가합니다.
// 목적지가 192.168.0.x인 패킷은 eth0으로 향합니다.
# route add -net 192.168.0.0 netmask 255.255.255.0  dev eth0 

// default gateway 추가
# route add default gw 192.168.0.1
}}}

==== 인터넷에서의 경로 설정 ====
Gatewasy를 거쳐서 인터넷으로 나온 패킷은 '''라우터'''를 경유하게 됩니다. 이들 라우터는 역시 라우팅 테이블을 유지하고 있는데요. 패킷의 IP 주소 정보를 확인해서 주변에 있는 라우터중 어느 곳으로 보내야 할지를 결정합니다. 

그렇다면 라우터는 어떻게 라우팅 테이블 정보를 유지할 까요 ? 네트워크 관리자가 주변 네트워크 상황을 확인해서 직접 관리할 수 있겠지만 이건 좋은 방법은 아니겠죠 ? 인터넷은 변화가 매우 심한 네트워크 입니다. 수시로 구성이 바뀝니다. 새로운 라우터가 추가되거나 제거되기도 하구요. 혹은 라우터가 존재하더라도 라우터의 고장이나 회선의 문제로 사용을 못할 때도 있습니다. 

때문에 라우터의 라우팅 테이블은 주변의 네트워크 환경을 이용해서 '''동적'''으로 구성이 되야 합니다. 이를 위해서 RIP 라는 프로토콜을 사용합니다. RIP는 Routing Information Protocol의 줄임말로 라우팅 정보를 관리하기 위해서 사용하는 프로토콜입니다. 라우터는 주변의 라우터들과 주기적으로 RIP 패킷을 주고 받는데요. 이때 주고 받은 정보를 이용해서 라우팅 테이블을 상황에 맞게 갱신할 수 있습니다.  

아래 그림은 RIP을 이용해서 라우팅 테이블 정보를 관리하는 것을 대략 보여주고 있습니다.

{{{#!html
<img src="https://docs.google.com/drawings/pub?id=1rJorey4i5bzZqjNKiPa0BHSbIBu69qqiHJJqsY9Gmkg&amp;w=598&amp;h=469">
}}}

A,B,C 3개의 라우터가 있다고 가정해보죠. 라우터 A의 테이블은 아래와 같을 겁니다.
{{{#!plain
# route add -net 192.168.1.0 netmask 255.255.255.0 eth0 
# route add -net 192.168.2.0 netmask 255.255.255.0 ppp0 
# route add -net 192.168.3.0 netmask 255.255.255.0 ppp1 
}}}
192.168.1.xxx로 향하는 패킷은 eth0, 2.xxx로 향하는 것은 ppp0, 3.xxx로 향하는 패킷은 ppp1로 보내라는 명령이 담겨있습니다.

그런데 A와 B의 케이블이 단절되었네요. 그럼 A<->B 경로를 이용할 수 없게 될건데요. 그렇다고 해서 데이터 전송을 포기하면 안되겠죠 ? A<->C<->B라는 경로를 사용하면 되니까요. A는 B로 향하던 패킷을 C로 향하도록 동적으로 갱신합니다. 나중에 A<->B 회선이 복구되면, RIP 패킷을 교환하면서 경로를 사용할 수 있다는 것을 환인하게 되겠죠 ? 그러면 경로를 다시 설정하면 됩니다. 한번에 갈 수 있는데, 굳이 C를 경유할 필요는 없으니까요

이렇게 라우터는 자동으로 주변 네트워크 상황을 확인하면서 최적의 라우팅 테이블을 구성하고, 이 라우팅 테이블을 이용해서 패킷을 보낼 경로를 결정합니다. 이렇게 작게는 몇개에서 많게는 수십개의 라우터를 거치면서 목적지에 도착하게 되는 거죠.   

==== 라우터는 몇 계층의 장비일까요 ? ====
자. 그럼 이 라우터는 OSI7 계층의 어느 레벨에서 작동하는 장비인지 알 수 있겠죠 ? IP를 가지고 패킷의 경로를 설정하니 IP가 포함된 계층을 확인하면 되죠. IP는 네트워크 계층인 3계층에서 작동하죠 ? 기본적으로 3계층에서 작동하는 장비임을 알 수 있습니다. 물론 이건 어디까지나 경로 설정과 관련된 작업에 대해서만 그렇다는 얘기구요. 일반적으로 라우터는 2계층 장비로 취급합니다. L2 장비인 셈이죠.

네트워크 관련된 경험을 해봤다면 L4 스위치, L7 스위치라는 얘기를 들어봤을 겁니다. 이들은 L4/L7 스위치 라우터의 줄임말입니다. 전자는 4계층을 커버하고 후자는 7계층까지 커버하는 라우터라는 의미가 담겨있습니다. 계층이 높아질 수록 다루어야하는 프로토콜의 양이 많아지니, 그만큼 복잡해지고 더 비싸겠죠 ?

L4 스위치는 웹에서 로드벨런싱을 위한 목적으로 널리 사용되고 있는데요. 트래픽이 많다면, 아래 그림처럼 하나의 웹 서비스를 위해서 여러 대의 웹 서버를 둬서 트래픽을 분산할 수 있을 겁니다. 

{{{#!html
<img src="https://docs.google.com/drawings/pub?id=16p2hDhetuSWv7_13uWa-u2G7XwOpXS3NDnxnOczl620&amp;w=707&amp;h=223">
}}}

그런데, 단순한 스위치라우터를 이용하면 트래픽 분산이 제대로 이루어지지 않습니다. 인터넷에서 데이터 전달은 패킷단위로 이루어지는데요. 이때문에 하나의 데이터가 여러 패킷으로 나눠서 전달될 수 있습니다. 그래서 특별한 장치 없이 저렇게 두면, 패킷의 흐름이 끊어지겠죠 ? 하나의 데이터가 여러개의 패킷으로 쪼개져서 하나는 1번 서버로 다른 하나는 3번 서버로 향할 수 있을테니까요.  

문제는 '''흐름'''이죠. 흐름을 관리하는 프로토콜은 4계층의 TCP죠 ? L4 스위치를 이용하면, 위의 문제를 해결해서 안전한 로드벨런싱이 가능합니다. 패킷의 TCP 정보를 확인해서, 어떤 서버로 보낼지를 결정할 수 있거든요.  

==== 패킷이 목적지 네트워크에 도착 했다면 ====
자. 이렇게 인터넷으로 나간 패킷은 라우터를 떠돌면서, 결국 목적 컴퓨터가 포함된 네트워크의 게이트웨이(gateway)까지 도달합니다. 

게이트웨이 컴퓨터는 패킷의 IP 정보를 분석해서 자신이 관리하는 네트워크로 향하는지 확인합니다. 자신이 관리하는 네트워크로 향하는 거라면, 역시 라우팅 테이블을 참고해서 해당 인터페이스로 패킷을 보내면 됩니다.  

여기에서 사용되는 프로토콜이 ARP(Address Resolution Protocol)입니다. 아이피는 컴퓨터에 부여되는게 아닙니다. 네트워트 인터페이스에 부여됩니다. 그런데 컴퓨터는 여러 개의 네트워크 인터페이스를 가질 수 있는데다가, 하나의 인터페이스에 하나 이상의 IP 주소를 할당할 수도 있습니다. 그러므로 게이트웨이 컴퓨터는 "IP 주소와 네트워크 인트페이스"의 맵핑 테이블을 가지고 있어야 합니다.      

그럴려면 네트워크 인터페이스의 이름을 알고 있어야 겠죠 ? 이 이름을 '''MAC Address''' 라고 합니다. 네트워크 인터페이스에 부여되는 고유한 이름이죠. 다음과 같은 형식을 가집니다.
{{{#!plain
00:25:b3:7b:f6:e8 
}}}

예컨데 IP는 00:25:b3:7b:f6:e8 이라는 Mac 주소를 가지는 인터페이스에 묶이는 거죠.

arp는 "요청 -> 응답"으로 이루어집니다. 상대 컴퓨터에 너가 관리하는 Mac Address와 할당된 IP주소 정보를 달라고 요청하는 식인 거죠. 게이트 웨이 컴퓨터는 주기적으로 ARP를 네트워크에 브로드캐스팅 해서 arp 테이블을 유지합니다. 

게이트 웨이 컴퓨터가 아닌 PC들도 arp 정보를 유지합니다. 일반 PC도 주변 네트워크 정보를 알고 있어야 하니까요. arp 명령으로 arp 테이블 정보를 확인할 수 있습니다.  
{{{#!plain
# arp -a
? (192.168.0.1) at 00:11:f3:1b:f1:17 [ether] on eth0
? (192.168.0.17) at 61:26:3d:33:04:13 [ether] on eth0
? (192.168.0.56) at 00:29:82:eb:5b:a1 [ether] on eth0
? (192.168.0.122) at 00:ee:76:33:1a:83 [ether] on eth0
}}}

컴퓨터에 도착한 패킷은 운영체제로 전달되고 최종적으로 응용 애플리케이션으로 유저 데이터가 복사됩니다.  

== 인터넷과 유닉스 ==
책에도 인터넷과 유닉스의 관계를 간단히 설명했는데요. 부연 설명을 드리도록 하겠습니다.

일단 네트워크 장비의 상당수는 여전히 유닉스 기반입니다. 유닉스가 다른 운영체제 보다 훌륭해서라는 것은 진정한 이유라고 하기 힘들겁니다. 다른 운영체제들도 충분한 수준의 강력함을 보여주고 있으니까요. 그럼에도 유닉스가 대다수를 차지하는 이유는 역사적인 이유가 가장 클겁니다. 유닉스에서 인터넷이 개발되고 발전되어 왔기 때문입니다. 그러다 보니, 네트워크 기술자와 프로그래머 들도 유닉스를 사용할 수 밖에 없었구요. 이미 설치된 네트워크 장비들도 유닉스 기반이다 보니 계속되는 순환구조를 만들게 된거죠. 

네트워크 관리 쪽은 유닉스 쪽은 무조건 필수고요. 프로그래밍 역시 서버쪽이라면 유닉스 환경은 필수라고 볼 수 있습니다. 아.. 유닉스에는 리눅스(:12)도 포함됩니다.

== 인터넷과 클라우드 컴퓨팅 ==
2010년 그리고 2011년의 화두는 아마 아이폰과 안드로이드 폰으로 대변되는 모바일 컴퓨팅과 클라우드 컴퓨팅일 거라고 생각합니다. 요즘에는 TV 광고에도 나오더라구요 ? 언제 어디서나 원하는 정보를 꺼내고 저장할 수 있는 클라우드 컴퓨팅 시스템. 클라우드 컴퓨팅 시스템이 부쩍 관심을 받는 이유는, 클라우드 컴퓨팅 기술이 모바일을 지원하는 핵심 기술이기 때문입니다.

모바일을 사용하는 이유는 시간과 장소의 제한 없이 자유롭게 정보에 접근하기 위해서입니다. 언제 어디서나 정보를 읽고 쓸수 있게 하겠다는 클라우드 컴퓨팅과 지향하는 바가 비슷하지 않나요 ? [wiki:man/12/cloud%20computing 클라우드 컴퓨터]에서 클라우드 컴퓨터가 무언지에 대해서 알아보세요.

== 인터넷의 미래 ==
인터넷의 미래를 예측하는 건 어려운 일입니다. 컴퓨터 천재 빌게이츠도 인터넷을 잘 못 예측하는 바람에 지금까지도 고생하고 있을 정도니까요. 그러니 제 말은 그냥 그럴 수도 있겠구나 하는 정도로 받아들이시면 됩니다. 

=== 웹으로 통합 ===
HTTP를 기반으로 하는 웹으로의 통합이 가속화될 것으로 보입니다. 요즘 가상화가 뜨고 있죠 ? 가상화가 뜨는 이유는 유휴자원을 최대한 활용할 수 있다는 점과 함께 기기에 상관없이 정보에 접근 가능하도록 만들어 준다는 장점 때문인데요. 그런 점에서 '''웹은 가장 강력하면서도 보편적인''' 가상화 도구거든요. 구글이 HTML5(:12)과 부라우저 기반의 Chrome OS에 집중하는 이유입니다. 이미 존재하는, 그것도 누구나 다 사용하는 가상화 도구가 있는데, 굳이 새로운 걸 개발할 필요가 없잖아요 ? 

웹 기술은 필수 기술이 될 것으로 생각됩니다. 

=== 플랫폼 지향 ===
플랫폼이란 말.. 참 애매모호한 말인데요. 서비스 사용자 생태계를 지원하기 위한 시스템을 플랫폼이라고 할 수 있습니다. 원하는 서비스를 이용하기 위해서 여기 저기 기웃거릴 필요가 없이 하나의 도메인에서 필요한 모든 서비스를 사용할 수 있는 통합된 시스템을 갖추는 거죠.  

구글을 예로 들어보죠. 검색, 메일, 정보공유, 문서작성, 프로젝트 관리, 채팅, 동영상 모든 걸 구글이라는 도메인에서 할 수 있게 만들어 뒀죠. 거기에 PC, 스마트폰, 태블릿 PC, 넷 북등 기기를 가리지도 않습니다. 말 그대로 플렛폼을 만든건데, 플렛폼은 만들어 놓으면 화물열차든 여객열차든 관광열차든 마음껏 드나들 수 있죠. 그걸 생각하시면 됩니다. 서비스의 종류와 장치, 운영체제에 관계 없이 서비스를 할 수 있는 시스템인 거죠. 

{{{#!html
<img src="https://docs.google.com/drawings/pub?id=1Ru-y4xJrMguaozxuEGBA1Gc-zVoI2toClH3pHienB-Q&amp;w=673&amp;h=641">
}}}

물론 플랫폼에서도 HTML 기반의 WWW는 가장 중요한 역할을 담당하게 될 겁니다.

최근 스마트폰과 태플릿 PC를 대상으로한 앱 시장이 뜨고 있는데, 앱 시장도 웹 기반의 앱이 상당한 영역을 차지할 것으로 생각됩니다.  

=== 놀이 지향 ===
미디어가 어느 정도 성숙하면, 문화적 기반을 가지게 되는데요. 이 단계에 이르면 놀이가 중요한 요소가 됩니다. 책을 봐도 그렇죠. 처음 출판혁명이 시작되었을 때의 책과 지금의 책을 비교해 보세요. 라디오 TV 프로도 마찬가지죠. 하다 못해 요즘엔 '''내셔널지오그라픽이나 히스토리 채널'''도 놀이를 중심으로 방송이 편성됩니다.

인터넷도 그렇죠. 처음 인터넷은 단지 학술문서만을 주고 받기 위해서 사용했었습니다. 그러던게 이제는 새로운 놀이의 장이 되었죠. 인터넷에서 놀이는 가장 큰 영역을 차지할 겁니다. 요즘 뜨는 소셜네트워크라는 것도 결국은 댓글놀이인 거잖아요. 
