#title 비동기 입출력

[[tag(네트워크프로그래밍,입출력다중화,소켓타임아웃)]]
{{{#!html
<HTML
><HEAD
><TITLE
>비동기 입출력(시그널)</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><META
http-equiv="Content-Type"
content="text/html; charset=euc-kr"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>비동기 입출력(시그널)</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN4"
>윤 상배</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>				dreamyun@yahoo.co.kr<br>
			</P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>&#52264;&#47168;</B
></DT
><DT
>1&#51208;. <A
HREF="#AEN9"
>소개</A
></DT
><DT
>2&#51208;. <A
HREF="#AEN14"
>비동기 입출력</A
></DT
><DD
><DL
><DT
>2.1&#51208;. <A
HREF="#AEN16"
>비동기 입출력에 대해서</A
></DT
><DT
>2.2&#51208;. <A
HREF="#AEN21"
>비동기 입출력의 형식</A
></DT
><DT
>2.3&#51208;. <A
HREF="#AEN27"
>비동기 입출력을 위해서 사용되는 신호</A
></DT
><DT
>2.4&#51208;. <A
HREF="#AEN32"
>비동기 입출력 구현</A
></DT
><DD
><DL
><DT
>2.4.1&#51208;. <A
HREF="#AEN34"
>파일지정자를 비동기입출력 방식으로 변경</A
></DT
><DT
>2.4.2&#51208;. <A
HREF="#AEN39"
>시그널 핸들러 준비</A
></DT
><DT
>2.4.3&#51208;. <A
HREF="#AEN43"
>구현시 몇가지 주의해야할 문제점</A
></DT
><DT
>2.4.4&#51208;. <A
HREF="#AEN49"
>비동기 입출력 구현 모델</A
></DT
></DL
></DD
></DL
></DD
><DT
>3&#51208;. <A
HREF="#AEN55"
>구현 테스트</A
></DT
><DT
>4&#51208;. <A
HREF="#AEN64"
>결론</A
></DT
></DL
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN9"
>1&#51208;. 소개</A
></H1
><P
>		이번은 리눅스(유닉스) 입출력 모델 중 비동기 입출력 모델에 
		대해서 다루며, 비동기 입출력 모델중 일반적인 signal 을 이용한 
		구현에 대해서 다룬다. 
	</P
><P
>		보통 signal 을 사용하게 될경우 이것저것 고려해야될 사항이 많고 
		다루기가 꽤 까다로우며, signal 자체가 가지는 여러가지 제약사항들 
		때문에 signal + 비동기 입출력 은 그리 많이 쓰이는 편은 아니다. 
		오래된 몇가지 디바이스(기기)를 다루는 프로그램들 소수의 프로그램과 
		사용자 입력을 처리하는 몇가지 사용자 어플리케이션에서 간혹 사용된다.  
		보통의 경우는 select, poll 과 같은 다른 대체가능하면서도 
		비교적 구현이 간단한 것들을 이용한다.  
	</P
><P
>		그렇지만 어쨋든 이런 모델이 있다는 것도 알아두면 도움이 된다. 
		(적어도 입출력 모델을 선택하고자 할때 무얼 선택해야 할지) 
		특히 이 모델은 signal 의 단점을 보완한 realtime signal 과 
		비동기 입출력 조합 모델의 기본이 됨으로, realtime OS/어플리케이션 
		에 관심이 있다면 알아두는게 많은 도움이 될것이다. 
	</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN14"
>2&#51208;. 비동기 입출력</A
></H1
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN16"
>2.1&#51208;. 비동기 입출력에 대해서</A
></H2
><P
>			비동기입출력은 영어로 Asynchronous  I/O 라고 불리운다. 
			Asynchronous는  동시성을 가지고 있지 않은(非同期)이라는 
			뜻을 가지고 있다. 간단히 말하자면 "시간을 일치시킬수 없는" 
			이란 뜻으로 해석할수 있으며, 비동기 입출력이란 입력과 출력시간을 
			일치시킬수 없는 즉 언제 입력과 출력이 일어날지를 알수 없는 
			입/출력 모델을 뜻한다.  
		</P
><P
>			그렇다면 한가지 문제점이 눈에 보일것이다. 언제 문제가 발생할지 
			모른다면(입/출력) 어떻게 입출력을 처리할수 있을것인가 하는 문제 
			이다. 비동기 입출력외의 동기입출력에서라면 이러한 문제는 발생 
			할수 없을것이다. 왜냐하면 입력과 출력의 시간을 알수 있기 
			때문이다. - 보통 동기 입출력은 해당영역에 입출력이 있을때까지 
			기다린다 -  
		</P
><P
>			가장 간단하게 생각할수 있는 방법은 입력과 출력이 생겼을때 
			프로세스에서 지금 입력(혹은 출력)이 감지 되었으니 확인을 해보라고 
			신호를 보내는 것이 될것이다. 이것은 일상생활에서의 전화를 
			대기하는 것과 비슷하다. 보통 사무실에서 일할때 우리는 
			전화가 언제 올지 알수 없다(스케줄 관리를 하지 않을경우). 
			그렇다면 전화가 올경우 전화가 왔다는 것을 어떻게 전화받을 
			당사자에게 통보할수 있는가. 그건은 전화벨 이라는 "신호"를 통해서 
			가능하다. 
			유닉스에서는 이러한 비동기적 상황을 위해서 "signal" 을 이용한다.  
		</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN21"
>2.2&#51208;. 비동기 입출력의 형식</A
></H2
><P
>			비동기 입출력은 다음과 같은 구현모델을 따른다. 
			<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>   application                            kernel
+--&#62;+----&#62;----+                        no data ready 
|   | WORK    |                             |                
|   |         |                             |
|   |         |                             |
|   +----&#60;----+                             |          
|                       signal              | 
|   +---------+  &#60;--------------------- data ready
|   | Event   |                             
|   | Handler |                             
|   | read()  |  ----------------------&#62; copy data   
|   | data    |  &#60;---------------------- copy 완료
|   +---------+
|        |
+--------+
			</PRE
></TD
></TR
></TABLE
>
			어플리케이션은 특정한 작업을 연속적으로 하고 있을것이다(WORK). 
			물론 이러한 특정한 작업을 하고 있는 도중에 kernel 로부터의 
			입출력관련 signal 을 받기 위해서, 관심있는 파일지정자에 대해서 
			async 하게 작동을 하라고 설정을 해둔 상태이다. 
		</P
><P
>			그러다가 해당 파일지정자에 대해서 입/출력 사건이 발생하면 
			커널은 어플리케이션에게 signal 을 보내서 입/출력이 발생했음을 
			통보하게 될것이다. 그럼 어플리케이션은 미리 준비해둔 
			event handler 를 이용해서 해당 파일지정자로 부터 파일을 읽어들이고 
			지정한 작업을 하게 될것이다. 작업을 모두 마친다음에는 
			event handler 는 리턴을 하게 되고 어플리케이션은 해당 작업을 
			계속 수행하게 될것이다. 
		</P
><P
>			event handler 이 주로 하는일은 네트웍으로 연결된 소켓지정번호로 
			부터 데이타를 읽어와서 적당히 처리하는 일일 것이다. 
		</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN27"
>2.3&#51208;. 비동기 입출력을 위해서 사용되는 신호</A
></H2
><P
>			위에서 비동기 입출력의 비동기사건의 전달을 위해서 유닉스는 
			signal 을 이용한다고 했었다. 그렇다면 어떤 signal 을 사용할것인지 
			에 대해서 알아보도록 하겠다.
		</P
><P
>			유닉스는 SRV4 와 BSD 어느 모델을 따르느냐에 따라 사용하는 
			시그널의 종류가 약간 다르다. 
			SRV4 유닉스라면 SIGPOLL 을 사용할것이며, BSD 모델을 따른다면
			SIGIO와 SIGURG 조합을 따르게 된다. 	
		</P
><P
>			Linux 는 기본적으로 SRV4 와 BSD 모두를 따른다. 
			각각의 장점을 수용했다고 볼수 있는데, 특히 BSD에 좀더 가깝게 
			설계되어 있다.    
			Linux 는 SIGIO 를 받아들인다. 
		</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN32"
>2.4&#51208;. 비동기 입출력 구현</A
></H2
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="AEN34"
>2.4.1&#51208;. 파일지정자를 비동기입출력 방식으로 변경</A
></H3
><P
>				비동기 입출력을 위해서는 관심있는 파일지정자를 비동기 
				모드로 변경시켜야 한다. 
			</P
><P
>				open(2)등의 함수를 이용해서 파일을 열였을경우 해당 파일지정자는
				Sync(동기) 모드로 지정된다. 그럼으로 비동기 모드로 
				변경하기 위해서는 fcntl(2)등의 함수를 이용해서 비동기 모드로 
				변경 시켜주어야 한다. fcntl 함수의 사용법에 대해서는 
				<A
HREF="/modules.php?name=News&file=article&sid=93"
TARGET="_top"
>fcntl 사용하기</A
> 에 자세하게 설명되어 있는데, 이 
				문서를 참고하기 바란다.       
			</P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="AEN39"
>2.4.2&#51208;. 시그널 핸들러 준비</A
></H3
><P
>				파일지정자를 비동기입출력 모드로 변경했다면, 
				이제 시그널이 발생했을때 시그널을 처리해야할 핸들러를 
				준비해주면 된다. 이 핸들러는 해당 어느 파일지정자에 
				읽을데이타가 있는지 확인을 한후 해당 파일지정자에서 
				데이타를 읽어와서 이를 처리하는 일을 하게 될것이다.  
			</P
><P
>				시그널 핸들러는 SIGIO 에 대해서 준비하면 된다. 
			</P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="AEN43"
>2.4.3&#51208;. 구현시 몇가지 주의해야할 문제점</A
></H3
><P
>				비록 여러개의 파일지정자로 부터 입력이 들어온다고 하더라도 
				오직 하나의 신호만을 사용할수 있음으로, 결과적으로 
				어떤 파일지정자로 부터 입력이 있었는지를 알수가 없다. 
				그럼으로 모든 파일지정자를 뒤져서 어떤 파일지정자에 읽기 
				데이타가 있는지 확인할수밖에 없다.   
			</P
><P
>				시그널의 특성때문에 발생할수 있는 문제인데, 
				시그널이 발생해서 시그널 핸들러를 수행하고 있을때 
				동일한 시그널이 다시한번 발생한다면 비록 시그널 핸들러가 
				수행중에 있다고 하더라도 처리중에 빠져나와 버린다. 
				그럼으로 반드시 시그널 핸들러를 처리할때는 동일한 
				시그널에 대해서 잠금을 걸어줘야 한다. 
			</P
><P
>				시그널은 기본적으로 대기열을 가지지 못하며, 한번에 하나의 
				시그널정보만을 유지할수 있다. 
				그럼으로 해당 시그널이 발생해서 핸들러를 사용하고 있는중에 
				동일한 시그널이 2개이상 발생한다면 시그널을 
				잃어버리게 된다 - 마지막 시그널만을 유지한다 -. 
				이는 매우 바쁜 서버에서 데이타를 잃어버릴수도 있음을 
				의미한다. 이문제를 해결하기 위한 몇가지 방법들이 
				있긴하지만, 완전한 해결책은 없다. 
				매우 바쁜 서버이고 데이타를 잃어버리는 문제가 심각할수 
				있다면 비동기 입출력을 사용해야 하는지에 대해서 고민해야 
				할 것이다.   
			</P
><P
>				역시 시그널의 특성때문에 발생할수 있는 문제인데, 
				시그널 핸들러가 실행되고 있는 동안은 시그널 핸들러를 
				호출한 영역에서 블럭된다라는 점이다. 그럼으로 시그널 핸들러의 
				처리 시간이 길면 길수록, 그 시간동안 다른 입/출력을 
				처리 못할 확률이 커짐으로 어플리케이션의 효율을 떨어트릴수 
				있다. 그런 이유로 가급적이면 시그널 핸들러는 짧은 시간에 
				작업을 끝내도록 해야 한다. 
				시그널 핸들러는 조건변수를 이용해서 입력을 다루는 
				쓰레드를 깨워서 원하는 작업을 할수 있도록 해주고, 
				곧바로 리턴하는 방법이 가장 무난할것 같다. 
			</P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="AEN49"
>2.4.4&#51208;. 비동기 입출력 구현 모델</A
></H3
><P
>				위의 몇가지 문제점들까지 해결한 비동기 입출력을 사용하는 
				네트웍 서버 프로그램의 프로세스는 다음과 같을 것이다. 
				<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>// 쓰레드 함수
// 시그널 핸들러에서 호출한 쓰레드 함수이다. 
void *thread_func()
{
    pthread_cond_wait 를 이용해서 쓰레드 시그널을 기다린다.  
    어느 파일지정자에서 입력이 있었는지를 검사한다. 
    만약 endpoint (socket 함수를 이용해서 만들어진) 소켓이라면 
    {
        accept 함수를 호출해서 클라이언트를 위한 듣기 소켓을 만들도록 한다. 
    }
    만약 입력이 있는 파일지정자가 듣기 소켓이라면
    {
        read를 호출해서 데이타를 읽어들이고 적절한 작업을 한다. 
    } 
    만약 예외 상황이 발생했다면 
    {
        예외상황을 분석해서, 적절한 행동(종료하든지 하는등의)을 
        취하도록 한다.  
    }
    소켓을 닫고 쓰레드를 종료한다. 
}

// sig_handle 는 시그널이 발생하면 호출할 시그널 핸들러이다. 
void sig_handle()
{
    호출된 시그널을 잠근다. 
    pthread_cond_signal 을 이용해서 쓰레드 시그널을 발생한다. 
    호출된 시그널의 잠금을 해제한다. 
}

int main()
{
    socket 함수를 이용해서 endpoint 소켓지정자를 만든다. 
    socket -&#62; bind -&#62; listen 으로 해당 소켓지정자에 대한 특성 설정 

    fcntl 을 이용하여 endpoint 소켓지정자를 비동기모드로 전환시킨다.  

    signal 핸들러를 지정한다. 
    signal 핸들러의 이름은 sig_handle 로 한다.  

    
    thread_func 쓰레드를 실행시킨다. 
    while(1)
    {
        어떤 작업을 한다. 
    }
}
				</PRE
></TD
></TR
></TABLE
>
				위의 모델은 상당히 바쁜 입출력이 있을것이라는 가정하에 
				만들어진 모델이다. 만약 그리 바쁜 입출력 상황이 예상되지 
				않는다면 필요 없는 부분을 제거해서 좀더 
				단순화 시킬수 있을것이다 - 아마도 많은 경우 thread_func 는 
				필요 없을수도 있다 -.  
			</P
><P
>				특수한 경우가 아니라면 네트웍서버를 비동기입출력 모드를 
				이용해서 작업하는 경우는 흔하지 않다. 특별히 select 나 poll 
				등에 비해서 특이한 잇점이 없으며, 제대로 구현하려면 꽤 
				까다롭기 때문이다. 대기열을 가지지 못하는 시그널의 특징도 
				무시못할 문제점이다 - 이 문제는 realtime signal 을 이용해서 
				해결할수 있을것이다 -. 
			</P
><P
>				네트웍 서버를 비동기 입출력모드로 만들고자 한다면, 
				아마도 realtime signal 을 사용해야 할것이다. 
				그럼에도 비동기 입출력 구현모델을 네트웍 서버를 이용해서 
				설명하는 것은 비동기 입출력에 대한 기본적인 모든 사항을 
				포함하면서도 몇가지 생각해야될 문제점들을 알아낼수 있기 
				때문이다.  
			</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN55"
>3&#51208;. 구현 테스트</A
></H1
><P
>		네트웍 서버 구현을 하지는 않을것이다. 
		단지 이런식으로 비동기입출력 프로그래밍이
		가능하다는 기법 정도에서 설명을 마칠것이다.  
	</P
><P
>		이유는 (앞에서 설명했듯이)굳이 서버 플밍을 하는데 
		비동기입출력을 사용할 
		필요성이 없기 때문이다. 일단 리눅스 상에서 비동기 입출력을 
		위해서 사용하는 SIGIO 신호의 경우 어떤 파일지정자로 부터 
		입력이 있었는지를 알수가 없다. 
		그럼으로 select 를 쓰던지, 비봉쇄로 파일을 검사하든지 하는방법 
		으로 모든 파일지정자에 대해서 몽땅 검사를 해주어야 한다. 
		이럴 바에는 차라리 처음부터 select, poll 을 사용해도 되기 때문이다.    
	</P
><P
>		그렇다면 실제로 비동기 입출력이 유용하게 쓰일수 있는 곳은 
		사용자와 상호대화하는 어플리케이션 제작시 Thread 를 사용하지 
		않기를 원할때 - 백그라운드로 작업하면서 사용자 입력을 처리하고 싶을때 - 		와 디바이스(기기) 로부터의 입/출력 을 처리할때가 될것이다. 
		물론 신경써야 될게 꽤 있고, 효능이 의심스럽긴 하지만 네트웍 서버 
		프로그램을 작성할수도 있을것이다. 
		(고성능 서버어플리케이션 제작을 위해서 realtime signal 을 이용한 
		비동기입출력 모델을 고려할수 있기는 하다) 
	</P
><P
>		여기에서는 어떤식으로 구현가능한지에 대한 힌트만 얻을수 있는 
		최소한의 코드를 제공하도록 한다. 
	</P
><P
>		<B
CLASS="EMPHASIS"
>예제: async_input.c</B
>
		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>#include &#60;signal.h&#62;
#include &#60;unistd.h&#62;
#include &#60;string.h&#62;
#include &#60;fcntl.h&#62;
#include &#60;sys/types.h&#62;
#include &#60;sys/stat.h&#62;

#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;

#define STDIN 0 

int sockfd;
int client_num;

void iohandler(int signo)
{
	sigset_t sigset, oldset;
	sigfillset(&#38;sigset);	
	// 새로들어오는 모든 시그널에 대해서 block 한다. 
	if (sigprocmask(SIG_BLOCK, &#38;sigset, &#38;oldset) &#60; 0)
	{
		printf("sigprocmask %d error&#92;n", signo);
	}
	printf("INPUT CHECK&#92;n");
	// 입력에 따라서 다양한 작업을 한다. 
}

int main(int argc, char **argv)
{
	struct sigaction iosig; 
	int value;

	client_num = 0;

	iosig.sa_handler =iohandler;
	sigemptyset(&#38;iosig.sa_mask);
	iosig.sa_flags = 0;

	if (sigaction(SIGIO, &#38;iosig, 0) == -1)
	{
		perror("error ");
		exit(0);
	}

	// 표준입력에 대해서 비동기 모드로 지정한다. 
	value = fcntl(STDIN, F_GETFL, 0);
	value |= O_ASYNC;
	fcntl (STDIN, F_SETFL, value);

	// 표준입력에 대해서 SIGIO 시그널이 발생할경우 
	// 현재 프로세스가 시그널을 받도록 설정한다. 
	fcntl (STDIN, F_SETOWN, getpid());

	
	while(1)
	{
		// 무언가 백그라운드 작업을 할것이다. 
		sleep(1);	
	}
}
		</PRE
></TD
></TR
></TABLE
>
	</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN64"
>4&#51208;. 결론</A
></H1
><P
>		이상 시그널을 이용한 비동기 입출력에 대해서 알아보았다. 
		비동기 입출력은 사실상 쓰일만한곳이 그렇게 많지 않다. 
		다루기가 까다롭고 다른 비슷한 도구들을 이용해서 구현이 가능하기 
		때문이다. 
	</P
><P
>		하지만 몇몇 기기와 관련된 프로그램들 혹은 과거에 만든 프로그램들은 
		시그널 비동기 입출력 기법을 적용한 것도 있으니 알아두면 편리할 
		것이다. 
	</P
><P
>		그럼에도 불구하고 시그널은 거의 실시간으로 전달되어 질수 
		있다는 특성으로 realtime OS/어플리케이션의 구현에서 
		사용되어 질수있다. 물론 일반적인 signal 은 안되고 realtime signal 을 
		이용한 비동기 입출력의 구현일테지만...
	</P
></DIV
></DIV
></BODY
></HTML
>
}}}
