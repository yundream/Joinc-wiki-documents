#title 간단한 스핌 프로그램

[[TableOfContents]]

== 9장 첫 번째 SPIM 프로그램 ==
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_1.html

이 장에서 SPIM 시뮬레이터를 작동하는 방법을 공부하자. 작은 MIPS프로그램이 예제로 사용했다.

공부할 요점

    * SPIM 시작하기 Starting SPIM
    * SPIM 유저 인터페이스 The SPIM user interface
    * 어셈블리 소스프로그램 작성하기 Writing an assembly source program
    * 어셈블링과 프로그램 로딩하기 Assembling and loading a program
    * 프로그램을 실행시키기 Running a program

이 장은 SPIM으로 어떻게 프로그램을 실행하는지 단계적으로 공부합니다.  다음 장에선 프로그램을 만드는 법을 공부합니다.

질문: 레지스터가 무엇입니까?

=== SPIM 시작하기 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_2.html
[[Image(startSPIM.gif,0,0,right,)]]

답: 레지스터는 프로세서의 일부분으로써 1개의 비트패턴을 저장한다. 프로세서는 여러 개의 레지스터를 가지고 있다.


MIPS 프로세서는 32개의 일반적인 목적으로 쓰이는 레지스터를 가지고 있다. 각각의 레지스터는 32개의 비트를 저장한다. MIPS 프로세서는 일반적인 목적으로 쓰여지는 레지스터들 이외에 다른 레지스터들도 가지고 있다.
SPIM 프로그램의 첫 번째 예는 정수를 표현하는 비트패턴을 2개의 레지스터에 저장하는 법과 저장된 두 패턴을 덧셈하는 방법을 보여준다. 옆에 스크린샷은 윈도우즈 ME의 스크린샷이지만 다른 윈도우 OS도 비슷할 것이다. 유닉스와 리눅스도 비슷하다.
스타트 버튼을 클릭해서 SPIM 아이콘을 찾아서 클릭하자.  SPIM을 아직 설치하지 않았다면 설치를 먼저하자. 참조링크 http://www.cs.wisc.edu/~larus/spim.html



질문: SPIM을 시작할 수 있는 다른 방법이 있습니까?

=== SPIM 디스플레이 윈도우 열어보기 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_3.html

답: 시작메뉴로부터 실행명령을 사용하여 실행하거나 도스창에서 직접 pcSpim이 설치된 디렉토리로가서 pcSpim.exe를 실행 시킬 수 있다.   



윈도우 머신에서 스핌을 실행했을 때 처음 창의 스크린은 아래 그림과 같다. 창은 크게 4가지 부분으로 나누어져 있다.

attachment:firstScreen.gif

레지스터 디스플레이(Register Display): 레지스터 디스플레이는 32개의 범용 레지스터들과 소수점 레지스터들 그리고 그 외에 여러 다른 종류의 레지스터들이 담고 있는 비트 패턴들을 16진수 표현법으로 보여준다.

문자 또는 텍스트 디스플레이(Text Display): 문자 디스플레이는 어셈블리 소스와 그 소스명령들에 해당하는 16진수 비트 패턴으로 표현된 기계명령들과 명령의 메모리 위치를 나타내는 주소(Address)를 보여준다.

데이터와 스택 디스플레이 (Data and Stack Display): 데이터와 스택 디스플레이는 밉스 메모리가 담고있는 일반적인 데이터와 스택에 들어간 데이터를 보여준다.

스핌 메시지(SPIM Messages): 스핌 메시지 디스플레이는 스핌 시뮬레이터에서 발생하는 시뮬레이터의 자체 메시지(주로 에러 메시지)를 보여준다.

여기서 텍스트(Text)란 궁극적으로 실행을 목적으로하는 기계언어 비트 패턴을 의미한다. 프로그램(program)이라는 단어가 혼동을 가져오는 경우가 많기 때문에 대신에 텍스트를 사용한다. 텍스트란 실행될 기계언어 프로그램이다.
그림에서 보이는 콘솔 아이콘에 선택하면 콘솔 윈도우를 볼 수 있다. 스핌 콘솔 윈도우는 실행시 모방하는 스핌 컴퓨터의 문자 출력 다른말로 캐릭터 아웃풋(character ouput)을 보여준다.

질문: 시뮬레이터 자체에서 발생하는 스핌 메시지와 모방된 스핌 컴퓨터에서 어셈블러 프로그램을 실행시 발생하는 프로그램의 캐릭터 아웃풋 메시지는 차이가 있습니까?


=== 어셈블리 프로그램 작성하기  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_4.html

답: 차이가 있다.

스핌 콘솔 윈도우에 출력되는 메시지는 시뮬레이션되는 스핌 컴퓨터에서 출력되는 메시지이다. 다시말해 시뮬레이션에서 어셈블리 프로그램이 실행 될때 실행되는 프로그램이 가상의 모니터인 콘솔에 출력하는 메시지이다. 만일 진짜 밉스 컴퓨터로 이 어셈블리 프로그램을 실행하면, 똑같은 메시지를 실제 모니터에서 볼 수 있다.

시뮬레이터로부터 발생하는 스핌 메시지는  실행하는 어셈블리 프로그램이 아닌 시뮬레이터 자체로부터 발생된다. 이러한 메시지들은 시뮬레이터 사용자를 위한 메시지들로써 에러메시지,프롬프트와 리포트등의 메시지들이다.

이제 시뮬레이터를 실행하여 보았다면 어셈블리코드를 어셈블하고 프로그램을 올려(load)볼 차례이다. 시뮬레이터의 셋팅(setting)에따라 시뮬레이터 메모리에 이미 기계 명령이 있을 수도 있다. 그러한 기계명령들은 프로그램을 실행할 수 있도록 보조해 준다. 시뮬레이터 메뉴를 사용하여 시뮬레이터를 시작한다면 그러한  기계명령이 실행될 것이다. 하지만 무한루프 상태가 될지도 모른다. 무한루프 상태를 끝내기 위해서는 시뮬레이터의 브레이크(Break)를 클릭하자.

어셈블리나 또는 다른 프로그램언어에서 소스파일은 (일반적으로) 프로그래머가 제작한 프로그래밍언어로 쓰여진 텍스트 파일이다. 메모장(notepad)같은 에디터로 그러한 파일을 작성할 수 있다. 메모장보다 더편한 에디터를 사용하여 작성할 수 도 있다. 개인적으로는 크림슨 에디터를 좋아한다. 무료로 다운로드하여 사용할 수 있다.(http://www.crimsoneditor.com/). 어떤 에디터도 괜찮다. 자바나 다른 프로그램언어로 작성할 때 사용했던 어떤 에디터를 사용해도 된다.

질문: 메모장은 어떤 종류의 파일을 작성합니까?

=== 2+3 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_5.html

답:
텍스트 파일. 텍스트 파일의 바이트들은 ASCII 문자로 해석될 수 있다.

워드 프로세서는 일반적으로 바이너리 파일을 만든다. 그렇기 때문에 프로그램의 소스 파일을 만드는 일에는 적합하지 않다. 워드 프로세서를 텍스트 파일로 출력할 수도 있겠지만 프로그래밍 에디터를 사용하는 것이 편리하다. 텍스트 에디터를 사용해서 addup.asm 이라는 파일을 만들어 보자.  웹브라우저로부터 다음 코드를 복사해서 에디터에 옮겨보자.

{{{#!plain
## 2와 3을 더하는 프로그램 Program to add two plus three 
        .text
        .globl  main

main:
        ori     $8,$0,0x2       # 2의보수법으로 표현된 2를 레지스터 8번에 저장한다 put two's comp. two into register 8
        ori     $9,$0,0x3       # 2의보수법으로 표현된 3을 레지스터 9번에 저장한다 put two's comp. three into register 9
        addu    $10,$8,$9    # 8번과 9번레지스터의 값을 합하여 결과를 레지스터 10번에 저장한다. add register 8 and 9, put result in 10

## 파일 끝 End of file
}}}

첫번 째 열의 처음 행은 "#"이다. "#"문자는 주석 또는 코멘트를 시작 한다는 의미이다. "#"로부터 시작해서 그 행의 오른쪽에 있는 모든 문자가 프로그램을 컴파일 시에 무시된다. 두개의 #를 사용한것은 코멘트라는 것을 강조하기 위해서이다. 두번째#는 무시되고 # 표시 하나만 있어도 된다. main: 다음의 3개의 열들은 각각의 열이 하나의 기계 명령에 해당한다.

질문: 기계명령(machine instruction)이란 무엇입니까?



=== 스핌 설정하기 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_6.html
[[Image(settings.gif,0,0,right,)]]
답:
기계명령은 기계에게 한 동작(a machine operation) 이 실행되도록 요청하는 비트 패턴입니다.

하나의 MIPS 기계명령은 32개의 비트(4바이트)로 이루어져있다. main: 후에 세줄은 3개의 기계명령을 부른다.
남은 공간은 어셈블러와 사람을 위한 주석을 위하여 쓰인다.

이 첫 프로그램을 위해서 먼저 SPIM옵션을 설정해야 한다. 메뉴바에서 Simulator 와 Settings 를 클릭해 settings 다이얼로그를 연다.
다음의 옵션을 선택하자.

선택 | 옵션
ON | Save window positions (윈도우 위치를 기억)
ON | General Registers in hexadecimal (일반 레지스터를 16진수로)
OFF | Floating point registers in hexadecimal (부동소수점 레지스터를 16진수로)
ON | Bare Machine (순수 머신)
OFF | Allow pseudo instructions (수도 또는 의사 명령 허용)
OFF | Load trap file(트랩파일을 불러들인다)
ON | Delayed Branches (지연 분기처리)
ON | Delayed Load (지연 로드) 
ON | Mapped I/O (맵화된 IO)
OFF | Quiet  (디버그 메시지) 

이 세팅은 유저 편의를 전혀 고려하지 않고 순수한 기계를 재현한다. 우리는 나중에 그 편의 기능을 포함시킬것이다.


질문:
(생각이 필요한 질문) 실제로 대부분의 컴퓨터가 순수한 기계(Bare Machine)로 시작(start up) 합니까?

=== 소스 파일 올리기 (loading the source file) ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_7.html
[[Image(open.JPG,0,0,right,)]]

답: 아니오.

현대 컴퓨터는 순수한 기계로 시작하기 보단 사용자에게 편리한 상태로 부팅이 된다. 일반적으로 주소 공간(address sapce)의 특별한 영역에  EEPROM에 영구히 상주하는 기계명령코드로 펌웨어(firmware)가 존재한다. 이 기계 명령은 컴퓨터의 파워를 켜는 순간부터 작동되기 시작하고 오퍼레이팅 시스템을 로딩한다. 스핌은 어느정도 기본적인 펌웨어를 시뮬레이션할 수 있다. 하지만 여기서는 그 옵션을 껐다(off).

스핌 시뮬레이터에서 File 메뉴 그리고 open을 클릭해서 프로그램을 올려(load)보자. 여러분이 만든 소스파일 addup.asm을 오픈으로 선택해서 열어보자. 파일이 다른 장소에 있다면 파일 다이얼로그에서 파일이 있는 디렉토리로 옴겨가서 선택해야 할 지도 모른다.

만약 addup.asm 파일에 실수가 있다면 스핌의 메시지 표시창에 에러 메시지가 뜰것이다. 에디터를 사용해서 실수한 것을 교정하고 파일을 저장한 뒤 그 파일을 같은 방법으로 다시 열어보자.

질문: 텍스트 에디터와 스핌이 동시에 같은 파일을 열 수 있습니까?

=== 어셈블링하기 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_8.html

답:물론 할 수 있다. 텍스트 에디터로 교정을 보고 파일을 다시 저장해서 스핌에 다시 로딩할 수 있다. 

소스파일을 스핌에 로딩할 경우 다음과 같은 2가지 것이 뒤따라 일어난다.

(1) 소스파일은 기계 명령으로 컴파일 또는 어셈블 된다.
(2) 기계명령은 스핌의 메모리에 올려(load)지고 텍스트(소스) 표시창은 메모리에 올려진 결과를 보여준다.

attachment:loadedSource.gif

텍스트 표시창은 위에서 2번째의 창이다. 표시창에 올려진 소스파일의 일부분과 그 소스가 기계명령화한 것을 창에서 볼 수 있을 것이다. 가장 왼쪽 행은 가상(simulated) 메모리의 주소(address)이다.

질문: 텍스트 표시창을 자세히 보자.

1. 어셈블리의 첫번째 소스 명령(ori $8,$0,0x2)이 어떠한 기계명령(비트 패턴)으로 어셈블리화 하였습니까?
2. 메모리의 어떤 주소에 그 명령이 위치해 있습니까? 


=== 프로그램 카운터(PC) 설정 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_9.html

답: 1. 0x34080002 2. 0x00400000

 프로그램 카운터는 현재 기계명령의 위치를 담고있는 프로세서의 한 부분이다. (사실 이것은 현재 명령의 첫 4바이트의 주소를 가르키고 있다.) 
레지스터 디스플레이(맨 윗창)에 프로그램 카운터가 0에서 부터 시작하는것을 볼 수 있다. 이것은 첫 명령주소인 0x00400000으로 바뀌어야한다.
이것을 하려면 메뉴바에서 Simulator->Set Value를 누른다.

attachment:SetValue.gif

Set value 다이얼로그에서 윗쪽 박스에는 PC를 아랫쪽에는 0x00400000을 넣는다. OK를 누르면 PC가 바뀔것이다.


질문: 사용자가 "400000" 라는 값을 입력시키고 OK를 눌렀다. 그런데 프로그램카운터가 00061a80으로 변한다. 무슨일인가?


=== 프로그램 실행시키기 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_10.html

답: 0x가 선행하지 않는 "400000" 은 10진수로 받아들여진다. 그래서 PC(프로그램카운터) 는 부호없는 2진수패턴 0x0061a80으로 된다.

attachment:lawwl.jpg

F10 를 눌러 한 명령을 실행시키자. 처음 명령이 실행되며 8번 레지스터에 2가 로드된다.(레지스터 디스플레이참고.) PC는 다음 명령인 0x00400004로 증가한다. 그리고 메세지 디스플레이 윈도우는 방금 실행된 명령을 보여준다.
 
F10을 두번 더 눌러 남아있는 명령들을 처리하자. 각각의 명령은 32bit만큼 길기때문에 PC는 매 명령마다 4만큼 증가한다. 3번째 명령을 수행후 10번 레지스터에는 2와 3의 합이 있을것이다.

질문: 0x00000002 와 0x00000003의 합이 뭡니까?


=== 프로그램의 결과 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_11.html

답 : 0x00000005

attachment:lawl.jpg

저런 작은 숫자들의 비트 패턴은 쉽게 알 수 있다. 레지스터 10번을 보기위해 레지스터 디스플레이를 스크롤 할 필요가 있다. 
F10을 다시 누르면 PC는 기계명령으로 적절하지 못한 비트를 담고 있는 스핌 메모리 주소를 가르키게된다. 시뮬레이터는 그러한 적절하지 않은 명령들을 실행하려고 시도할 것이다. 스핌 가상 프로세서가 아니고 실제 프로세서라면 이 지점에서 정말 크래쉬(crash)될 수 있다. (이것은 보통 프로그램끝에서 떨어지기(falling off at the end of a program)라고 한다.)  이런경우 시뮬레이터는 맨 아래 패널에 에러메세지를 출력할 것이다.

질문: 실제 컴퓨터에서 프로그램의 끝에 도달하면 무슨일이 일어납니까?
 

=== 프로그램 설명 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_12.html
답 : 프로그램은 운영체제에 제어를 넘긴다.

실제 기계에서 운영체제에 제어를 넘기는 방법은 여러가지가 있지만, 우리는 운영체제가 없으므로 일단 명령어 하나하나를 살펴보겠다.

{{{#!plain
## Program to add two plus three 
        .text
        .globl  main

main:
        ori     $8,$0,0x2       # 2의 보수법으로 표현된 수 2를 8번 레지스터에
        ori     $9,$0,0x3       # 2의 보수법으로 표현된 수 3을 9번 레지스터에
        addu    $10,$8,$9    # 레지스터 8, 9 값을 더해 10번에 넣는다
## End of file
}}}
첫줄은 주석이다. 어셈블러가 무시하고 아무 기계명령도 생성하지 않는다.
.text는 지시어다. 지시어는 어셈블러에게 프로그래머의 요구를 알려주나, 기계 명령은 아니다. 이 지시어는 어셈블러에게 다음의 줄들은 프로그램의 소스코드라고 알려준다.
.globl main은 또다른 지시어다. 이것은 main이 이 소스코드 밖에서(글로벌 혹은 전역) 사용될 것이라고 알려준다. 더불어 main memory의 특정장소의 레이블이다.


질문: (기억력 시험) 첫 명령이 메모리 어디에 저장되었습니까?

=== 프로그램 설명 계속 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_13.html

답: 0x00400000 

빈줄은 무시된다. main: 줄은 주소 심볼(구문 라벨)을 정의한다. 심볼릭 주소는 메모리 위치를 소스코드내에서 가리키는 이름이다. 이 프로그램에서 main은 첫 명령의 위치를 상징한다(0x00400000). 심볼릭 주소를 사용하는것은 숫자로 메모리 주소를 가리키는것 보다 훨씬 쉽다. 프로그래머는 심볼주소를 사용해 이름으로 메모리 주소를 참조한다. 어셈블러는 이 이름으로 지정된 메모리 장소를 숫자로 해석할 수 있다. 
{{{#!plain
## Program to add two plus three 
        .text
        .globl  main

main:
        ori     $8,$0,0x2       # 2의보수법으로 표현된  2를 레지스터8에 넣는다
        ori     $9,$0,0x3       # 2의보수법으로 표혀된 3을 레지스터9에 넣는다
        addu    $10,$8,$9    # 레지스터 8과 9의 합을 10에 넣는다
## End of file
}}}

main 심볼은 전역(global)심볼이다. 여러 다른 소스파일에서 "main"심볼은 같은장소를 가리킬수있다.(그러나 SPIM은 이 기능을 지원하지 않는다. 우리가 할 모든 프로그램은 파일하나에 들어 갈것이다) 


질문:  (당신의 직관을 시험해보세요:) 소프트웨어시스템의 각 부분이 서로를 참조할 필요가 있을것 같습니까?


=== 레지스터 8 불러들이기 ===

http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_14.html

답:예

모든 소프트웨어는 상호접속된 모듈로 구성된다. 한 모듈이 다른 모듈에 있는 주소를 가리킴으로써 서로 연결이 된다.

다음줄: 
ori $8,$0,0x2 은 32비트 기계 명령으로 바뀐다. 기계명령은 실행시에 32비트의 2의보수 2를 8번 레지스터에 집어넣는다(나중에 자세히).

{{{#!plain
## Program to add two plus three 
        .text
        .globl  main

main:
        ori     $8,$0,0x2       # 2의보수법으로 표현된 수 2를 레지스터8에 넣는다
        ori     $9,$0,0x3       # 2의보수법으로 표현된 수 3을 레지스터9에 넣는다
        addu    $10,$8,$9    # 레지스터 8과 9의 합을 10에 넣는다

## End of file
}}}

이 다음줄의 명령은 (실행시에) 3을 9번 레지스터에 넣는 기계어로 번역된다. 마지막 명령은 레지스터 8과 9의 값은 더해 레지스터10에 32비트로 된 결과를 저장 시킨다.

질문: 32비트 덧셈을 위해 무슨 알고리즘을 사용하겠습니까?


=== 런타임(실행 시간) ===

http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_15.html

답: 8장의 바이너리 덧셈 알고리듬을 사용한다.

"실행할경우 명령은 어셈블리화되고 메인메모리로 올려진 후 .... 수행을 한다." 라는 표현을 반복해서 말하는 것은 어색하다.

대신에 사람들은 일반적으로 

"실행시 또는 런타임(runtime)에서는 명령이 ...을 한다."라고 표현하다.

예를 들어 

"실행시에 ori $8,$0,0x2 명령은 8번 레지스터에 2를 집어넣는다."라고 표현할 수 있다.

혹은 줄여서,

"ori $8,$0,0x2 명령은 8번 레지스터에 2를 집어넣는다."라고 표현할 수 있다.

여러분은 이런식으로 줄여서 표현한 말을 분명히 이해하고 있어야 한다. 항상 컴퓨터에서는 비트패턴으로 표현된 기계 명령이 작동을 일으키고 실행시간(Runtime)에서만 그 작동이 수행된다.

가끔 어셈블리타임(assembly time)에 대해 논할 때가 있다. 어셈블리 타임(assembly time)이란 어셈블러(assembly)가 소스코드를 기계어로 번역할 때를 가리킨다.

질문: (복습) 일반적으로 (실제) 컴퓨터 시스템에서  어셈블러가 만들어낸 비트패턴은 어느 곳에 저장됩니까?

=== 9장 끝 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_16.html

답: 오프젝트 모듈안에 파일 형태로 저장되어있다.

스핌 스뮬레이터에서는 오프제트 모듈 과정이 생략되었다. 스핌 어셈블러는 비트 패턴을 스핌의 가상 주메모리에 직접 올려 놓는다. 스핌을 종료하기 위에서는 File 메뉴의 Exit을 선택한다. 

논의된 주제들

    * 스핌 유저 인터페이스 The SPIM user interface.
    * 스핌 시작하기 Starting SPIM
    * 소스 파일들 Source files
    * 환경설정 다이얼로그 Settings dialog
    * 소스 파일 올리기 Loading the source file.
    * 파일을 올릴때 스핌이 하는 2가지. The two things that SPIM does to a loaded file.
    * 프로그램 카운터 설정하기 Setting the program counter
    * 한 스텝씩 스핌하기 Single stepping SPIM
    * 어셈블리 지시어 Assembly language directive
    * 심볼릭 어드레스 Symbolic address
    * 런타임 (실행 시간) Run time

9장 [http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09quiz.html 퀴즈]를 꼭 풀어봅시다.

=== 프갤러들의 수다 ===
==== 번역기(記) ====
0. '''자바하는놈''' 9장에도 이거 붙여도 됩니까?
1. '''자바하는놈''' 위키 에디트 하는 곳에 스크롤바좀 있었으면 좋겠네요.
2. '''자바하는놈''' 번역 거의 다 했습니다. 마지막 페이지 남았습니다. 오타수정했습니다.
3. '''자바하는놈''' 프갤에 어떤&#52898;이 이걸 뭐라하는데 참 난감..

