#title 포인터와 관련된 Joinc 대화

IRC #joinc 에서 . . .

오옷 - yundream

{{{#!plain
<minzkn> 하이.
<산하> class멤버 메스드에서 main함수의 전역변수를 엑세스 할려는데요.
<산하> 바로는, 안되더군요.
<산하> 그래서 reference를 이용해서.
<산하> 넘길려고 했더니. 그것도 문제가 있는것이.
<산하> 레퍼런스는, 선언할때, 값이 주어져야하는데.
<산하> 클래스의 멤버변수로 레퍼런스를 하나두고 생성자에서 레퍼런스를 받아 대입할려고 했거든요
<minzkn> int main(void){static int s_Global=0; class a(s_Global); } 이런건가요?
<산하> 잠시만요 전화와서리..
<산하> 예..끊었음.
<산하> 음.
<산하> 예제를 든다면요.
<산하> main.cpp의 내용이.
<산하> int a[10];
<산하> int main() {
<산하> tClass tc(a);
<산하> return 1;
<산하> }
<산하> 이렇다치구요
<산하> class tClass {
<산하> int& b;
<산하> public:
<산하> tClass(int& b) {
<산하> this->b = b;
<minzkn> 아~ reference로 외부변수를?
<산하> b[3] = 2;
<산하> }
<산하> 예.
<minzkn> 그건 포인터밖에 안들거 같네요.
<산하> 예.포인터로 하면..뭐
<산하> 되겠는데..
<산하> 레퍼런스로는, 
<yundream> 음..
<minzkn> 레퍼런스는 그 사용이 잘못된듯 하군요.
<minzkn> 만약 그게 가능하다면
<산하> 멤버변수로 넣을때 바로 그 값이 대입되어야 하는데.
<minzkn> class가 소멸자를 만났을때
<산하> 그 값자체를 생성자로 받아서 대입할려고했는데.
<minzkn> 전역변수 a는 어떻게 될까요?
<산하> 레퍼런스만
<산하> 사라지는거죠..
<산하> a가 사라지는건아니죠
<minzkn> 레퍼런스는 포인터 개념이 아니고 같은 주소공간을 가르키는 라벨의 개념이므로
<minzkn> a를 레퍼런스로 class안으로 끌어들이는것은 논리 오류일듯 합니다.
<산하> 그냥 멤버메소드에 인자로 넣고 그 안에서 뭔가를 처리하는 건 레퍼런스로 해도 되거든요.
<산하> 문젠 레퍼런스는 선언될때 초기화되어야하는데.
<minzkn> int &b;를 static int &b; 이렇게 바꿔보세요. 될지도... (믿거나 말거나)
<산하> 음 해보께요. 그리구요
<산하> 배열이거든요. 또 문제가.
<minzkn> 킁..
<산하> 그럼 어떤식으로 인자를 받고ㅗ 보내야하죠?
<minzkn> 배열을 int &b로?
<yundream> 아싸리 처음부터 설정을 dbm으로 할걸 그랬나..
<yundream> 아니면 xml로..쩝.
<산하> 전역배열변수.
<산하> int a[10]이라면요.
<산하> 클래스를 떠나서..
<산하> 다른 함수에 레퍼런스로 넘길려면
<산하> 어떻게 처리하죠?
<산하> 그 함수에서 받는 인자를 int&
<산하> int& b일케해서
<산하> b[3]=2;
<산하> 일케 안될듯.싶은데
<minzkn> int &b[]; 이렇게 하면 안될까요? 이건 저도 모르겠네요...
<산하> 그건 레퍼런스들의 배열이아닐까요?
<minzkn> 그런가?
<산하> 각각이 초기화되어야할듯싶은데.
<minzkn> 그럼
<minzkn> int &(b[]);
<minzkn> ㅋㅋㅋ. 억지인가?
<산하> 음..
<minzkn> 그냥 포인터 쓰세요.
<yundream> 멜록후.. 넘기기
<minzkn> 그런 애매한 경우가 편하려고 쓰다가 복잡하게 된다는...
<산하> 클래스의 멤버변수로 레퍼런스를 쓰는건 아무래도 무리겠구...일반 함수의 인자로 레퍼런스를 주고 받는건 비일비재한데, 배열을 넘기는 경우도 많을것 같네요.  이 해결방법은 한번 검토해볼만하죠?
<yundream> 음. ... .. 저도 그런 경우는 보통 뽀인터 사용하는데..
<minzkn> 검토해볼만은 하겠는데요. 저라면 방법을 알아도 안쓸거 같아요.. 
<산하> 크,
<yundream> 음.. ..
<산하> 가만 포인터로 넘길때 배열인자를 어케 처리하죠?
<yundream> 울나라에도 배포판이 있으면.. ..
<minzkn> int a[10];       &a[0];
<산하> 함수인자는요?
<산하> int* b;
<산하> 일케되나요?
<minzkn> int func(int b[]);
<산하> 아 b[]...
<minzkn> 배열은 배열로 받는 경우가 위처럼 할수 있고요
<산하> 그럼 받아서 그냥 쓰듯이 씀 되는군요..
<산하> b[3]=4..
<minzkn> 보통은 그렇게 하는 이유는 보안때문에 하는거고요.
<minzkn> int func(int *b); 이것을 많이 쓰죠...
<산하> 음.
<minzkn> 만약에 
<산하> 그럼 3번째 인자의 엑세스는?
<minzkn> int a[10];
<산하> 인자가 아니고 멤버.
<minzkn> 이렇게 있다면
<minzkn> int func(int b[]); 이렇게 해서 a를 받으면
<산하> 예.
<minzkn> b의 값을 바꿔도 a가 안바뀌죠
<minzkn> int func(int *b); 이렇게 하면
<산하> 아 그럼 의도하는바가 아니죠..
<minzkn> b를 바꾸면 a도
<산하> 그럼 인덱스처리는요?
<산하> b = b+3;
<minzkn> *(b + x); 또는 b[x] 또는 gnu에서는 x[b]도 가능.
<산하> *b = 4;
<산하> b[x]도 가능?
<minzkn> 예.
<minzkn> 원래 가능해요.
<산하> 흐음~
<산하> 그럼 편하군요..
<minzkn> *(b + 3) == b[3]
<산하> 예~
<산하> 근데 좀 재밌다해야하나의문점스러운건  
<minzkn> *(b + 3) == b[3] == 3[b] /*단, b는 int일때 */; 
<산하> int a[10]에서 주소를 넘길때
<산하> 사실 a가 a[0]의 주소일텐데..
<산하> &a[0]을 꼭 해줘야한다는점..
<minzkn> a = &a[0];
<산하> 왜 그럴까요?
<yundream> 음.. 이런걸 남겨서 정리해야 하는데.
<산하> 그냥 a를.
<산하> 넘기면 안되죠?
<minzkn> &a[0] 으로 하면 (void *)캐스팅 효과가 있어요.
<산하> a[0]은 데이터형이고
<산하> a는 포인터형이라고 할수있잖아요
<minzkn> (void *)a = &a[0]; 
<산하> 받는쪽에서, 데이터형을 명시해서 받는다면.
<산하> 그냥 a해도 될까요?
<yundream> 산하 / 이거 로그좀 위키에 남겨주세요.. 저도 정리좀 하게.. 배열/포인터/레퍼런스 헷갈리는게 많아서.. 이번기회에 대화내용 참고로 확실히..
<산하> 예..
<yundream> 전 bx라서 로그로 남기기가.
<산하> 진짜 자료정리에...열심이시다..쿠쿠.
<hkpco> !uptime
<hkpco> uptime : 1시간 8분 52초
<-- hkpco has quit (X-iRc v2.6.1 Armour au Claire de Lune -- http://www.dgtalx.net)
<yundream> 3[b] 이런것도 되는 거였었군 흠..
<산하> minzkn: 그데 아까 포인터로 받은 배열을 인덱스로접근하는거..
<산하> 객체배열도 되나요?
}}}
