#title statfs(2)
[wiki:function_statfs(2) HTML 변환문서]

{{{#!plain
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<chapter lang=ko>
<!-- 작성자 : yundream             -->
<!-- 작성일 : 2004/02/25           -->
<!-- 연락처 : yundream@joinc.co.kr -->

<!-- 함수 이름을 입력합니다 -->
<title>statfs(2)</title>

<!-- 이건 함수에 대한 대략적인 설명이구요 -->
<para>
	파일 시스템 정보를 가져온다. 
</para>
 
<!-- 여기에 함수의 간단한 사용법이 들어갑니다 -->
<section>
	<title>사용법</title>
	<para>
		<screen>
#include &lt;sys/vfs.h&gt;

int statfs(const char *path, struct statfs *buf);
int fstatfs(int fd, struct statfs *buf);
		</screen>
	</para>
</section>

<!-- 여기엔 함수의 자세한 설명 이 들어갑니다 -->
<section>
	<title>설명</title>
	<para>
		statfs()는 마운트된 파일 시스템에 대한 정보를 반환한다. 
		<emphasis>path</emphasis>는 마운트된 파일 시스템내 파일의 
		경로 이름이다. 파일 시스템의 정보는 <emphasis>buf</emphasis>가 
		가르키는 공간에 채워진다. <emphasis>statfs</emphasis>구조체는 
		다음과 같이 정의되어 있다.
		<screen>
struct statfs {
   long    f_type;     /* 파일 시스템 타입(아래에서 보여준다) */
   long    f_bsize;    /* 최적화된 전송 블럭 크기 */
   long    f_blocks;   /* 파일 시스템내 총 데이터 블럭들 */
   long    f_bfree;    /* 파일 시스템내 여유 블럭들 */
   long    f_bavail;   /* 비-슈퍼 유저를 위한 여유 블럭들 */
   long    f_files;    /* 파일 시스템내 총 파일 노드들 */
   long    f_ffree;    /* 파일 시스템내 여유 파일 노드들 */
   fsid_t  f_fsid;     /* 파일 시스템 ID */
   long    f_namelen;  /* 파일 이름의 최대 길이 */
   long    f_spare[6]; /* 나중을 위한 여유분 */
};
		</screen>
		다음은 파일 시스템 타입이다.	
		<screen>
linux/affs_fs.h:
   AFFS_SUPER_MAGIC      0xADFF
linux/ext_fs.h:
   EXT_SUPER_MAGIC       0x137D
linux/ext2_fs.h:
   EXT2_OLD_SUPER_MAGIC  0xEF51
   EXT2_SUPER_MAGIC      0xEF53
linux/hpfs_fs.h:
   HPFS_SUPER_MAGIC      0xF995E849
linux/iso_fs.h:
   ISOFS_SUPER_MAGIC     0x9660
linux/minix_fs.h:
   MINIX_SUPER_MAGIC     0x137F /* orig. minix */
   MINIX_SUPER_MAGIC2    0x138F /* 30 char minix */
   MINIX2_SUPER_MAGIC    0x2468 /* minix V2 */
   MINIX2_SUPER_MAGIC2   0x2478 /* minix V2, 30 char names */
linux/msdos_fs.h:
   MSDOS_SUPER_MAGIC     0x4d44
linux/ncp_fs.h:
   NCP_SUPER_MAGIC       0x564c
linux/nfs_fs.h:
   NFS_SUPER_MAGIC       0x6969
linux/proc_fs.h:
   PROC_SUPER_MAGIC      0x9fa0
linux/smb_fs.h:
   SMB_SUPER_MAGIC       0x517B
linux/sysv_fs.h:
   XENIX_SUPER_MAGIC     0x012FF7B4
   SYSV4_SUPER_MAGIC     0x012FF7B5
   SYSV2_SUPER_MAGIC     0x012FF7B6
   COH_SUPER_MAGIC       0x012FF7B7
linux/ufs_fs.h:
   UFS_MAGIC             0x00011954
linux/xia_fs.h:
   _XIAFS_SUPER_MAGIC    0x012FD16D
		</screen>
		정의되지 않은 파일시스템이 검색되었을 경우 필드는 -1로 설정된다. 
	</para>
	<para>
		fstatfs()는 열린 파일지정자<emphasis>fd</emphasis>를 사용한다는 것을 
		제외하고는 statfs()와 동일하다.
	</para>
</section>

<!-- 함수가 되돌려주는 값이구요 -->
<section>
	<title>반환값</title>
	<para>
		성공시 0이 리턴되고, 에러가 발생하면 -1이 리턴된다. 
	</para>
</section>

<!-- 에러가 발생했을때 되돌려주는 값들입니다 -->
<section>
	<title>에러</title>
	<para>
		statfs():
		<variablelist>	
			<varlistentry>
			<term>ENOTDIR</term>	
			<listitem>
				<para>	
					path의 경로 요소가 디렉토리가 아니다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>ENAMETOOLONG</term>	
			<listitem>
				<para>	
					<emphasis>path</emphasis>가 너무 길다. 
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>ENOENT</term>	
			<listitem>
				<para>	
					탐색 허가권이 <emphasis>path</emphasis>경로 요소에서 
					거부되었다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>ELOOP</term>	
			<listitem>
				<para>	
					너무 많은 상징 연결을<emphasis>path</emphasis>해석시에 
					만났다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>EFAULT</term>	
			<listitem>
				<para>	
					<emphasis>buf</emphasis>나<emphasis>path</emphasis>가
					유효하지 않은 주소를 가리키고 있다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>EIO</term>	
			<listitem>
				<para>	
					파일 시스템을 읽거나 쓰는 동안 I/O 에러가 발생했다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>ENOMEM</term>	
			<listitem>
				<para>	
					이용할 수 있는 커널 메모리가 충분하지 않다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>ENOSYS</term>	
			<listitem>
				<para>	
					<emphasis>path</emphasis>파일 시스템이 statfs를 지원하지
					않는다.
				</para>	
			</listitem>
			</varlistentry>
		</variablelist>	
		fstatfs():
		<variablelist>	
			<varlistentry>
			<term>EBADF</term>	
			<listitem>
				<para>	
					<emphasis>fd</emphasis>는 유효한 파일지정자가 아니다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>EFAULT</term>	
			<listitem>
				<para>	
					<emphasis>buf</emphasis>가 유효하지 않은 주소를 
					가리키고 있다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>ENOSYS</term>	
			<listitem>
				<para>	
					<emphasis>path</emphasis>파일 시스템이 statfs를 지원하지
					않는다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>EIO</term>	
			<listitem>
				<para>	
					파일 시스템을 읽거나 쓰는 동안 I/O 에러가 발생했다.
				</para>	
			</listitem>
			</varlistentry>
		</variablelist>	
	</para>
</section>

<!-- 마지막으로 에제 입니다                                                 -->
<!-- 여기에는 완전한 예제가 들어가 있는데, 굳이 완전한 예제를 만들필요 없이 -->
<!-- 코드 일부분만 작성해서 올려주셔도 됩니다                               --> 
<!-- "<", ">", "&" 등은 변환해 주셔야 하는데, 귀찮으시면 :-) 변환 하지 않   -->
<!-- 아도 됩니다. 제가 검사 해서 올리겠습니다                               -->
<!-- 예제에 대한 간단한 설명을 적어주셔도 되구요                            -->
<section>
	<title>예제</title>
	<para>
		<screen>
/*
 * 파일시스템 정보 얻어오기
 * /proc/mounts 정보와 statfs를 이용한다. 
 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;libgen.h&gt;
#include &lt;sys/vfs.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;

const char *MMOUNT = "/proc/mounts";

struct f_size
{
    long blocks;
    long avail; 
};

typedef struct _mountinfo 
{
    FILE *fp;                // 파일 스트림 포인터    
    char devname[80];        // 장치 이름
    char mountdir[80];        // 마운트 디렉토리 이름
    char fstype[12];        // 파일 시스템 타입
    struct f_size size;        // 파일 시스템의 총크기/사용율 
} MOUNTP;

MOUNTP *dfopen()
{
    MOUNTP *MP;

    // /proc/mounts 파일을 연다.
    MP = (MOUNTP *)malloc(sizeof(MOUNTP));
    if(!(MP-&gt;fp = fopen(MMOUNT, "r")))
    {
        return NULL;
    }
    else
        return MP;
}

MOUNTP *dfget(MOUNTP *MP)
{
    char buf[256];
    char *bname;
    char null[16];
    struct statfs lstatfs;
    struct stat lstat; 
    int is_root = 0;

    // /proc/mounts로 부터 마운트된 파티션의 정보를 얻어온다.
    while(fgets(buf, 255, MP-&gt;fp))
    {
        is_root = 0;
        sscanf(buf, "%s%s%s",MP-&gt;devname, MP-&gt;mountdir, MP-&gt;fstype);
         if (strcmp(MP-&gt;mountdir,"/") == 0) is_root=1;
        if (stat(MP-&gt;devname, &amp;lstat) == 0 || is_root)
        {
            if (strstr(buf, MP-&gt;mountdir) &amp;&amp; S_ISBLK(lstat.st_mode) || is_root)
            {
                // 파일시스템의 총 할당된 크기와 사용량을 구한다.        
                statfs(MP-&gt;mountdir, &amp;lstatfs);
                MP-&gt;size.blocks = lstatfs.f_blocks * (lstatfs.f_bsize/1024); 
                MP-&gt;size.avail  = lstatfs.f_bavail * (lstatfs.f_bsize/1024); 
                return MP;
            }
        }
    }
    rewind(MP-&gt;fp);
    return NULL;
}

int dfclose(MOUNTP *MP)
{
    fclose(MP-&gt;fp);
}

int main()
{
    MOUNTP *MP;
    if ((MP=dfopen()) == NULL)
    {
        perror("error");
        return 1;
    }

    while(1)
    {
        while(dfget(MP))
        {
            printf("%-14s%-20s%10lu%10lu\n", MP-&gt;mountdir, MP-&gt;devname, 
                                MP-&gt;size.blocks,
                                MP-&gt;size.avail);
        }
        printf("=========================\n\n");
        sleep(1);
    }
}
		</screen>
	</para>
</section>
<section>
	<title>참고문헌</title>
	<para>
		<orderedlist>
		<listitem>
			<para>
			<ulink url="http://www.joinc.co.kr/modules/moniwiki/wiki.php/article_sms_프로그램_제작">SMS 프로그램 제작</ulink>
			</para>
		</listitem>
		<listitem>
			<para>
			<ulink url="http://www.joinc.co.kr/modules/moniwiki/wiki.php/Code_C_dfget">디스크 정보 가져오기</ulink>
			</para>
		</listitem>
		</orderedlist>
	</para>
</section>
</chapter>
}}}
