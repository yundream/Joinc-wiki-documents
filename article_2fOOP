== 객체지향에 대한 여러가지 단상들 ==

'''작성자:''' SaNha

{{{#!plain
객체지향적 프로그래밍과 절차지향적 프로그래밍의 가장 큰 차이점은 '객체지향적으로 생각' 한다는 것이다.
이 둘은 완전히 다르다. 절차지향적에서는 어떤일을 처리해나가는 순서를 생각하며 코딩한다. 
그리고 그 중간중간에 필요한 함수들을 만들고 라이버러리화 하여  다음에 같은 함수가 필요할때 재사용을 한다.
이때 이 함수들은 그 행위를 하는 그 이상도 그 이하의 역할도 못한다.
객체지향적에서는 처리해나가는 순서는 당장 급하게 생각하지 않는다.
다만, 전체 프로세스를 고찰하여 어떻게 '객체'를 분류할 것인가를 먼저 생각한다.
이러한 어떻게 클래스의 속성을(멤버변수) 정의하고 파생시키고 상속시킬 것이며 클래스간의 행위를(메소드) 정의할 것인가 객체지향적 프로그래밍의 관건이며 핵심이라고 할 수 있겠다.
}}}

{{{#!plain
클래스를 추출하고 멤버변수와 메소드를 정의하는 효율적인 방법은 여러가지 연구가 거듭되어 좋은 방법론들이 많이 나와있다.
특히 UML은 객체지향프로그래밍과 매우 궁합이 잘 맞으며 심지어 UML을 소스코드로, 소스코드를 UML로 자유자재로 변환시킬수가 있다. 
작은 규모의 프로젝트에선 머리속에서만 어느정도 생각을 하며 코딩해나가도 되겠으나 다수가 참여하는 엔터프라이즈급 프로젝트에서는 우수한 소프트웨어개발 방법론을 도입하여 진행을 하여야 할 것이다.
소프트웨어 개발 방법론들은 UML과 CBD(Component Based Developement) 를 활용하여 MS의 MSF(Microsoft Solutions Framework), 
삼성SDS방법론 등 큰 개발회사에서는 자체적으로 연구 개발하여 사용하고 있는 것들이 있으며 ETRI에서도 기업에 기술이전을 해주기 위하여 연구개발해놓은 마르미라는 개발방법론이 있다.
이 방법론들은 세세하게는 다를지 모르나 중요한 부분에서는 일맥상통하는 것이 많다고 할 수 있겠다.
향후, 큰 프로젝트들의 개발은 레고블럭 조립과 같이 컴포넌트들을 조립하고, 구성만 하면 또하나의 프로젝트가 마무리되는 방식이 될 것이다.
때문에 최근의 SI업체들은 CBD 기반의 프로젝트를 위한 상용컴포넌트의 매출에서도 큰 수익을 내고 있는 상황이며 자체 개발에서도 이를 활용하며 개발기간과 비용을 단축시키고 있다.
}}}

{{{#!plain
절차지향적 개발방법과 객체지향적 개발방법의 예시를 DBMS를 통해 나타내보자.
먼저 절차지향적으로 개발하게 되면 다음과 같은 순서를 떠올리게 될 것이다.
}}}

'''클라이언트 -> 쿼리 -> DBMS 소켓수신 -> 쿼리파싱 -> DB엑세스 -> 결과데이터 -> 소켓 -> 클라이언트'''

{{{#!plain
그리고, 이 순서에 따라 전체적인 코드의 구성이 정해질 것이다.
소켓은 비동기로 대기중일 것이고 쿼리가 들어오면 파싱함수를 통해 적절한 행위를 DB에 가할 것이고 결과를 다시 소켓을 통해 클라이언트로 보낼 것이다.
}}}

{{{#!plain
자, 이번엔 객체지향적으로 생각해보자.
객체지향적에서는 그 프로그램이 실제 형태를 지니고 있지 않다 하더라도 마치 현실세계의 그것과 같이 모델링하고 객체로 나누기 위해 노력한다.
DBMS라는 기계가 있다고 치자. 그렇다면 독립적인 속성과 메소드를 지닐수 있는 단위로 클래스는 한번 나눠보자
(여기서의 클래스추출은 어떤 방법론에 의한 효율적이고 체계적인 것은 아니다.
다만, 두 프로그래밍 방법에 대한 가장 큰 차이를 단적으로 보이기 위해 간단한 경우를 예로 드는 것이다)
DBMS에서는 먼저 외부와 소켓으로 데이터를 주고 받고 하는 소켓관리자란놈이 필요할 것이다.
이놈은 단지 소켓으로 데이터를 받고 보내고하는 역할만 할 것이다.
그리고 실제 DB에 적절한 쿼리를 행하고 결과를 받아내는 DB관리자가 필요할 것이다.
또한 소켓관리자와 DB관리자 사이에서 쿼리를 파싱하고 에러메세지를 던지며 적절한 상호교류를 하게 해주는 브레인관리자가 필요할 것이다.
}}}

{{{#!plain
자 그러면 큰 3개의 클래스는 대략 정해졌다. 잠깐 여기서 짚고 넘어가야할것은 모든것이 그러하듯이 클래스를 나누는데 정답은 없다는 것이다.
다만, 좀더 효율적이고 좋은 구조와 선택은 있을 것이다.
그러한 방법론들은 UML과 여러 소프트웨어 개발방법론에 잘 나와있으니 공부해보시기 바란다.
또한, 여기서처럼 크게 3개의 클래스로 나누는것으로 끝나는것이 아니다.
그러하다면 큰 프로시쥬어 3개와 별 다를바가 없는것이다. 보통은 다시 공통적으로 뽑아내고 분해할 수 있는 클래스로 나눠서 상속과 파생을 시켜나가는것이다.
그리하여 클래스란것은 진화발전하여 기존의 클래스들에서 다시 새로운 클래스를 뽑아냄으로서 개발기간을 줄이고 오류를 최소화하며 개념적으로 잘 정리되어 가는 것이다.
자바의 API와 MFC등을 보라. 얼마나 작은 뼈대클래스들로부터 굉장히 큰 클래스들까지 진화시켜 나간것을 알 수 가 있을 것이다.
자 이제 위의 클래스들을 프로세스를 대략 그림으로 본다면 아래와 같을것이다
}}}

'''소켓클래스 <-->  브레인클래스 <---> DB클래스'''

{{{#!plain
자 이번엔 이 클래스들이 내부엔 어떤 멤버변수와 메소드를 갖고 있어야할지 생각해보자.
멤버변수는 그 클래스의 속성이라고 볼 수 있으며 메소드는 외부와 통신하기 위한 혹은 내부적으로 어떠한 행위를 하기위한 '행동'이 될것이다.
소켓클래스는 속성으로 소켓fd, 버퍼 등이 있을것이며 DB클래스는 DB이름, 비밀번호, 포트, 쿼리, 결과값등이 있을것이며 브레인클래스는 상태머신에 따른 몇가지 속성이 있을것이다
 (생각나는대로 대략 적어본것이니 너무 꼬치꼬치 따지진 말아주시기를)
 자 이제 메소드를 생각해보자 메소드는 각 클래스가 외부와 통신하는 방법이다.
그 메소드가 다시 내부적으로 필요한 메소드도 있을것이니 후자를 private라 전자를 public이라 생각해도 좋을것이다. 
소켓클래스는 수신대기하는 서버소켓을 가동시키는 public형의 startWait() 와 소켓에 쓸 데이터를 처리하는 handleWrite() 메소드가 필요할것이고,
private로는 데이터가 들어왔을때 처리하는 handleRead() 가 필요할 것이다. 브레인클래스는 public로 쿼리를 받아서 파싱하여 적절한 일을 하는 parsingQuery(), 
DB클래스로부터 쿼리결과값을 받아서 적절한 일을 하는 handleResult()등이 있을수 있겠고,
private로는 각 소켓fd별로 지금의 상태를 기록하고 판단할 수 있게하기위한 stateProcess() 가 있을수 있겠다.
DB클래스는 public로 쿼리를 받아서 DB에 보내는 inputQuery()가 있겠고, private로 그 결과를 브레인클래스로 보내는 sendResult()가 있을수 있겠다.
자. 이제 무엇이 되었는가? 프로그래밍이 끝났다.
믿어지지 않는가?
각 속성과 메소드만 잘 정의하고 테스트하면 되는 것이다. 테스트는 테스트코드를 만들어 각 클래스별로 테스트하는 것이 디버깅시에 용이할 것이다.
전체 프로세스를 한번 살펴보자
}}}


'''main() -> 소켓클래스,브레인클래스,DB클래스 생성 -> 소켓클래스.startWait()'''

{{{#!plain
이번엔 소켓에 쿼리구문이 들어왔을때의 처리상황을 한번 살펴보자
}}}

'''Client -> query data -> 소켓클래스.handleRead() -> 브레인클래스.parseQuery(), stateProcess() -> DB클래스.inputQuery(), sendResult() -> 
  브레인클래스.handleResult(), stateProcess() -> 소켓클래스.handleWrite() -> Client'''

{{{#!plain
이상과 같이 대략 객체지향적으로 생각하고 프로그래밍하는 것에 대해 고찰해보았다.
다시 한번 강조하고 싶은 것은 절차지향적 프로그래밍과 객체지향적 프로그래밍의 가장 큰 차이점은 프로그램의 설계시에 "객체지향적으로 생각"한다는 것이다.
이것이 훈련이 되면 아무리 규모가 크고 복잡한 프로그램도 적은 오류와 빠른 시간에 쉽게 개발이 가능해진다.
하지만 실제 잘된 객체지향 프로그램은 그리 많지는 않다.
객체지향을 가장한 절차지향적 프로그램이 넘쳐나는 실정이다.
모쪼록, 여러분들은 UML, 디자인패턴, 소프트웨어공학, 개발방법론, CBD등등 다양한 분야와 기초지식 및 객체지향 프로그래밍에 대하여 많은 공부를 하여 자기것으로 만들어 진정 '아름다운' 객체지향적 코드를 생성해내길 바란다.
끄읕.
}}}
