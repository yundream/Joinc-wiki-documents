#title 펄의 과거, 현재 그리고 미래 - Larry Wall -

출처 : http://advance.sarang.net/~aero/perl/perl_present_future.html

[[TableOfContents]]
=== Perl은 어디서 아이디어를 가져왔는가 ===
좋은 아침입니다.

attachment:2.png
 
이 그림은 그동안 많은 제 강연을 통해서 보여드린것입니다. Perl은 많은것들로 부터 아이디어를 얻었지만 이 4가지는 그중에서도 가장 큰것들입니다. 이 그림을 보고 언어학(Linguistics)이 상식(common sense)의 반대되는 개념이라고 오해하시지는 말기 바랍니다.(웃음) 하지만 많은 컴퓨터과학자들은 언어가 좀 더 기술적이고 덜 예술적이여야 한다고 불평합니다. 저는 동의하지 않습니다만 일단 좋습니다.

attachment:4.png

하지만 Perl은 또한 생태학,수학,사회학 등등 다른 많은 과학분야에서 그 아이디어를 끌어왔습니다. 저는 그것들에 대해 이야기해왔지만 오늘은 하지 않겠습니다. 또한 골프과학에서의 Joel의 아이디어 Perl의 생물학 ... 많은 다른관점들도 있습니다. 이런것들에 대해 궁금한것이 있으시면 나중에 주저하지 마시고 질문해주시기 바랍니다.

하버드법칙이 뭔지 여러분들은 알고 있습니다. 그것은 물,온도,빛,음식이 조절되는 상황에는 생물체가 아주 즐거워 할 것이다. 라는걸 말합니다. (웃음).

=== Perl은 어떻게 UNIX의 세상에 나왔는가 (2:06) ===
아무튼 고생물학적으로 말하면 저는 이 화석을 캐내었다고 할 수 있습니다. 그것은 일종의 공룡알이었지요. 그리고 Perl이 처음시작 되었을때는 이것은 사람들이 어떻게 세상을 보는가 하는것 이었습니다. 

attachment:6.png

만약 C나 shell을 모두 사용하는 Unix 프로그래머였다면 아마 그 사이에는 뭔가가 전혀 없었을겁니다. 그리고 몇가지 이런 shell위에서 돌아가는 작은 언어들이 있었습니다만 그 영역은 크게 어긋나 있었습니다. 

attachment:10.png

여기서 Perl이 탄생하게 되고, 말하자면, 2차원의 세계에 나타나게 됩니다. C는 복잡한것을 다루는 manipulexity라고 하는데 좋고 반면 shell은 이것저것 후려치는데 적합한 whipuptitude라고 하는데 좋습니다. 

그래서 Perl이 작은 알처럼 탄생했고 그것은 Perl 1이었습니다. 그리고 그것은 첫시작부터 진화에 적합하도록 설계되었습니다. 변수들의 앞에 표식들을 넣은것은 이름공간(namespace)을 새로운 키워드로 부터 보호하기 위한것이었습니다. 그것은 의도적인것이었지요, 그래서 우리는 큰충격없이 아주 빠른속도로 언어를 진화시킬 수 있었습니다.

attachment:11.png

attachment:12.png

attachment:13.png

attachment:14.png

그리고 진화를 거듭하고 거듭하여 마침내 우리는 Perl 5를 가지게 되었고 그래서 아마도 Perl 6의 슬로건은 "모든 패러다임은 우리들의 것이다."가 될것이고 우리는 그것을 실현할것입니다.

=== 왜 Perl은 그렇듯이 진화했나 (3:54) ===

이렇게 우리는 5개의 성공적인 유기체를 가지게 되었습니다. 만약에 지금 Perl 문화를 들여다본다면 아주 건강하고 활기에 넘치며 많은것이 진행되고 있을을 느낄겁니다. 아무도 그 모든것을 따라갈 수 가 없습니다. 왜 그렇냐고요? 음, 그곳에는 진화적인 이유, 사회적인 이유, 언어학적인 이유, 인류학적 이유, 그리고 때로는 특별한 이유가 없을때도 있습니다. 그래서 저는 저자신의 불합리성을 가지고 얘기를 시작하고자 합니다. 

저는 문법이 바람속에 달랑달랑 거리지 않아야 한다고 생각합니다. 저는 아리스토텔레스와 같이 어떤 물체에는 시작,중심,그리고 끝이 있어야 한다고 생각하는데 그것은 제가 K&R의 괄호묶기를 좋아한다는 뜻입니다. 저는 python 하는 방식처럼 끝도없이 물체를 여기저기 매달아놓는것을 좋아하지 않습니다. 

저는 보통의 사람들은 추상화를 싫어한다고 생각합니다. 그것은 제가 추상화를 싫어하고 제가 보통의 사람이라고 생각하기 때문입니다.(웃음) 제가 그것에 대해 잘못됐을 수 도 있지만, 저는 모르겠습니다.

동시에 저는 언어는 멋지기도하고 아주 나쁘기도 하다고 믿습니다. 여러분들은 이것 둘다를 받아 들여야 합니다. 흉한 물건이 아름다울수 있고 아름다운것이 아주 빨리 흉해질 수 도 있습니다. 아시겠지만 Lisp예를 들어봅시다. 그것은 적어도 haskell이 나오기 전에는 세상 언어들 중에서 가장 아름다운 언어였습니다.(웃음) 그러나 아시겠지만 Lisp로 작성된 모든 프로그램은 흉합니다. 저는 그것들이 어떻게 동작하는지 종잡을 수 가 없습니다.

저는 시각적 은유가 아주 중요하다고 생각합니다. 어떻게 보든 다른 물체가 다르게 보여야하고 유사한 물체는 유사하게 보여야 합니다. 언어 설계자는 다른 사람의 생각을 신경쓸것과 다른 사람 생각을 신경쓰지 말아야할것을 동시에 고려해야합니다. 그렇지 않으면 미쳐갈겁니다. 음.(웃음)

마지막으로, 저는 신은 자유의지를 가지고 있다고 생각합니다. 따라서 그는 프로그래머가 자유의지를 가지게 창조했고 그들에게 주어진 선택권이 있어야 합니다. 

=== 다른 언어들의 비합리성 (5:54) ===
한데, 저 혼자만이 비합리성을 가진 언어 설계자는 아닙니다. 여러분은 다른 어떤 언어들도 이런것들을 가지고 있다고 생각할 수 있습니다. 

 * "밑 바닥부터 모조리 갈아엎고 시작해야 한다." - 대부분의 학문적인 언어
 * "영어 표현" - 그것은 Cobol. 카고컬트(남태평양의 원주민들이 미군이 비행기로 화물을 실어 와서 착륙하던걸 보고 다시 비행기가 착륙하여 자기들을 구원해주고 도와주기를 바라는 신앙- 다시는 일어나지 않을 어이없는것을 바라는 어리석음을 뜻함) 영어. (웃음)
 * "문자열 처리는 중요한 문제가 아니다" - Fortran.
 * "간단한 언어는 간단한 해결책을 만든다." - C.
 * "빨라지길 바란다면 C로 만들것이다." - 원본 awk 페이지로 부터의 거의 직접적인 인용
 * "나는 어떻게 해야할지 생각을 했다. 따라서 그것은 올바른것이 틀림없다." - 그것은 명백하게 PHP. (웃음과 박수)
 * "무엇이라도 NAND게이트로 만들 수 있다." - 전자공학자에 의해 만들어진 아무 언어들. (웃음)
 * "이것은 고차원 언어이다. 누가 bit를 신경쓰느냐?" - 4세대 언어의 전 영역이 이 문제에 봉착함
 * "사용자는 우아함에 신경쓴다." - 유럽쪽에서 만들어진 많은 언어들이 여기에 봉착함, Eiffel.
 * "언어명세(specification)가 충분히 좋다." - Ada.
 * "추상화는 사용성과 같다." - Scheme. 그와 비슷한 언어들.
 * "일반 핵심(common kernel)은 가능한한 작아야 한다." - Forth.
attachment:19.png
 * "컴퓨터가 알아먹기 쉽게 만들자" - Lisp.(웃음)
 * "대부분 프로그램이 하향식으로 설계되어진다." - Pascal.(웃음)
 * "모든것은 벡터다" - APL.
 * "모든것은 객체다" - Smalltalk 와 그 파생언어들. (속삭이며:) Ruby. (웃음)
 * "모든것은 가설이다." - Prolog. (웃음)
 * "모든것은 함수이다." - Haskell. (웃음)
 * "프로그래머에게는 주어진 자유의지가 있어서는 안된다." - 명백하게, Python. (웃음)
 
이렇게 저의 심리학적인 추측은 일반적인 사람, 그들이 컴퓨터 언어가 이론을 배우기를 강요한다는것을 인지하면 그것을 좋아하지 않을것이다라는 것입니다. 다르게 말해서, 

선호하는 것들을 감춰라. 설령 있다고 해도 그냥 감춰라는 것입니다. 

=== 언어학 (8:22) ===
심리학에서부터 언어학적측면까지 봤을때 , Perl은 첫째로 자연어처럼 동작한다는 이유로 성공이다 라고 생각합니다. cobol이 했던것 같은 구문안의 카고컬트 보다 더한 기초를 이루는 깊은 원칙 몇몇것들, 언어학의 깊은 원칙을 목표로 했습니다. 

'''언어학의 원칙''': 여러분은 여러분이 하던 방식대로의 배운 자연어로. 알다시피, 한 번 배우면 많이 사용합니다. 따라서, 여러분은 쉬운 학습용이성을 위해서가 아니라 표현성을 위해 최적화 해야합니다. 학습용이성 그것 좋습니다. 하지만 표현성이 더 중요합니다. 

'''언어능력''': 우리는 15살먹은 사람이 5살먹은 사람같은 신뢰성 수준을 가지고 얘기하리라 기대하지 않습니다. 그렇다 쳐도. 여러분은 갓난아이 말도 구사할 수는 있습니다. 

같은것을 말하는 방법에는 여러가지가 있습니다.

프랑스인이 아니라면 단어를 차용해서 쓰는데 수치심을 느끼지 않을것입니다. (웃음)
차원상의 문제로 돌아가서. 여러분이 언어학적으로 뭔가를 말할때, 그것은 여행을 가는것과 같습니다. 아시겠지만, 캘리포니아에서 네타니아로 여행을간다고 치면 남쪽으로 직선으로 갔다가 서쪽으로 직선으로 갔다가 그리고 북쪽으로 직선으로 가지 않습니다. 그것은 직교적인게 아닌거죠. 시작시에는 몇가지 방식이 있고. 비행기에 올라 더 큰 단계를 거치고 마지막에는 더 작은 단계를 거쳐 끝에 이릅니다. 언어는 똑같은 방식으로 동작합니다. 언어는 자기분열적입니다. 거기에는 직교성이 적습니다. 적어도 표면적으로는; 직교적인 시각을 가질 수 있고, 직교적인 부분들이 있습니다. 하지만 거기에는 다양한 직교적 부분들이 있습니다. 언뜻 처음 봤을때 그것은 네트워크처럼 보입니다, 그리고 여러분은 그 지세를 탐색해나가야 합니다. 

더 자연어적으로는, 우리는 아마도 많은것을 생략할것 입니다.,하지만 Perl에서도 똑같이 그럴것입니다. 
 
자연어의 습득과정에 있어, 최우선의 원칙이 없으면. 상대방이 여러분에게 스타일을 강요할 수 있으나. 언어는 여러분에게 스타일을 강요하지 않습니다. 

설계는 분산적입니다.

표현형식은 다양하게 갈릴겁니다. 따라서 여러분은 표현형식에 대한 마음을 먹어야합니다. 여러 언어들에서 가져와서 하나의 언어에 붙여넣은것들도 유용하며. 여러분은 Perl안에 그러한 것들이 있음을 알아챘을겁니다. 
 
그리고 마지막으로, 문화가 없는 언어는 죽습니다. 그것은 언어를 설계하기위한 지적연습일뿐입니다. 여러분은 동참해서 따를 문화를 가져야합니다. 그것이 저를 인류학적 관념으로 이끌었고, 문화는 언어를 고칠 수 있으나 언어는 문화를 고칠 수 없기 때문에 Perl 문화가 언어 그 자체만큼 중요한것 입니다. 

=== 인류학 (11:10) ===
이제 인류학적인 측면에서 우리는 Perl계로 들어오는 사람들을 환영하려고 합니다. 우리는 사람들이 자신들만의 작은 주도권을 가질수 있고 자신이 주도자인 곳에서는 따르는 사람들을 이끌 수 도 있게 합니다. 

우리는 사람들이 서로서로 공유할 수 있게 합니다. 우리는 지식을 얻으려고 합니다. 두가지를 할 수 있는 이유는 우리가 이론의 여지없는 재사용 가능한 세계에서 가장 큰 시시한(?) 소프트웨어 저장소의 하니인 CPAN( Comprehensive Perl Archive Network - http://cpan.org )을 가졌기 때문입니다. (웃음).

그리고 우리는 또한 다른 문화와 협력할 수 있는 문화를 가지고 있습니다. 우리는 다른언어들이 parrot(Perl 6의 기반이되는 일종의 가상머신VM - http://www.parrotcode.org )위에 돌아갈 수 있게 만들려고하며 항상 Perl을 겸허한 방식을 취하면서 모든것들과 연결시키려고 했는데 그것은 재미의 문화입니다. 적어도 우리는 그런 방식을 만들려고 했고 그것이 제가 이런 이상한(?) 얘기를 하는 까닭입니다. 

=== 다른 과학들 (12:14) ===
어려운 과학들엔 어떤것들이 있을까요? 아마도 물리학 집어서 말하면 양자물리학이란걸 아실겁니다. 그건 매우 어렵죠.(웃음) 만약에 물리학처럼 생각한다면 화학도 어려운 과학일 수 있습니다. 그리고 골프는 매우 어렵지만 그렇게 확신하지는 못합니다.

attachment:30.png

자, 전 이 폭포수 도표(waterfall chart)을 자주 보여드렸었는데 여러분중 많은 분들이 아마도 보셨을겁니다. 만약 프랙탈 피드백 루프에 들어가서 만약 그것을 반대 방향으로 수행한다면, 아마도 익스트림 프로그래밍일겁니다. 

attachment:33.png

그러나 핵심은, 여러분은 어떤 이상한 힘들에 끌려가면서 이런식으로 하고 있을겁니다. 

attachment:34.png

 하지만 여러분이 수행한것을 어떻게 알 수 있을까요? 다름 아닌 테스트가 여러분이 수행한것을 말해줍니다. 하지만 테스트가 올바를까요? 누가 알겠습니까? 

attachment:35.png
자, 과학을 공부했던 우리는 이 포텐설에너지 그래프를 봤을겁니다. 만약에 경제학자라면 이 그래프를 위아래로 뒤집으면 언덕오르기 알고리즘 (hill-climbing algorithms)이 되겠지요. 하지만 모두 같은 것입니다. 

attachment:36.png

공은 언덕아래로 굴러 내려가려고 합니다. 

attachment:37.png

우리는 최적일까요? 이것은 최적의 상태일까요? 아마도 아닐겁니다. 

attachment:38.png

우리는 잘못된 최소값에 있을 수 있습니다. 

attachment:39.png

자, 그럼 우리는 어디있어야 행복할까요, 하지만 우리는 아직 저 너머에서 더 행복할 수 있을지 알지 못합니다. 

attachment:41.png

언덕을 올라서 살짝 들여다 보려면 어느정도의 에너지가 필요하고 여러분은 그런 방식으로 할 수 있습니다. (정점을 올라간다.), 또는 

attachment:43.png

그냥 지나기 위해 꼼수를 쓸 수 있습니다.(터널 통과하기) 아마 틀림없이, 첫번째는 Parrot의 접근방식이고, 두번째는 Pugs(haskell언어로 만든 Perl 6의 구현 - http://www.pugscode.org)의 접근방식이 되겠습니다. 

attachment:44.png

하지만 어떻게 그곳에 도달하게 되든, 

attachment:46.png

그곳은 약속된 땅입니다. 아마도 여러분은 약속된 땅에 대해 어느정도 알고 계시리라 생각합니다.(웃음). 여러분들이 만약 여기에 되돌아간다면, 여기가 야곱과 칼렙이 살금살금 들어오기를 원했던 그곳이고 여기가 이스라엘의 아이들이 사막에서 4년을 보내기를 원했던 그곳이라는걸 아실겁니다.(웃음) 희망적으로 우리는 Perl 6에 4년안에 이를 수 있을겁니다.(웃음) 얼마나 걸릴지 모르지만, 우리는 여전히 다가가고 있습니다. 
=== 팬 메일 (14:42) ===
 * Q: "존경하는 Larry, 저는 Perl을 사랑합니다. Perl 이 저의 회사,동료,내정신 그리고 결혼을 구원해냈습니다. Perl을 만난 이후로 저는 다른 언어로 돌아간다는것을 상상할 수 없습니다. 저는 Perl안에서 꿈을 꿉니다, 그리고 모두에게 Perl에 대해 얘기합니다. 당신은 어떻게 완벽성을 발전시킬수 있나요? 서명됨, 하이파(이스라엘의 도시명)에서 Happy 

 * A: "존경하는 Happy, 
Perl은 어떤 영역에서는 좋을 수 있고 또 다른영역에서는 좋지 않을 수 도 있다는걸 아셔야하며 또한 진짜 최소값에 이르는 장벽을 오르든지 터널처럼 지나가든지 어느정도 고통이 따를것이라는걸 아셔야 합니다.  

지금 Perl 5는 몇몇의 잘못된 최소값들을 가집니다. 문법,의미론,어용론,(웃음), 논설구조,구현,문서,문화... 그렇다 치더라도 Perl 5는 그렇게 나쁘지 않습니다. 

 * Q: "존경하는 Larry, 
당신은 언어학의 복잡성의 물침대이론(waterbed theory - 비압축성의 물이든 침대의 한곳을 누르면 다른곳이 튀어 나온다는 말)과 미모와 지식의 곱은 상수이다 (미모가 뛰어나면 머리가 비고 머리에 든게 많으면 미모가 떨어진다는 말)라는 Beckhap의 법칙에 대한 말을 종종 해왔습니다. 그것은 Perl의 특정 부분을 발전시키면 자동적으로 다른 부분은 나빠진다는 말 아닙니까? 서명됨, 텔아비브의 Terrified"  

 * A: "존경하는 Terrified, 
... 
아닙니다." (웃음) 

attachment:52.png

보시다시피, 여러분은 더 나빠지는것 없이 어떤것들을 만들 수 있습니다. 예를들면, 우리는 모든 표식들을 더 일관성있게 바꾸었고 그것들은 똑같은 길이를 가졌고, 단지 모양이 다릅니다. 그리고 어떤것들은 더 좋게 만들 수 있습니다. 

attachment:54.png

Perl 5의 이런 이해하기 힘든 디레퍼런스 연산자를 Perl 6에서는 직접 왼쪽에서 오른쪽으로 이렇게 쓰기만하면 됩니다. 또 다차원배열에 대한 더 빠른접근과 상수 해쉬에 대한 기호가 추가되어 더 또렸하게 구별됩니다, 다시말하자면 우리는 학습용이성을 위해서가 아니라 표현성을 위해 최적화 하고 있습니다. 

 * Q: "존경하는 Larry, 
Perl 6가 Java 또는 Python 또는 (속삭이며:) Ruby와 같이 될것이다라는 소문을 들었습니다. 만약 그냥 또 하나의 다른 객체지향언어가 된다면 Perl을 사용해야 할 중요한 포인트가 무엇입니까? 왜 화살표 연산자를 점 연산자로 바꾸나요? 서명됨, 네타나야의 Nervous" 
 
 * A: "존경하는 Nervous, 
무엇보다도, 다른것들이 더 나빠지는것 없이 객체지향을 더 좋게 사용할 수 있습니다. 제가 말했듯이. 이제 화살표에서 점연산자로 바꾸고 있습니다. 왜냐하면 ... 왜냐하면 ... 음, 제가 그렇게 말했기 때문이죠!"  

attachment:58.png
아시다시피, 실제로, 우리는 합당한 이유들을 가지고 있습니다. - 그것은 더 간단하기때문이고, 산업표준이고, 저는 화살표를 어떤 다른것으로 바꾸기를 원했기 때문이고 점을 두번째의 표식으로 사용하기를 원했기 때문입니다. 이제 우리는 그것을 통해 접근자를 가진것들의 속성을 가져오는데 쓸 수 있습니다. 또한 저는 객체의 왼쪽에서 점 단항연산자를 통해 특정 형태의 호출을 원했습니다. 그리고 마지막으로 제가 그렇게 말했기 때문이고. 그렇게 짜맞췄습니다. 

=== 미래완료 (17:25) ===
따라서, 불완전일 수 도 있는 현재진행에서 미래완료로, 적어도 더나은것으로 나아갑시다. 

우리가 Perl 6의 모험을 시작했을때 우리는 "커뮤니티가 Perl 6을 재작성 할것이다. 그것은 언어,문화,개발,모든것의 재작성일것이다."라고 발표했습니다. 그래서 우리는 그것을 시작했고, 저는 변화를 위한 아마도 20개의 RFC를 기대했는데 우리는 361개 RFC( http://dev.perl.org/perl6/rfc/)를 가지게 되었고 그것들은 모두 지도위에 있습니다. 그것들은 서로 반박했고, 몇몇은 정말 사이비같은 해결책도 있었고, 모두다 똑같은 문제점을 겪었는데 그것은: 모두가 이것이 Perl 5에 가하고자 하는 최고의 변화이고 그렇지 않으면 모든 다른것들이 말짱 도루묵이다 라고 했던것입니다. 

자, 그런방법은 재설계하는 방법이 아닙니다. 그런 방식으로 재설계 한다면, 결국에는 뒤죽박죽되어 버릴겁니다. 따라서, 제가 발견한것중 하나는, 예를들면, 언어 설계의 첫번째 법칙은 그들만의 특별한 문법을 위해 "모두가 콜론을 원한다" 그리고 그들 스스로의 모순성때문에 그들 모두 그것을 가질 수 는 없다 입니다. 그렇게 해서 언어 설계의 두번째 법칙은 "Larry는 그가 원하는 무엇을 위해서든 콜론을 가진다" 입니다."(웃음) 

나는 친절하게 가르쳐주는 방법(Winnie the Pooh approach)를 선택했는데 이것은 한 사람을 위해 너무 많은 정보를 주는 방법일 뿐이였습니다. 아시겠지만 Audrey(혜성처럼 등장해서 Pugs를 개발하고 Perl/Perl 6 개발에 활발한 활동을 보이는 대만의 신예 프로그래머 - http://en.wikipedia.org/wiki/Audrey_Tang)만큼 똑똑한 사람도 이 모든것을 한 번에 이해하긴 힘듭니다. 그리고 나는 적어도 어떤면에 있어서 Audrey보다 어리석습니다. 그래서 나는 일반적 인 Perl 프로그래머들이 좋아할 정도의 어리석음을 가진 수준안에서 방법을 찾았었고. 그래서 내가 어떤것들은 쉽게 이해하지 못할 정도면 다른 사람에게 쉽게 이해될 수 없을것이다 따라서 나는 그런 종류의 특징을 소개하는데 아주 신중해야 할것이라고 판단했습니다. 아시다 시피, 우리는 그것을 "아주 작은 뇌를가진 곰 접근방식"이라고 부릅니다. 그것이 제가 할 수 있는 유일한 방법이기 때문에 저 한테 잘 맞습니다. 

제가 시작할때 우리는 "그것을 올바르게 할 때는 절대 없겠지만, 개선할 시간은 항상있다." 라고 말했습니다. 따라서 우리는 그것을 올바르게 하기 위해 시간을 가지고 있을 뿐입니다. 아마 "좋은것, 빠른것, 싼것. 두개씩 골라" 이렇게 말하는것을 들어봤을겁니다. 이것이 오픈소스입니다. 우리는 손쉽게 이것을 해야합니다. 그리하여 그것은 "좋은것 또는 빠른것. 하나만 골라"의 문제를 줄여주고 우리는 빠른것을 선택하지 않고 좋은것을 선택했습니다. 아마 여러분은 이런것을 알아챘을것입니다.(웃음) 우리가 Perl 6을 5년반 전에 시작선언했던것을 생각해보면 우리는 여전히 그것을 똑바로하려고 하고 있습니다. 다양하게 모여드는 개발진행상황이 존재하는한 우리는 거기에 이를것입니다. 그것은 정말 간단합니다. 좋은 모든것들을 수용하고 나쁜 모든것들을 버리는것입니다. 그것은 말하기는 쉬워도 행하기는 어렵습니다. 

