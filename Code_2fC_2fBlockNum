#title Bit필드에서 최상위 블럭 얻어오기

== blocknum ==
 * 32bit 데이터를 2bit씩 16블럭으로 나눈다.  
 * 최상위 블럭부터 검사해서, 0보다 더큰 블럭을 얻어온다. 

{{{#!plain
즉 다음과 같은 int형 값을 해당 함수에 집어넣으면 
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|00|00|01|10|00|11|00|00|01|01|10|11|11|00|00|00|
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  0  1  2  3  4  ...                          15

2가 리턴된다.
}}}

{{{#!plain
#include <stdio.h>

int blocknum(int num)
{
  int n = 0;
  for ( n = 0; n < 16; n++)
  {
    if ((num >> 30))
    {
      printf("Stop%d\n", n);
      break;
    }
    num = num << 2;
  }
  return n;
}
int main()
{
  int i=1;
  printf("%d block\n", blocknum(1));
  printf("%d block\n", blocknum(1000));
}
}}}

== 활용 ==
검색엔진에서 해당 '''Term'''을 포함한 문서가 발견되었을 경우, Term이 문서의 어느위치에 있는가에 따라서 점수를 달리해줄 필요가 있다. 문서의 앞쪽에 발견되었다면 좀 더 높은 점수를 주는 식이다.  

Term이 발생된 위치에 따른 정확한 점수를 주기 위해서는 문서에서 Term이 어느위치에 있었는지를 모두 기억하고 있어야 한다.

  문서 A가 Term '''T'''를 포함한다면, 토큰으로 분리된 A문서의 몇번째에 위치하는지의 정보를 가진 Prox DB가 있어야 한다. 여기에는 <5,12,24,50> 이런식으로 위치정보가 들어가는데, 이는 문서 '''A'''에 Term '''T'''가 4번 발생했으며 문서의 5, 12, 24, 50번째 위치에 존재한다는 정보를 포함한다.

  이 방식을 사용하면 문서에 대한 정확한 Score가 가능하지만 연산에 대단히 많은 시간이 소모된다. 위의 비트블럭방식은 문서를 16개의 블럭으로 나누어서, Term이 발생된 위치에 대응되는 비트블럭에 체크를 하는 방식이다. 이는 Prox DB를 이용하는 방식에 비해서는 정확도가 약간 떨어지지만, 빠른 Score가 가능하게 한다. 속도튜닝에 사용할 수 있을 것이다.

검색엔진에 대한 자세한 내용은 lucene(:12)문서를 참고하기 바란다.
