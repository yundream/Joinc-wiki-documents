#title 커널 스택 크기 제한 사항 

다음 코드를 컴파일한 후 실행 시켜보자.

코드는 Linux kernel.2.4.20, gcc 3.2.2를 통해서 테스트 되었다.
{{{#!plain
#include <stdio.h>
#include <string.h>

void __a__(void)
{
 unsigned char s_AAA[ 8 << 20 ]; // 8M
 fprintf(stdout, "Entering memset\n"); 
 memset(s_AAA, 0xff, sizeof(s_AAA)); 
 fprintf(stdout, "Leave memset\n");
}

int main(int s_Argc, char *s_Argv[])
{   
        __a__(); 
        return(0);  
}
}}}

그럼 세그먼트 폴트 에러를 출력하면서 종료되어 버린다. 이유는 커널레벨에서 각 프로세스에서 할당 가능한 스택사이즈에 제한을 가지고 있기 때문이다. 이러한 제한 사항은 다음과 같이 정의되어 있다. 
{{{#!plain
/usr/src/linux/include/linux/sched.h
------------------------------------
#define _STK_LIM  (8*1024*1024) // 8M
}}}

(배열등을 저렇게 크게 만들어서 사용하는 경우는 드물긴 하겠지만) 필자의 경우에도 배열을 매우 크게 잡아서 사용해서 코딩한 프로그램이 있었다. 이 프로그램이 잘 돌다가 간혹 죽는 문제가 있었는데, 이 문제 잡을려고 상당히 시간을 투자했었고 결국 위의 스택사이즈 제한 문제 때문이란걸 알게 되었다. 문제는 malloc()을 이용해서 간단히 해결할 수 있었다. 스택영역을 사용하는 변수의 사용시에는 크기에 주의해서 사용해야 한다는 교훈을 얻었다. 

이건 커널 제한 사항이므로 Linux가 아닌 다른 운영체제에서는 문제가 되지 않을 수도 있다. 예를 들어 윈도우즈 환경에서의 경우 위의 코드는 문제 없이 실행되었다. 어쨋든 큰 스택메모리를 사용해야 할 경우라면 malloc()를 이용해서 동적으로 할당하도록 하자. 

만약 이 제한을 풀기 위한 묘책을 찾는다면 2가지가 있습니다. 첫째는 커널의 헤더 /usr/src/linux/include/sched.h 에서 직접 수정하여 커널을 재컴파일 하는 방법이 있으며 또 다른 방법은 ulimit 명령 또는 함수를 사용하여 해결하는 방법입니다. "ulimit -s" 를 실행해보시면 자신의 스택 제한값을 KByte 단위로 알수 있으며 이것을 "ulimit -s <스택 최대 제한값>" 과 같은 형식으로 변경할수 있습니다. 또한 C코드에서 사용하려면 man 페이지의 setrlimit(2) 를 참조해보면 보다 좋은 정보를 확인할수 있다.
