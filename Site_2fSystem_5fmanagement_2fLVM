#title LVM - Logical Volume Manager

[[TableofContents]]
== 1시간이면 LVM 이해할 수 있다. ==
소프트웨어쪽은 원리보다 용어를 이해하는게 더 어려운 경우가 많습니다. 용어 자체가 추상적인데, 그나마 줄여서 표현하기 때문입니다. 특히 "논리적", "추상적"같은 단어가 들어가면 전혀 감이 잡히지 않는 경우가 많습니다.

그래서 애초에 포기해버리는 경우가 많죠.

사람은 애초에 추상적인 것보다는 구체적인 것을 논리적인 것보다는 직관적인 것을 더 잘 이해할 수 있기 때문이죠. 학자가 아닌 평범한 사람들이 지금 수준의 추상적인 생각을 한거는 2세기가 채 안되지 싶습니다. 그러니 머리에 들어올리가 만무하죠. 

가장 좋은 방법은 구체화 하는 거죠. 구체화 하는 가장 좋은 방법은 자신의 경험을 직접 글로 나타내는 겁니다. 그림이 포함된다면 그보다 좋을 수 없죠.  

해서 한 시간이면, LVM을 이해할 수 있도록 글과 그림으로 제 경험을 표현해 볼까 합니다. 그렇다고 해도 리눅스 운영체제를 어느정도는 다룰 수 있어야 겠죠 ?

== LVM에 관심을 가지게된 이유 ==
LVM은 별 관심이 없는 기술이었습니다. 시스템관리자에게 필요한 것이지 저 같은 프로그래머에게야 그다지 필요한 기술은 아니니까요. 재미삼아서 설치해볼까 했지만 귀차니즘 때문에 포기했었구요. Logical이란 단어가 들어간 기술이 흔히 그렇듯이 왠지 복잡해 보일것 같아서 말이죠.

역시 일때문에 LVM에 관심을 가지게 됐습니다. 최근 Cloud(:12)관련일을 하고 있는데요. 클라우드 컴퓨팅의 가장 큰 장점중의 하나는 '''유연함''' 아니겠습니까 ? 그러하니 파일 시스템도 유연한 LVM을 사용하면 뭔가 도움이 되지 않을까 ? 이렇게해서 LVM에 관심을 가지게 됐습니다.

=== LVM 구조 ===
리눅스 시스템에서 Volume를 만드는 일반적인 방법은 블록 디바이스에 파일 시스템을 만들어서 사용하는 거죠. 파일 시스템은 형식에 맞게 포맷해서 사용 하고요. 그림으로 그려보자면 대략 아래와 같을 겁니다
. 

{{{#!html
<img src="https://docs.google.com/drawings/pub?id=1J1dPlGsEURadwLRRBZnDR_Vam1p4AMedB8SfYg89Mco&amp;w=258&amp;h=209">
}}}

블럭 장치인 /dev/sda1, /dev/sda2를 파일 시스템에 마운트 해서 사용하는 방식입니다.

만약 /dev/sda1 을 /mnt/ftp에 마운트 해서 사용하고 싶다면 아래와 같이 할 겁니다.
{{{#!plain
# mkfs -t ext4 /dev/sda1                 # 포맷 하구요
# mount -t ext4 /dev/sda2 /usr/data/ftp  # 마운트 합니다.
}}}

이 방식은 파일 시스템과 장치가 직접 맵핑되기 때문에 사용이 직관적이라는 장점이 있습니다. 하지만 하드웨어를 직접 다루는 기술들이 그렇듯이 '''유연하지 않다'''는 단점이 있습니다. 처음 /dev/sda1의 크기를 10G로 잡았는데, 용량이 부족하면 어떻게 해야 할까요 ? 장치를 새로 마련하는 방법 밖에 없습니다. 장치를 여러개 묶어서 크기를 늘리는 것도 쉬운일이 아니죠. 혹은 파티션을 나눠야 한다던지..

특히 대량의 데이터를 사용하는 일이 많은 요즘에는 disk를 함께 묶어서 단일한 거대 storage를 구성해야 할 필요성이 늘어나고 있습니다. 물리적인 볼륨을 논리적인 단일 볼륨으로 묶을 수 있어야 하는 거죠.  

이때 LVM을 사용합니다. Logical이란 말은 대상을 추상화 하겠다는 겁니다. File System과 블럭 디바이스 사이에 추상화 계층을 하나 더 둔 거죠. 아래의 그림을 보죠.

{{{#!html
<img src="https://docs.google.com/drawings/pub?id=1WUZ9yu749btuq8WcP8LXM4D9k8XMVgDXXmDKjL5_2j0&amp;w=341&amp;h=298">
}}}

논리적인 볼륨을 하나 만들어서 블럭 장치들을 하나로 묶어 버립니다. 그 다음 적절한 크기로 나눠서 사용하는 거죠. 논리적이니 만큼 볼륨을 새로 만들거나 기존 볼륨의 크기를 늘리거나 하는 일을 자유롭게할 수 있습니다. 개인이 사용한다면, 볼륨을 나누어서 사용하는 것에 관심이 있겠고요. 저 같이 cloud쪽 일을 하는 사람이라면 볼륨을 하나로 묶는 것에 관심이 많겠죠.  

LVM이라는 것은 Logical Volume를 Managing하는 인터페이스를 제공하는 Storage 소프트웨어인 거죠.

LVM를 좀 더 자세히 살펴 보겠습니다. LVM에서 가장 밑에 있는게 물리적 볼륨이죠. 이것을 PV(Physical Volume)라고 합니다. 위 그림은 2개의 PV로 구성돼 있습니다. 그리고 PV는 PE라는 블럭의 모음으로 구성됩니다. PE는 Physical Extents의 줄임말 입니다. 

PV위에 VG가 있습니다. Volume Group의 줄임말인데, PV를 논리적으로 묶은 볼륨 그룹입니다. VG는 하나 이상의 PV로 구성이 되구요. 이제 LVM에 Volume를 요청하면, 요청한 크기만큼 LV를 돌려줍니다. 이 LV를 (/mnt/ftp 등에)마운트 해서 사용하는 거죠. 만약 /mnt/ftp의 볼륨크기를 키울려면 남는 PE를 요청해서 LV크기를 키우면 됩니다.

{{{#!html
<img src="https://docs.google.com/drawings/pub?id=10XKYaHmA_K_zQA5A5gNT4nrYjN_v6bOpixxkVCC0nmw&amp;w=526&amp;h=358">
}}}

== LVM으로 할 수 있는 것들 ==
대략 LVM으로 할 수 있는 것들이 정리가 됩니다. 
  1. 새로운 블럭 장치가 추가 할 경우, 기존 파일시스템의 변경 없이 볼륨의 크기를 키울 수 있습니다.
  1. 간단하게 LV를 확장할 수 있습니다.
  1. LV로 부터 읽기 전용의 snapshot를 만들 수 있습니다.
  1. RAID 0처럼 PV를 2개 이상 엮어서 데이터를 읽고 쓸 수 있습니다. 대역폭을 늘일 수 있죠.  
     * 하지만 parity기능은 없습니다. fault tolerance 하지 않죠. 
  1. RAID 1처럼 mirror 구성을 할 수 있습니다.
=== Linear Mapping LV 와 Striped Mapping LV ===
위에서 RAID 0 처럼 PV를 엮어서 대역폭을 늘일 수 있다고 했는데요. 이것에 대해서 알아보도록 하겠습니다.

{{{#!html
<table>
<tr>
<td>
<img src="https://docs.google.com/drawings/pub?id=1jSefkW1X9_iKyJTwNGO0lQQ3jYG2nA0jHWXIXhe5b2Y&amp;w=341&amp;h=671">
</td>
<td>
<img src="https://docs.google.com/drawings/pub?id=1RCbeoUYvJ4m4UQ-xvTmuPWaiqTSVP8HeaejsbNPxcEg&amp;w=341&amp;h=671">
</td>
</tr>
</table>
}}}
  * Linear Mapping LV 일반적인 방식입니다. 블럭 장치에 데이터를 쓰듯이 순차적으로 씁니다. 
  * Striped Mapping LV : 두 개의 PV를 striping해서 사용합니다. PV의 PE는 적당한 크기의 조각들로 나누어지는데, LVM은 데이터를 두 PV에 분산하여 할당을 합니다. 그래서 두개의 PV에서 동시에 데이터를 읽고 쓸수 있게 돼서 대역폭을 늘리게 되는 거죠. 물론 이런 효과를 얻을려면 PV가 독립된 장치여야 겠죠. 같은 장치내의 파티션이라면 오히려 역효과가 날 겁니다.

=== snapshot LV ===
서비스의 중지 없이 백업을 하려고 할때 특히 신경써야 하는게, 백업 도중 데이터 변경이죠. 이 문제는 Snapshot LV를 이용해서 해결할 수 있습니다. 이 기능을 이용하면 특정 시점의 데이터 상태를 고정할 수 있습니다. 고정하기 원하닌 LV를 복사해서 읽기 전용의 새로운 LV를 만드는 거죠. 그러니 데이터 변경을 고민하지 않고 백업작업을 마칠 수 있습니다. 


== Linux LVM ==
Linux에서 LVM을 테스트 해보기로 했습니다. 지금 사용하고 있는 리눅스 박스에는 LVM을 테스트할 더 이상의 공간이 없었기 때문에, VirtualBox(:12)를 이용해서 테스트 하기로 했습니다. 장치를 추가할 수 있기 때문에 간단히 테스트 환경을 구축할 수 있었습니다. VirtualBox 짱. 두 개의 SATA 디바이스를 추가했습니다. 이름은 PV1 PV2, 크기는 2G byte로 했습니다. 
{{{#!html
<table style="width:auto;"><tr><td><a href="https://picasaweb.google.com/lh/photo/AiVLzFpbmwplvKcv46FEsw?feat=embedwebsite"><img src="https://lh4.googleusercontent.com/-NzRJ9O3tR48/Tl7ccWlYWbI/AAAAAAAABw8/yHtZ3OTuuP0/s800/lvnubuntu3.png" height="475" width="618" /></a></td></tr><tr><td style="font-family:arial,sans-serif; font-size:11px; text-align:right">보낸 사람 <a href="https://picasaweb.google.com/yundream/Linux?authuser=0&feat=embedwebsite">Linux</a></td></tr></table>
}}}
=== 현재 장치 상태 확인 ===
VM을 실행한 다음 fdisk로 장치 상태를 확인했습니다. root에 준하는 권한으로 실행해야 합니다.
{{{#!plain
# fdisk -l
....
Disk /dev/sdb: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000

Disk /dev/sdb doesn't contain a valid partition table

Disk /dev/sdc: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000
}}}
2G byte 크기의 블럭 장치를 확인할 수 있습니다. /dev/sdb, /dev/sdc 이군요.


=== pv 확인하기 ===
현재 시스템의 physical volume을 먼저 확인해 보겠습니다.  
{{{#!plain
# pvscan 
No matching physical volumes found
}}}
pv가 하나도 없군요. 당연하죠.

=== pv 만들기 ===
이제 pv를 만들겠습니다.
{{{#!plain
# pvcreate /dev/sdb /dev/sdc
  Physical volume "/dev/sdb" successfully created
  Physical volume "/dev/sdc" successfully created
}}}

다시 한번 pvscan으로 확인을 해보죠.
{{{#!plain
# pvscan
  PV /dev/sdb                      lvm2 [2.00 GiB]
  PV /dev/sdc                      lvm2 [2.00 GiB]
  Total: 2 [4.00 GiB] / in use: 0 [0   ] / in no VG: 2 [4.00 GiB]
}}}
2개가 추가돼 있군요. 

=== vg 만들기 ===
자 이제 vg를 만듭니다. lv의 그룹으로 - 컨테이너로 봐도 됩니다. - 하나 이상의 PV를 볼륨 그룹으로 묶어줍니다. 
{{{#!plain
# vgcreate myVG /dev/sdb /dev/sdc
  Volume group "myVG" successfully created
}}}

=== lv 만들기 ===
그럼 LV를 만들겠습니다. 1기가 짜리로 만들기로 했습니다. 이 LV는 myVG에 들어가겠죠.
{{{#!plain
# lvcreate -L 1000M myVG
  Logical volume "lvol0" created
}}}
잘 만들어졌네요.

lvdisplay로 lv 정보를 확인해 볼 수 있습니다.
{{{#!plain
#lvdisplay 
  --- Logical volume ---
  LV Name                /dev/myVG/lvol0
  VG Name                myVG
  LV UUID                fxc9Lm-MmRh-JTg2-rt6u-2shi-KvPN-udIS73
  LV Write Access        read/write
  LV Status              available
  # open                 0
  LV Size                1000.00 MiB
  Current LE             250
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     256
  Block device           252:0
}}}
네 잘 만들어 졌군요. 장치 이름은 /dev/myVG/lvol0 이네요.

=== mount해서 잘 사용하기 ===
이제 파일 시스템사용 하듯이 마운트 해서 사용하면 됩니다. 물론 포맷은 해야 겠죠.
{{{#!plain
# mkfs.ext4 /dev/myVG/lvol0 
# mount -t ext4 /dev/myVG/lvol0 /mnt/ftp/
# mount | grep mnt
/dev/mapper/myVG-lvo10 /mnt/ftp  type ext4 (rw)
}}}
마운트 성공

=== Volume 관리하기 ===
'''볼륨 크기 키우기'''
사용하다 보니 볼륨이 꽉찰 지경에 이르렀습니다. 그래서 LV의 크기를 500M만큼 키우기로 마음먹었습니다.
{{{#!plain
# lvextend -L+500M /dev/myVG/lvol0 /dev/sdb /dev/sdc 
  Extending logical volume lvol0 to 1.46 GiB
  Logical volume lvol0 successfully resized
}}}
LV 크기가 확장된 걸 확인 할 수 있습니다.

아 하지만 지금은 볼륨만 커진 상태입니다. 실제 파일시스템이 커진 상태는 아니죠. 이를테면 1.5GB 중 1기가 바이트를 사용하고 있는 상태인거죠. 
{{{#!plain
# df -h
/dev/mapper/myVG-lvol0  985M   18M  918M   2% /mnt/ftp
}}}

이제 파일 시스템을 늘려야 하는데요. 포맷하지 않고 파티션의 크기를 조절해주는 프로그램을 사용하면 됩니다. 
{{{#!plain
# resize2fs /dev/myVG/lvol0
resize2fs 1.41.14 (22-Dec-2010)
Filesystem at /dev/myVG/lvol0 is mounted on /mnt/ftp; on-line resizing required
old desc_blocks = 1, new_desc_blocks = 1
Performing an on-line resize of /dev/myVG/lvol0 to 384000 (4k) blocks.
The filesystem on /dev/myVG/lvol0 is now 384000 blocks long.
}}}

깔끔하네요. df나 cfdisk로 파티션 크기가 늘어났는지 직접 확인할 수 있습니다.

=== LVM과 iSCSI ===
 * [wiki:Site/System_management/iSCSI iSCSI를 이용해서 원격으로 Volume에 접근하는 방법을 소개합니다.]

== History ==
  * 작성일 : 2011년 8월 30일
  * 수정
    * 2011년 9월 31일 : Linear Mapping LV 그림 수정 

[[tag(LVM,iSCSI)]]
[[Category(15)]]
