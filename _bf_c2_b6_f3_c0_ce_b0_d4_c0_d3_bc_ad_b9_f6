[[UploadFile]]
그리고 갑자기 생각한건데요.. 
가상의 가로 100, 세로 100 정도의 격자를 만들고 여기에 2개의 객체를 둔 다음에 두개의 객체간에 정보를 교환하는 그런 프로그램 만들어서 테스트 해보면 어떨까요 ?  

 1. 거리에 따라서 두 객체간의 정보 민감도?가 달라지게 하구요. 예를 들자면 가까운 거리에 있을 경우 매우 자세한 정보들 까지 출력하고/대화도 가능하고 좀 멀어지면 이동 정보 정도만 출력시키고 한계 거리를 넘어가게 되면 아예 정보전달을 하지 못하도록 하구요..

 1. 그리고 격자위의 모든 객체의 위치 정보를 가지고 있는 쓰레드가 하나 있어야 겠죠? 하나의 객체는 처음 기준점에서 상하 좌우로 3칸 정도의 격자를 이동하면 서버에게 객체의 지평선 내에 있는 객체가 있는지 요청해서 통신을 하구요. 

 1. 각 객체는 자신만의 ID를 가지고 있구요. 각 객체는 "수색"기능을 가지고 있어서 지평선 바깥에 있는 객체를 찾아낼 수 있고, 이 객체중 하나를 추적하게 되면, 객체의 위치 정보를 계속해서 받을 수 있도록 하구요.  

이걸 소켓을 이용해서 구현하면 재미있을것 같은데요. :-) 

 [[TableOfContents]]
=== 음 대략 정리 ===

==== 개요 ====
온라인 게임은 각각의 객체가 인터액티브하게 연관된다. 이들 연관관계를 잘 나타내야 여러가지 이벤트(전투, 대화등)들을 소화해 낼수 있다. 어떻게 하면 이러한 객체간의 효과적인 정의가 가능할지에 대한 난상 토론.

==== 객체간의 상효연관에 있어서 문제점 ====
각각의 객체들이 상호연결될 수 있어야 하고 그럴려면 지속적으로 데이터를 뿌려야 한다. 그런데 이렇게 하려면 많은 연산과 패킷 교환이 필요하다는 문제가 발생한다. 

==== 윤드림이 몇개 온라인 게임을 즐겨본 결과 -.-; ====
Shadow bane를 예로 든다. 이유는 외국 온라인게임이 그렇듯이 개발자적인 마인드가 게임에 많이 포함되어 있기 때문이다. 주위의 모든 발생한 이벤트들을 얻어온다든지 커맨드 입력에 따라서 공격가능 범위가 표현되거나 하는등..

SB에서는 주위 일정 범위에 있는 모든 이벤트들 - 유저가 어떤 자세와 행동을 취하는지, 성향의 변경이 있는지, 어느정도의 데미지를 입혔는지, 회피와 공격에 성공했는지 실패했는지등 - 모든 정보가 별도의 대화창에 표시된다. 물론 일정 범위 안에 있어야 가능하다. 어느정도의 범위를 벗어나게 되면 해당 객체에 대한 어떠한 이벤트도 전달되지 않는다. 그러나 맵지도를 보면 상당히 넓은 범위의 지형과 몹, 유저들의 위치가 표시된다. mz님의 의견대로 일종의 민감영역 같은게 있는것 같다. 자신의 객체로 부터가까우면 많은 데이터가 전송되지만 거리가 멀경우에는 단지 위치 정보정도만 표시하는 식일것 같다. 위치 정보같은 것은 아마도 해당 타일에 객체가 위치를 적는 정도의 방식이고 같은 타일에 있을 경우 타일의 정보를 읽어와서 유저에게 전달하는 방식인 것 같다. 

객체의 위치와 관련되어서 SB에는 상당히 재미있는 기능이 있다. 몇몇 캐릭터의 경우 고유 능력에 '''수색'''능력이 있는데, 대단히 넓은 범위(심지어 가장 높은 해상도의 미니맵을 벗어나는)의 특정 캐릭터의 위치를 지속적으로 추적하는 능력이다. 

참고로 라그나로크 같은 경우는 256*256개의 타일로 이루어진 여러개의 맵들로 구성되는데, 각 맵들간에는 전혀 통신이 이루어지지 않습니다. 이런 경우는 비교적 구현하기가 쉽겠죠 ?  

=== 객체 동기화의 개념 (By gururang) ===
가정 1. 모든 객체는 최대 1초에 두번만 움직일수 있다.(이동,전투행동 등...)

가정 2. 서버는 1초에 두번 모든 클라이언트들에게 클라이언트 화면 영역안에 있는 객체 정보를 전송한다.

가정 3. 여러개의 타일이 모여 하나의 맵을이루는 타일맵으로 이루어져있다.

가정 4. 클라이언트의 화면에 보이는 타일갯수의 크기는 고정되어 있다. 이것을 '클라이언트 화면영역' 이라 칭하겠다.

가정 5. 클라이언트 화면영역의 크기는 "해상도/타일사이즈"의 공식으로 구할수 있다.

가정 6. NPC를 제외한 사용자 객체끼리의 동기화이다.

'''서버 작업'''

 1. 클라이언트의 행동에 대한 메시지를 전송받아서 맵의 객체를 저장하는 변수에 저장한다.
 {{{#!vim c
case C_MOVE_E:  //동쪽으로 이동
    ud[fd].pos.x++;
    ud[fd].s_num=DIRECTION_RIGHT;
    break;
case C_MOVE_W:  //서쪽으로 이동
    ud[fd].pos.x++;
    ud[fd].s_num=DIRECTION_LEFT;
    break;
case C_MOVE_S:  //남쪽으로 이동
    ud[fd].pos.y++;
    ud[fd].s_num=DIRECTION_DOWN;
    break;
case C_MOVE_N:  //북쪽으로 이동
    ud[fd].pos.y--;
    ud[fd].s_num=DIRECTION_UP;
    break;
}}}
||<|3>ud[]|||| 사용자들의 정보를 담고 있는 구조체 ||
|| .pos|| 위치 정보 저장 ||
|| .s_num|| 행동 번호.(Sprite 번호) ||
||fd|||| 사용자의 파일지시자(=소켓 번호) ||

요약해서 정리하자면...
  '''이동 메시지가 왔을때 해당 유저의 위치 정보(pos)와 행동 번호(s_num)를 Update해준다.'''


 2. 클라이언트들에게 1초에 두번 객체정보를 전송한다. (쓰레드로 만들어서 백그라운드 작업)
  {{{#!vim c
void *thread_bg(void *data)
{
    int i=0;
    int m_tick=0;
    int tick_count=0;
    
    while(1)
    {
        m_tick++;
        for (i=0;i<=max_fd;i++)
        {
            if (ud[i].fd>0 && ud[i].state==STATE_PLAYING)  //연결된 소켓이고, 게임중인 사용자에게만..
                get_circum_obj(i);  	//해당 클라이언트에게 클라이언트 화면영역안에 있는 객체의 정보를 전송해준다.
        }
        if (m_tick%120==0)   //2(1초에 두번)*60(60초) = 120(분당 120번)
        {
            tick_count++;
            m_tick=0;
        }
        usleep(500000);	//0.5초를 쉬어준다. 
    }
}
}}}
||max_fd|| 연결된 소켓중의 가장 큰 소켓 번호||

  {{{#!vim c
1:  void get_circum_obj(int fd)
2:  {
3:     POINT range={0,0};	//맵 Position 과 동일..
4:  
5:     if(ud[fd].pos.x>SCR_W)        range.x=md[ud[fd].nowmap].mh.width-SCR_W;
6:     else if(ud[fd].pos.x>SCR_W/2)	range.x=ud[fd].pos.x-(SCR_W/2);
7:  
8:     if(ud[fd].pos.y>SCR_H)        range.y=md[ud[fd].nowmap].mh.height-SCR_H;
9:     else if(ud[fd].pos.y>SCR_H/2)	range.y=ud[fd].pos.y-(SCR_H/2);
10:  
11:    send_proc(ud[fd].fd,S_CIRCUM_OBJ_START,"");
12:    for (cmd_t1=0;cmd_t1<=max_fd;cmd_t1++)
13:    {
14:	if(ud[cmd_t1].fd<=0 || cmd_t1==fd)	continue;	//빈 소켓이거나 동일한 소켓이면 위로.. 
15:    	if ((ud[cmd_t1].pos.x>=range.x) && ud[cmd_t1].pos.x<=(range.x+SCR_W)	//해당 범위[X축] 검사 
16:     	 && (ud[cmd_t1].pos.y>=range.y) && ud[cmd_t1].pos.y<=(range.y+SCR_H))	//해당 범위[Y축] 검사 
17:	{
18:	    sprintf(buf,"%s|%d|%d|%d",ud[cmd_t1].id,ud[cmd_t1].s_num,ud[cmd_t1].pos.x,ud[cmd_t1].pos.y);  //사용자ID,행동번호,위치 
19:	    send_proc(ud[fd].fd,S_OBJECT_POS,buf);  //전송
20:	}
21:    }
22:    send_proc(ud[fd].fd,S_CIRCUM_OBJ_END,"");
23: }
}}}

||SCR_W|||| 클라이언트 화면영역의 가로 넓이||
||SCR_H|||| 클라이언트 화면영역의 세로 넓이||
||range|||| 상대좌표를 저장하는 변수       ||
||ud[] || .nowmap || 현재 사용자가 있는 맵 인덱스 ||
||<|3>md[]||||||맵 정보||
||.mh.M_Width||맵의 가로 크기(단위 : 타일)||
||.mh.M_Height||맵의 세로 크기(단위 : 타일)||


||3 ~ 9|| ud[]의 좌표정보는 절대 좌표이다. 이것을 상대좌표로 변환시켜 줘야한다. 여기에 사용된 공식은 제가 게임에서 사용하고 있는 공식입니다. 나중에 설명할 기회가 있겠지만 간단히 이야기 한다면 절대좌표 = 맵좌표 + 맵안에서의 사용자좌표(상대좌표) 입니다.||
||11|| 주변객체 전송 시작을 알립니다. 이 메시지를 받은 클라이언트는 현재 가지고 있는 객체정보를 모두 지웁니다.||
||12~21|| 클라이언트의 화면영역에 속해있는 객체인지 판별해서, 맞으면 클라이언트에게 전송해줍니다.||
||22|| 주변객체 전송 종료를 알립니다.||

===== 객체 동기화에 대한 JOINC 채널에서의 난상 토론 =====
[AM 02:17:43] <[PTG]구루랑> 흠

[AM 02:17:49] <[PTG]구루랑> 리니지 소스나 한번 보고 싶네 -_-;

[AM 02:17:54] <[PTG]구루랑> 아...정말 방법론의 문제네 -_-;

[AM 02:18:13] <[PTG]구루랑> 어떻게 하면 객체 동기화를 시킬수 있을지..

[AM 02:18:15] <[PTG]구루랑> 정말 -_-;

[AM 02:18:43] <[PTG]구루랑> 방법은 몇가지가 있는데....

[AM 02:19:04] <멍^--> 구루랑 / 오호 잼난거 하시네요

[AM 02:19:13] <[PTG]구루랑> 1. 움직이는 모든 객체의 데이터를 다 받아서 저장 .... 가장 간단하지만... 네트워크 부하 증가

[AM 02:19:30] <멍^--> 구루랑 / 그게 노하우죠 ^^;

[AM 02:19:30] <멍^--> 흐흐

[AM 02:19:39] <멍^--> 요새 게임 프로그래밍 기법도 많이 공개되는데 --

[AM 02:19:42] <멍^--> 그런게 한번 보심이.. ^^

[AM 02:19:51] <[PTG]구루랑> 2. 현재 사용자에게 보이는 영역의 객체의 움직임만 전달.. .. 효율적이지만.. 굉장히 복잡함..머리 깨짐

[AM 02:20:18] <[PTG]구루랑> 두가지 뿐이 생각이 안나네요

[AM 02:20:19] <[PTG]구루랑> 멍님..

[AM 02:20:28] <[PTG]구루랑> 게임 프로그래밍 기법 공개라... 공개된게 있다면 알려주세요 -ㅁ-

[AM 02:20:37] <minzkn^초보> 구루랑: 압축전송도 고려해보면 어떨까요?

[AM 02:20:38] <멍^--> 서점 가면 널렷어요 ㅋㅋ

[AM 02:20:40] <[PTG]구루랑> 흐..이걸 어케 처리해야하지

[AM 02:21:07] <[PTG]구루랑> min//압축전송이요? 지금은 압축 문제는 커녕..어케 해야할지 감이 -_-;

[AM 02:21:50] <minzkn^초보> 구루랑: 보이는 부분만 전송하는것은 좋은 방법인듯 하고요..

[AM 02:22:11] <[PTG]구루랑> min//근데 이럴경우 데이터 동기화 객체 동기화가 정말 여러모로 생각해도 쉽지 않군요

[AM 02:22:26] <minzkn^초보> 동기화가 필요없도록 해야될거 같은...

[AM 02:22:38] <[PTG]구루랑> 하나의 객체가 Input/Output 되는걸 일일이 다 체크해야 하는데

[AM 02:22:50] <[PTG]구루랑> 흠... 서버 CPU부하를 주는쪽이 더 나을려나..

[AM 02:23:05] <minzkn^초보> 기본적으로 이동과 관련해서 동기가 필요 없겠지요?

[AM 02:23:22] <[PTG]구루랑> 필요하지 않나요?

[AM 02:23:28] <[PTG]구루랑> A와 B가 같은 화면에 있다면

[AM 02:23:38] <minzkn^초보> 중요한것은 인접한 캐릭터들간의 동기만 열심히 하면... (직접적인 타격점에 영향이 있는 캐릭간

[AM 02:23:43] <[PTG]구루랑> A가 이동한다면.. B의 화면에 A가 이동하는게 보여야 할텐데용

[AM 02:24:09] <멍^--> 음..

[AM 02:24:14] <minzkn^초보> 그 외의 보이는 현상은 약간의 시간차가 존재해도... 별로 무리 없을듯...

[AM 02:24:25] <멍^--> 옷

[AM 02:24:34] <minzkn^초보> 즉, 타격점영향권에 근접하면 서버가 긴장하면 될듯해요.

[AM 02:24:34] <멍^--> 산하님 전송 완료&#46095;나 보네요 698메가임

[AM 02:24:36] <[PTG]구루랑> min//이게 타일맵인데.. 하나의 타일에는 하나의 오브젝트 뿐이 있을수가 없어서요

[AM 02:24:39] <산하> 멍^--: 감사.

[AM 02:24:46] <[PTG]구루랑> 흠..타격점 영향권이라

[AM 02:24:50] <산하> r구루랑님

[AM 02:24:52] <산하> 일케해보세요.

[AM 02:25:12] <산하> 동기화란건..두 쓰레드가 동시에 쓸려고할때 문제가 발생하는건데, 지금 각 객체에서,,

[AM 02:25:17] <산하> 각 객체들이.

[AM 02:25:24] <산하> 자기 정보를, 전역(내지는 공유메모리)에

[AM 02:25:28] <산하> 자기 정보를 씁니다.

[AM 02:25:33] <산하> 그리고 나머지 객체들은 리딩만 합니다.

[AM 02:25:34] <minzkn^초보> 보통 온라인 게임 보면 화살쏘는 캐릭 있으면 느려지쟎아요.. 그게 아마도 타격점 영향권이 &#45344;ㅂ은 캐릭이라서 그런듯 생각되서요..

[AM 02:25:37] <산하> 동기화 필요없죠.

[AM 02:26:00] <멍^--> 다 올라갔군

[AM 02:26:01] <멍^--> 케케

[AM 02:26:02] <[PTG]구루랑> 산하//그러면요 문제점이

[AM 02:26:29] <[PTG]구루랑> 산하//매 프레임마다 서버에 객체 자료를 요청하고 받고 그래야하자나요

[AM 02:26:38] <[PTG]구루랑> 그러면 네트워크 부하량이 엄청나게되요

[AM 02:26:56] <minzkn^초보> 구루랑 별로 많은 데이터 양은 아닐거 같아요.

[AM 02:26:57] <산하> 게임인가요.

[AM 02:27:03] <산하> 보통.

[AM 02:27:06] <산하> UDP.로..

[AM 02:27:09] <산하> 계속 뿌립니다.

[AM 02:27:18] <minzkn^초보> 만약에 동작에 대한 종류를 숫자 하나로 정의하면 ...

[AM 02:27:24] <산하> 퀘이크같은 겜 보면. 케이블모뎀의. 불이 안꺼지고 계속 켜져잇습니다..

[AM 02:27:25] <[PTG]구루랑> 산하//계속 뿌린다는 얘기는 지속적인 통신


[AM 02:27:40] <minzkn^초보> 칼을 서쪽으로 뽑는다 = 0, 칼을 다시 집어넣는다. = 1, ...

[AM 02:27:54] <minzkn^초보> 칼을 동쪽으로 향해서 높이 든다. = 2

[AM 02:27:57] <산하> UDP로 하셔야합니다..

[AM 02:27:57] <[PTG]구루랑> 흠..그게 좋을려나... 제가 맨처음 생각한 방법이 그 방법입니다만...

[AM 02:28:14] <[PTG]구루랑> 네트워크 부하량이..엄청날것 같아서요

[AM 02:28:21] <산하> 아뇨 그리 많지않죠. 양은..

[AM 02:28:42] <산하> 글구 클라이언트에서 서버로 주위환경정보 받아올때..범위를 define해놓고..

[AM 02:28:50] <산하> 그 범위안에 들엉오는 다른 객체의 정보만 받는거죠.

[AM 02:29:12] <[PTG]구루랑> 흠..

[AM 02:29:19] <[PTG]구루랑> 중앙 집중 관리식으로군요

[AM 02:29:23] <산하> 마치 각 행성이 자기 불을 밝히고, 다른 행성이 그 빛을 받듯이..

[AM 02:29:25] <minzkn^초보> 구루랑: 전송량이 많다기 보다는 패킷수가 많다고 봐야 겠네요..

[AM 02:29:30] <[PTG]구루랑> min//네

[AM 02:29:37] <산하> 각 객체는 자기정보를 계속뿌리죠..

[AM 02:29:42] <산하> 필요한 객체는 그 정보를 받음되고.

[AM 02:30:00] <산하> 아얄씨도..

[AM 02:30:07] <산하> udp로 계속뿌릴겁니다 아마..

[AM 02:30:12] <산하> 글자가 나오던 ,안나오던..

[AM 02:30:12] <minzkn^초보> 구루랑: 때문에 자주 발생되는 작은 패킷을 적당히 merge해서 클라이언트에게 보내주는 작업이 서버에서 필요할거 같고..

[AM 02:30:29] <산하> minzkn^초보: 프로토콜 정의죠..

[AM 02:31:09] <산하> 자기정보란건 데이터양은 정말 몇바이트 내진 몇십바이트 안짝이죠.

[AM 02:31:12] <[PTG]구루랑> 지금 초당 행동이 2번 일어나게 설정해놨는데... 동접수가 100명이라면.. 100*2 = 200 패킷...

[AM 02:31:13] <minzkn^초보> 온라인 게임들 보면 렉과 동시에 backtime이라는게 있쟎아요.

[AM 02:31:47] <minzkn^초보> 서버에서는 초당 2번 클라이언트와 수신하도록 한다면

[AM 02:32:04] <[PTG]구루랑> 서버는 200개의 패킷을 받고, 최악의 경우는 10000패킷의 센드..

[AM 02:32:11] <minzkn^초보> 100명의 정보가 하나의 클라이언트에게 집중할때 100*2의 200패킷이 되겠지만

[AM 02:32:27] <minzkn^초보> 서버는 클라이언트 1개당 1초에 2번만 보내도록

[AM 02:32:41] <minzkn^초보> 200개의 패킷을 1개의 패킷으로 합해서 보내주는 처리가 ...

[AM 02:33:28] <[PTG]구루랑> 흠...

[AM 02:33:33] <minzkn^초보> 200개가 아니라 100개를 1개의 패킷으로 묶어서 2번 1초에 보내겠죠.

[AM 02:33:52] <산하> 객체가..서버로 보내는건,,,객체정보가 될터이구요.

[AM 02:33:59] <산하> 객체가 서버로 부터 받는건,,환경정보가 되어야죠..

[AM 02:34:15] <산하> 각각 다른 프로토콜을 계획하셔야할겁니다

[AM 02:34:22] <[PTG]구루랑> 산하//네

[AM 02:34:49] <minzkn^초보> 동작정의 DWORD + x좌표 DWORD + y좌표 DWORD + 방향 BYTE + z(높이좌표) WORD + 모양새 DWORD

[AM 02:35:12] <[PTG]구루랑> 기본가정을 컴퓨터와 네트워크는 빠르다 라는 가정하에 만들어야겠군요....

[AM 02:35:16] <minzkn^초보> 1개의 칼라이언트가 19바이트의 정보를 1개의 패킷으로 하면

[AM 02:35:23] <[PTG]구루랑> 최적의 속도를 내게 알고리즘을 생각했더니..흠.. 너무 어렵네요

[AM 02:35:50] <minzkn^초보> 19바이트 + 패킷 merge header QWORD = 17byte

[AM 02:36:04] <minzkn^초보> 초당 100명의 클라이언트가 1클라이언트에게 집중되면

[AM 02:36:24] <minzkn^초보> 그리고 1초에 2회 처리한다면

[AM 02:37:03] <minzkn^초보> 100 * 17 / 2 = 850바이트를 한개의 패킷 merge하면서 2회 보내면 끝나겠네요.

[AM 02:37:18] <minzkn^초보> 고로 한 클라이언트당 부하량은

[AM 02:37:24] <minzkn^초보> 1700 * 8 bps

[AM 02:37:47] <minzkn^초보> 13600 bps = 1.3Kbps

[AM 02:38:00] <minzkn^초보> 1.3kbps + 20%의 마진율 =

[AM 02:38:18] <minzkn^초보> 1.5kbps이하만 아니라면 게임진행하고

[AM 02:38:28] <멍^--> ㅋㅋ

[AM 02:38:37] <minzkn^초보> 아니라면 "클라이언트가 폭주중입니다." 라고 뿌리고 끊어버리고...

[AM 02:38:44] <멍^--> ㅋㅋ

[AM 02:38:50] <[PTG]구루랑> 1.5kbps * 100 = 150k bps...

[AM 02:38:55] <minzkn^초보> 캬~ 논리적인 계산이죠? ㅋㅋㅋ.

[AM 02:39:02] <[PTG]구루랑> 20% 마진율은 머죠?

[AM 02:39:11] <minzkn^초보> 구루랑: 100을 이미 곱해서 1.5K가 나온거쟎아요.

[AM 02:39:23] <[PTG]구루랑> 크.. 그건 한 클라이언트에 집중되는 정보 아닌가요?

[AM 02:39:27] <[PTG]구루랑> 클라이언트가 100개니깐

[AM 02:39:41] <[PTG]구루랑> 다른 클라이언트들한테도 전송해줘야 하지 아나요?

[AM 02:39:45] <minzkn^초보> 그렇죠... 거기에 100을 곱하면 서버가 실제 처리하는 부하겠네요.

[AM 02:39:55] <[PTG]구루랑> 생각보다 많진 않군요

----
=== 토론 및 잡담 ===
 * 여기다 글 남겨도 될까요? 위키는 익숙치 않아서( 배우는 중입니다만.. ^^; )
지금 말씀하시는 동기화가 클라이언트 주변상황이 변할때의 각 클라이언트들의 동기화를 말씀하시는건가요?
저는 지금 현업으로 게임서버를 프로그래밍하고 있습니다만 보통 이벤트 발생시 이벤트가 발생한 플레이어
주변의 클라이언트들에게 해당 이벤트를 날려줍니다만.. 
제가 잘못 하고 있는건가요? 그렇게 네트워크 과부하가 일어날거 같진 않은데요.. 오히려 클라이언트에서 해당이벤트
수신시 모니터에 보여줄때 부하가 더 심할겁니다.
보통 클라이언트 화면 영역을 구해서 주변의 캐릭터에게 뿌려줍니다만.. ^^;
주제에 어긋나거나 예의가 바르지않았다면 지워주세요   - 서영완 -
   * 그것도 좋은 방법이로군요.. 현업에 계신분을 알지 못해서 제 나름대로 생각해서 만들어본 동기화 방법이었거든요..
     저 방법보단 영완님이 제시해주신 방법이 좋을듯 하네요..그렇다면 저럴경우 서버에서 하는 역할을 메시지 중계 역할 정도되겠네요..
     서버 부하를 덜고 클라이언트 쪽으로 부하를 돌리는것도 좋고... 굉장히 만족합니다 ^_^   - 구루랑 -

   * 물론 글남겨도 되죠.. 위키가 그러라고 있는 거니까요 :-) 자유롭게 참여해서 의견교환하고 잘된못 내용있으면 고치고.. 그러면서 발전하는 방식이니까요. 


