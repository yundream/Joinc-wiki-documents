head	1.3;
access;
symbols;
locks
	root:1.3; strict;
comment	@# @;


1.3
date	2014.01.28.01.14.34;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2013.12.04.02.29.15;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.05.38.24;	author root;	state Exp;
branches;
next	;


desc
@./data/text/Site_2fC_2fDocuments_2fBit_5fOperation
@


1.3
log
@121.185.117.125;;Anonymous;;
@
text
@#title Bit 연산의 필요성에 대해서

고급언어를 사용하다 보니, 이제는 bit 연산은 교과서에나 찾아볼 수 있는 구닥다리 정보가 된 것 같다. 고급 어셈블리어(:12)라고 하는 C(:12)에서도 잘 사용하지 않는 것 같으니 다른 언어에서는 사용할일이 더욱 드물지 않을가 생각해본다.

C언어에서 조차 비트연산을 사용하지 않는 이유는 대부분의 책들이 비트연산을 사칙연산자 다루듯이 연산방법만을 나열하고 있다는데 있다. 비트연산의 강력함과 활용가능성을 생각해 볼때 매우 유감스러운 일이다. 해서 비트연산에 대한 실용적인 문서를 만들어 보기로 했다.

== bit에 대해서 : 다분히 원칙적 설명 ==
비트에 대한 고리타분한 다분히 역사적인? 설명은 [man/12/byte joinc 용어 설명 : byte]문서를 순전히 재미삼아서 읽어보기 바란다. 절대 재미삼아서만 읽어달라.  

;ㅣ'ㅏ
== bit 일반 연산 ==
bit 연산에 대한 일반적인 내용은 [wiki:Site/C/Documents/CprogramingForLinuxEnv/Ch4_VarAndOper 리눅스 환경에서의 C 프로그래밍 4장 연산자]를 참고한다. 

== bit의 확장 ==
bit 는 단위가 너무 작아서 다루기가 힘들다. 그래서 bit를 개개로 사용하기 보다는 몇개씩 모아서 사용하고 있다. 이들의 단위는 다음과 같다.

|| '''단위명''' || '''자료크기'''        || '''표현가능한 최대 수'''   || '''기타''' ||
|| bit          || 최소단위         || 2^0                  ||
|| nibble       || 4개의 비트 모음  || 2^4                  ||
|| octet        || 8                || 2^8                  ||
|| byte         || 8                || 2^16                 || 컴퓨터과학에서 다루는 정보의 기본단위  ||
|| word         || 16, 32 or 64     ||    || 컴퓨터 디자인에 따라 사용하는 데이터 단위  ||
|| dword        || word * 2         ||    || x86 플랫폼의 경우 word 크기는 16이 되고, dword는 32bit가 된다. ||

 * byte : 컴퓨터 과학에서 다루는 정보의 기본단위이다. 일반적으로 8bit를 1byte라고 하지만 표준은 아니다.
 * word : 컴퓨터 디자인에 따라 사용되는 기본 데이터 단위로 16, 32, 64가 주로 사용된다. Intel 8086 플랫폼의 경우 1word 는 16bit 다. 기타 MIPS는 32bit, IA-64 64bit, Alpha 64bit, ARM1 32bit 크기를 가진다. 

== bit 연산의 장점과 응용들 ==
=== 속도 ===
'''bit'''연산의 가장 큰 장점 중 하나는 '''스피드'''에 있다. bit는 최소정보단위로 다른 추상화된 정보들과는 달리 '''재현'''의 과정을 거치지 않는다. 재현의 과정을 거치지 않고 즉시 해석되어서 의미를 전달하기 때문에 그만큼 빠를 수 밖에 없다. bit 연산은 가장 빠른 연산중 하나다. 

예를 들어 '''* 2'''를 하는 연산에 대해서 생각해 보자. 이때는 산술 연산자를 사용하는 것보다 shift 연산을 사용하면 속도를 높일 수 있다. 
{{{#!plain
 4 * 2 보다.
 4 << 1 이 효율적이다.
}}}
비트 수준에서 보자면 다음과 같다. 단지 비트를 왼쪽으로 한번 이동시키기만 할 뿐이므로 효율적임을 직감할 수 있다. 일반적인 32Bit CPU에서라면 32bit - 4byte를 기본으로 사용하기 때문에 32bit로 설명을 해야 하겠지만 너무 길어지는 관계로 하위 2byte만을 가지고 설명하도록 하겠다.   
{{{#!plain
4 =>   00 00 00 00 00 00 01 00  
4 << 1 00 00 00 00 00 00 10 00 => 8
}}}
이는 나눗셈에도 동일하게 적용된다. 
{{{#!plain
8      00 00 00 00 00 00 10 00
8 >> 1 00 00 00 00 00 00 01 00 => 4
}}}

유저응용 프로그램(:12) 수준에서 속도최적화를 위해서 2의 배승으로 나누어주거나 곱해주는 수고까지 하는 경우는 그리 흔하지 않을 것이다. 그러나 많은 데이터를 다루어야 하는 서버 프로그램이나 PC에 비해서 자원이 제한된 임베디드(:12) 환경에서는 중요하게 사용될 수도 있다.

=== flag 연산 ===
ffff
=== bit 필드 연산 ===
=== bit 필드 연산 응용 ===
@


1.2
log
@211.106.170.134;;Anonymous;;
@
text
@d51 1
@


1.1
log
@210.218.235.4;;Anonymous;;
@
text
@d10 1
@
