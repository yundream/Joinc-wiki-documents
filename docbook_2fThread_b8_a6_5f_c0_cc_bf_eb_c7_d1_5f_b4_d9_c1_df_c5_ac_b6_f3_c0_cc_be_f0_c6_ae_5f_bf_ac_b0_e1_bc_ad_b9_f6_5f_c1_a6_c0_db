#title Thread를 이용한 다중클라이언트 연결서버 제작

[wiki:article/Thread를_이용한_다중클라이언트_연결서버_제작 HTML 변환문서]

{{{#!plain
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<article lang="ko">

<!--           -->
<!-- 문서 정보 -->
<!--           -->
<articleinfo>
	<title>thread 를 이용한 다중클라이언트 연결서버 제작</title>

	<author>
		<surname>윤 상배</surname>

		<affiliation>
			<address>
				<email>dreamyun@yahoo.co.kr</email>
			</address>
		</affiliation>
	</author>
</articleinfo>


<!--                                                                 -->
<!-- 섹션 시작                                                       -->
<!--                                                                 -->
<section>
	<title>소개</title>
	<para>
		지금까지 fork(),select(),poll() 을 이용한 다중클라이언트를 받아들이는 
		서버제작에 다루었었다. 이번은 그중 마지막으로 thread 를 이용한 
		서버제작을 아룰것이다. thread 의 구현을 위해서는 pthread 를 이용
		하도록 하겠다. 
	</para>
	<para>
		물론 이들 fork, select, poll, thread 외에도 몇가지 (좀더 진보된 형태의) 
		다중 클라이언트 서버를 위한 방법들이 있으나 
		나중에 다루도록 일단은 논외로 하겠다. 
	</para>
	<para>
		여기에서는 쓰레드의 개념과 각종 API 에 대한 설명은 하지 않을것이다. 
		이미 이 사이트에서 몇번에 걸쳐서 다루고 있음으로 쓰레드에 대한 개념이 
		충분히 잡혀있지 않다면 먼저 이들 문서에 대해서 읽어보기 바란다.  
	</para>
</section>

<section>
	<title>Thread 네트웍 프로그래밍</title>
	<para>
		Thread 를 이용한다고 해서, fork, select, poll 과 구별되는 어떤 기술을 
		필요로 하는건 아니다. 구현 기본원리는 동일하며 여기에 단지 몇가지 Thread API 
		가 들어갈 뿐이다.  
	</para>
	<para>
		다른 것들과 마찬가지로 Thread 역시 최초 socket() 함수를 호출해서 
		endpoint(접점) 소켓을 생성하고 accept()로 endpoint 소켓으로 연결이 있는지 
		확인후 연결이 있다면 새로운 쓰레드를 생성하는 방식으로 프로그래밍이 
		이루어진다. 전체적으로 봤을때 fork 와 특히 유사하다. 다른점이라면 
		accept 한후에 frok 대신 thread 를 이용해서 해당 연결에 대한 처리를 
		한다는 점 정도가 될것이다. 
		<screen>
            +--------+   
            | Start  |  ㅣ
            +--------+  ㅣ
            +--------+  ㅣ
            | Socket |  ㅣ
            +--------+  ↓
            +--------+
            | Bind   |
            +--------+
            +--------+
            | Listen |
            +--------+
            +--------+
            | Accept | <------+
            +--------+        | polling
                |             |
        +---------------+     |
        | Thread Create | ----+
        +---------------+
                |
            +--------+
            |        |
         +------+  +------+
         | TH 1 |  | TH 2 | .....
         +------+  +------+
            |         |
           END       END
		</screen>
	</para>
	<para>
		소켓의 생성과 연결 기다림은 전형적인 
		Socket -> Bind -> Listen -> Accept 의 순서를 따른다. 
		Accept 에 만약 새로운 연결이 리턴되면, pthread_create 를 이용해서 
		새로운 쓰레드를 생성시키고, 해당클라이언트와 통신하게 된다.   
	</para>
	<section>
		<title>Thread 를 이용함으로써 얻는 이익과 손해</title>
		<para>
			리눅스에서 사용하는 pthread 는 clone() 함수를 이용해서 구현된다. 
			clone() 함수는 fork(2) 와 마찬가지로 새로운 프로세스를 생성한다. 
			하지만 fork 와는 달리 파일기술자, 시그널 핸들러 외에도 
			실행문맥과 전역메모리 등을 공유하게 된다. 많은 부분들을 서로 
			공유하게 됨으로써, 거의 새로운 프로세스가 생성되는 fork 에 비해서 
			좀더 적은 비용을 들이며서 프로세서의 생성이 가능하다. 
			이러한 생성속도의 차이는 대부분의 경우 무시할만 한 수준이지만, 
			요즘처럼 인터넷이 보편화된 시점에서는 무시할수 없는 상황이 발생하기도 
			한다.       
		</para>
		<para>
			그러나 역시 현실적으로 느낄수 있는 가장큰 잇점은 IPC 의 사용을 줄일수 
			있다라는 점이다. fork 를 사용할경우 부모프로세스와 자식프로세스의 
			통신을 위해서, pipe, fifo, 공유메모리, 메시지큐등 상황에 따라서 
			다양한 종류의 IPC 를 선택해서 사용해야 하는데, 이들을 제대로 사용하기
			위해선 상당히 까다로운 프로그래밍 기법을 요구한다. 
			그러나 Thread 는 많은 부분을 서로 공유하게 됨으로 공유되는 영역에 
			값을 입력하는 정도만으로 충분히 각 쓰레드간 통신이 가능해진다.  
		</para>
		<para>
			반면 단점이 있는데, 우선 문맥을 공유하게 됨으로써 하나의 쓰레드가 
			잘못 작동하게 될경우 모든 프로세스가 죽어버리는 문제가 발생할수 있다. 
			fork 를 이용한 프로세스의 모델의 경우 하나의 프로세스가 죽는다 하더라도 
			다른 프로세스에 영향을 미치지 않는것과는 대조적이다.  
		</para>
		<para>
			사실 프로세스가 죽는 문제는 유저의 잘못된 입력등을 처리하지 못하거나 
			또는 예외상황에 대한 처리를 하지 않아서 일어나는 경우도 있을수 있다. 
			이는 꽤 심각할수 있는데,   
			현재 약 100 명의 유저가 들어와서 작업을 하는중 단 한명의 유저가 
			잘못된 입력을 하고 때문에 쓰레드가 죽었고, 해당 쓰레드만 죽는게 아니고 
			다른 정상작동 하고 있는 쓰레드까지 몽땅 죽어버리는 심각한 사태가 
			벌어질수 있기 때문이다. 
		</para>
		<para>
			그러므로 쓰레드 프로그래밍을 할때는 이것 저것 꼼꼼히 따져서 
			작업을 해야한다. 또한 쓰레드가 조금만 복잡하게 얽혀 있어도 
			문맥을 교환한다는 특징때문에 어느 쓰레드에서 어떤 문제가 
			발생했는지 알아내기 어렵다는 단점을 가진다. 이는 디버깅의 어려움으로   
			이어진다. 
		</para>
		<para>
			하지만 쓰레드 프로그래밍에 대한 충분한 경험과 이해가 있다면, 
			고성능의 프로그램을 좀더 쉽게 개발할수 있다. 
		</para>
	</section>
	<section>
		<title>쓰레드를 이용한 네트웍 서버 프로그래밍</title>
		<para>
			만들고자 하는 프로그램은 여러번 다루었던 "우편번호 검색" 프로그램이다.
			<ulink url=></ulink> 에 있는 서버프로그램을 쓰레드버전으로 
			제작성하게 될것이다. 	 
		</para>
		<para>
			<emphasis>예제 : zipcode_th.c </emphasis>
			<screen>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <signal.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <vector>
#include <string>

// 주소 정보를 저장하기 위한 전역 변수 선언 
vector<string> vaddress;

void *thread_comm(void *);
int load_address();

int main(int argc, char **argv)
{
	pthread_t p_thread;
	struct sockaddr_in clientaddr, serveraddr;

	int server_sockfd, client_sockfd, client_len; 

	if (argc != 2)
	{
		printf("Usage : ./zipcode [port]\n");
		printf("예    : ./zipcode 4444\n");	
		exit(0);
	}

    // 우편번호 파일로 부터 
    // 우편번호 데이타를 읽어온다. 
    // 읽어온 데이타는 vaddress 에 push 한다.  
	load_address();

    // socket -> bind -> listen 순서로 
    // 듣기 소켓 생성 
	if ((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
	{
		perror("socket error : ");
		exit(0);
	}
	bzero(&serveraddr, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons(atoi(argv[1]));
	if (bind(server_sockfd, (struct sockaddr *)&serveraddr, 
			 sizeof(serveraddr)) == -1)
	{
		perror("bind error : ");
		exit(0);		
	}
	if (listen(server_sockfd, 5) == -1)
	{
		perror("bind error : ");
		exit(0);	
	}


	while(1)
	{
        // 만약 듣기 소켓에 연결이 들어온다면 
        // 새로운 쓰레드를 생성시킨다. 
        // 새로운 쓰레드 생성시 클라이언트 소켓을 쓰레드 
        // 인자로 넘겨서 쓰레드와 클라이언트가 통신하도록 한다.  
		client_sockfd = accept(server_sockfd, (struct sockaddr *)&clientaddr, 
								(socklen_t *)&client_len);
		if (pthread_create(&p_thread, NULL, thread_comm, (void *)&client_sockfd) == -1)
		{
			perror("thread Create error\n");
			exit(0);
		}
		else
		{
			cout << "Thread Create Success" << endl;	
		}
	}	
}

// 쓰레드 생성시 넘어온 클라이언트 소켓을 
// 이용해서 클라이언트와 통신한다.  
void *thread_comm(void *data)
{
	int sockfd = *((int *)data);
	char buf[255];
	vector<string>::iterator mi;
	pthread_t th; 

	cout << "socket fd is " << sockfd << endl; 
	while(1)
	{
		if (read(sockfd, buf, 255) <= 0)  
		{
			perror("read error : ");
			close(sockfd);
			pthread_exit((void *)NULL);
		}
		if (strncmp(buf, "quit", 4) == 0)
		{
			write(sockfd, "bye bye", 8);
			close(sockfd);
			pthread_exit((void *)NULL);
		}
		mi = vaddress.begin(); 
		while(mi != vaddress.end())
		{
			if(strstr(mi->c_str(), buf) != NULL)
			{
				cout << "Send " << mi->c_str(); 
				write(sockfd, mi->c_str(), 255);
			}
			*mi++;
		}
		write(sockfd, "end", 255); 
		memset(buf, 0x00, 255); 

	}
}

int load_address()
{
	char line[255];
	FILE *fp;

	if ((fp = fopen("zipcode.txt", "r")) == NULL)
	{
		perror("file open error : ");
		exit(0);
	}

	while(fgets(line, 255, fp) != NULL)
	{
		vaddress.push_back(line);
	}
	fclose(fp);	

	return 1;
}
			</screen>
		</para>
		<para>
			프로그램은 C++ 로 작성되었다. 특별한 이유는 없고 단지 vector를 
			사용하기 위한게 목적이다. 프로그램에 대한 설명은 
			주석만으로도 충분히 이해가능할것임으로 주석으로 대체하도록 하겠다.   
		</para>
	</section>
</section>
</article>
}}}
