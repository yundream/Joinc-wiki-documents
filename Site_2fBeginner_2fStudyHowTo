#title 시작하려는 이를 위해서
[[tag(C,C++,시스템프로그래밍,네트워크프로그래밍,어셈블리어,Linux,FAQ)]]

[[TableOfContents(title=목차)]]

== 목적 ==
 * 프로그래밍 세계에 입문하는 유저를 위한 가이드 라인 제시 
   1. 학습방법및 방향
   1. 학습문서들 : 언어, 프로그래밍 환경...
   1. 업계현황, 정보, 조언
   1. FAQ 정리
 * 사이트 이용과 관련된 도움문서 제작
   1. 위키 사용법 (기존에 있지만 보기 힘들었음)

== 필요한 것들 ==
 * 관련문서 수집 
 * 시스템 정비 : 게시판의 선택 혹은 확장
 * RSS(12) : 기존에 있는 시스템의 확장
== 관련 문서들 ==
[[subindex(Site/Beginner/Document)]]

== 나의 프로그램 배움 ==
나는 개인적으로 공부란 말을 별로 좋아하지 않는다. 배움이라는 단어를 더 좋아한다.
여기를 출입하는 많은 분들 중에 프로그래밍를 습득한 분도 많고 습득하기를 원하는 분도 많다. 특히 [http://kr.dcinside1.imagesearch.yahoo.com/zb40/zboard.php?id=programming 프로그래밍 갤러리]를 통해서 이곳으로 들어 오는 분들은 말이다. 많은 사람들을 만나 보면서 이런 질문을 하는 사람들이 정말 많다. 프로그래밍은 어떻게 공부 해야 하는가? 어떤 언어를 배워야 하는가?

[http://freefeel.org/wiki/%EB%82%98%EC%9D%98%EC%98%81%EC%96%B4%EA%B3%B5%EB%B6%80 나의 영어 공부] From Freefeel
처럼 많은 고수(또는 일반인)들의 이야기를 들어 봤으면 좋겠다. 나는 이렇게 배워 왔다. 이런 시행착오(Try and Error)를 해 봤다. (Join C 주인장님의 후배들은 덜 하길 바라며...) --Crystal

=== 질문하는 법 ===
[wiki:Site/Beginner/Document/HowToAsk 질문하는 법]

무시되는 질문들
 * 입문서로 뭐가 좋을까요 ?
 * (소스를 그대로 올리고) 이거 안되는데 좀 봐주세요.
 * printf 로 어떻게 찍어야 하나요? 수준의 질문
 * 어떻게 공부해야 하나요.

무시되는 질문이 있는가 하면, '''욕 먹는''' 질문도 있습니다. 모든 커뮤니티의 Q&A에 공통적으로 해당되는 사항입니다. 
 * 숙제를 그대로 올리는 유형
   .... 하는 함수를 작성하라. 단 .... 해야함 
 * 테스트를 가장한 질문
 * 답변이 없다고 중복해서 올리는 행위 
   왜 답변이 없는지를 확인해 보도록해야 합니다. 위의 '''질문하는 법'''문서를 읽어 보시기 바립니다. 물론 좋은 질문임에도 불구하고 답변이 올라오지 않는 경우도 있는데, 그렇다고 해서 중복해서 질문을 올리면 욕먹습니다.

질문올리기 전에 다음 사이트들을 검색해 보세요.
 * VC++, C#등 M$ 기술관련 : http://www.devpia.com
 * 자바 : http://javanuri.net
 * PHP : http://www.phpschool.com
 * asp : http://www.taeyo.net
 * javascript, CSS : http://www.koxo.com
 * C FAQ : http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/FAQ/CfaqHTML/cfaqs-ko.html 
 * 다양한 FAQ : [wiki:Site/FAQ FAQ 정리 사이트]
 * Linux 시스템 함수및 명령 : [wiki:man Joinc man page]
 * Linux/Unix 프로그래밍 : [http://www.joinc.co.kr/modules.php?op=modload&name=Forum&file=viewforum&forum=1&0 Joinc 게시판], [http://kldp.org/forum/5 KLDP 게시판]

 * WIN31 API : http://www.winapi.co.kr
 * M$ API : http://msdn.microsoft.com
 * J2SE 1.5.0 API : http://java.sun.com/j2se/1.5.0/docs/api/
 * 기타 모든 것 : http://www.google.co.kr
 * 심심할적에 : [http://kr.dcinside1.imagesearch.yahoo.com/zb40/zboard.php?id=programming&banner=&page=1&page_num=20&category=&sn=off&ss=on&sc=off&keyword=&prev_no=20694&sn1=&divpage=4&select_arrange=headnum&desc=asc DC 프겔] <!> 단 ..심장 강한 사람만

이거 가능할까요 ?
 * http://www.codeguru.com
 * http://www.sourceforge.net
 * http://www.codeproject.com


=== C언어 혹은 어셈블리어를 배울 필요가 있는가 ===
[[sadsense(click)]]
많은 개발자들이 C(:12)언어와 (C++도 포함하겠다) 어셈블리어를 구석기 시대쯤에 사용되는 언어로 취급한다. 확실히 이들 언어는 '''강력하긴 하지만''' 플렛폼 지향적이지도 않으며, 객체지향적이지도 않다. 문자열을 다루기도 쉽지않고, pointer(:12)를 이용해서 메모리 관리도 어드레스 수준에서 직접 해주어야 한다. [wiki:Site/C%2B%2B C++]은 그래도 최신의 언어들이 가지고 있는 기능들을 지원하기는 하지만 C와의 호환성과 업계표준이라는 보수성 때문에 지원에 한계를 보여주고 있다. 그러나 여전히 이들 언어는 많이 사용되고 있으며, 다음과 같은 이유로 배워야할 가치가 충분하다고 생각된다.

 * '''뛰어난 학습 효과''' : 
    이 이유는 아마도 전공 학부생에게 주요한 이유가 될 것이다. 시간이 부족하거나 활용에 치중해야 하거나, 이미 실무에서 높은 수준의 응용을 만드는 일에 종사하고 있다면 인정하기 어려울 수도 있을 것이다.
    
    어셈블리(:12)언어는 (기계어를 제외하고는) 컴퓨터 시스템에 가장 근접한 언어며, C가 그 뒤를 따르고 있다. 이말은 이 언어들을 사용할 경우 더욱 자연스럽게 컴퓨터과학(혹은 공학)에 대한 학구적인 접근이 가능하다는 얘기가 된다. Java(:12), Python(:12), Ruby와 같이 고도로 추상화된 언어들은 소프트웨어공학의 입장에서 더 좋은 학습 환경을 만들어 주기는 하지만, 그 추상화가 단점이 되어서, 추상화 아래 단계에 근본적인 접근을 어렵게 한다.
    
    여러분이 컴퓨터/소프트웨어 공학에 뜻을 두고 있거나, 혹은 학부생이라면 어셈블리와 C는 기본을 튼튼하게 하는데 많은 도움을 줄 것이다. 

 * '''여전히 널리 쓰인다.'''
   비록 학생이라고 하더라도, 내가 배운 언어가 실제 산업현장에서 널리 사용되고 있는가 하는 점은 중요한 점이다. Java(:12)언어와 엎치락 뒤치락 하고 있으며 많은 영역을 내주기는 했지만, C/C++이 더 잘하는 영역이 여전히 존재하며, C/C++ 을 합한다면 확실히 현재 가장 널리쓰이는 언어다. 특히 14위에 랭크되어 있는 '''D'''언어의 약진을 눈여겨 볼만하다.  D(:12)언어는 C/C++을 계승하고 있으며, 우리나리엔 아직 알려진거 같지 않긴 하지만, Ruby 언어와 함께 가장 주목되는 언어 중 하나다.
   {{{#!html
<table align="center" border="1" class="ttable">  <colgroup> <col align="center"> <col align="center"> <col align="center">  <col> <col align="center"> <col align="center"> <col align="center">  </colgroup><tbody>  <tr>  <th align="center" nowrap="nowrap">  Position<br/>  Jan 2007 </th>  <th align="center" nowrap="nowrap">  Position<br/>  Jan 2006 </th>  <th align="center" nowrap="nowrap">  Delta in Position </th>  <th align="center" nowrap="nowrap">  Programming Language </th>  <th align="center" nowrap="nowrap">  Ratings<br/>  Jan 2007 </th>  <th align="center" nowrap="nowrap">  Delta<br/>  Jan 2006 </th>  <th align="center" nowrap="nowrap">  Status </th>  </tr>  <tr height="25">  <td align="center">  1 </td>  <td align="center">  1 </td>  <td align="center">  <img border="0" src="http://www.tiobe.com/tiobe_index/images/Same.gif"/>  </td>  <td>  <a href="http://www.tiobe.com/tiobe_index/Java.html">Java</a>  </td>  <td align="center">  19.160% </td>  <td align="center">  -3.10% </td>  <td align="left">  &nbsp;&nbsp;A </td>  </tr>  <tr height="25">  <td align="center">  2 </td>  <td align="center">  2 </td>  <td align="center">  <img border="0" src="http://www.tiobe.com/tiobe_index/images/Same.gif"/>  </td>  <td>  <a href="http://www.tiobe.com/tiobe_index/C.html">C</a>  </td>  <td align="center">  15.807% </td>  <td align="center">  -3.20% </td>  <td align="left">  &nbsp;&nbsp;A </td>  </tr>  <tr height="25">  <td align="center">  3 </td>  <td align="center">  3 </td>  <td align="center">  <img border="0" src="http://www.tiobe.com/tiobe_index/images/Same.gif"/>  </td>  <td>  <a href="http://www.tiobe.com/tiobe_index/C__.html">C++</a>  </td>  <td align="center">  10.425% </td>  <td align="center">  -1.04% </td>  <td align="left">  &nbsp;&nbsp;A </td>  </tr>  <tr height="25">  <td align="center">  4 </td>  <td align="center">  5 </td>  <td align="center">  <img border="0" src="http://www.tiobe.com/tiobe_index/images/Up.gif"/>  </td>  <td>  <a href="http://www.tiobe.com/tiobe_index/%28Visual%29_Basic.html">(Visual) Basic</a>  </td>  <td align="center">  9.123% </td>  <td align="center">  +0.03% </td>  <td align="left">  &nbsp;&nbsp;A </td>  </tr>  <tr height="25">  <td align="center">  5 </td>  <td align="center">  4 </td>  <td align="center">  <img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/>  </td>  <td>  <a href="http://www.tiobe.com/tiobe_index/PHP.html">PHP</a>  </td>  <td align="center">  7.943% </td>  <td align="center">  -1.46% </td>  <td align="left">  &nbsp;&nbsp;A </td>  </tr>  <tr height="25">  <td align="center">  6 </td>  <td align="center">  6 </td>  <td align="center">  <img border="0" src="http://www.tiobe.com/tiobe_index/images/Same.gif"/>  </td>  <td>  <a href="http://www.tiobe.com/tiobe_index/Perl.html">Perl</a>  </td>  <td align="center">  6.237% </td>  <td align="center">  -0.81% </td>  <td align="left">  &nbsp;&nbsp;A </td>  </tr>  <tr height="25">  <td align="center">  7 </td>  <td align="center">  7 </td>  <td align="center">  <img border="0" src="http://www.tiobe.com/tiobe_index/images/Same.gif"/>  </td>  <td>  <a href="http://www.tiobe.com/tiobe_index/C_.html">C#</a>  </td>  <td align="center">  3.521% </td>  <td align="center">  -0.03% </td>  <td align="left">  &nbsp;&nbsp;A </td>  </tr>  <tr height="25">  <td align="center">  8 </td>  <td align="center">  8 </td> <td align="center"> <img border="0" src="http://www.tiobe.com/tiobe_index/images/Same.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/Python.html">Python</a> </td> <td align="center"> 3.502% </td> <td align="center"> +0.90% </td> <td align="left"> &nbsp;&nbsp;A </td> </tr> <tr height="25"> <td align="center"> 9 </td> <td align="center"> 10 </td> <td align="center"> <img border="0" src="http://www.tiobe.com/tiobe_index/images/Up.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/JavaScript.html">JavaScript</a> </td> <td align="center"> 2.845% </td> <td align="center"> +1.31% </td> <td align="left"> &nbsp;&nbsp;A </td> </tr> <tr height="25"> <td align="center"> 10 </td> <td align="center"> 21 </td> <td align="center"> <b>11 * </b><img border="0" src="http://www.tiobe.com/tiobe_index/images/Up.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/Ruby.html">Ruby</a> </td> <td align="center"> 2.519% </td> <td align="center"> +2.15% </td> <td align="left"> &nbsp;&nbsp;A </td> </tr> <tr height="25"> <td align="center"> 11 </td> <td align="center"> 11 </td> <td align="center"> <img border="0" src="http://www.tiobe.com/tiobe_index/images/Same.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/SAS.html">SAS</a> </td> <td align="center"> 2.343% </td> <td align="center"> +1.18% </td> <td align="left"> &nbsp;&nbsp;A </td> </tr> <tr height="25"> <td align="center"> 12 </td> <td align="center"> 9 </td> <td align="center"> <img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/Delphi.html">Delphi</a> </td> <td align="center"> 2.336% </td> <td align="center"> +0.75% </td> <td align="left"> &nbsp;&nbsp;A </td> </tr> <tr height="25"> <td align="center"> 13 </td> <td align="center"> 12 </td> <td align="center"> <img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/PL_SQL.html">PL/SQL</a> </td> <td align="center"> 1.570% </td> <td align="center"> +0.54% </td> <td align="left"> &nbsp;&nbsp;A </td> </tr> <tr height="25"> <td align="center"> 14 </td> <td align="center"> 22 </td> <td align="center"> <b>8 * </b><img border="0" src="http://www.tiobe.com/tiobe_index/images/Up.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/D.html">D</a> </td> <td align="center"> 1.335% </td> <td align="center"> +0.97% </td> <td align="left"> &nbsp;&nbsp;A- </td> </tr> <tr height="25"> <td align="center"> 15 </td> <td align="center"> 20 </td> <td align="center"> <img border="0" src="http://www.tiobe.com/tiobe_index/images/Up.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Up.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Up.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Up.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Up.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/ABAP.html">ABAP</a> </td> <td align="center"> 1.229% </td> <td align="center"> +0.82% </td> <td align="left"> &nbsp;&nbsp;A- </td> </tr> <tr height="25"> <td align="center"> 16 </td> <td align="center"> 14 </td> <td align="center"> <img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/Lisp_Scheme.html">Lisp/Scheme</a> </td> <td align="center"> 0.674% </td> <td align="center"> +0.07% </td> <td align="left"> &nbsp;&nbsp;B </td> </tr> <tr height="25"> <td align="center"> 17 </td> <td align="center"> 18 </td> <td align="center"> <img border="0" src="http://www.tiobe.com/tiobe_index/images/Up.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/Ada.html">Ada</a> </td> <td align="center"> 0.638% </td> <td align="center"> +0.17% </td> <td align="left"> &nbsp;&nbsp;B </td> </tr> <tr height="25"> <td align="center"> 18 </td> <td align="center"> 13 </td> <td align="center"> <img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/COBOL.html">COBOL</a> </td> <td align="center"> 0.637% </td> <td align="center"> -0.13% </td> <td align="left"> &nbsp;&nbsp;B </td> </tr> <tr height="25"> <td align="center"> 19 </td> <td align="center"> 15 </td> <td align="center"> <img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/><img border="0" src="http://www.tiobe.com/tiobe_index/images/Down.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/Pascal.html">Pascal</a> </td> <td align="center"> 0.570% </td> <td align="center"> +0.04% </td> <td align="left"> &nbsp;&nbsp;B </td> </tr> <tr height="25"> <td align="center"> 20 </td> <td align="center"> 34 </td> <td align="center"> <b>14 * </b><img border="0" src="http://www.tiobe.com/tiobe_index/images/Up.gif"/> </td> <td> <a href="http://www.tiobe.com/tiobe_index/Transact-SQL.html">Transact-SQL</a> </td> <td align="center"> 0.510% </td> <td align="center"> +0.34% </td> <td align="left"> &nbsp;&nbsp;B </td> </tr> </tbody> </table>
}}}
   출처 : http://www.tiobe.com/tpci.htm

 * '''기초가 된다'''
   위에서도 언급했듯이 이들언어는 컴퓨터/소프트웨어 공학에 관한 기초를 다지는데 많은 도움을 준다. 이는 다른 언어나 새로운 개발 환경에 쉽게 적응할 수 있음을 얘기한다. 실제 C/C++ 프로그래머라고 해서, 이들 언어만을 사용해서 개발하는 개발자는 흔하지 않다. 주언어로 Java를 함께 사용하며, 유틸리티 언어로 Perl, Python 언어들을 사용한다.

   예를들어 여러분이 보안전문가로써의 길을 걷고 싶다고 가정을 해보자. 이 경우 필요한 능력은 언어를 잘 다루는 능력이 아니다. C, Java, 혹은 Python을 얼마나 능숙하게 다루며, 객체지향적인 마인드를 가지고 있는가 하는건 부차적인 문제다. 정말 필요한 능력은 시스템(:12)과 네트워크(:12)에 대한 이해다. 일반적으로 추상화된 언어들은 사용자로 하여금 하부구조에 신경을 써도 되지 않도록 만들기 때문에, C/C++/어셈을 다루어본 경험자에 비해서 (비슷한 시간을 투자했을 경우) 하부구조에 대한 이해가 떨어질 수 밖에 없다. 즉 자신의 영역을 확대시키가 어렵다는 얘기가 된다. 이는 기초를 바탕으로 자신의 영역을 선택해야 하는 학생에게는 매우 중요한 요소다. 기초가 튼튼하면 그만큼 선택의 폭도 넓어 진다.
   
   고수준의 언어로 프로그래밍 환경에 빠르게 적응한 후, 기본이 되는 환경에 대해서 배우면 되지 않느냐고 할 수 있을거 같다. 물론 그렇기는 하다. 모든건 효율의문제다. 인간은 기본적으로 낮은 곳에서 높은 곳으로 향하려고 하는 욕구를 가지고 있으며, 이에 익숙하도록 되어 있다. 오늘 PHP를 이용해서 '''Hello World'''를 출력할 수 있는 웹페이지를 만들었다면, 내일은 DB연결, 내일 모레는 게시판 만들기를 하고 싶어하는게 본성이다. 어떻게 브라우저를 통해서 Hello World가 찍힐까를 알아보기 위해서, TCP(:12)/ IP(:12), socket(:12)도구, pipe(:12)와 환경변수(:12)를 제공하는 운영체제(:12)의 시스템특성에 대해서 공부하는 건 일반적인 경우가 아니다. 더 높은 단계에서 이룩해야 할 많은 것들이 눈에 보이기 때문에, 하부단계에 대해서는 신경쓸 여력도 없다.

   '''웹플밍은 좀합니다. 그런데 더 나아갈려면 기초도 튼튼해야 될거 같아서, 네트워크나 시스템쪽도 좀 알아보려고 하는데, 시간이 없어서 못하겠네요.''' 하는 얘기는 흔히 듣는 얘기중 하나다. 그렇다면 초기에 좀 힘들더라도 기초부터 튼튼히 다진 다음에 자연스럽게 앞으로 나아가는게, 나중에 익숙하지 않는 방향으로 힘들게 뒤로 유턴하는 것보다는 훨씬 효율적일 것이다.

   '''왜 C++을 선택해야 하는가'''
   [wiki:Site/Development/Forum/manager/WhyCpp 왜 C++인가] : 게임 프로그래머의 입장에서 C++의 장점을 설명한 글이다.
 
 * '''어셈블리어'''
 C/C++은 그렇다 치고 어셈블리어(:12)를 배워야 하는지에 의문을 가질 수 있을 것이다. 개인적인 생각으로도 특별한 목적의식 없이 어셈블리어를 깊이 배울 필요는 없다고 생각한다. 어셈블리어 관련 교체를 보면 처음 5장 정도를 컴퓨터 구조와 소프트웨어에 대해서 언급을 하는데, 이들 문서만 읽어도 충분한 가치가 있다. 컴퓨터 시스템 구조와 소프트웨어에 대한 기본적인 소양을 갖추게 하는데 많은 도움을 주며, C/C++,Java와 같은 고수준 언어를 더 쉽게 이해하고 공부할 수 있도록 만들어 준다.
  
  1주 정도 틈틈이 시간을 내어서 공부를 하고 - 아마 1주에 공부를 한다면, 어셈블리어가 아닌 컴퓨터 시스템의 구조에 대한 학습을 하게 될 것이다. - 더욱 관심이 있다면, 가벼운 마음으로 뒷장들을 읽어 나가면 될것이다. [wiki:Site/Assembly/Documents/Spim Spim]문서를 기준으로 한다면 1-9장 정도를 가볍게 읽어주면 된다. (실제 가벼운 내용이다)
  
 * '''Embedded System 분야에서 ''' : 
 2007년1월 현재 임베디드(:12) 시스템을 동작시키는 대부분의 언어는 약80%의 C언어 + 약10%의 어셈블리어(기본 제공 된 소스 그대로 사용)+약10%(C++,JAVA?로 파악됨)이다. 프로젝트에 따라 달라질수도있으며 자바(:12)또는 다른 언어가 사용되기도 하지만 절대강자는 C이다. 당신들이 사용하고 있는 PMP, DMB, 휴대폰(휴대전화), 머리에 떠 있는 인공위성등 모든것을 C로 이루어 진다고 추측합니다. 단 이것은 Crystal의 경험에 의한것 입니다. (2007 01 21,수정 2007 08 08)


=== 운영체제의 선택 ===
일정 수준 이상에 올라가면 언어와 운영체제가 상관없다라고 합니다만, 우리는 아직 일정수준에 올라가 있지 않기 때문에 운영체제의 선택에 있어서 어느정도 신중할 수 밖에 없을 겁니다.

저는 Unix(:12) 그 중에서도 Linux(:12)를 운영체제로 선택할 것을 권합니다. 이유는 다음과 같습니다.

  * '''Unix 를 따른다.'''
  비록 Linux가 Unix와는 전혀다른 운영체제라고 말하지만 철학,운용,개발 환경 모두 Unix의 그것을 따르고 있습니다.

  그렇다면 Unix를 따르는게 왜 선택의 이유가 되는지가 궁금해질 수 있을 겁니다. Unix운영체제는 현재 운용체제의 모습을 확립한 선조격이 되는 운영체제 입니다. 비록 처음이라고 할 수는 없겠지만 현실적으로 모든 운영체제의 할아버지격이 되는 운영체제라고 할 수 있습니다.

  지금의 인터넷이 가능하게한 TCP(:12)/ IP(:12)와 같은 프로토콜과 서비스들이 Unix 환경에서 만들어지고 테스트되어져 왔습니다. 또한 운영체제가 가져야될 여러가지 구성요소들인 파일, 디렉토리, 소켓, IPC, 프로세스/쓰레드 개념과 이들을 사용하기 위한 시스템함수(:12)들이 유닉스에서 만들어졌습니다. 이러한 개념과 함수들은 전혀 다른 운영체제라고 생각할 수 있는 윈도우즈와 Mac OS에도 거의 그대로 전승되고 있습니다.

  즉 Unix를 공부한다는 것은 현대적인 네트워크 시스템과 컴퓨터 시스템을 공부한다는 것을 의미하게 됩니다.

  물론 다른 운영체제로도 위의 일들은 가능합니다. 그러나 효율성에 있어서 차이가 있습니다. 윈도우즈는 네트워크와 시스템의 많은 부분을 추상화 시킨 운영체제 입니다. 이는 뛰어난 장점이 될 수도 있지만 기초부터 공부를 하고자 할때, 오히려 방해요소가 될 수도 있습니다. 

  반면 유닉스 운영체제들은 추상화단계가 낮은 단순화된 환경을 제공합니다. 프로그램을 만들거나 운영체제를 제어하는데 있어서, 이것 저것 많은 것을 알아야 된다는 의미가 됩니다. 이는 초기 운영체제에 대한 접근을 어렵게 하므로 단점이 될겁니다. 그러나 기초부터 공부를 하고자 한다면, 이는 크나큰 장점이 됩니다. 공부해야 하는 필요성을 느끼는 환경을 만들어 준다고 보시면 될거 같습니다. 
  유닉스를 따름으로 얻는 또다른 잇점은 리눅스를 통해서 획득한 지식을 유닉스에 거의 그대로 확장시킬 수 있다는 점입니다. '''리눅스에서 만든 프로그램은 소스코드의 변경없이 그대로 유닉스에서 사용할 수 있다'''라는 건 분명히 과장이 섞인 주장이긴 합니다만. 리눅스를 통해서 얻은 지식은 유닉스에 거의 그대로 적용할 수 있으며, 비교적 쉽게 다른 유닉스 환경에 적응할 수 있습니다. 

  좋은 리눅스 개발자는 더 쉽게 좋은 유닉스 개발자가 될 수 있습니다.

  * '''Free'''
  리눅스는 이러한 유닉스의 장점을 계승할 뿐만 아니라. 운영체제와 그 위에서 움직이는 거의 모든 프로그램들이 완전히 공개 (free)되어 있습니다. 라이센스 걱정 없이 설치해서 사용할 수 있으며, 크고 작은 수많은 잘만든 소스코드를 얻어서 분석하고 수정하고 테스트할 수 있습니다. 

  이건 실무개발자와 공부하는 학생을 막론하고 축복입니다.
==== 리눅스의 선택 ====
리눅스는 다양한 배포판이 존재한다. 이 배포판들은 만들어진 용도가 각각다르며, 독자적인 패키징 형식을 가지고 있다. 이러한 차이점으로 인해서 - 비록 모든 리눅스 배포판이 근본적으로 같다고 하지만 - 하나의 배포판에 익숙해진 상태에서 다른 배포판으로 넘어가는건 그리 쉬운일이 아니다. 그러므로 초기 배포판을 잘 선택할 필요가 있다. 다음은 대표적인 배포판들이다.
  || 이름    || 패키징      || 설명      ||
  || RedHat    || RPM        || 접근용이, 많은 자료  ||
  || Fedora    || RPM        || 접근용이, 많은 자료  ||
  || Suse    || RPM        || 접근용이, 중간 자료  ||
  || Ubuntu    || 데비안      || 접근용이, 많은 자료  ||
  || gentoo    || portage      || 접근어려움, 중간 자료  ||

가장 손쉽게 사용할 수 있는 배포판은 '''Fedora'''와 '''Ubuntu'''인데, 이 중 Ubuntu를 추천한다. Ubuntu와 관련된 내용은 [http://ubuntu.or.kr Ubuntu 한국 커뮤니티]를 참고하기 바란다. gentoo(:12)는 개발자를 위한 최고의 배포판이란 평을 듣고 있지만, 초기에 접근이 좀 어렵다는 평가가 있다.   

=== 공부하는 방법 - yundream ===
제가 나름 대로 생각하는 공부하는 법입니다. 공부하는데 있어서 이게 최선의 방법이다 라는게 있지는 않을겁니다. 개인적인 경험을 바탕으로한 의견이며, 어떻게 받아들일지는 여러분의 몫입니다. 방법론이 중요한 것은 '''문제를 해결하기 위한 길을 제시'''하기 때문에 중요한게 아니라고 생각합니다. 생각의 넓이를 넓힐 수 있는 계기를 만들어 주기 때문에 중요한 것이라 생각합니다.

==== 학과 커리큘럼이 최고 ====
학과 커리큘럼을 무시하는 경향이 있는 거 같다. 재미가 없고, 필요 없을 것 같고 시간낭비 같으니 그냥 재미있는거 찾아서 하겠다. 혹은 인터넷 게시판에 물어봐서 해야지 라고 생각하는 경우가 많은거 같다.

우선 알아둘건 대학교는 학원이 아니며, 커리큘럼은 주먹구구식으로 만들어진게 아니라는 것이다. 수십년의 역사동안 수천 수만의 대학교에서 수만,수십만의 (여러분보다 수십년이상의 경험을 더 가진)교수들에 의해서 다듬어져서 내려온 것들이다. 대학교는 학원이 아니기 때문에, 기술의 활용 이런걸 가르키는 곳이 아니다. 학문이 우선이다. 그러다 보니 고리타분하고 심심할 수도 있겠지만, 이걸 배우기 싫다면 대학에 올 필요가 없다. 학원에 가면 더 싼가격에 더 재미있게 배울 수 있다. 인터넷 서핑을 통한 독학도 가능하다. 기술을 배울거면 이 방식이 훨씬 낳다. 그럴거면 왜 대학에 오는가. 학원 다니는걸 추천한다.

일단 학과 공부에 충실하라. 학문에 대한 응용은 시간을 만들어서 하라. 재미있는 걸 공부해야 한다? 나는 그렇게 생각하지 않는다. 물론 자신의 적성에 맞는 분야를 찾아야 함은 당연하겠지만, 재미없고 힘들어도 해야 하는게 공부라고 생각한다. 공부란 자기수양이란 말도 있지 않은가. 
==== 문법책은 빠르게 독파 ====
C언어 자체는 매우 단순합니다. 또한 말그대로 언어이기 때문에, 문법과 몇 가지 주요 요소를 숙지하는 수준까지만 올리면 충분합니다. 내용을 암기할려고 한번 두번 읽을 필요 없이 한달 정도에 걸쳐서 한번 읽을 정도면 충분합니다. 그 이상 비슷한 문법책을 두권이상 사서 보는건 낭비라고 생각합니다. 혹은 C++ 부터 시작해도 관계는 없습니다. C++은 C(:12)를 포함하고 있으며, 여기에 객체지향과 같은 철학을 적당히 구현할 수 있도록 기능이 확장되어 있습니다.

영문학을 한다고 해도, 문법익히는데 걸리는 시간은 사실은 1년 정도도 채 안될겁니다. 나머지는 문화를 공부하는 것이지 문법을 공부하는건 아니니까요.

문법책은 그렇게 한번 훑어보고, 음.. 가능하면 assembly(:12)쪽을 한번 쭉 훑어보는게 컴퓨터의 작동방식을 이해하는 방식으로 나가면 좋을거 같구요. 깊게 들어갈 필요없이 소설책 읽듯이 부담없이 읽어가면 충분합니다. [wiki:Site/Assembly/Documents Programming from the Ground Up], [wiki:Site/Assembly/Documents/Spim Spim] 문서를 추천합니다.

==== 시스템/네트워크 프로그래밍의 세계로 ====
문법책을 떼고나면 뭘해야 될지 모르는 상황이 오게 됩니다. 배우긴 배웠는데, 어디에 써먹어야 될지를 모르게 되니, 내가 배우긴 배운건가 하는 불안감을 가지게 되고, 불안감을 해소 하기 위해서 간단간단한 코드 만들기 등을 시도하게 됩니다. 많은 예제를 포함한 책들을 선택하게 되는 이유이기도 합니다. 물론 이러한 코드들을 보면, 많은 도움이 됩니다. 이러한 책혹은 코드들은 문제가 주어졌을 때, 어떤식으로 풀면 되겠다라는 아이디어를 줍니다. 팁이라는 거죠. 팁도 당연히 중요합니다만 일에는 순서가 있는 법입니다. 공부를 잘하는 100가지 방법 ? 많은 도움이 되겠지만, 일단 머리에 든게 있어야 방법을 써먹을 수 있겠죠. [[sadsense(big)]]

  '''시스템 프로그래밍'''
  문법책을 떼었다면 시스템프로그래밍(:12)쪽을 공부하도록 합니다. 시스템 프로그래밍은 모든 프로그래밍의 기초가 됩니다. 여러분이 네트워크프로그래밍(:12)을 하든 임베디드(:12), 게임, 보안을 하든 웹을 하든지간에 반드시 필요합니다. 게임이든 보안솔류션이든지, 웹응용이든지 간에 시스템 위에서 돌아가는 프로그램들입니다. 시스템을 이해하지 못하면 제대로된 프로그램을 작성할 수 없습니다. 시스템 프로그래밍은 시스템에 대한 이해도와 활용도를 높여준다는 점에서 필수 코스 입니다.

  시스템 프로그래밍은 그 양과 깊이가 매우 방대하기 때문에, 단시간내에 마스터할 수 있는 성질의 것이 아닙니다만, 단계별 공부와 응용이 가능한 기초 수준 정도로 올리는 것이라면 3달 정도면 됩니다.

  '''네트워크 프로그래밍'''
  이렇게 한 4달 하면 언어도 어느정도 사용할 수 있고, 시스템 프로그래밍에 대한 개념도 어느정도 잡히게 될겁니다. 그럼 네트워크프로그래밍(:12)을 공부하면 됩니다. 모든게 인터넷으로 통하는 세상이니 네트워크 프로그래밍의 중요성에 대해서는 강조할 필요도 없으리라 생각됩니다.
  
  네트워크 프로그래밍의 중요성이 강조되다 보니, 가끔 문법을 띠고 나서 바로 네트워크 프로그래밍으로 발을 들여놓으려고 하는 분들도 있습니다. 그러나 네트워크 프로그램도 시스템 위에서 돌아가는 겁니다. 시스템 프로그래밍에 대한 이해가 필수선행 조건입니다.

  '''다시 시스템 프로그래밍으로'''
  네트워크 프로그래밍 진도가 나다가 보면, 어느 단계에서 고급 시스템 프로그래밍 기법의 응용이 필요함을 절감하게 됩니다. 이 시점에서 다시 시스템 프로그래밍을 공부하게 됩니다. 이미 어느정도 기초를 닦아두었기 때문에 효율적인 공부가 가능할겁니다. 이쯤되면 네트워크 프로그래밍과 시스템 프로그래밍의 경계는 사라집니다. 병행하면서 공부해 나가게 되는 거죠.

  '''관심 분야로 진출'''
  시스템/네트워크 프로그래밍에 대해서 어느정도 가닥이 잡히게 되면, 뭘해야 할지 혹은 뭘하고 싶은건지에 대한 감이 올겁니다. 간혹보면, 이들에 대한 기초없이 처음부터 목표를 정해 놓고, 뭘 공부해야 좋을까요를 물어보는 경우가 있습니다. 평소에 게임을 좋아하는데 MFC를 하는게 좋을까요. 이런류의 질문입니다. '''아는 만큼 보인다'''라는 말이 있습니다. 알아야지 자기가 뭘 하고 싶은건지, 어디에 재능이 있는건지를 판단할 수 있습니다.
  
  프로그래밍에 대해서 아는 거라고는 게임과 오피스 밖에 없는데, 뭘 할지 뭘 좋아하는지를 어떻게 판단할 수 있나요.

  먼저 기초를 잡고나가면, 기존에 하고 싶었던것 이외에도 해야할 엄청나게 많은 것들이 있다는 것과 뭐를 하면 잘할 수 있겠다라는 것을 파악하실 수 있습니다. 기존에 하고 싶었던 일을 더 잘할 수 있음을 말할 필요도 없겠지요.

  객체지향과 같은 프로그래밍 철학, 개발 방법론, 시스템 관리, 네트워크 관리, 임베디드, 보안, 웹서비스, 모바일, 그래픽, 고급 유저 응용 등등에서 원하는 것을 선택하면 됩니다. Java나 Python과 같은 새로운 언어를 접할 기회도 생길겁니다.

==== 자료구조와 알고리즘 ====
자료구조는 데이터를 효율적으로 처리하기 위해서 어떻게 자료를 배치할 것인가에 대한 이론이다. 알고리즘은 이렇게 배치된 데이터를 어떻게 효율적으로 처리할 수 있을 것인가에 대한 '''방법'''이다.

처리해야될 데이터량이 많아 지기 때문에, 실제 시스템 프로그래밍과 네트워크 프로그래밍의 응용단계에서 반드시 필요한 내용들이라 할 수 있다. 예를 들어 2명이 채팅하는 프로그램을 만든다면 자료구조, 알고리즘 이런거 필요 없다. 그러나 동시에 수만명이 접속하는 대규모 채팅서버를 만들어야 한다면 효과적인 자료구조와 알고리즘을 생각해 낼 수 있어야 한다. yundream이 dreamyun에게 메시지를 보낼려면, 수만명의 유저이름중에서 dreamyun을 찾아야 하는데, 찾는데에만 1초가 걸리면 문제가 되지 않겠는가.

이럴 경우 유저를 빠르게 검색할 수 있는 자료구조를 만들고 만들어진 자료구조에서 효과적으로 검색이 가능한 알고리즘을 고안해 내어야 할 것이다. 이둘은 언제나 쌍으로 붙어다닌다고 볼 수 있을 것이다.  

이들의 내용은 [wiki:Site/Database Database 위키]를 살펴보기 바란다. 단 여기에 있는 내용들은 개론적인 내용들이므로 제대로 공부하기 위해서는 관련 책을 사서 보는걸 추천한다. 어쨋든 자료구조와 알고리즘이 무엇이며 왜 필요한지에 대한 개념은 잡을 수 있을 것이다.

==== 테스트를 위한 코드들 ====
다양한 응용이 가능하도록 테스트해볼 수 있는 코드들
  * [wiki:Code 조각코드 모음]
  * [wiki:Site/Test 문제들]
  * [wiki:man/2 시스템 함수 예제들]
  * [wiki:man/3 표준 라이브러리 함수 예제들]

==== 암기는 가장 나쁜 학습법 ====
사람들이 '''암기'''를 선호하는 가장 큰 이유는 빠른시간내에 인지할 수 있는 결과를 얻을 수 있음으로 학습에 대한 (심리적인)만족도를 높일 수 있다는 점 때문입니다. 물론 암기가 필요한 경우가 있긴 합니다. 운전면허나 기타 면허를 따기 위해서 족보를 공부해야 하는 경우가 되겠죠.

하지만 그 지식을 나의 것으로 하고자 하는 중/장기적인 목표의 학습에 있어서 '''암기'''는 학습을 방해하는 최대의 적입니다.

암기는 학습자에게 획일적인 생각을 하도록 강제합니다. A를 해결하는 방법은 B이다. 이걸 머리로 달달 외어버리고, 그에 대한 학습효과에도 만족을 느끼기 때문에, 다른 생각을 하지 못하게 됩니다. 편협한 사고방식을 가지게 될 확률이 높게되고, 이건 프로그래머에게는 치명적입니다.

인간의 머리는 한계가 있습니다. 별로 되지도 않는 공간에 집어 넣을 수 있는 정보는 그 끝이 있습니다. 머리를 유연하게 가져가세요. 굳이 암기하려고 하지말고, 이해하고 넘어가세요. 이해하고 넘어가는 경우에 학습자는 뭔가 불분명하기 때문에 학습에 대한 만족도가 떨어집니다. 하지만 인간의 두뇌가 강력한것은 어떤 사실에 대한 암기력 때문이 아니라, 여러가지 이해된 정보들을 네트워크화 할 수 있는 능력때문입니다. 머리속에 정보의 네트워크를 만들려면 생각이 유연해야 합니다. 암기는 머리를 굳어버리게 만듭니다 -'' 경험을 통해서 이미 알고 있으리라 생각됩니다'' -.
[[adsense]]
=== 전문가가 되는 법 ===
attachment:1153807845_how_to_be_an_expert.jpg
   1. 아놔 젠장 못해 먹겠네. 이건 내가 할 수 있는게 아냐.
   1. 오케이 해냈어. 이거 하나면 충분해. 
   1. 오케이 해냈어. 하지만 해내기 위한 더 좋은 방법이 있을거야. 이걸 찾아내기 위해서 노력할거야.

=== 기타 개발자와 관련된 문서들 ===

==== 프로그래머의 길을 선택해야 할지 고민이 되시나요 ? ====

지금까지의 글들은 이미 프로그래머로의 길을 가기로 마음먹은 분들 혹은 시작하려 하는 분들의 입장에서 작성되었습니다. 이제 그 이전 단계인 '''선택'''의 갈림길에서 고민하는 분들의 입장에서 글을 써보도록 하겠습니다.

  * '''하고자 하는 자신감만 있으면 된다? 아니다.'''
    선택은 고민되는 일 입니다. 이 선택이 잘한 것일까? 내 적성에 맞는 것일까? 괜찮은 미래가 보장될까? 등등등 이죠. 이러한 선택의 기로에 있는 분들에게 '''하고 싶으면 시작해라. 자신감 하나면 충분하다'''라고 말하는 경우를 종종 보게 됩니다. 

    하지만 '''당신도 노력하면 Bill Gates가 될 수 있습니다'''. Steve Jobs는 창고에서 시작해서 지금의 성공에 이르렀다. 이런 류의 조언은 도움이 되지 못합니다. 왜냐하면 이 세계는 나 혼자 잘한다고 되는 세계가 아니기 때문입니다. 비슷한 진로를 가고 있는 사람들과 경쟁해야 하며, 또 다른 영역의 사람들과 경쟁 해야 합니다. 

    놓인 의자는 하나인데, 앉으려고 하는 1000명의 사람들이 경쟁하는 열악한 조건을 생각해 보세요. '''당신도 열심히 하면 의자에 앉을 수 있습니다. Bill Gates를 보세요. 의자를 독차지하고 저 높은 곳에 군림하고 있지 않습니까.'''라는 조언이 타당한 조언이라고 생각되지는 않을 겁니다. 물론 여러분이 불굴의 정신과 투지, 체력, 판단력을 가지고 있다면 999명의 경쟁자를 물리치고 의자를 차지할 확률이 높아지긴 하겠지만. 여러분 모두가 슈퍼맨일 수는 없는 겁니다.

   자신감은 기본적으로 가지고 있어야 하는 거지 전부가 아닙니다. 사이클 선수가 되려면 자전거를 가지고 있어야겠죠. 그러나 자전거를 가지고 있다고 해서 사이클 선수가 되는건 아닙니다. 

  * '''그러므로 현실을 알아볼 필요가 있다'''
   이미 들어서 알고 있겠지만, 현실은 그리 밝지 않다. 일단 소프트웨어 개발회사가 없다. 생각나는 소프트웨어 회사가 혹은 제품이 있는가 ? 아마 5개 이상 생각해내기가 힘들 것이다. 여러가지 이유로 소프트웨어 회사는 전멸직전이고, 몇개 서비스회사들만 존재한다. 멋진 서비스만 만들어 내도 되는 것 아니냐라고 할 수 도 있겠지만. 제조업이 모든 사업의 기본이 되는 것처럼, 소프트웨어 패키지 제작업체가 이 분야의 기초가 된다. 

  소프트웨어 제작 업체가 없다는 것은 소프트웨어 산업기반이 그만큼 취약할 수 밖에 없다는 것을 의미하고, 기술인력의 수요가 그만큼 줄어든다는 얘기가 될 것이다. 그렇다고 너무 상심해할 필요는 없다고 생각된다. 내가 알기로 다른 분야 역시 소프트웨어 분야만큼 어렵다. 대충대충 할거면 이쪽을 선택하지 않는게 좋다. 응용범위가 넓은 인문학과는 달라서, 이 분야는 다른 분야로 눈을 돌리는게 그리 수월하지 않다. 

==== 프로그래밍 관련 ==== 
 * [wiki:Site/Development/Forum/manager 프로그래밍 관련 글들]

=== 관련 문서 프로젝트 ===
 * [wiki:Site/C/Documents/CprogramingForLinuxEnv 리눅스환경에서의 C프로그래밍]
 * [wiki:Site/Java/Documents/ComputerScienceUsingJava 자바로 하는 컴퓨터과학]
 * [wiki:Site/Assembly/Documents/Spim MIPS Assembly 언어]
 * [wiki:Site/Assembly/Documents/ProgrammingGroundUp/index.html Programming Ground Up]

==== 이런저런 잡다한글들 ====
 * [wiki:Site/Development/Forum/Fun 개발관련 재미있는 글들]
 * [wiki:Site/Development/Forum/etc 이런 저런 잡다한 글들]


=== 윤덕용교수님의 초보자 특별교실 ===
  [http://cpu.kongju.ac.kr/frame3.htm 윤교수님의 초보자 특별교실]
 * [http://cpu.kongju.ac.kr/ 윤교수의 마이크로프로세서 월드] : 추천 --Crystal

=== 빵집-양병규 ===
빵집 도움말 읽어보면...

=== KELP 임베디드 리눅스 개발 가이드 ===
[http://kelp.or.kr/korweblog/faq.php?id=4 임베디드 리눅스 개발 가이드]


=== 프로그래머의 뇌 구조 ===
 * [wiki:Site/Development/Forum/manager/Brain 프로그래머의 뇌 구조]


== 권장 문서들 ==
 
=== 권장 사이트 ===

=== 권장 도서 ===
열혈C프로그래밍
== 디렉토리 ==
[[subindex(Site/Beginner,1)]]



== 외부 링크 (참고 사이트) ==
=== C언어 기초 관련 외부 링크 ===
 * '''각 검색엔진도 충분히 이용해 보실것을 권해 드립니다.'''
 1. [http://tea815.com.ne.kr/c/ C 언어 강좌]
 1. [http://tc.pukyung.co.kr/index.htm 생각하는 C++] C 기초 강좌
 1. [http://winapi.co.kr/ Win32 Api 연구 사이트] 
 1. [http://cafe.daum.net/pway Daum 카페  프로그래머의 길]

== 하고픈 말들 ==
{{{#!comment
yundream 2007/01/17 12:42:36
코멘트 테스트 입니다.
}}}
{{{#!comment
후루룹 2007/01/17 19:32:26
플밍 비기너들에게 제가 객체지향 언어를 권하지 않구 c를 권하는 또 하나의 이유는 함수, 모듈화에 대한 개념조차 없을때에 객체지향을 이해하기란 매우 힘들기 때문입니다. 초보가 객체지향을 강요하는 언어(java라든지)로 시작하면 똥인지 된장인지 구분 못하는 사태가 벌어집니다 (지역변수로 가야될 게 멤버 변수로 간다든지, 함수로 가야될게 클래스로 나간다든지, has-a관계로 해야될게 is-a관계가 된다든지 static 멤버의 남발이라든지 등등 - 모두 내 경험입니다-_-) 내가 머리가 나빠서 이런 삽질을 했는지 모르겠지만 어쨌든 c처럼 문법자체가 간결한 언어로 프로그래밍의 제어 흐름, 구조적 프로그래밍에 대한 개념을 익힌 다음에 객체지향을 익히는게 쉽다 생각합니다
}}}
{{{#!comment
후루룹 2007/01/17 19:51:40
디펜스를 위해서 사족을 달자면은 자바를 싫어하거나 나쁜언어라 주장하거나 그러진 않습니다 플밍 시작은 c로 했지만 제대로 프로그래밍에 흥미를 가졌을때 그때에 마침 내 손에 있던 도구는 자바였습니다.(우연이었던것 같습니다) 그래서 사실상 시작을 함께한 언어라 정이 들었습니다. c++은 단일 프로젝트로는 가장 큰 규모의 프로젝트를 해 본 언어입니다. 그래서 미운정, 고운정이 들었습니다. c는 셋중에 가장 많은 코드를 짜본 언어입니다. 이 셋외에 나머지 언어들은 그리 많은 코드를 짜보진 않았습니다. 이러저러한 이유로 언어에 대한 편견은 없습니다 c, c++, java모두 사연이 있는 녀석들이니까요 셋다 별로 안 좋아 합니다 ㅋ
}}}
{{{#!comment
yundream 2007/01/17 20:04:41
개인적으로 제일 좋아하는 언어는 C++입니다. 요즘 자바로 프로젝트를 진행하고 있어서, C++과 알게 모르게 비교하게 되는데, 뭐 자바쪽은 아직 익숙하지 않아서 더욱 그런지 모르겠지만 C++이 그리워집니다. C의 단순함을 향유할 수 있다는게 아마도 가장 큰 이유가 되겠습니다. 

현재는 D언어에 관심이 쏠리고 있습니다. 언뜻 봤는데, 꽤 괜찮아 보이더군요. 누구 관심있는 분 없을려나. 공부해보면 잼있을거 같은데.
}}}
{{{#!comment
javaseki 2007/01/18 07:02:48
저도 후루룹님과 동일한 경험을 한적이 있어요..오래전에..:)
}}}
{{{#!comment
sioth 2007/01/20 01:50:22
추천서적에 c관련으로는
1. The C programming Language - 말이 필요없지요
2. C : Reference Manual - 표준 c나 표준 라이브러리 함수에 대해서 궁금할때 쓸데없이 웹을 헤멜 필요가 없죠
3. C traps and pitals - c를 하다가 하기 쉬운 삽질에 대한 이야기를 미리 해 주었지요
4. c 기초 플러스 - 아줌마 잔소리 같이 책이 말이 많으며 두껍기는 하지만 그래두 풍부한 내용을 원할땐 좋죠
위의 1,2,3번 책은 모두 번역서가 나와 있는데 2번 번역서는 번역이 괜찮습니다. 1,3번은 제가 번역이 어떤지를 확인을 사실 못해봤네요
4번은 음..개정판마다 번역자가 달라서 뭐라 말해야 될지 모르겠네요

c 관련 웹싸이트
1. http://www.cinsk.org/cfaqs/index-ko.html - c에 관한 faq를 번역한 웹 싸이트죠
2. http://www.cppreference.com/ - cpp뿐 아니라 c의 표준 라이브러리 함수의 프로토타입이나 간단한 사용법에 대한 설명등이 man page보다는 
친절(?)한 말투로 설명이 되어 있어요 간단하긴 하지만요

c로 프로그래밍 공부하는 사람들은 뭔가 궁금할때에 적어도 위의 책, 웹싸이트들을 찾아보구 그 다음에 naver나 google을 검색해보구 질문을 하면은 좋겠다는 바램이드는군요
}}}
{{{#!comment
sloth 2007/01/20 02:02:52
헉, 위의 Name의 스펠링이 틀렸군요 sloth인데 sioth로 썼군요-_-;; 술을 먹어서 그렇단 변명을 해 봅니다 역시 그냥 쓰던 한글 닉인 후루룹을 계속 쓰는게 더 나을까-_-;;
}}}
{{{#!comment
yundream 2007/01/20 13:19:36
sioth가 더 좋아 보입니다만..
}}}
{{{#!comment
Zaphod 2007/01/25 10:45:49
양병규씨? 빵집 진짜 좋던데요
빵집->도움말->빵집은... -> ㄲㄲㄲ
}}}
{{{#!comment
초보 2007/06/13 23:28:31
4.10 윤덕용교수님의 초보자 특별교실 
http://cpu.kongju.ac.kr/
}}}
