#title setrlimit
[wiki:man/2/setrlimit HTML 변환문서]

{{{#!plain
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<chapter lang=ko>
<!-- 작성자 : yundream             -->
<!-- 작성일 : 2004/04/16           -->
<!-- 연락처 : yundream@joinc.co.kr -->

<!-- 함수 이름을 입력합니다 -->
<title>getrlimit(2)</title>

<!-- 이건 함수에 대한 대략적인 설명이구요 -->
<para>
	자원(resource)의 값을 얻어오고, 값을 설정한다.
</para>
 
<!-- 여기에 함수의 간단한 사용법이 들어갑니다 -->
<section>
	<title>사용법</title>
	<para>
		<screen>
#include &lt;sys/types.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;unistd.h&gt;

int getrlimit(int resource, struct rlimit *rlim);
int getrusage(int who, struct rusage *usage);
int setrlimit(int resource, const struct rlimit *rlim);
		</screen>
	</para>
</section>

<!-- 여기엔 함수의 자세한 설명 이 들어갑니다 -->
<section>
	<title>설명</title>
	<para>
		getrlimit()와 setrlimit()는 자원의 제한값을 알아내거나 설정하기 
		위해서 사용한다. 이때 자원의 종류는 <emphasis>resource</emphasis>를 
		이용해서 지정가능하다. resource는 다음중 하나이다. 리소스의 크기는 
		<emphasis>rlim</emphasis>를 이용하면 된다. rlim구조체는 다음의 
		멤버들을 가진다.  
		<screen>
struct rlimit
{
    rlim_t rlim_cur;   /* soft limit */
    rlim_t rlim_max;   /* Hard limit */ 
};
		</screen>
		소프트 리미트(soft limit)는 변경하고자 하는 값을 커널에 
		요청한다. 하드 리미트(hard limit)는 자원의 설정가능한 최대 값으로 
		rlim_cur은 하드 리미트의 제한을 받게 된다.  
	</para>
	<para>
		다음은 선택가능한 resource의 종류들이다.
		<screen>
RLIMIT_CPU     /* 초 단위의 CPU 시간 */
RLIMIT_FSIZE   /* 최대 파일 크기 */
RLIMIT_DATA    /* 최대 데이타 크기 */
RLIMIT_STACK   /* 최대 스택 크기 */
RLIMIT_CORE    /* 최대 코어 파일 크기 */
RLIMIT_RSS     /* 최대 거주 집합 크기 */
RLIMIT_NPROC   /* 최대 프로세스 수 */
RLIMIT_NOFILE  /* 최대 열 수 있는 파일의 수 */
RLIMIT_MEMLOCK /* 최대 잠긴 기억 장소 주소 공간 */
RLIMIT_AS      /* 주소 공간(가상 메모리) 제한값 */
		</screen>
	</para>
	<para>
		getrusage()는 현재 사용중인 resource 정보를 되돌려준다. 
		<emphasis>who</emphasis>는 RUSAGE_SELF 와 RUSAGE_CHILDREN 둘 중 
		하나를 선택할 수 있다. 전자는 현재 프로세스가 사용하는 리소스의 정를보
		되돌려주고 후자는 현재 프로세스와 그 자식 프로세스들이 사용하는 
		모든 리소스의 정보를 되돌려준다(종료되어서 기다리는 자식 프로세스도 포함된다.)
		이들 리소스 정보는 <emphasis>rusage</emphasis>에 저장된다.
		<screen>
struct rusage {
    struct timeval ru_utime; /* user time used */
    struct timeval ru_stime; /* system time used */
    long   ru_maxrss;        /* maximum resident set size */
    long   ru_ixrss;         /* integral shared memory size */
    long   ru_idrss;         /* integral unshared data size */
    long   ru_isrss;         /* integral unshared stack size */
    long   ru_minflt;        /* page reclaims */
    long   ru_majflt;        /* page faults */
    long   ru_nswap;         /* swaps */
    long   ru_inblock;       /* block input operations */
    long   ru_oublock;       /* block output operations */
    long   ru_msgsnd;        /* messages sent */
    long   ru_msgrcv;        /* messages received */
    long   ru_nsignals;      /* signals received */
    long   ru_nvcsw;         /* voluntary context switches */
    long   ru_nivcsw;        /* involuntary context switches */
};
		</screen>
	</para>
</section>

<!-- 함수가 되돌려주는 값이구요 -->
<section>
	<title>반환값</title>
	<para>
		성공할경우 0을 실패했을경우에는 -1을 반환하며, 적당한 errno 값을 
		설정한다. 
	</para>
</section>

<!-- 에러가 발생했을때 되돌려주는 값들입니다 -->
<section>
	<title>에러</title>
	<para>
		<variablelist>	
			<varlistentry>
			<term>EFAULT</term>	
			<listitem>
				<para>	
					<emphasis>rlim</emphasis> 혹은 <emphasis>usage</emphasis>이 
					잘못된 주소를 가리키고 있다.
				</para>	
			</listitem>
			</varlistentry>

			<varlistentry>
			<term>EINVAL</term>
			<listitem>
				<para>
					getrlimit()나 setrlimit()에서 잘못된 <emphasis>resource</emphasis>나 
					<emphasis>who</emphasis>값을 사용했을 경우
				</para>
			</listitem>
			</varlistentry>

			<varlistentry>
			<term>EPERM</term>
			<listitem>
				<para>
					슈퍼유저가 아닌 사용자가 setrlimit()를 이용해서 현재 하드리미트 값을 
					초과해서 소프트 리미트 값이나 하드 리미트 값을 적용시킬려고 할경우 
				</para>
			</listitem>
			</varlistentry>
		</variablelist>	
	</para>
</section>
<section>
	<title>예제</title>
	<para>
		<screen>	
#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    struct rlimit rlim;

    // 생성가능한 프로세스의 갯수를 출력한다. (현재 : 최대) 
    getrlimit(RLIMIT_NPROC, &amp;rlim);
    printf("PROC MAX : %lu : %lu\n", rlim.rlim_cur, rlim.rlim_max);

    // 오픈가능한 파일의 갯수를 출력한다.   
    getrlimit(RLIMIT_NOFILE, &amp;rlim);
    printf("FILE MAX : %lu : %lu\n", rlim.rlim_cur, rlim.rlim_max);

    // 사용가능한 CPU자원을 출력한다. 
    getrlimit(RLIMIT_CPU, &amp;rlim);

    // 만약 무한대로 사용가능하다면 UNLIMIT를 출력하도록한다.
    // CPU자원은 최대한 사용가능하도록 되어있음으로 UNLIMIT를 출력할것이다.
    if(rlim.rlim_cur == RLIM_INFINITY)
    {
        printf("UNLIMIT\n");
    }
}
		</screen>	
	</para>
</section>
</chapter>
}}}
