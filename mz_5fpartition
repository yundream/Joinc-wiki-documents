#title 파티션의 이해
== 파티션의 이해 ==
 * 작성자
  조재혁 ([mailto:minzkn@minzkn.com])

 * 고친과정
  2003년 9월 22일 : 처음씀

=== 파티션(Partition)의 목적 ===
 * 첫째 : 하나의 물리적 디스크를 몇개의 영역으로 나누어 관리가 용이하도록 하는 것. 
 * 둘째 : 운영체제가 여러가지인 경우 그러한 각각의 고유 파일시스템을 단일 영역에 독립적으로 유지할수 있게 하기 위해서. 
 * 셋째 : 한 파티션이 손실되더라도 다른 파티션 영역은 손실로부터 보호할수 있는 확률을 높이기 위한 수단. 

=== 먼저 알아둘 필요가 있는 C/H/S, LBA mode란? ===
==== CHS모드 ====
 '''Cylinder(0~1023)''', '''Head(0~15)''', '''Sector(1~63)''' 이렇게 3가지 요소를 통한 주소매핑을 하여 '''최대 528MByte가 주소매핑 가능'''합니다.

 그러나 만약 BIOS가 LBA를 지원하게 되면 내부적으로 LBA로 바꾸어 헤드수를 늘려 ''가상적인 헤드수''를 갖게 될수 있는데 이를 이용하면 '''Head의 범위는 0~15가 아닌 0~255 의 범위를 주소매핑''' 가능하게 됩니다. 그렇게 되면 '''최대 주소매핑 가능한 공간은 8GByte'''가 됩니다. 바로 이 크기가 '''1024실린더 제약이라는 말이 나오는 근거'''가 됩니다. 그리고 BIOS를 통하지 않고 PIO/DMA를 통한 접근을 시도하면 추가적으로 '''Cylinder는 0~65535의 범위'''를 가질수 있고 반면에 '''Head는 0~15의 범위'''가 되며 '''Sector는 0~255'''의 범위를 가질수 있도록 되어 있습니다. 이는 '''2의 28승'''을 뜻하며 '''가능한 주소매핑 영역은 총 128GByte'''가 되는 비약적인 발전을 가질수 있습니다. 그리고 이는 한 블럭에 512바이트라는 것을 가정한 계산 이며 블럭당 크기가 커질수록 그 용량은 늘어납니다. 

=== LBA모드 ===
 '''0 ~ 268435456(2의 28승)Blocks의 범위'''를 갖는 선형 주소방식으로 물리적 위치 주소를 나타내는 방식입니다. 그리고 1개의 Block은 통상 '''512/1024/2048/4096Bytes''' 로 구성되며 보통 대부분의 HDD는 512로 구성됩니다. 그러므로 계산해보면 '''약 128GByte가 최대 주소매핑공간'''이 되는 방식입니다. 점차 HDD의 용량이 증가함에 따라서 충분할줄 알았던 LBA 주소에 사용되는 bit 가 모자르게 됨에 따라서 '''최근(2008년 4월 16일 현재 기준) 에는 이것을 좀더 늘려 48bit address 지정할수 있도록 확장'''되었습니다.

=== 파티션은 어디에 위치한 것일까? ===
 파티션은 '''주 파티션'''과 '''확장 파티션'''으로 나뉘어 지는데 주 파티션의 경우는 LBA방식으로 나타낸다면 0번 섹터이며 '''CHS방식으로 나타낸다면 0/0/1''' 에 위치한것이 됩니다. 즉, 물리적으로 가장 처음부분이 주 파티션이 위치하는 곳이며 이곳을 '''Master Boot Record(MBR)'''이라고도 불리워집니다. 도스에서 "'''fdisk /MBR'''"명령은 이곳을 초기화 하는 명령이 되는 것이고요. 또한 이곳에는 파티션정보만 있는것이 아니고 PC가 부팅되면 이곳에서 부팅코드를 읽어와서 부팅하게 됩니다. 즉, 만약 이곳이 읽어질수 없는 상태(파괴?)가 된다면 하드디스크는 무용지물이 되버리는 중요한 영역이 되는 것입니다. 

=== MBR의 구조 ===
 MBR은 1개의 Sector로 보통 구성되어지는데 이 크기는 통상 512바이트입니다. 그리고 이 512바이트중에서 '''처음 446바이트는 운영체제를 읽어들이기 위한 준비단계 코드'''가 들어 있으며 나머지 '''64바이트가 파티션에 대한 정보를 담아두는 테이블'''입니다. 그리고 '''마지막 2바이트는 MBR이 맞는지 확인하기 위한 예약값'''으로 기록되어 있습니다. 즉, '''446 + 64 + 2 의 구조'''를 가지고 있습니다. '''파티션 1개를 명시하는데는 16바이트의 영역이 소요'''되는데 64바이트뿐이 없으니까 64 / 16 = 4 개의 파티션이 나뉘어 질수 있는 계산이 나옵니다. 여기서 의문을 가지시는 분이 계실텐데 "나는 파티션 5개 나눠서 쓰는데?" 라고 생각하시는 분이 계실겁니다. 맞습니다. 5개건 100개건 용량 남는데로 파티션을 나누는 것이 가능하지만 이것은 주파티션에서 나뉘어진 부파티션에서 그러한 파티션의 증설이 됩니다. 어디까지는 주파티션이건 부파티션이건 하나의 섹터에 4개의 파티션만이 기록되는것을 반드시 알고 계셔야 합니다. 부 파티션은 이 4개의 파티션중에 1개의 파티션에 부파티션의 위치를 명시하여 확장되는 개념이라고 보시면 이해가 되실겁니다. 즉, 다음과 같은 모양새가 될수 있습니다.
 {{{
#1 Linux 
#2 Windows 98 
#3 DataBackup 
#4 Extension --->>>> #1 WindowsXP 
                     #2 No used 
                     #3 Extension ->>> ... 
                     #4 No used 
}}}
 이런식으로 파티션의 확장개념이 적용됩니다. 

=== 파티션정보 테이블 ===
 위에서 16바이트당 1개의 파티션을 명시할수 있다고 설명하였습니다. 그러면 16바이트에는 어떤것이 기술될까요? 다음과 같습니다. 
 || '''OFFSET''' || '''값''' || '''내용''' ||
 ||<|3> 00H || ||byte boot indicator ||
 || 00H ||non-bootable partition ||
 || 80H ||bootable partition (one partition only but minzkn is first 80H) ||
 || 01H || ||byte beginning sector head number ||
 || 02H || ||byte beginning sector (2 high bits of cylinder) ||
 || 03H || ||byte beginning cylinder (low order bits of cylinder) ||
 ||<|9> 04H || ||byte system indicator ||
 || 00H ||unknown operating system (Empty partition) ||
 || 01H ||FAT12 ||
 || 02H ||XENIX ||
 || 04H ||FAT16 ||
 || 05H ||Extended partition (DOS) ||
 || 06H ||FAT16 (32bit sector number) ||
 || 0BH ||FAT32 ||
 || 0CH ||FAT32 (64bit sector number) ||
 || 05H || ||byte ending sector head number ||
 ||<|2> 06H || ||byte ending sector (2 high bits of cylinder) ||
 || ||1st byte (sector) Sector offset within cylinder High order bits of cylinder ||
 ||<|2> 07H || ||byte ending cylinder (low order bits of cylinder) ||
 || ||2nd byte (cylinder) Low order bits of cylinder ||
 || 08H || ||dword number of sectors preceding the partition ||
 || 0BH || ||dword number of sectors in the partition ||

 이러한 정보를 통해서 운영체제위치를 찾아 부팅하게 됩니다. 여기서 '''맨처음 "boot indicator"이 부분이 80h 인가 그냥 0인가에 따라서 부팅가능한 파티션인가를 결정'''짓게 됩니다. '''fdisk에서 보면 Active와 같은 개념'''이겠죠. 아무리 운영체제가 설치되어 있더라도 이 부분이 80h가 아니라면 부팅을 시도하지 않습니다. 보통 부트매니저는 이를 이용한 방식을 사용하는 경우가 많습니다. 여기서 또 문제가 되는것이 1024실린더를 넘는 영역을 어떻게 부팅할것인가라는 논재의 시점이 발생하는데 이 부분에 대한 설명은 너무 세부적인 부분이라서 접도록 하겠습니다. 

=== 그렇다면 fdisk같은 툴 없이도 파티션 나눠볼수 있을까? ===
 당연히 가능합니다. Sector Editor같은 것이 있다면 직접 보다 세부적인 내용을 제어할수 있게 됩니다. 예를 들면 파티션 겹치기, 데이터 저장후 파티션 감추기, 바이러스에 의한 MBR 손상시 복구 등의 작업이 가능합니다. 통상 쓰레기값으로 MBR이 파괴된경우 fdisk는 제대로 읽지 못하고 다운되는 현상이 있는 경우가 있는데 이때 또한 직접 수정하여 이를 고칠수 있습니다. 단, 이러한 것이 가능하려면 사용자가 이 구조를 알고 계셔야 겠죠. 

=== 파티션 분할의 문제점 ===
 * 속도개선을 위해서 Cylinder/Head/Sector의 순서를 바꾸어 운영체제를 개발하면 다른 파일시스템과 충돌하여 데이터 유실이 되므로 바꿀수 없다.(단, Sector건너뛰는 방식은 존재함) 
 * 보다 큰 용량이 개발됨에 따라서 조만간 다른 구조가 필요. (이미 일부 운영체제 개발사들은 다른 섹터에 추가분을 두어 해결한 경우도 있음.) 
 * 새로운 저장매체에 대해서 이방식을 계속 유지할 경우 복잡성이 있는 매체에서는 446바이트의 코드로는 부팅이 어렵다. 또는 에러를 감지할수 없거나... 
