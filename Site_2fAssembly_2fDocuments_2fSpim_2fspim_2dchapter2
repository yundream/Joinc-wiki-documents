#title 아날로그와 바이너리 신호

== CHAPTER 2 &#8212; 아날로그와 바이너리 신호  Analog and Binary Signals  ==
[[TableOfContents]]

===  아날로그와 바이너리 신호  Analog and Binary Signals ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_1.html
[[Image(wwatch.gif,0,0,right,)]]
여러분도 알다시피 컴퓨터는 디지털 기계이며, 2진수를 이용해서 필요한 계산을 한다. 아마 중학교 교과 과정에서 배웠을 것이다. 그런 이유로 디지털과 이진수가 무엇을 의미하는지 어느 정도는 이해 하고 있으리라 생각된다. 하지만 어셈블리 프로그래밍을 하기 위해선 이러한 의미들에 대해서 좀더 명확히 하고 넘어갈 필요가 있다. 이번 장에서는 다음과 같은 주제들을 다루게 될 것이다.

이장의 논제들:

    * 이진수의 신호 Binary signals.
    * 아날로그 신호 Analog signals.
    * 이진수의 장점들Advantages of Binary.
    * 비트 Bits.
    * 노이즈 신호들 Noisy signals.

컴퓨터에 진짜로 어떠한 일이 일어나는지 알고 싶다면 이러한 주제를 주의깊게 공부를 해야 한다.


질문: 태엽과 기어로 작동되는 아날로그 시계와 달리, 전기의 힘만으로 작동되는 시계를 디지털(전자) 손목시계라고 부른다. 왜 디지털이라는 수식어가 붙는가 ?


프겔러들의 수다
{{{#!textbox
안방거사  	Traditional watches have hands but digital watches have digits to tell the time. 뭐 그렇단 이야기요.
}}}


=== 바이너리(이진수적인) Binary  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_2.html

답: 아날로그 시계는 시계바늘의 위치를 측정(measure)해야만 시간을 알 수 있다. 디지털 시계는 명확한(definite) 숫자를 사용해서 시간을 보여준다.

이진수 혹은 바이너리(Binary)는 2가지의 상태가 있다는 것을 의미한다. 두가지 상태는 "1" 과 "0" 의 상태일 수 도 있고 "참" 과 "거짓" 의 상태일 수 도 있고 "켜진것" 과 "꺼진것"의 상태일 수 도 있다. 하나의 바이너리(이진수)가 2 가지 가능한 상태 중에 하나의 상태를 나타낸다는 것이 이진수적인 특징이다. 

하나의 비트(bit)은 "꺼짐/켜짐" 둘중에서 하나 의 값을 갖는다. 불을 껏다 켰다 하는 스위치가 좋은 예이다. 스위치로는 "켜거나" 또는 "끄거나"만 할 수 있다. 중간쯤 켰다와 같은 다른 작동이란 있을 수 없다. 하나의 비트(bit) 정보는 스위치로 불을 껏다 켯다 하는 일 같은 것을 담을 수 있다.

이와 달리 불빛 조절계(light dimmer)는 바이너리 장치가 아니다. "꺼짐"과 "완전히 켜짐"사이에 무수한 상태가 가능하다. 만일 여러분이 불의 밝기를 25% 정확히 맞추고자 한다면, 여러분은 힘을 들여가며 주의깊게 불빛 조절계를 조정해야만 할 것이다. 우리는 이러한 여러가지 기계적 상태가 존재하는 장치를 아날로그장치 라고 한다.


질문:
다음 중에 어떤것이 바이너리 장치일까요?

    * 자동차 점화 스위치
    * 시계의 시침
    * 전자계산기의 입력버튼
    * 스테레오에서 둥그런 볼륨 조정장치.
 

프겔러들의 수다
{{{#!textbox
 안방거사  개념적으론 점화 스위치가 더 가까울 것 같소. On and Off 가 명확히 있으니 말이요. 전자계산기의 단추는 글쎄요. 전자 계산기 나름일 것 같소. 옛날엔 아날로그 형도 있었던 것 같소.  
 }}}
{{{#!textbox
 자바하는넘  좀 코에 걸면 코걸이 귀에걸면 귀걸이 측면이있죠. 아예 점화 스위치를 빼버릴까 생각도 듭니다.
}}}
{{{#!textbox
 푼내기  답 두 개지 말입니다. 점화 스위치는 눌러질 때 익니션이고 누르는 중에 익니션 준비라던가 반만 익니션이라는 상태가 없으니 점화 스위치도 바이너리 장치 
}}}
{{{#!textbox
yundream  	불을 침침하게 하는 디머라는 장치라기 보다는 그냥 온도조절장치 정도로 의역하는게 훨 와 닿을거 같어. 디머?라고 하면 좀 그렇잖아.
}}}
{{{#!textbox
자바하는넘  	아무래도 그렇지 거 단어 생각나는것도 없고. 껄끄러웠는데
}}}
{{{#!textbox
자바하는넘  	그런데 이 사람이 불빛 조정기(dimmer)의 예를 너무 많이들고 있네....난 구글해 보니까 걍디머는 디머라고 써서 썼는데... 불빛조정기로 그냥 갑시다. 전기 스위치와 대조도 되고 문맥상.
}}}
{{{#!textbox
푼내기 	우리나라 같이 형광등을 많이 쓰는 나라에서는 디머를 거의 쓰지도 않고 쓸 수도 없는데 미국은 형광등보다 백열등이 훨씬 많아서 침실이고 거실이고 할 꺼 없이 온/오프 스위치 옆에 디머가 있거나 스탠드 라이트에 부착
}}}

===  왜 컴퓨터는 이진수를 사용하나 Why Computers use Binary ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_3.html
[[Image(shannonSmall.jpg,0,0,right,)]]

답:
자동차의 점화스위치 => 아니다. 
시계의 시침 => 아니다.
계산기의 버튼 => 그렇다
스테레오의 볼륨 콘트롤 => 아니다.  

자동차의 점화 스위치는 개별적(discrete) 이다 - 점화 스위치는 명백하게 정의된 상태들을 가지고 있다 - 그렇지만 2가지 이상의 상태를 가지고 있다 (꺼진상태,달리는 상태,시작상태, 가속상태....).
계산기의 단추는 이진수적인 장치이다.  계산기의 단추는 누르거나 또는 안누르거나 두가지의 상태만 있다. 보통은 안누른 상태이다. 여러분이 버튼을 눌렀을때, 그것은 "누른상태"가 된다.
여러분이 손을 땔때 버튼은 "안누른 상태"로 돌아온다. 그런점에 있어서 전구를 껏다 켰다 하는 스위치와같이 이진수적인(binary) 장치 이다. 이진수를 사용하는데에는 많은 장점들이 있다. 

여기에 이진수를 사용하는 4가지 이유를 나열해 본다.(서로 중첩될 수 도 있다.) 
   1.  간단하다. 만들기 쉽다.
   1.  신호가 명확하다. 그렇기 때문에 잡음(noise)을 최소화할 수 있다. 
   1.  완벽한 복제물을 만들 수 있다. 
   1.  형태를 가진 모든 것을 "비트(bit)의 형태"로 표현할 수 있다. 

벨 전화 연구소의 수학자였던 클라우드 셰논(Claude Shannon)은 1948년 논문 "통신에서의 수학적인 이론(A Mathematical Theory of Communication)"에서 이러한 이진수적인 특징을 명확히 했다.  이 논문은 정보이론과 컴퓨터 과학의 기초에 많은 영향을 주었다. 

질문:
어떤 것이 제조 하기 쉬울까요?

 * "껏다"/"켰다" 스위치
 * 불빛 조절계(ligth dimmer)

프겔러들의 수다
{{{#!textbox
 안방거사  	뭐 원시적인 스위치를 생각하면 on/off이겠지요. binary의 효율성은 좀 의심이 가오. 현재의 기술수준으로 보면 그렇겠지만 당장 생물의 gene을 보면 4가지 정보로 되어있소. 
}}}
{{{#!textbox
자바하는넘 	gene 을 복사하는걸 영어로 transcription이라고 하나요 프로테인을 만드는걸 translation이라고 하죠. 서양ㅤㅎㅛㅇ들 용어사용하는것 봐도 재미있는것 같에요. 컴한다는게 어케보면 프렉탈적인게 있는것 같에요... 로고스에대한 인간의 욕망표출 같기도 하고...
}}}
{{{#!textbox
sparrow 	어려운말 쓰지 맙시다....ㅡ,.ㅡ;;
}}}
{{{#!textbox
자바하는넘 	미안 좀 있어보이려고 주름잡았는데. 원래 아는거 별로 없는사람이 어려운말써요. 있어보이려고.
}}}
{{{#!textbox
안방거사 	3 state 혹은 4 state를 사용하면 더 재미있는 정보를 함축하오. 옛날에 러시아인이 쓴 논문을 한번 본적 있는데 내용은 이미 가물가물하오. 4 state system으로 보면 Octal number는 1bit 가 1 digit이 될 것 같은데 말이요. 그리고 이동네에서 좀 있어보이려면 NP Hard, NP complete 뭐 그런 것이 좋지 않겠소 ^^ 
}}}
{{{#!textbox
자바하는넘 	제가 원래 문과 출신 입니다. 그쪽으론 구라를 잘 못치죠.
}}}
{{{#!textbox
푼내기 	아우 P, NP 나오면 머리아파지지 말입니다.
}}}
{{{#!textbox
안방거사 	미 국쪽도 IS쪽은 문과 출신들 꽤 되오. 내 개인적으론 NP Complete 문제들중 일반 문제에서 NP Complete 문제 (3 set problem)로 reduce하던 것이 젤로 힘들었던 것 같소. 뭐 Program correctness proof도 만만치 않았지만 말이요. 그놈의 튜링머신이나 URM써서 밤새 숙제하던 아련한 기억이 있으오.. 허허
}}}



===  바이너리의 장점 1 단순하다 그래서 쉽게 만들수 있다 Advantages of Binary 1 : Simple; easy to build  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_4.html
[[Image(OnSwitch.gif,0,0,right,)]]
답 : 켯다/껏다 하는 스위치

켯다/껏다 하는 스위치는 단순하며 만들기 쉽다.
켯다/껏다 하는 스위치는 2개의 금속체를 붙게하거나 떨어지게 한 것이다.
불빛 조절계(light dimmer) 천천히 부드럽게 빛이 도달하도록 전류를 조절 해야만 한다.
불빛 조절계는 껏다/켰다 하는 스위치 보다 더 많은 부품이 필요하고 조심스럽게 조립해야 한다.
25%가 정확히 25%를 의미하는 아주 정밀한 불빛 조절계를 만드는 것은 정말 어렵다.

실리콘 칩안에 있는 작은 장치들의 경우에도 똑같은 사실이 적용 된다. 
켰다/껏다 하는 스위치들은 비교적 제조하기 쉽다. 실리콘 칩에서 "쉽게 만들 수 있다"는 것은 싸고,작고, 믿을만한 수십만 개의 켯다/껏다 장치를 작은 공간에 채워넣을 수 있다는 것을 의미한다.

질문:
책을 만드는 다음 방법들중에 어떤 방법이 가장 쉽고 단순할까요?

 * 점토에 그려넣어 책을 한 권씩 만든다. 
 * 종이에 펜과 잉크로 한자 한자 직접써서 한 권씩 만든다.
 * 평평한 나무에 글자를 새겨낸후 책을 찍어 낸다.
 * 활자를 만들어 책을 찍어 낸다. 


프겔러들의 수다
{{{#!textbox
안방거사  	질문뒤의 의도는 뭘까? 뭔가 말할려고 도입하는 것 같은데.
}}}
{{{#!textbox
제4의눈 	분명한건 어셈블리로 윈도 어플리케이션을 만드는건 바이너리 에디터로 모나리자 그림의 JPG파일을 만드는 거나 비슷하다는것.
}}}
{{{#!textbox
푼내기 	종이에 쓰는게 젤 쉽고 단순한건데 답은 그게 아니네 -.-;;;
}}}
{{{#!textbox
책 몇권을 	만드느냐에 따라 틀리지.
}}}
{{{#!textbox
푼내기 	문제가 답을 유도해내는게 아니고 답이 문제를 유도해낸다 -.-;;; 이 교수 왜 이러는거지? 모호한 문제 내서 학생들 낚는게 취민가? -.-;;
}}}

===  바이너리의 장점 2. 신호가 명확하다. Advantages of Binary 2:Unambiguous Signals  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_5.html
답: 활자로 만드는 것
[[Image(jikji.jpg,0,0,right,)]]
나무 한토막을 깍아서 책 한페이지를 만들어 내는 대에는 굉장히 고급의 기술과 예술적인 기교가 필요하다.
그런 일은 복잡하고 노력이 많이 들어간다. 작은 실수가 전체 책을 다 망칠 수도 있기 때문이다.
르네상스시대의 나무깍는 기술자들이 아마 나무깍는 기술자들 중에서는 최고의 기술을 가졌었던 사람들 이었을 것이다.

활자를 맞추는 일은 그에 비하면 쉬운 일이다.
예술적이거나 기능적인 기술이 조금만 있으면 누구나 할 수 있다.
각각의 활자를 맞추어 책을 만드는 방법은 실수가 적고 믿을만 하다.
혹 실수가 있더라도 쉽게 고칠 수 있으며 활자를 여러번이라도 다시 사용할 수 있다.

기술의 진보가 종종 단순한 방법으로 향한다는 것은 역설적인 사실이다.
나무깍기는 복잡한 일이다 그렇지만 활자를 맞추는것은 쉬운일이다.
컴퓨터의 혁명(1950)은 구텐베르그(Gutenberg 1450)의 활자 혁명과도 비교 할 수 있다.

바이너리의 장점을 복습해 봅시다.

1. 단순하다. 그래서 만들기 쉽다.
2. 신호가 명확하다 (그래서 노이즈에 저항력이강하다)
3. 완벽한 복사가 가능하다.
4. 패턴으로 표현될 수 있는 모든것이 bits 패턴으로 표현 될 수 있다.

질문: 어떤일 이 더 쉽겠습니까?

    * 불의 밝기를 정확히 알아내는 일
    * 불이 꺼졌는지 켜졌는지 알아내는 일

프겔러들의 수다
{{{#!textbox
자바하는넘 [한줄 요약:팔만대장경과 직지심경(1372) 생각하시면됨]
}}}
{{{#!textbox
안방거사 	목판파기는 칼 하나만 있으면 되는데 활자는 한자 한자 다 만들어 놔야지요. 그래야 그 다음이 쉽죠.
}}}
{{{#!textbox
자바하는넘 	나름대로 연금술도 발달해야 하고 뭔가가 있어야 되겠죠. 
}}}
{{{#!textbox
here4you 	연금술은 일단 약초 채접과 함께...(죄송 =.=)
}}}


=== 올드 노스 빗 Old North Bit ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_6.html
[[Image(oldnorth01.gif,0,0,right,)]]
답:불이 꺼졌는지 켜졌는지 알아내는 일

신호가 분명해야 된다는 것을 염두해두고 다음의 이야기를 생각해보자. 폴 리비에(미국의 독립운동가)는 영국군을 공격하고자 공격 준비를 하고 첩보를 기다리고 있었다. 
첩보는 영국군이 어떻게 공격해 올지를 가리켜주는 것이었다. 미리한 약속에 따라 북쪽 교회의 탑에서 전등 불빛으로 신호가 오기를 기다리고 있었다.
그런데 불빛신호가 만약 1.32456 만큼 밝으면 육로로 공격할거라하고 1.71922 만큼 밝으면 바다로 공격할거라 했다고 상상해보자.

교회에서 불빛 신호가 보이기 시작한다! 만약에 폴 리비에가 그 때 불빛신호 밝기가 얼마나 밝았는지 알아내려고 끙끙대었다면 폴 리비에의 유명한 공격은  몇 시간씩 지체되었을 것이다.
신호가 분명하다는 것은 엄청난 장점이다.
  

1775년 그 밤에 폴 리비에가 기다리고 있던 신호는 불빛이 하나면 육로로 공격이고 불빛이 둘이면 해로로 공격이라는 뜻이었다.

 
누구든 쉽게 해석할 수 있는 신호이다. 숫자만 세면된다. 그러한 신호들을 우리는 이산적(discrete) 신호라고 부른다. 왜냐하면 이산적(discrete) 신호들은 고정된 숫자로 정의된 상태들을 가지고 있기 때문이다.
때때로 디지털이라는 단어도 같은 문맥에서 사용된다. 


질문: 왜 주판을 일종의 "디지털 컴퓨터"로 간주할 수 있을까요?

프겔러들의 수다
{{{#!textbox
 안방거사  	주판알을 digit으로 보고 1 column을 1개 code로 보아서 column을 모으면 number가 된다나 뭐라나...
}}}

=== 아날로그 신호 An Analog Signal ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_7.html

답: 주판에서 계산은 주판알을 일정하게 정의된 위치로 옴기는 것이다. 주판알을 셈에 쓰일때는 숫자의 일부분으로 간주되는 위치에 놓고 그렇지 않을때는 숫자로 간주되지 않는 위치에 놓는다. 주판은 이와같이 신호가 분명한 이산적인 장치이다.


아날로그 신호에서는 측정값들이 지속적으로 변화할 수 있다. 측정값은 일정한 영역내에서 불특정한 어떤 값일 수 있다 . 또한 아날로그 신호를 측정할 때 특정한 순간에 정확한 값을 측정하는 것은 대단히 중요하다.
아래 그림은 아날로그 신호를 표현하고 있다. 그림은 특정 순간에 측정된 정확한 값들에 대한 정보를 담고 있다. 우리는 "T2"라는 순간에 어떤 값을 가지는지 정확히 알 수 있다.

attachment:Figure2-1.gif


자 이제 여러분이 전선의 전압을 관 찰한다고 생각해 보라. 그리고 경계점을 정하고 경계점보다 낮은 전압일 때는 "off"로 간주하고 경계점보다 높은 전압일 때는 "on"으로 간주했다고 생각해보자.

질문:

"T2"에서의 신호는 "on" 신호 입니까 "off" 신호 입니까?

=== 바이너리 신호 Binary Signal  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_8.html

답:
아날로그 신호가 전압에따라 변하긴 변하지만 T2 지점에선 정밀한 측정 없이도 경계점(threshold) 위에 있다는 것이 명백하다.

아날로그 신호의 측정값은 끊어짐 없이 변한다. 경계점(threshold)을 이용하여  아날로그 신호를 "켯다/껏다" 같은 바이너리 정보로 표현할 수 있다. 경계점을 정해 전압의 위와 아래를 정하는 방법은 사람 뿐만 아니라 전기기기(electronic device)에게도 편하고 빠른 방법이다.
아래 그림은 꺼짐(off) 이후에 켜짐(on)을 전송하는 신호다.
T1과 T2에서 신호를 측정했다.

attachment:Figure2-2.gif

질문 8:
신호가 T1에서 꺼짐(off)이고 T2에서 켜짐(on)이라는 것이 명확합니까?

프겔러들의 수다
{{{#!textbox
 yundream  	보통 threshold를 임계영역/임계값/임계치 등으로 번역하잖아. 임계치를 넘으면 오류.. 넘지 않으면 정상 뭐 이런식으로 
}}}
{{{#!textbox
자바하는넘 	걍 경계값 경계치 경계영역하면 안될까?
}}}
{{{#!textbox
yundream 	경계값으로 해도 되겠네.. ㅎㅎ 내가 원자력 출신이라서.. 임계치란 단어에 익숙하다 보니... ㅎㅎ 
}}}
{{{#!textbox
졸려. 	threshold는 그냥 역치라고 번역하는게 좋지않을까? 경계값이라고 해도 무리는 없지만 schmitt trigger같은 개념이 도입되면 threshold가 2개가 되기도 하니까 좀 부족하지.
}}}
{{{#!textbox
자바하는넘 	역치도 감이 좀 안오네... 이게 좀 입문글인데... 내가 뭐 한자래도 보고 그게 팍감이오면 쓰겠는데... 내가 쓸줄모르고 이해못하는 한자 쓰기가 그렇네용 참... 
네이버 단어장에 이걸로 나오는데 역치(値)[명사] 생물의 감각에 반응을 일으키게 하는 최소한의 자극의 강도(强度).
}}}

=== 불완전한 전송 Imperfect Transmission  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_9.html
[[Image(vacuum.gif,0,0,right,)]]
답 : 명확합니다.

위에 장에서 신호를 경계영역(threshold)을 두게해서 "켜진상태(ons)"와 "꺼진상태(offs)"로 구분하는 것을 명확히 파악할 수 있었다. 경계치를 넘으면 켜짐 넘지 못하면 꺼짐으로 하면 되기 때문이었다.  
만일 신호를 긴 전선을 통해 전송시키면서 그 전선 근처에서 어떤 사람이 진공청소기를 켜고 청소를 한다고 가정해 보자. 아래 그래프는 신호를 전송받은 쪽에서의 신호를 보여준다.

비록 신호가  아날로그 수준으로 잡음(noise)이 많더라도,  바이너리 값은 완벽히 전송 된다.
전기기기적인 측면에서나 또는 여러분이 직접 보아도 T1 에서의 신호는 꺼짐(off)을 말하고 T2 에서의 신호는 켜짐(on)인것이 분명하다. 신호를 받는 쪽에선 이진수의 값만 받으면 된다.

attachment:Figure2-3.gif

오직 켜짐(on)이냐 꺼짐(off)이냐 라는 정보만 의미가 있기 때문에, 아날로그 신호의 노이즈는 무시할 수 있다. 이진수 값으로 규정된 원래 의도한 신호는 정확히 전달 된다.

질문:
만일 신호가 아날로그 신호라고 가정하고 그리고 정확한 측정값이 중요한 것이라고 가정해 봅시다. 만약에  이렇게 잡음이 많다면 아날로그 신호에선 중요한 정보가 손상 되겠습니까?

=== 바이너리의 장점 3. 완벽한 복사물을 만들 수 있다. Advantages of Binary 3:  Flawless copies can be made.  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_10.html
답: 손상된다. 신호가 가수의 목소리를 재현하는 신호라고 가정해보자.  신호가 잡음이 많을 경우에 가수의 노래는 당연히 잡음이 많게 들릴것이다. 신호 복사과정에서 잡음으로 인해 목소리가 담고 있는 정보를 잃은 것이다.
 
바이너리의 장점을 복습해 보자.

1. 단순하다. 그래서 만들기 쉽다.
2. 신호가 명확하다 (그래서 잡음에 저항력이 강하다)
3. 완벽한 복사가 가능하다.
4. 형태가 있는 모든 것은 비트의 형태로 표현 될 수 있다.

완벽한 복사가 가능하다.  신호를 받는 쪽은 0이냐 1이냐 같은 바이너리 값에만 관심이 있다. 신호가 기준점 위냐 밑이냐만 확인하면 된다. 잡음이 대단히 심하지 않다면 바이너리 값은 완벽하게 전달 될 수 있다.
예를들어, 아래 그림은 "on"/"off" 값을 잡음이 많은 신호속에서도 완벽히 재현한 그림이다.

attachment:Figure2-4.gif

그림과 같이 원래의 신호가 잡음속에서도 완벽히 회복될 수 있다. 또한 이러한 과정을 매번 완벽한 복사물이 필요할 때마다 몇번씩 반복할 수 있다.  컴퓨터 시스템에서 1과 0의 또는 on과 off같은 비트 형태들이 일초에 수백만번씩 프로세서와 메모리속에서 이리저리로 복사하는 과정을 거치는데 이런 과정속에서 연산이 정확하게 이루어지기 위해선 복사물이 완벽해야 된다는 점은 필수적인 요소이다.

질문:
뭔가 이상하지 않습니까. 시간 "x" 지점에서 신호가 켜짐(on) 일까요 꺼짐(off) 일까요? 쉽게 말할 수 가 없습니다. 또한 그 "x" 지점에서 잡음이 크다면 답이 틀려지기 쉽습니다.
이런 문제는 디지털에서 어떻게 해결할까요? (힌트: 모든 지점에서의 신호값을 다알고 있어야만 할까요?)



=== 클럭  Clocks ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_11.html

답: 컴퓨터 시스템은 전체 신호 값을 다 테스트 하는것이 아니고 특정한 순간에 신호 값을 측정 하도록 고안 되었습니다. 신호가 바뀌는 일도 이런 측정값들 사이에서 일어 나도록 고안 되었다.

디지털 시스템에서 "on"과 "off" 같은 이진수(binary) 값은 어떤 지정된 순간에만 측청된다. 그렇게 함으로써 측정시간 사이에 여유를 줄수있고 트랜지스터나 전선에서 이진수 값이 변화할 기회를 준다.
이것이 왜 컴퓨터 시스템이 "클럭(clock)"을 가지고 있는 이유이다. 클럭에 따라 모든 측정 시간들이 맞추어 질 수 있다. 클럭 수가 더 크다는말 또는 클럭이 더 빠르다는 말은 초당 더 많은 측정을 할 수 있다는 말이다. 
그렇게 더 많은 측정이 가능하기 때문에 전체 시스템이 더 빠르다.

우리는 종종 컴퓨터를 프로세서와 칩의 클럭 속도로 묘사한다.  클럭 속도는 Hertz(헤르츠)단위로 측정 된다. 1 Hertz는 초당 1 클럭 사이클을 말한다.  MHz(메가 헤르츠)는 초당 백만 번의 클럭 사이클을 말한다.
700 MHZ 펜티움 프로세서는 바이너리 값을 초당 7억 번 측정한다. 그런 측정 시간들 사이에 바이너리 값이 바뀌거나 정해질 수 있다. 
프로세서의 칩이 빠르면 빠를 수록 초당 더 여러번 값들이 0 또는 1인지 측정 될 수 있고 초당 더 많은 값들이 정해질 수 있다.

질문:
400 MHZ 펜팁 프로세서와 800MHZ 프로세서 둘 중에 어떤 것이 더 빠르겠습니까?

=== 바이너리의 장점 4. 어떤것도 다 표현할 수 있다. Advantages of Binary Representation 4 : Representing Anything ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_12.html

답: 800 MHZ 프로세서가 두배로 더 빠르다.  초당 8억만번의 값을 측정할 수 있다. 그렇지만 이것은 프로세서의 종류가 같을 경우에만 해당한다. 프로세서의 종류가 다를 때는 클럭 속도 이외에 다른 요소를 고려 해야한다. 

바이너리의 장점을 기억해보세요:

    *패턴 또는 형태로 표현될 수 있는 어떤 것이든 0과 1을 사용해서 0과 1의 형태로 재현할 수 있다.

온갖 종류의 데이터가 똑같은 전기적 방법을 이용해 컴퓨터의 주메모리나 보조메모리 같은 메모리에 저장 된다.  그렇게 메모리에 저장 될 수 있다는 것은 컴퓨터가 온갖 종류의 데이터나 프로그램을 무수히 완벽하게 복사 할 수 있다는 것을 의미한다. 
 
추상적 상징으로 표현될 수 있는 어떤 시스템도 0과1의 비트의 형태로 해석할 수 있다.
예를 들자면 우리는 영어의 글자들을 8 비트의 형태로 표현할 수 있다.
어떤 비트의 형태가 특정한 영어글자를 표현한 것 이다라고 동의한 기준을  ASCII(American Standard Code for Information Interchange)라고 부른다.
컴퓨터 시스템의 기계와 소프트웨어는 일반적으로 데이터가 "문자 텍스트(text)"인경우 이러한 동의한 기준을 따른다. 나중에 더 문자 텍스트에 대해 배울 것이다.
데이터가 문자가 아닌 경우에는 다른 방식을 사용해 표현한다.

질문: 영어가 아닌 다른 글자도 0과1의 비트형태로 표현이 가능할까요?

=== 바이너리 또는 이진수로 모든 것을 표현 할 수 있다라는 것에 대해 더 생각해 보기 More on Representing Anything in Binary  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_13.html

답: 물론이다. 어떤 문자도 바이너리 형태로 나타낼 수 있도록 규정할 수 있다.

일본 문자나 중국문자도 비트의 형태로 표현할 수 있다. 컴퓨터들은 영어 알파벳이 아닌 다른 문자들도 ASCII처럼 쉽게 문자 기호들(symbols)을 조작할 수 있다.
유니코드(unicode)는 16 비트를 사용해서 문자를 비트형태로 어떻게 표현할 것인가를 국제 위원회를 통해 만들어진 기준 또는 동의안(agreement)이다.
여기 16 비트 111110011111110 가있습니다 그리고 이 16 비트의 형태는 유니코드(unicode)에서 茶 로 표현된다.
만약에 국제위원회에서 새로운 한자를 표현하도록 결정했다고 가정하자. 어떻게 이것을 컴퓨터로 표현하는 것이 가능할까요?
쉽습니다: 아직까지 어떤 기호(symbol)에도 사용되지 않았던 비트 형태를 찾아내 그 형태가 새로운 글자를 나타내는것으로 지정하면 된다.

언어의 문자 기호(symbol)와 비트의 형태는 임의적인(arbitary) 것이다.
여기서 유의할 점은 모든 언어가 갖는 문자기호들을 표현하고 담기위해서는 충분히 많은 비트가 필요하다는 점이다.


질문: 음악 악보 같은 것을 바이너리 또는 이진수로 표현할 수 있을까요?

=== 기호와 패턴 Symbols and Patterns  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_14.html
답: 물론입니다. 어떤 기호(symbols)도 표현이 가능합니다. 워드프로세서가 글자를 다루는 프로그램인것처럼 악보를 다루는 음악 프로그램도 있습니다. 

바이너리의 마지막 장점을 다시 기억해 봅시다:

    * 패턴으로 표현할 수 있는 어떤 것이든 비트의 패턴(pattern)으로 표현될 수 있다.

언어의 문자같은 것이 아닌 추상적인 개념은 어떻게 바이너리로 표현 할까요?  아마도 이런 주제로 책 한 권을 써도될 것이다.  대략적 이나마 논점을 다음과 같이 설명해보자. 어떤 주제를 정해서 그것을 문장으로 서술해 보자. 그 문장을 ASCII 코드 같은 바이트 형태화된 문자들로 표현해 보자. 그렇다면 이제 주제는 바이너리로 일단 표현된 것이다. 만약 어떤 것이 언어로 표현될 수 있는 것 이라면, 곧 그것은 바이너리로도 표현될 수 있다.

이것은 주제의 "의미"나 "이해"라는 차원과는 무관하다. 인쇄된 책이 그 책 자체가 담고 있는 내용을 이해 하는것은 아니다. cd-rom에 담겨질 수 있는 디지털 버전의 책도 책 자체가 그 책의 내용을 이해해서 그것을 담고 있는 것은 아니다. 사람이 이해할 때까지 정보를 담고 있을 뿐이다. 전자책은 그러한 정보를 비트 패턴으로 담고 있을 뿐이다.
 
어느 누구도 이진수와 같은 바이너리 표현이 쓰기 쉽다고 하지는 않았다. 바이너리 표현 방식은 숫자 같은 것을 표현하는데 컴퓨터가 사용하기에 편한 것이지 사람이 이해하기는 어려운 것이다. 컴퓨터 과학자들이 하는 일 중에 많은 부분이 바이너리를 사용해서 쓸모있는 것을 어떻게 표현할 까를 고민한고 이해하는 것이다. 예를들어 지난 십년간 컴퓨터 공학에서 많은 부분의 작업들이 이미지와 오디오의 정보를 어떻게 최고로 표현할 것인가에 집중되었다.

중요점:

컴퓨터 메모리가 담고있는 모든 것이 1과0인 비트의 패턴이다. 그 비트 패턴들이 무었을 표현하는가는 사용하는 사람 마음이다.

질문:

사람들이 종종 "컴퓨터는 숫자만 다룰 줄 알지.숫자 이외의 것은 이해할 줄 모른다"라고 말을 합니다. 여러분은 이것이 맞다고 생각 하십니까? 

=== 2 장 끝 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_15.html

답: 전기기기적 차원에서 모든것이 이진수 즉 바이너리의 형태이다 이것을 가지고 사람들은 단지 숫자들 이라고 말할 수 있다. 그렇게 말하는 것은 어느 정도 맞는 표현 일 수 있다.
그렇지만 숫자 뿐만 아니라 어떤 종류의 기호나 상징적인 데이터도 바이너리를 사용하여 표현할 수 있다는 점을 유념하자.

알아야 될것:
바이너리가 의미하는 것이 무엇인가.
비트란 무엇인가.
바이너리를 컴퓨터에서 사용할 때의 장점.
아날로그란 무엇인가.
경계영역 또는 임계영역(threshold)이 어떻게 사용 되었는가.
컴퓨터에서 마스터 클럭이란.
메모리는 비트 형태를 그 내용으로 담는다.

2장 [http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02quiz.html 퀴즈]를 꼭 풀어봅시다. 

=== 프겔러들의 수다 ===
==== 바이너리파일, 텍스트파일의 정의 좀 갈쳐줘 - xp ====
attachment:binary_doc.GIF
형아들 ...
바이너리 파일...
텍스트 파일...  의 정의가 뭐야???
(그리고,  "텍스트 파일 == 아스키파일"  이지???)
c언어에서 FILE 처리할때, 쓰기를 wb 로 바이너리로 쓰면,
아래처럼 만들어더라고...
{{{#!plain 
가나다라 마바사 자차카타파하■■동해물과백두산라■마바사 자차카타파하■가나다라가다나라다
}}}
반대로, FILE 처리할때, 쓰기를 w 로 텍스트로 쓰면,
{{{#!plain 
가나다라 마바사 자차카타파하
동해물과백두산라
마바사 자차카타파하
가나다라가다나라다
}}}
이렇게 엔터값(CR)이 제대로 먹어서 만들어지고...
바이너리 파일과,  텍트스파일의 차이는 그져, 엔터값 (CR/ LF)의 차이인거야????
책에서도 보니까, 엔터값 (CR/ LF) 처리만 차이있는거 처럼 말하던데...
그말이 맞아???
아니면, 위에 사진(binary_doc.gif)처럼,
저렇게  글자까지 깨지는게  바이너리 파일이야???
내 궁금증좀 풀어줘...

프겔러들의 수다
{{{#!textbox
 샤  	바이너리랑 아스키파일 차이는 캐리지 리턴 차이인걸로 아는데... 
}}}
{{{#!textbox
yundream 	뭐 사실 모든 데이터가 바이너리 데이터이니까.. 이건 바이너리.. 저건 text뭐 이렇게 딱잘라 구분하기는 뭐하긴 하지만.. 일반적으로 ASCII 테이블에서 printable영역에 있는 문자로만 이루어진 파일을 text파일아라고해, printable이라는 것도 좀 애매모호 하지만 0 >, 128 < 정도라고 보면되
}}}
{{{#!textbox
yundream 	음 -.-;; 0 < < 128
}}}
{{{#!textbox
스미골ㅤㅎㅐㅎ 	1. 유닉스에서는 바이너리와 아스키(텍스트) 파일의 구분이 없다. 2. 윈도우에서는 구분이 있는데, 파일을 쓸때 LF(n)문자를 CRLF로 확장해서 기록해 주고, 그렇게 쓰여진 텍스트 파일을 읽을 때에는 CRLF를 LF로 바꿔 읽어준다는 게 유일한 차이점이다. 윈도우에서는 텍스트 파일을 저장할때 개행 문자로 CRLF를 쓴다. 
}}}
{{{#!textbox
스미골ㅤㅎㅐㅎ 	3. 따라서 윈도우에서 바이너리 모드로 텍스트 데이터를 쓰면 LF 문자가 CRLF로 확장되지 않고 곧이곧대로 LF문자(0xA)만 달랑 쓰여지기 때문에 메모장으로 읽어보면 이상하게 나온다. 끝.
}}}
{{{#!textbox
스미골ㅤㅎㅐㅎ 	4. 참고로 CR은 0x0D, LF는 0x0A. 
}}}
{{{#!textbox
졸려. 	0x00에서 0x1F까지는 Control Character 
}}}
{{{#!textbox
zf 	Binary data 는 2진 그대로의 data 를 의미해. 이말은 이 값이 뭔지는 모르지만 data 란 말이지. 대신 Text data 는 이 binary data 를 해석한거라고 볼수 있어. binary data 를 문자 형태로 parse 하면 Text data 가 되는거야. 
}}}
{{{#!textbox
zf 	ASCII 를 예로 들어보면 최소 data size 가 1 byte 야. 1 byte 를 정해진 값 가령 0x0D('n'), 0x0A('r') 하고 비교해서 같으면 "아 이놈이 carriage return, line feed 군아" 라고 해석되는 되고, "아.. 출력 위치를 처음으로 돌리고, 한라인 내리자." 이렇게 수행되는거지. parse 했는데 매칭 되는 놈이 없다 또는 매칭 되도 출력을 못시킨다. 이놈에 대한 출력 parse 가 맘데로 처리해도 돼.(해도 되고 안해도 되고, 그대로 조지면 희안한 font 와 매칭 되겠지) 
}}}
{{{#!textbox
zf 	Window 가 LF -> CRLF, CRLF -> LF 로 강제로 변환하지는 않아. 그냥 CRLF 로 해석만 하지. smart LF 랄까 암튼 Window 는 LF 하나가 CRLF 의 역할을 다 수행 해. 그리고 실제 이걸 parse 하는 부분이 필요하다면 이렇게 처리하도록 하고 있어. 대신 parse 된 data 를 다시 encoding 한다면 LF->CRLF 로 변환할 수 있겠지. CRLF 는 오래전에 규정되었고(RFC 822), 그렇게만 parse 되도록 되어있는놈에 대한 지원도 필요하고, CRLF 가 사실 더 명확하니 가급적 CRLF 로 쓰는게 맞겠지. 
}}}
{{{#!textbox
xp 	ㅤㅎㅛㅇ아들 고마워.... . . . 난 바이너리 파일이란게, 워드문서를 텍스트로 열었을때, 저 사진 처럼 깨지는거 .... 저렇게 나오는게 바이너리인지 헷갈렸어... . . . . . . 
}}}
{{{#!textbox
스미골ㅤㅎㅐㅎ 	Windows 환경에서는 C 런타임 라이브러리가 LF를 CRLF로 자동변환을 해준단다. 내가 그렇다면 그런줄 알아라. fopen()으로 파일 열고, fprintf로 "a(슬래쉬)n"을 출력해봐. 그럼 그 파일은 3바이트의 크기를 가지며, 헥스 덤프해 보면 a문자 뒤에 0x0D, 0x0A 문자가 나오게 되지. 유닉스와는 다른 특성이야. 그런데 이걸 또 읽어들이면 CRLF가 LF 하나만 있는 것처럼 읽혀. 즉, 윈도우의 경우에는 아스키 파일과 바이너리 파일을 구분하고, 이를 위해 윈도우즈용 C 런타임 라이브러리는 LF->CRLF->LF 변환을 해줘.
}}}
{{{#!textbox
스미골ㅤㅎㅐㅎ 	그런데 만약 바이너리 모드로 열어서 "a(역슬래쉬)n"을 출력하면 달랑 2바이트만 써지지. 곧이곧대로 출력하는 거야. LF를 CRLF로 변환하지 않고. 
}}}


