#title 마이크로커널 : microkernel

 * 2011/3/2 일 포스팅
[[TableOfContents]]
== 마이크로커널과 모놀리틱 커널 ==
마이크로커널은 '''메모리 관리''', '''스케쥴링''', '''기본적인 IPC'''등 최소한의 기능들만을 제공한다. 나머지 구현은 유저레벨에서 작동하는 모듈들을 끼워 넣어서 운영체제를 확장할 수 있도록 한다. 

{{{#!html
<img src="https://docs.google.com/drawings/pub?id=1NfEuKDfTD6_rQtbnJmz2GpL6eHCK-Imx_QuKZKeWbPE&amp;w=836&amp;h=413">
}}}

마이크로커널과 반대로 핵심적인 커널 기능외에 다른 부가적인 기능들 예를 들어 네트워크 스택과 파일시스템 디바이스드라이버 등을 커널 기본 기능으로 포함하는 방식의 커널을 '''모놀리틱 커널'''이라고 한다. 일반적으로 모놀리틱커널은 마이크로커널에 비해서 빠른 성능을 보여주는 것으로 알려져 있다. 리눅스와 윈도우즈등이 모노리틱커널 방식으로 개발되고 있다. 

모노리틱 커널은 시스템콜(:12)을 이용해서 커널 기능을 이용한다. 반면 마이크로커널은메시지를 전달하는 방식으로 자원에 접근한다.   

모노리틱 커널은 구현이 간단하며, 시스템자원을 효율적으로 사용할 수 있다는 장점을 가지고 있지만 많은 기능을 포함하기 때문에 다양한 환경의 시스템에 포팅하기 어렵다는 단점이 있다. 마이크로 커널은 최소한의 기능만 가지며, 나머지 기능은 모듈단위로 개발하면 되기 때문에 확장과 포팅이 쉽다는 장점을 가진다. 반면 메시지를 전달하는 방식으로 접근하기 때문에 태스크 스위칭에 많은 오버헤드를 초래하는 것으로 알려져있다.  

=== 마이크로 커널 ===
1970년대에 발명된 마이크로 커널은 운영체제의 서비스를 커널에서 꺼내서 사용자 모드로 옮겨서 사용하는 것을 기본 아이디어로 한다.

초기 운영체제 시스템은 컴퓨터 메모리의 한계 때문에 작게 설계될 수 밖에 없었다. 컴퓨터의 성능이 좋아지면서 운영체제가 다루는 장치의 갯수가 늘어나고 커널역시 이들 장치를 제어하기 위해서 점점 커지게 된다. 초기 유닉스 시스템의 커널은 디바이스 드라이버와 파일 시스템 관리 기능등을 포함해도 매우 작은 크기를 가질 뿐이었다. 주소공간이 16비트에서 32비트로 확장되면서 커널 디자인은 비좁흔 하드웨어의 구조적 제한에서 벗어나서 독립적으로 성장한다. 

버클리 UNIX는 커다란 커널을 가진 최초의 유닉스 시스템이라고 할 수 있다.  이 운영체제는 CPU, 디스크, 프린터를 제어하기위한 기능들외에 파일 시스템과 완전한 TCP/IP 네트워킹 시스템을 포함했다. 그리고 수년에 걸쳐서 지속적으로 기능을 추가하면서 그 크기가 수백만 라인에 이르게 되었다. 코드가 방대해진 만큼 커널은 관리하기 힘들어졌고 그만큼 버그를 포함할 가능성이 높아졌다.

마이크로 커널은 핵심 기능만 유지하고 나머지는 유저 스페이스 영역에서 모듈형태로 개발해서 덧붙이는 방식으로 디자인 되었다. 커널은 작은 크기로 유지되므로 그만큼 유지하기가 쉬웠으며, 모놀리틱 커널에 비해서 더 견고하게 개발할 수 있다. 

단점은 message passing 문제로 인한 성능 저하다. 

=== Server ===
마이크로커널의 '''Server'''는 커널의 권한을 가지고 직접 하드웨어에 접근할 수 있다는 것을 제외하고는 데몬(:12)프로그램처럼 작동한다.

마이크로 커널은 서버를 추가하는 방식으로 기능을 확장시킬 수 있다. 일반적으로 마이크로 커널은 '''file system server''', '''device driver server''', '''networking server''', '''display server''', '''user interface device server'''를 기본 셋으로 가지고 있다. 모노리틱커널은 이들 기능을 커널에 직접 내장하는 경우가 많다.

이들 서버들은 마치 리눅스 같은 운영체제에서 서비스 프로그램을 띄우듯이, 운영체제가 올라올때 실행된다. '''서버'''는 유저모드에서 작동하기 때문에 일반 응용 프로그램과 비슷한 방식으로 개발할 수 있다. 리눅스 커널 모듈을 개발해 봤다면, 모노리틱커널에서 응용 프로그램과 커널 모듈의 개발이 매우 다르다는 것을 알고 있을 것이다.

이들 서버는 일반 응용 프로그램 처럼 문제가 생기면 '''Stop & Start'''형식으로 간단히 문제를 복구할 수 있다. 물론 이 경우 해당 서버의 서비스를 받는 응용 프로그램의 자료를 잃어 버릴 수도 있지만 시스템 자체가 멈춰버리는 일은 막을 수 있다.

커널패닉에 의한 시스템 중단은 리눅스와 윈도우 운영체제에서 심심찮게 경험할 수 있다.

=== 리눅스는 ===
리눅스는 모노리틱커널 방식으로 버전 2.6 커널은 라인수가 400만 라인을 넘어서고 있다.

http://www.ibm.com/developerworks/kr/library/l-linux-kernel/figure1.jpg

출처: http://www.ibm.com/developerworks/kr/library/l-linux-kernel/index.html?ca=drs-

마이크로커널에 대한 연구는 1970년대부터 이루어졌고 1980년대에 이르러서는 마이크로 커널이 효율적인 구조라는 견해가 일반적이었다. 그렇지만 이론과 실제는 달라서, 실용적인 측면에서 마이크로 커널은 아직 실현단계였다. 기술이 충분히 성숙하지 않아서였겠지만 오랜시간동안 기술을 축적해온 모놀리딕 커널 방식보다 오히려 복잡하고 느리기까지 했다.

리누즈 토발즈는 모노리틱구조를 따르면서도 견고하며 이식성이 뛰어난 커널을 제작할 수 있다고 판단, 모노리틱 구조를 따르는 리눅스 커널을 개발한다.

{{{#!html
<img src="https://docs.google.com/drawings/pub?id=1rbw4u1JS8mw8ueIRK44dOzsRQMUVjmgCPZ_r9ARQ-gI&amp;w=697&amp;h=433">
}}}

리눅스 커널은 기본 서비스들이 커널에 포함된 형태로 개발된다. 소스코드양도 방대하다. 하지만 특이하게도 리눅스 커널은 다양한 아키텍처를 지원하고 있다. 모노리틱 커널은 이식성에 문제가 있다는 통념을 깨트린 것이다. 물론 이것은 커널형태에 따른 거라기 보다는 커널의 개발 방식에 영향을 받은 측면이 강하다. 완전히 공개된 리눅스 커널은 개발자들이 자발적으로 자신들의 필요에 따라 커널을 이식할 수 있기 때문이다. 아마 가장 많은 플랫폼에 이식된 운영체제일 것이다. 

=== 참고 문헌 ===
 * http://www.ibm.com/developerworks/kr/library/l-linux-kernel/index.html?ca=drs-
 * http://en.wikipedia.org/wiki/Microkernel

[[tag(모노리틱커널,마이크로커널,커널,리눅스)]]
