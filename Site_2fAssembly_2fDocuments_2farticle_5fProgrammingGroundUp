#title ProgrammingGroundUp 1페이지

{{{#!html
<HTML
><HEAD
><TITLE
>Programming from the Ground Up</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><META
http-equiv="Content-Type"
content="text/html; charset=euc-kr"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
></A
>Programming from the Ground Up</H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN4"
>Jonathan Bartlett</A
></H3
><H3
CLASS="OTHERCREDIT"
>윤상배</H3
><DIV
CLASS="AFFILIATION"
><SPAN
CLASS="ORGNAME"
>www.joinc.co.kr<BR></SPAN
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>				yundream@gmail.com<br>
			</P
></DIV
></DIV
><DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>&#44256;&#52828; &#44284;&#51221;</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>&#44256;&#52840; 0.8</TD
><TD
ALIGN="LEFT"
>2004년 2월 09일 19시</TD
><TD
ALIGN="LEFT"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>최초 문서작성</TD
></TR
></TABLE
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>&#52264;&#47168;</B
></DT
><DT
>1. <A
HREF="#INTRODUCTION"
>소개</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#HELLOPROGRAMMINGWORLD"
>프로그래밍의 세계로</A
></DT
><DT
>1.2. <A
HREF="#USEDTOOL"
>사용하는 도구</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#COMPUTERSTRUCTURE"
>컴퓨터 구조</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#COMPUTERMEMORYSTRUCTURE"
>컴퓨터의 메모리 구조</A
></DT
><DT
>2.2. <A
HREF="#CPU"
>CPU</A
></DT
><DT
>2.3. <A
HREF="#TERMS"
>몇 가지 용어들</A
></DT
><DT
>2.4. <A
HREF="#INTERPRETINGMEMORY"
>interpreting Memory</A
></DT
><DT
>2.5. <A
HREF="#DATAACCESSMETHOD"
>데이터 접근 방법</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#MAKEFIRSTPROG"
>첫번째 프로그램 만들기</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#ENTERINGINTHEPROG"
>Entering in the Program</A
></DT
><DT
>3.2. <A
HREF="#INTROASSEMBLY"
>어셈블리 프로그램의 개요</A
></DT
><DT
>3.3. <A
HREF="#PLANNINGTHEPROG"
>Planning the Program</A
></DT
><DT
>3.4. <A
HREF="#FINDMAXNUMBER"
>최대 숫자 찾기</A
></DT
><DT
>3.5. <A
HREF="#ADDRESSINGMODE"
>Addressing mode</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#ASSEMBLYLANGUAGEPROGRAM"
>함수에 대해서 다루기</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#HANDLECOMPLEXPROG"
>복잡한 프로그램 다루기</A
></DT
><DT
>4.2. <A
HREF="#MAKEFUNCTION"
>함수 만들기</A
></DT
><DT
>4.3. <A
HREF="#ASSEMBLYFUNCTION"
>C calling convention을 이용한 어셈블리어 함수설명</A
></DT
><DT
>4.4. <A
HREF="#SAMPLEFUNCTION"
>함수 예제</A
></DT
><DT
>4.5. <A
HREF="#RECURSIVEFUNCTION"
>재귀 함수</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#USEDFILE"
>파일 다루기</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#INTROFILE"
>유닉스 파일 소개</A
></DT
><DT
>5.2. <A
HREF="#BUFFERANDBSS"
>버퍼와 .bss</A
></DT
><DT
>5.3. <A
HREF="#FILETYPE"
>표준파일과 특수 파일들</A
></DT
><DT
>5.4. <A
HREF="#USEDFILEINPROG"
>프로그램에서 파일의 이용</A
></DT
><DT
>5.5. <A
HREF="#LASTSTUDY"
>복습</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#RECORDREADANDREAD"
>레코드 단위의 읽기와 쓰기</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#RECORDWRITE"
>레코드 쓰기</A
></DT
><DT
>6.2. <A
HREF="#RECORDREAD"
>레코드 읽기</A
></DT
><DT
>6.3. <A
HREF="#RECORDEDIT"
>레코드 수정</A
></DT
><DT
>6.4. <A
HREF="#ENDINGCHAPTER"
>마치며</A
></DT
><DD
><DL
><DT
>6.4.1. <A
HREF="#AEN724"
>복습</A
></DT
><DT
>6.4.2. <A
HREF="#AEN738"
>연습문제</A
></DT
></DL
></DD
></DL
></DD
><DT
>7. <A
HREF="#ROBUSTPROGMAKE"
>견고한 프로그램 작성하기</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#WHYLATE"
>왜 시간이 지연되는가 ?</A
></DT
><DT
>7.2. <A
HREF="#TIPFORROBUSTPROG"
>견고한 프로그램을 만들기 위한 몇가지 팁</A
></DT
><DD
><DL
><DT
>7.2.1. <A
HREF="#AEN771"
>사용자 테스트</A
></DT
><DT
>7.2.2. <A
HREF="#AEN775"
>데이터 테스트</A
></DT
><DT
>7.2.3. <A
HREF="#AEN802"
>모듈 테스트</A
></DT
></DL
></DD
><DT
>7.3. <A
HREF="#ERRHANDLING"
>에러 핸들링의 기본</A
></DT
><DD
><DL
><DT
>7.3.1. <A
HREF="#AEN810"
>모든 것은 에러코드를 가진다.</A
></DT
></DL
></DD
><DT
>7.4. <A
HREF="#LORDOFROBUSTPROG"
>견고한 프로그램으로 만들기</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#USEDLIBRARY"
>라이브러리를 통한 함수 공유</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#SHAREDLIBRARYUSED"
>공유 라이브러리의 이용</A
></DT
></DL
></DD
><DT
>9. <A
HREF="#ABOUTMEMORY"
>메모리에 대하여</A
></DT
><DD
><DL
><DT
>9.1. <A
HREF="#SEECOMPUTERMEMORY"
>컴퓨터는 메모리를 어떻게 바라보는가</A
></DT
><DT
>9.2. <A
HREF="#INSTRUCTIONPOINTER"
>Instruction Pointer</A
></DT
><DT
>9.3. <A
HREF="#MEMORYSTRUCTUREFORLINUX"
>리눅스 프로그램에서의 메모리 구조</A
></DT
><DT
>9.4. <A
HREF="#ADDRESSISLIE"
>Every Memory Address is Lie</A
></DT
><DT
>9.5. <A
HREF="#GETTINGMOREMEMORY"
>Getting More Memory</A
></DT
><DT
>9.6. <A
HREF="#MEMORYCONTROL"
>메모리 관리</A
></DT
><DT
>9.7. <A
HREF="#VARIABLEANDCONST"
>변수와 상수들</A
></DT
><DT
>9.8. <A
HREF="#ALLOCATEINIT"
>allocate_init 함수</A
></DT
><DT
>9.9. <A
HREF="#AEN931"
>allocate 함수</A
></DT
><DT
>9.10. <A
HREF="#AEN962"
>deallocate 함수</A
></DT
><DT
>9.11. <A
HREF="#AEN967"
>성능 및 다른 몇가지 문제들</A
></DT
><DT
>9.12. <A
HREF="#AEN975"
>Allocator 사용하기</A
></DT
><DT
>9.13. <A
HREF="#AEN991"
>더 많은 정보들</A
></DT
><DT
>9.14. <A
HREF="#AEN1010"
>복습</A
></DT
></DL
></DD
><DT
>10. <A
HREF="#OPTIMIZATION"
>최적화</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#AEN1032"
>최적화가 필요한 시점</A
></DT
><DT
>10.2. <A
HREF="#AEN1052"
>어디를 최적화 할 것인가</A
></DT
><DT
>10.3. <A
HREF="#AEN1059"
>지역 최적화 방안</A
></DT
><DT
>10.4. <A
HREF="#AEN1089"
>전역 최적화 방안</A
></DT
><DT
>10.5. <A
HREF="#AEN1103"
>복습</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#APPENDIXA"
>Appendix A. GUI 프로그래밍</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#AEN1114"
>GNOME 라이브러리</A
></DT
><DT
>11.2. <A
HREF="#AEN1119"
>다양한 언어를 이용한 간단한 GNOME 프로그램 작성</A
></DT
><DT
>11.3. <A
HREF="#AEN1169"
>GUI Builders</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#APPENDIXB"
>Appendix B. Common x86 Instructions</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="#AEN1185"
>Data Transfer Instructions</A
></DT
><DT
>12.2. <A
HREF="#AEN1239"
>Integer Instructions</A
></DT
></DL
></DD
><DT
>13. <A
HREF="#APPENDIXC"
>Appendix C. 주요 시스템 콜들</A
></DT
><DT
>14. <A
HREF="#APPENDIXD"
>Appendix D. ASCII 코드 표</A
></DT
></DL
></DIV
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="ABSTRACT"
><A
NAME="AEN17"
></A
><P
></P
><P
>        이 문서는 ProgrammingGroundUp의 번역 문서다. 계획으로는 하루 한시간씩을
        번역에 투자할 생각이지만 생각처럼 잘 될런지는 모르겠다. 누군가 참여하는 
        사람이 있다면 훨씬 진행이 빨라질 것이라고 생각된다. 
    </P
><P
>        번역은 매우 느슨하게 이루어질 것이다. 즉 필요없다고 생각 되는 부분은 
        과감히 생략할 수 있으며, 비슷한 다른 말론 바뀔 수 있으며 추가 될 수도 
        있다. 번역 순서역시 각장의 순서를 따르지는 않을 수도 있다(관심있는
        부분부터 번역이 이루어질 것이다).  
    </P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="INTRODUCTION"
></A
>1. 소개</H1
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="HELLOPROGRAMMINGWORLD"
></A
>1.1. 프로그래밍의 세계로</H2
><P
>        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="USEDTOOL"
></A
>1.2. 사용하는 도구</H2
><P
>            이책은 x86 프로세스기반의 GNU/Linux 운영체제에서 어셈블리어를 
            이용한 프로그래밍에 대해서 다룬다. 이런 이유로 이책의 모든 예제와
            이에 대한 설명은 GNU/Linux상에서 GCC도구를 이용해서 이루어질 것이다.
            이는 여러분이 GNU/Linux와 GCC도구에 대한 이해가 부족할경우 책의 내용을 
            이해하는데 있어 문제가 될 수 있음을 의미한다. 만약 Linux와 GCC에 생소
            하다면 이책을 읽기 전에 http://rute.sourceforge.net의 문서를 읽어 
            보기 바란다. 영문을 보기 싫다면 서점에서 매우 잘 번역된 많은 리눅스 관련
            서적으로 리눅스에 대한 스터디를 대신할 수도 있다. 
        </P
><P
>            리눅스 관련 문서와 책은 분명 많은 도움을 주긴 하지만 그때 그때 닥치는 
            실시간성의 의문점등을 해결하고 책에서는 얻기 힘든 도움을 얻기 
            원한다면 리눅스 유저 그룹을 활용하면 된다. 
            <A
HREF="http://www.kldp.org"
TARGET="_top"
>kldp</A
>와 
            <A
HREF="http://www.joinc.co.kr"
TARGET="_top"
>joinc</A
>,  
            <A
HREF="http://www.gentoo.or.kr"
TARGET="_top"
>gentoo</A
>와 같은 사이트를 
            이용하기 바란다. 좀더 실시간의 도움을 원한다면 irc를 이용하기 바란다.   
        </P
><P
>            여기에 있는 프로그램들은 RedHat Linux 9.0, Kernel 2.6.x 환경에서 
            작성되고 테스트될 것이다. 다른 배포판을 사용하고 있다고 해서 
            걱정할 필요는 없을 것이다. 패키지 관리, 시스템 관리와 관련된 사항들을 
            제외하고는 거의 100% 호환을 장담할 수 있기 때문이다.   
        </P
><P
>            여러분의 PC에 직접 리눅스를 설치해서 공부를 하는게 가장 좋은 방법이긴 
            하지만 이게 여의치 않을 경우 리눅스 계정을 얻을 수 있는 시스템을 
            수소문해 보기 바란다. 여러분 주위의 리눅스 시스템을 가지고 있는 친한 
            친구에게 밥한끼 사주고 절대 시스템에서 이상한 행동을 하지 않겠다고
            다짐해 준다면 쉽게 얻을 수 있을 것이다. 이러한 친구가 없다면 
            어쩔 수 없다. 리눅스를 설치하기 바란다. 위에서 언급했던 리눅스 유저 
            모임등에서 쉘 계정을 얻을 수도 있겠지만 여러분이 오랜시간동안 
            유저 모임에서 활동을 해서 충분한 신뢰를 쌓은 경우가 아니라면 계정을 
            얻는건 매우 힘든 일이 될것이다.  
        </P
><P
>            그런데 리눅스가 뭐지? 라고 궁금해 할 수도 있을 것 같으니, 간단히 
            언급하도 넘어가도록 하겠다. 리눅스는 유닉스와 매우 비슷한 
            운영체제로 <A
HREF="http://www.gnu.org"
TARGET="_top"
>GNU</A
>
            프로젝트의 일부로 개발되어지고 있는 공개 운영체제다. 리눅스 운영체제는 
            리눅스 커널과 그 밖의 다른 수많은 GNU프로젝트에 의해서 개발된 
            응용프로그램으로 구성된다. 이러한 응용프로그램 중에 GCC도구가 
            포함되어 있는데, 이걸 이용해서 다양한 (프로그래밍)언어로 작동가능한 
            프로그램을 만들어 낼 수 있다.  
        </P
><P
>            리눅스 운영체제의 핵심은 커널(kernel)이며, 엄격한 의미로 리눅스는 이 
            커널을 가르킨다. 커널은 운영체제의 핵심으로써 모든 것을 제어한다. 
            인체로 말하자면 두뇌쯤 되는 부분일 것이다. 두뇌는 신경으로 전달되는 
            외부의 자극을 받아들이고 자극을 해석해서 각 기관을 움직인다. 
            벌래가 눈앞으로 달려들면 눈을 감는다거나, 뜨거운 물건을 쥐었을 경우 
            반사적으로 손을 움추리거나 하는 등의 행동이 그것이다. 커널은 
            사용자의 명령을 받아들여서 프로세스를 실행하고 각종 
            장치(인체로 말하자면 기관)을 제어한다. 또한 다중의 프로세스가 작동중일 
            경우 프로세스를 스케쥴링한다. 예를 들어 키보드(장치)를 사용자가 누르면 
            커널은 키입력을 받아들이고 키입력을 키에 매핑되는 문자로 변환해서 화면에
            출력할 것이다. 만약 X Windows 시스템이라면 윈도우 시스템은 커널로 부터 
            키입력을 읽어 들이고 현재 떠있는 애플리케이션의 입력창에 문자를 
            출력한다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>Keyboard -&#62; Kernel -&#62; Windowing system -&#62; Application program
            </PRE
></TD
></TR
></TABLE
>
            위의 키보드 입력을 보면 커널은 윈도우 시스템과 장치 그리고 애플리케이션 
            프로그램간의 데이터 흐름을 제어한다. 여기에서 커널이 장치와 프로그램 
            사이, 프로그램과 프로그램 사이의 정보의 흐름을 제어함을 알 수 있다. 
        </P
><P
>            프그램이 다루는 각각의 데이터와 장치의 권한을 관리해서 서로의 데이터 영역을 
            침입하지 않도록 제어하는 것 역시 커널의 중요한 기능 중 하나이다.            
        </P
><P
>            이상으로 커널은 곧 리눅스라는 걸 이해했을 것이다. 그러나 커널만 있다고 해서 
            운영체제가 작동할 수 있는 건 아니다. 회사를 예로 들어 보자.
            전화가 놓여 있고 컴퓨터가 있다고 해서 회사가 돌아가는 건 아니다. 실제 일을 하는
            사람이 있어야 한다. 전화와 컴퓨터와 같은 기반 시설은 리눅스 커널이며
            사람은 (GNU)응용 애플리케이션 볼 수 있다. 둘이 조화를 이루어야 목적을 
            달성할 수 있을 것이다.      
        </P
><P
>            우리는 커널이라는 갖추어진 기반 시설위에서 작동하는 애플리케이션을 작성할 
            것이며, 애플리케이션의 작성을 위해서 어셈블리(assembly)어를 사용하는 법을 
            배울 것이다. 어셈블리어를 다루기전에 기본이 되는 3가지 언어에 대해서 
            알아보도록 하겠다.    
            <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>기계어(Machine Language)</DT
><DD
><P
>                        컴퓨터가 직접 이해할 수 있는 언어다. 모든 명령은 컴퓨터가 
                        이해할 수 있는 일련의 숫자로된 명령에 의해 이루어진다. 
                        특수한 사람만 이해할 수 있다는 단점이 있다.  
                    </P
></DD
><DT
>어셈블리어(Assembly Language)</DT
><DD
><P
>                        기계어와 동일하지만 이해하기 어려운 일련의 숫자대신 
                        사람이 이해하기 쉬운 문자로 이루어진다. 
                    </P
></DD
><DT
>고급어(High-Level Language)</DT
><DD
><P
>                        좀더 쉽게 프로그래밍 할수 있도록 만들어진 언어로 보다 
                        인간의 언어에 근접하다. 인간이 이해하기 쉽다는 장점이 있으나 
                        하나의 어셈블리 명령으로 실행해도 될걸 여러번의 명령으로 
                        실행되므로 비효율적일 수 밖에 없다.   
                    </P
></DD
></DL
></DIV
>
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="COMPUTERSTRUCTURE"
></A
>2. 컴퓨터 구조</H1
><P
>        언어를 이해하려면 그 밑바탕이 되는 문화를 이해하고 역사를 이해해야 하듯이
        프로그래밍을 이해해서 프로그램을 만들고자 한다면 그 밑바탕이 되는 컴퓨터에 
        대해서 이해하고 있어야 한다. 물론 여러분이 전자공학을 공부할 필요는 없겠지만 
        적어도 컴퓨터에서 프로그램이 어떻게 실행될 수 있는지와 같은 기본적인 것에 
        대한 이해 하고 있어야 한다.
    </P
><P
>        현재 컴퓨터의 구조는 구조를 만든 창시자의 이름을 딴 Von Neumann(폰 노이만)이라고 
        불리우는 구조에 기반을 두고 있다. 폰 노이만은 컴퓨터의 구조를 
        CPU(Central Processing Unit)와 메모리(memory)의 두개의 주요 부분으로 나누어서 
        구성했다. 이 구조는 개인 컴퓨터, 슈퍼 컴퓨터, 메인 프레임 심지어는 핸드폰과 같은 
        모든 현대적인 컴퓨터가 채택하고 있다. 간단히 말해서 "연산"과 "저장"의 두 부분으로 
        나누었다. 
    </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="COMPUTERMEMORYSTRUCTURE"
></A
>2.1. 컴퓨터의 메모리 구조</H2
><P
>            컴퓨터가 메모리를 보는 방식을 쉽게 이해하려면 다세대 주택에 비치되어 있는 
            우편함을 생각하면된다. 우편함은 기본적으로 해당 호수에 사는 사람이 염람이 
            가능하며 열람해야할 우편함을 쉽게 찾을 수 있도록 번호(보통 호수)가 메겨져 
            있음을 알 수 있다. 컴퓨터가 메모리를 보는 관점역시 이와 비슷하다. 컴퓨터는 
            각 메모리 영역을 쉽게 찾아내어서 데이터를 저장하거나 가져올 수 있도록 
            하기 위해서 번호가 메겨져 있다. 예를 들어서 당신의 컴퓨터가 256Mbyte의 
            메모리를 가지고 있다는 것은 당신의 컴퓨터가 256*백만의 저장 공간을 가지고 
            있음을 의미한다. 256*백만 개의 우편함을 가지고 있는 것이다. 각각의 영역은 
            유일하게 구별될 수 있는 번호가 메겨 진다.     
            <DIV
CLASS="FIGURE"
><A
NAME="AEN61"
></A
><P
><B
>&#44536;&#47548; 1. 메모리 영역은 우편함과 비슷하다</B
></P
><P
><IMG
SRC="http://www.joinc.co.kr/albums/album01/agl.gif"></P
></DIV
>
            컴퓨터가 위와 같은 방법으로 메모리를 관리하는 이유는 간단한 관리가 가능하기 
            때문이다. 만약 컴퓨터가 데이터의 크기에 따른 가변크기의 다양한 크기의 메모리
            영역의 조합을 관리해야 한다면 이들 메모리영역을 다루기가 매우 어려울 것이다. 
        </P
><P
>            메모리에는 컴퓨터의 연산에 필요한 모든 정보가 저장된다. 지금 당신이 사용하고 
            있는 컴퓨터를 예로 들어보도록 하자. 지금 당신이 사용하는 컴퓨터의 메모리에는
            다음과 같은 내용들이 저장되어 있을 것이다.
            <P
></P
><UL
><LI
><P
>                        커서의 스크린상에서의 위치
                    </P
></LI
><LI
><P
>                        스크린상에 존재하는 각 윈도우의 위치와 크기들    
                    </P
></LI
><LI
><P
>                        사용하고 있는 폰트의 정보들
                    </P
></LI
><LI
><P
>                        각 윈도우에서 사용하고 있는 위젯들(버튼, 박스, 메뉴)
                    </P
></LI
><LI
><P
>                        아이콘의 그래픽 정보
                    </P
></LI
><LI
><P
>                        대화상자 등에 표시되는 메시지들
                    </P
></LI
><LI
><P
>                        기타
                    </P
></LI
></UL
>
            메모리에 데이터가 있다면 데이터를 다루는 프로그램들도 있을 것이다. 
            이 프로그램은 메모리 데이터를 쓰거나 읽는 일을 할 것이다. 데이터와는 
            좀 다른 특성을 가지고 있으므로 데이터와 좀 다르게 취급될 수 있을거라
            생각될 수 있지만 폰 노이만 구조에 의해 이들 프로그램역시 데이터와 
            동일하게 메모리에 저장된다. 폰 노이만 구조를 따르는 컴퓨터의 입장에서 
            보자면 프로그램 역시 데이터일 뿐이다.   
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="CPU"
></A
>2.2. CPU</H2
><P
>            메모리에 데이터가 저장되어 있다고는 하지만 이것만 가지고는 
            아무런 의미가 없다. 단지 비트의 나열 뿐으로 데이터를 쓸모 있는 정보로 
            바꾸기 위해서는 데이터를 읽어들이고, 수정하고, 옮기는 등의 일을 
            해야만한다. 이러한 일은 CPU가 담당하게 된다. 
        </P
><P
>            CPU는 한번의 시간에 메모리로 부터 명령(instruction)을 읽어 들이고 
            이것들을 실행한다. 이것을 <B
CLASS="EMPHASIS"
>fetch-execute cycle</B
> 
            라고 하는데, 이 명령에는 다음과 같은 요소들이 포함되어 있다.  
            <P
></P
><UL
><LI
><P
>                        Program Counter
                    </P
></LI
><LI
><P
>                        Instruction Decoder
                    </P
></LI
><LI
><P
>                        Data bus
                    </P
></LI
><LI
><P
>                        General-purpose register
                    </P
></LI
><LI
><P
>                        Arithmetic and logic unit
                    </P
></LI
></UL
>
            <B
CLASS="EMPHASIS"
>program counter</B
>는 컴퓨터에게 다음 수행해야될 
            명령(instruction)을 알려주기 위해서 사용한다. 우리는 앞서 컴퓨터의 
            입장에서 프로그램과 데이터가 메모리에 저장되는 방식에 의해서는 
            어떠한 차이도 없다고 배웠었다. 단지 해석에 있어서 차이가 있을 뿐이다.  
            program counter은 실행될 다음 명령이 저장되어 있는 메모리주소값을 
            가지고 있다. <B
CLASS="EMPHASIS"
>instruction decoder</B
>는 수행해야될 
            명령의 형식을 알려주기 위해서 사용된다. 수행해야될 명령의 형식이란 
            다름 아닌 더하기, 빼기, 곱하기, 데이터 이동과 같은 것들이다.
            이상에서 컴퓨터의 수행은 명령들과 명령이 저장된 메모리 위치의 
            목록에 의해서 이루어 짐을 알 수 있다.    
        </P
><P
>            이제 컴퓨터는 어떤 일을 수행할 준비가 되어있다. 일을 수행(계산)하기 
            위해서는 데이터가 있어야 한다. <B
CLASS="EMPHASIS"
>data bus</B
>는  
            계산할 데이터가 있는 메모리의 위치를 가진다. data bus라고 불리우는 
            이유는 CPU와 Memory사이를 연결해주기 때문이다. 버스라는건 하나의 
            객체에 필요로 하는 여러개의 다른 객체를 연결하는 구조를 말한다. 
            운송수단으로 이용하는 버스를 생각하면 될것이다. 
        </P
><P
>            전형적으로 보자면 메모리는 CPU(이하 프로세서)의 외부에 위치하고 있다. 
            그렇지만 프로세서도 <B
CLASS="EMPHASIS"
>register</B
>라고 불리우는 빠르게 
            접근 가능한(물리적으로 가깝기 때문에) 자체 메모리를 가지고 있다. 
            이러한 레지스터는 일반목적(general-purpose) 레지스터와 
            특별목적(special-purpose) 레지스터의 두가지 종류로 나뉜다. 
            일반 목적 레지스터는 말그대로 더하기, 빼기, 곱하기, 비교와 같은 일반적인 
            명령을 위해서 사용된다. 컴퓨터는 제한된 몇개만의 일반 목적 레지스터를 
            가지고 있을 뿐이며 대부분은 주(main)메모리를 이용한다.  
        </P
><P
>            이제 CPU가 필요로 하는 데이터를 가져왔다면 decoded instruction에 따라서 
            수치연산(arithmetic)과 논리연산(logic)을 수행한다. 이것들은 실제
            수행되는 명령들로써 연산수행 결과는 data bus를 통해서 주 메모리공간 
            이나 레지스터리에 저장된다.  
        </P
><P
>            CPU의 이러한 작동은 매우 심플하다(만약 그렇지 않다면 CPU제작 단가가 
            극적으로 올라갈 것이다). 비록 초기 프로세서에 비해서 현재의 
            프로세스가 매우 많은 발전을 하고 매우 복잡해지기는 했지만
            기본적인 작동방식은 초기의 모델을 따르고 있다. 다만 여기에
            chache hierarchies, superscalar processors, pipelining, branch prediction,
            out-of-order execution, microcode translation, coprocessors등의 
            (매우 생소한)기술이 추가 되어서 성능을 향상 시켰다는 것만 다르다고 
            할 수 있다. 이러한 성능향상 기술들은 옵션으로 붙은 사항이라고 보면 
            되겠다. 위의 단어들중 pipelining와 coprocessors(수치연산 프로세스) 
            외에는 처음 접해본 단어들이 많을 건데, 그렇다고 해서 그리 걱정할 
            필요는 없다. 저것들을 모른다고 해도 CPU의 기본작동 방식을 이해하는데 
            별 문제는 없다. 꼭 알아야 겠다면 인터넷을 통해서 CPU에 대한 더욱 
            자세한 내용을 찾아 보길 바란다.
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="TERMS"
></A
>2.3. 몇 가지 용어들</H2
><P
>            컴퓨터의 메모리는 고정된 크기를 가지는 연속된 숫자를 가지는 저장공간의 
            연속이다. 이들 숫자는 저장공간의 위치를 가리키는데 이를 
            '''주소(address)'''라고 한다. 고정된 크기를 가지는 단일 공간을 
            X86 프로세서에서는 '''byte'''라고 부르며 0에서 255사이의 값을 가진다. 
        </P
><P
>            주소공간의 크기가 0에서 255의 값을 가진다고 했다.  
            아마도 화면에 표시되는 문자와 그림을 표현하기 위해서는 훨씬 큰 값이 
            필요할 것이다. 이런것들은 어떻게 표현할까 ? 이러한 표현은 
            그래픽 카드(graphics card)가 있음으로 가능해 진다. 그래픽 카드는 
            연속된 여러개의 값들을 해석해서 화면에 출력시킨다. 화면에 
            데이터를 출력할 때는 읽어들인 값을 ASCII 코드에 맵핑 시켜서 여기에 
            있는 값을 화면에 뿌려주게 된다. 예를 들어 읽어들인 값이 65라면 'A'가 
            화면에 출력된다. 화면에 "HELLO"를 출력하기 위해서는 
            72, 69, 76, 76, 79의 연속된 값들을 필요로 한다. 다음은 ASCII 코드표이다.  
            <DIV
CLASS="FIGURE"
><A
NAME="AEN108"
></A
><P
><B
>&#44536;&#47548; 2. ASCII 테이블</B
></P
><P
><IMG
SRC="http://www.joinc.co.kr/albums/album01/age.gif"></P
></DIV
>
            분명 0에서 255까지의 값이라고 했는데 왜 127까지 밖에 없지? 라고 생각할 
            수 있을 것 같다. 실제 화면출력과 제어를 위해서는 0-127까지의 값을 
            사용한다. 128에서 255는 Extended ASCII Codes라고 불리우며 영문외의 
            다른 문자들(특히 2바이트 문자)과 특수 문자들을 나타내기 위해서 사용 
            한다.   
        </P
><P
>            그렇다면 255보다 더큰 값은 어떻게 해야 다룰 수 있을까 ? 이것은 바이트를 
            두개 이상 결합함으로서 가능해 진다. 두 바이트라면 0에서 65536까지 표현
            가능 하다. 4 바이트로 할경우 0에서 4294967295까지의 값을 표시할 수 
            있을 것이다. 큰 수를 표현하기 위해서 바이트 조합을 해야한다면 프로그래밍 
            할 때 꽤나 귀찮을 거라고 생각할 수 있지만 다행이도 컴퓨터는 4바이트를 기본단위로
            묶어서 관리하고 있으니 크게 걱정할 필요는 없다.
        </P
><P
>            앞서 우리는 컴퓨터가 내부적으로 사용하는 레지스터라고 불리우는 저장공간에 
            대해서 알아 보았다. 레지스터는 컴퓨터가 (빠른)계산을 하기위한 용도로 
            사용한다. 여러분의 책상으로 비유해 보자. 여러분의 책상에는 작업에 사용하기 
            위한 많은 책, 문서, 보고서들이 한 귀퉁이를 차지하고 있을 것이다. 그러나 분명 
            여러분이 지금 처리해야할 일과 관련된 문서는 여러분과 가까운 곳에 위치하고 
            있을 것이다. 아마도 모니터 옆이나, 책받이 정도가 될건데, 이렇게 하는 이유는 
            작업에 필요한 데이터를 좀더 빨리 찾기 위해서이다. 이러한 장소가 컴퓨터의 
            레지스터에 해당한다. 레지스터에는 컴퓨터가 현재 작업중인 데이터가 놓여서 
            좀더 빠른 작업이 가능하도록 한다. 
        </P
><P
>            아마도 여러분의 대부분은 X86프로세스를 사용하는 컴퓨터를 사용하고 있을 것이다. 
            x86 프로세스는 4바이트 크기의 레지스터를 가진며 이를 <B
CLASS="EMPHASIS"
>word</B
>
            라고 한다. 즉 1워드는 4바이트가 된다. 레지스터의 크기를 4바이트로 정한건 
            컴퓨터가 계산을 하기 위한 가장 편한 자료의 크기이기 때문이다. 4바이트는 
            40억정도의 크기를 가진다.  
        </P
><P
>            주소(address)는 레지스터의 크기에 맞도록 4바이트(1워드)의 크기를 가진다. 
            주소가 4바이트 크기를 가지게 되므로 최대 4294967296바이트 만큼을 다룰 수 
            있을 것이다. 이것은 4기가 바이트의 크기로 일반적인 컴퓨터가 제어가능한 
            물리적인 메모리의 크기가 된다.  
        </P
><P
>            주소는 결국 데이터가 저장된 메모리의 위치를 가리키게 되는데, 이러한 
            가리킨다는 특징 때문에 <B
CLASS="EMPHASIS"
>pointers</B
>라고 부르기도 한다. 
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="INTERPRETINGMEMORY"
></A
>2.4. interpreting Memory</H2
><P
>            컴퓨터는 매우 엄격하게 작동되는 논리기계다. 때문에 컴퓨터를 다루는 프로그래머 
            역시 매우 엄격해질 수 밖에 없다. 컴퓨터는 혼자서는 어떠한 일도 수행할 
            수 없으며 반드시 프로그램이 있어야 하며, 프로그램역시 엄격한 규칙을 따르도록 
            작성되어야 하기 때문이다. 컴퓨터가 원하는 일을 하는 걸 보고 싶다면 
            여러분은 컴퓨터에게 컴퓨터가 수행해야 할 일을 명확하게 명령할 수 있어야 한다. 
        </P
><P
>            컴퓨터가 대략 알아서 해줄거라고 기대하지 말라. 컴퓨터는 문자건, 그림이건,
            음악이건 웹페이지건 단지 숫자로 저장할 뿐이며, 연속된 숫자의 나열로 
            볼 뿐이다. 문자, 그림, 음악들을 들을 수 있는건 이러한 숫자의 나열을 해석할수 
            있는 (프로그래머가 작성한)특별한 프로그램이 있어야지 가능하다.   
        </P
><P
>            메모리에 고객정보를 저장하는 걸 예로 들어보자. 여러분은 고객의 이름과 
            주소를 저장하기 위해서 각각 10개와 50개 정도의 ASCII 문자를 사용해야 하는걸 
            쉽게 생각해 낼 수 있을 것이다. 고객의 나이와 고객의 아이디를 저장하기 위해서는
            숫자가 필요함을 알아 낼 수 있을 것이다. 이 경우 메모리 블럭에는 다음과 같은 
            형태로 고객의 정보가 저장될 수 것이다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>레코드의 시작 :
   고객의 이름 (10 바이트)   = 레코드의 시작 
   고객의 주소 (50 바이트)   = 레코드의 시작 + 10 바이트
   고객의 나이 (4 바이트)    = 레코드의 시작 + 10 + 50 
   고객의 아이디 (4 바이트)  = 레코드의 시작 + 10 + 50 + 4
            </PRE
></TD
></TR
></TABLE
>
            고객 데이터가 저장된 레코드의 주소(address)를 알고 있다면 우리는 간단한 
            연산(덧셈)을 통해서 고객 레코드에서 원하는 가져올 수 있다. 그러나 위의 
            방법으로 데이터를 저장하는 방식은 한가지 단점을 가지고 있다. 위의 예에서는 
            고객의 주소가 50바이트로 제한되어 있는데, 이런 이유로  50바이트 보다 
            더 큰 주소가 입력된 경우 50바이트 이후의 주소 데이터는 분실해 버린다. 
        </P
><P
>            위의 데이터 저장방식에 따른 제한을 없애기 위해서 데이터의 위치만을 
            가리키는(포인트)하는 방법이 사용된다. 고객의 이름을 예로 들자면 고객의 
            이름의 실제 데이터는 메모리의 임의의 영역에 저장되고 레코드에는 단지 
            고객의 데이터가 저장된 메모리의 주소 값만을 명시하는 방법이다. 
            이 경우 메모리는 다음과 같이 구성될 것이다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>레코드의 시작    
    고객의 이름 포인터(4 바이트)  = 레코드의 시작
    고객의 주소 포인터(4 바이트)  = 레코드의 시작 + 4
    고객의 나이 (4 바이트)        = 레코드의 시작 + 4 + 4 
    고객의 아이디 (4 바이트)      = 레코드의 시작 + 4 + 4 + 4 
            </PRE
></TD
></TR
></TABLE
>
            이렇게 되면 고객의 실제 데이터는 메모리의 임의의 위치에 저장될 수 있음으로 
            입력가능한 주소의 길이에 제한을 받지 않아도 된다. 
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="DATAACCESSMETHOD"
></A
>2.5. 데이터 접근 방법</H2
><P
>            프로세스는 addressings mode라고 불리우는 데이터에 접근하는 
            몇 가지 방식을 가지고 있다. 가장 간단한 mode는 
            <B
CLASS="EMPHASIS"
>immediate</B
>모드라고 부리는 것으로 데이터 접근이 
            명령(instruction)자신에게서 이루어지는 방식이다.   
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="MAKEFIRSTPROG"
></A
>3. 첫번째 프로그램 만들기</H1
><P
>        이번 장에서는 리눅스 어셈블리 프로그램을 만드는 방법에 대해서 알아볼 것이다. 
        여기에 더불어 어셈블리 프로그램의 구조와 어셈블리 프로그래밍을 작성하는데 
        필요한 어셈블리 명령어들에 대해서도 알아볼 것이다.    
    </P
><P
>        여러분이 주로 중/고급 언어만을 다루어 왔다면, 아마도 이들과는 전혀다른 
        저수준의 어셈블리어에 당황할 것이다. 어셈블리어에 익숙해지는 방법은 
        다른 언어에 익숙해지기 위해서 사용했던 방법들과 동일하다. 즉 꾸준히 
        코드를 접하고 많은 시간에 걸쳐서 연습하고 생각하고 인터넷혹은 서적을 
        통해서 관련 정보를 수집하고 자신의 것으로 만드는 것이다. 많은 시간이 필요하며 
        시행착오 역시 겪게 되겠지만 이러한 모든 것들이 어셈블리어를 여러분의 것으로 
        만드는데 반드시 필요한 도움이 되어줄 것이다.   
    </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="ENTERINGINTHEPROG"
></A
>3.1. Entering in the Program</H2
><P
>            간단한 프로그램을 만드는 것부터 시작해 보도록 하자. 처음으로 만들 
            프로그램은 아무런 하는일이 없는 -실행 후 바로 종료해 버리는- 어이 없는 
            프로그램이지만 어셈블리어와 리눅스 프로그래밍에 대한 기본적인 방법을 
            보여준다. 여러분이 좋아하는 에디터로 아래의 예제를 편집한 다음 
            exit.s 이름을 가지는 파일로 저장하도록 한다. 지금 당장 아래의 예제 코드가 
            이해되지 않는다고 해서 걱정할 필요는 없다. 우선은 아래의 코드를 만들고 
            컴파일 해서 실행 시키는데에만 신경쓰도록 한다. 실제 코드에 대한 
            상세한 설명은 <A
HREF="#ASSEMBLYLANGUAGEPROGRAM"
>4&#51208;</A
>에서 다룰 것이다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># 시작 후 바로 종료하는 간단한 프로그램으로 종료 할때
# 프로그램의 리턴값을 리눅스 커널에 전달한다.
#

# 입력 : 없음
#

# 출력 : 코드의 종료값을 리턴한다.
# 프로그램의 종료값은 쉘에서 다음과 같이 확인 가능하다.
# echo $?
#

# 변수 :
# %eax는 시스템 호출(system call)번호를 저장한다.
# %ebx는 종료값을 저장한다.

.section .data
.section .text
.global _start

_start:
movl $1, %eax    # 리눅스 커널에 exit(2)시스템 콜을 요청한다.
                 # exit(2)의 시스템 콜 번호는 1번이다.

movl $0, %ebx    # 프로그램이 종료하면서 운영체제에 넘겨줄
                 # 종료값이다.
                 # 프로그램 종료후 쉘상에서
                 # echo $? 로 확인 할 수 있다.
                 # 값을 바꾸어 가면서 테스트 해보도록 하자.

int $0x80        # exit 시스템콜을 실행한다.
            </PRE
></TD
></TR
></TABLE
>
            위와 같은 문장들을 우리는 소스코드(source code)라고 부르며, 소스코드가 
            저장된 파일을 소스파일 이라고 부른다. 소스코드는 
            인간이 쉽게 읽을수 있도록 만들어진 프로그램의 양식이다. 그러나 
            소스코드는 프로그램의 양식일 뿐 그 자체로 실행가능한 프로그램은 아니다. 
            인간이 이해하기는 쉽지만 컴퓨터는 인간의 문장을 이해할 수 없기 때문이다. 
            그래서 소스코드를 컴퓨터가 이해해서 실행 가능하도록 기계의 언어로 
            번역(transform)하는 작업이 필요하게 된다. 이러한 작업을 위해서 
            <B
CLASS="EMPHASIS"
>assemble</B
>와 <B
CLASS="EMPHASIS"
>link</B
>가 사용된다. 
        </P
><P
>            먼저 <B
CLASS="EMPHASIS"
>assemble</B
>를 이용해서 소스코드를 기계를 위한 
            명령으로 변경해야 한다. 이러한 변경(혹은 번역) 과정을 Assembling라고 
            한다. 이러한 어셈블링을 위해서 <B
CLASS="EMPHASIS"
>as</B
>가 제공된다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># as exit.s -o exit.o
            </PRE
></TD
></TR
></TABLE
>
            <B
CLASS="EMPHASIS"
>as</B
>는 소스파일인 exit.s를 번역해서 그 결과를 
            exit.o라는파일에 쓴다. exit.o와 같은 번역된 결과를 담고 있는 파일을 
            <B
CLASS="EMPHASIS"
>object file</B
>라고 부른다. 오브젝트 코드는 기계어로 
            이루어져 있다. 오브젝트 코드가 기계어로 이루어져 있으니 이 자체로 완전한 
            프로그램이라고 생각할 수 있겠지만 그렇지는 않다. 대부분의 
            규모가 있는 프로그램들은 여러개의 소스파일로 이루어 지고 이들 소스파일들은
            각각 별개의 오브젝트 파일들을 만들어 낸다. 그러므로 이러한 
            여러개의 오브젝트 파일들을 합쳐서 하나의 실행파일로 만들어야 하는 
            작업이 필요하게 된다. <B
CLASS="EMPHASIS"
>linker</B
>라는 프로그램을 
            이용하면 여러개의 오브젝트 파일을 하나로 합쳐서 커널에서 실행가능한 
            프로그램을 만들어 낼 수 있다. 리눅스는 <B
CLASS="EMPHASIS"
>ld</B
>라는 
            linker프로그램을 제공한다. 다음과 같은 방법으로 오브젝트 파일을 링크 
            시켜서 완전한 프로그램을 만들어 낼 수 있다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># ld exit.o -o exit
            </PRE
></TD
></TR
></TABLE
>
            위의 명령은 오브젝트 파일은 exit.o를 링크시켜서 실행파일인 exit를 
            만들어 낸다. 만약 위의 링크 과정중 에러가 발생했다면 프로그램의 소스코드를
            잘못 작성했을 경우가 대부분이다. 이런 경우 여러분은 소스코드를 주의 
            깊게 살펴서 문제가 된 부분을 수정해야 한다. 소스코드에 대한 수정이 
            이루어 졌다면 다시 assemble 과 link과정을 거쳐야 한다. 
            아무런 문제가 없이 링크까지 성공했다면 다음과 같이 exit 
            <A
NAME="AEN150"
HREF="#FTN.AEN150"
>[1]</A
>

            프로그램을 실행 시킬 수 있다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># ./exit
            </PRE
></TD
></TR
></TABLE
>
            <B
CLASS="EMPHASIS"
>./</B
>는 컴퓨터에게 실행시켜야 하는 프로그램이 일반적인 
            프로그램 실행 경로(PATH)가 아닌 현재 디렉토리에 있음을 알려주기 
            위해서 사용한다. 위의 프로그램을 실행 시켜보면 아무런 변화도 없이 
            다음 프롬프트가 떨어지는 걸 확인 할 수 있을 것이다. 프로그램은 하는일이 
            아무 것도 없는 것 같지만 내부적으로 종료하면서 종료값을 커널에 되돌려 
            주는데, 다음과 같은 방식으로 exit 프로그램의 종료값을 확인할 수 있다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># echo $?
            </PRE
></TD
></TR
></TABLE
>
            아마도 0이 출력될 것이다. 이것은 우리가 만든 exit프로그램 뿐만 아니라 
            다른 모든 프로그램에 공통적으로 적용된다. 모든 프로그램은 정상적으로 
            주어진 일을 해결하고 종료 했을 때는 0을 리턴하고 실패했을 경우 0이외의 
            다른 숫자를 리턴한다. 이 프로그램 종료값을 이용해서 프로그래머는 
            실행시켰던 프로그램이 일을 제대로 수행했는지 아니면 어떤 오류가 발생했는
            지를 확인할 수 있게된다. 0은 정상종료, 1은 파일열기 실패, 2는 잘못된 
            계산 등으로 정의해서 각 상황에 맞게 종료값을 넘기고 종료하면 된다. 
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="INTROASSEMBLY"
></A
>3.2. 어셈블리 프로그램의 개요</H2
><P
>            exit.s를 보면 많은 줄이 <B
CLASS="EMPHASIS"
>#</B
>처리 되어 있는걸 볼 수 있다. 
            이것은 주석이라고 불리운다. 주석은 어셈블러에 의해서 해석 되지 않는 
            부분으로 주로 프로그래머에게 프로그램 코드에 대한 설명, 힌트등을 
            명시해서 프로그래머가 좀더 쉽게 코드를 파악할 수 있도록 하기 위해서 
            사용된다. 잘 작성된 주석은 프로그램을 만들어낸 당사자 뿐만 아니라 
            프로그램을 읽어야 하는 다른 (팀동료등과 같은)프로그래머에게 많은 도움을 
            준다. 잘 작성된 주석은 다음과 같은 요소들을 가진다.   
            <P
></P
><UL
><LI
><P
>                    코드가 하는일
                </P
></LI
><LI
><P
>                    코드의 대략적인 흐름
                </P
></LI
><LI
><P
>                    주의를 기울여야 할만한 여러가지 특이사항들    
                    <A
NAME="AEN166"
HREF="#FTN.AEN166"
>[2]</A
>
                </P
></LI
></UL
>    
        </P
><P
>            몇 개의 주석후에 다음과 같은 줄이 등장한다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.section .data
            </PRE
></TD
></TR
></TABLE
>
            
        </P
><P
>            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.section .text
            </PRE
></TD
></TR
></TABLE
>
            텍스트 섹션이 시작함을 알린다. 텍스트 섹션에는 프로그램 명령
            (어셈블리 코드가 위치한다) 
        </P
><P
>            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.globl _start
            </PRE
></TD
></TR
></TABLE
>
        </P
><P
>_start:
        </P
><P
>            이제 실제적인 커퓨터 명령이 등장한다. 처음 등장한 명령은 
            다음과 같다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl $1, %eax
            </PRE
></TD
></TR
></TABLE
>
            프로그램이 실행되었을 때 이명령은 숫자1을 %eax 레지스터에 넣어라고 
            해석한다. 어셈블리어에 사용되는 많은 명령은 오퍼랜드(operands)를 
            가진다. 위의 movl명령은 <B
CLASS="EMPHASIS"
>source</B
>와 
            <B
CLASS="EMPHASIS"
>destination</B
> 두개의 오퍼랜드를 가진다. 
            이 경우 source는 숫자 1이 되고 destination은 %eax레지스터가 
            된다. 오퍼랜드는 숫자, 참조 메모리 위치 혹은 레지스터가 
            올 수 있다. 명령은 그 종류에 따라서 각각 다른 형식의 오퍼랜드를 
            가지게 된다. 각 명령이 가질 수 있는 오퍼랜드의 정보는 
            Appendix B를 참고하기 바란다.  
        </P
><P
>            명령에 따라서 오퍼랜드의 형식이 달라지긴 하지만, 대부분의 
            명령은 2개의 오퍼랜드를 가진다. 첫번째로 등장하는 오퍼랜드를 
            source 오퍼랜드, 두번째로 등장하는 오퍼랜드를 destination 오퍼랜드
            라고 한다. 이런류의 명령으로는 addl, subl, imul등이 있다. 
            이들 명령은 각각 "더하기","빼기","곱하기" 연산을 하며 
            source 오퍼랜드로 부터 destination 오퍼랜드로 연산을 하고 결과는 
            destination 오퍼랜드에 저장된다. 
        </P
><P
>            x86프로세스는 movl명령에 이용할수 있는 여러개의 general-purpose 
            레지시트럴 가지있다. 
            <P
></P
><UL
><LI
><P
>                    %eax    
                </P
></LI
><LI
><P
>                    %ebx
                </P
></LI
><LI
><P
>                    %ecx    
                </P
></LI
><LI
><P
>                    %edi
                </P
></LI
><LI
><P
>                    %esi
                </P
></LI
></UL
>
            이들 gerneal-purpose 레지스터와 함께 몇개의 special-purpose 
            레지스터도 가지고 있다.  
            <P
></P
><UL
><LI
><P
>                    %ebp
                </P
></LI
><LI
><P
>                    %esp
                </P
></LI
><LI
><P
>                    %eip
                </P
></LI
></UL
>
            이들 레지스터중에는 %eip와 %eflags와 같은 특별한 명령에만 
            접근가능한 레지스터들이 있다. 우선은 이정도만 설명하도록 하겠다.
            더 자세한 내용은 나중에 설명할 기회가 있을 거이다.  
        </P
><P
>            이제 <B
CLASS="EMPHASIS"
>movl</B
>명령은 숫자 1을 %eax레지스터로  
            옮기는 작업을 수행함을 이해했을 것이다. 1앞에 보면 달러표시가 
            있는데, 이는 immediate mode addressing을 이용할 것을 명시하기 
            위해서 사용한다. 달러표시가 없다면 direct addressing을 이용하게 
            되고 주소 1에 있는 어떤 값을 읽어 들이게 된다. 우리는 실제 숫자 
            1을 읽어들이기를 원하므로 immeiate mode를 사용했다.    
        </P
><P
>            우리가 숫자 1을 %eax에 옮긴 이유는 특정작업을 위해서 Linux 
            커널을 준비시키기 위함이다. 숫자 1은 시스템 콜(system call)
            번호 1번인 <B
CLASS="EMPHASIS"
>exit</B
>를 가리킨다. 시스템콜은 
            운영체제에 어떤 도움을 요청하기 위해서 사용되는 것이다. 시스템콜에 
            대해서는 조만간 자세히 다루게 될 것이다. 파일을 열거나 
            메모리 할당을 요청하거나 하기 위해서는 해당 시스템 콜에 매핑되는     
            번호를 %eax에 써주면 된다. 이들 시스템 콜 번호는 운영체제마다 
            약간씩 다르다.   
        </P
><P
>            운영체제에 어떤 일을 요청하기 위해서 시스템 콜을 사용한다고 
            했는데, 시스템콜 번호 만으로 할 수 있는 일은 존재하지 않는다. 
            어떤 요청을 수행하도록 하기 위해서는 커널에 좀더 많은 정보를 
            알려줘야 한다. 파일을 여는 것을 예로 들어보면 "파일을 열어라"라는 
            요청 외에도 파일이름이 무언지, 어떤 상태로 열건지 등을 커널에게 
            알려주어야만 한다. 이러한 부가적인 정보를 parameters(인자)라고 
            부르며 이들 값 역시 레지스터를 통해서 커널에 전달된다. 
            exit 시스템콜의 경우 컨널은 인자로 종료값을 요구한다. 이 값은 
            %ebx에서 읽혀 진다. 이 종료 값은 시스템에 리턴되어질 것이고 
            여러분은 <B
CLASS="EMPHASIS"
>echo $?</B
>를 통해서 리턴값을 읽을 수 
            있게 된다. %ebx에 0을 올리기 위해서는 다음과 같은 코드가 필요하다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl %0, %ebx
            </PRE
></TD
></TR
></TABLE
>
            리눅스는 시스템콜을 만들기 전에 인자의 값을 읽기 위해서 
            레지스터의 값을 요구한다. %eax는 언제나 시스템콜 번호를 올리기 
            위해서 사용되며 인자를 올리기 위해서 다른 레지스터들을 사용하게 
            된다. exit 시스템콜에서 보면 종료 상태를 저장하기 위해서 
            %ebx를 필요로 함을 알 수 있다. 각각의 시스템콜이 필요로 하는 
            인자의 갯수가 서로 다르다. 이들에 대한 정보는 Appendix C를 
            참고하기 바란다.  
        </P
><P
>            다음으로 아래와 같은 상당히 수상한 명령이 내려진다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>int $0x80
            </PRE
></TD
></TR
></TABLE
>
            int 는 C에서 정수형을 나타내는 int가 아니다. 
            <B
CLASS="EMPHASIS"
>interrupt</B
>의 줄임말이니 혼동하지 않도록 하자. 
            0x80은 사용할 인터럽트의 번호다.
            프로그램의 수행중 <B
CLASS="EMPHASIS"
>interrupt</B
>가 걸리게 되면 
            프로그램의 제어가 커널로 넘어가게 되고 커널은 프로그램이 요청한 
            시스템콜을 수행하게 된다. 이것은 배트맨에게 구조요청을 하기 위해서 
            신호를 보내는 과정과 같다. 여러분은 필요에 의해서 배트맨에게 
            신호를 보내고 배트맨은 여러분을 구조하러 온다. 구조가 된후에는 ?
            물론 일상생활로 되돌아 가게 될것이다. 마찬가지로 
            커널이 필요한 일을 마치게 되면 제어권은 프로그램으로 다시 넘어
            가게 된다. 만약 interrupt 신호를 사용하지 않는다면 어떠한 시스템 
            콜도 수행되지 않을 것이다.  
        </P
><P
>            이제 남은 일은 코드를 assemble시키고, 링크 시키고 실행하는 
            일이다. 테스트를 위해서 어셈블리 코드의 %ebx를 다른 값으로 
            바꾼후 <B
CLASS="EMPHASIS"
>echo $?</B
>의 출력값이 변하는걸 확인해 
            보기 바란다. 당연하지만 %ebx값을 변경한다음에는 
            assemble-&#62;링크-&#62;실행 과정을 거쳐야 변경된 내용이 적용된다.  
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="PLANNINGTHEPROG"
></A
>3.3. Planning the Program</H2
><P
>            이번 프로그램은 좀더 복잡한 일을 하게된다. 여러개의 숫자가 
            주어지고 이중 가장 큰 숫자를 찾는 일을 하는 프로그램이다. 
            컴퓨터는 프로그래머가 필요한 모든것을 세밀하게 지정해줘야 하는 
            기계다. 그러므로 원하는데로 작동하는 프로그램을 작성하기 원하다면 
            작성전에 프로그램에 대한 명세서를 만들어 주어야 한다. 
            우리가 만들고자 하는 프로그램은 다음과 같은 명세에 대한 정의가 
            있어야 할 것이다.  
            <P
></P
><OL
TYPE="1"
><LI
><P
>                    숫자의 목록을 어디에 저장할 것인가.        
                </P
></LI
><LI
><P
>                    가장 큰 숫자를 찾기 위해서 어떠한 프로시져를 필요로 하는가.
                </P
></LI
><LI
><P
>                    프로시져를 수행하기 위해서 어느정도의 공간을 필요로 하는가
                </P
></LI
><LI
><P
>                    공간은 레지스터에서 확보할 것인가 아니면 메모리를 이용할 
                    것인가.     
                </P
></LI
></OL
>
            여러분은 몇개의 숫자 중에서 가장 큰 숫자를 찾는 일을 하기 위해서 
            어떤 계획을 세운다거나 하지는 않을 것이다. 이런 일은 그냥 닥치면 
            한번에 쓰윽 보고 가장 큰 숫자를 골라 낼 것이다. 물론 숫자의 
            목록이 많다면 약간의 계획을 세워야 하겠지만 큰 문제가 되지는 
            않을 것이다 - 시간이 좀 걸리긴 하겠지만 -. 우리의 두뇌가 경험과 
            학습에 의해서 거의 반사적으로 그러한 일을 처리하기 때문이다. 
            여러개의 숫자 목록중에 가장 큰 숫자를 찾아야 한다면, 분명 여러분은 
            앞에서 숫자를 읽어 가면서 앞의 숫자 보다 더 크다면 그것을 머리에 
            새겨 두고, 머리에 새겨둔 숫자 보다 더 큰 숫자가 나온다면 숫자를 
            바꿔치기 할 것이다. 결국 마지막 숫자까지 모두 확인한다면 머리에 
            남아 있는 수가 가장 큰 수가 된다. 이러한 과정은 거의 자동으로 
            이루어진다.  
        </P
><P
>            컴퓨터의 경우 이러한 과정을 단계별로 알려주어야 한다. 이러한 
            단계를 명확히 정의 하기 위해서 약간의 계획이 필요하게 된다.   
            우선 가장 큰 숫자를 고르기 위해서 사용될 숫자의 목록이 있을 것이며
            이들 숫자의 목록은 메모리 공간에 저장되어야 할 것이다. 이들은
            <B
CLASS="EMPHASIS"
>data_items</B
>가 가리키는 메모리에 저장하도록 
            계획하겠다. 우리는 또한 숫자목록에서 현재 위치를 읽어 올 수 있어야
            한다. 그래야 검토해야할 숫자를 읽어 올 수 있기 때문이다. 그리고 
            가장큰 숫자를 저장하기 위한 공간도 마련되어야 한다. 이들 숫자
            정보를 저장하기 위해서 다음과 같은 레지스터를 사용하도록 계획했다. 
            <P
></P
><UL
><LI
><P
>                        %edi 는 목록에서 현재의 위치를 저장한다. 
                    </P
></LI
><LI
><P
>                        %ebx 는 현재 목록에서 가장 큰 숫자를 저장한다. 
                    </P
></LI
><LI
><P
>                        %eax 는 검토할 숫자를 저장하기 위해서 사용한다. 
                    </P
></LI
></UL
>
            한 가지 예외적으로 처리해야할 숫자가 있는데, 바로 목록의 가장 
            처음 가져온 숫자이다. 이 숫자는 다른 어떤 숫자와도 비교할 수 
            없으므로 자동적으로 가장 큰 숫자가 되어야 할것이다. 이러한 
            손쉬운 수행을 위해서 현재 위치가 가리키는 숫자를 0으로 하면 
            된다. 그러면 목록의 처음 숫자는 0과 비교되고 현재 시점에서 가장 
            큰 숫자로 %ebx에 저장될 것이다. 그 다음에는 목록의 다음 숫자와 
            배교하면 된다. 이러한 과정을 순서대로 기술해 보도록 하자. 
            <P
></P
><OL
TYPE="1"
><LI
><P
>                    목록의 처음 숫자가 0인지 확인한다.
                </P
></LI
><LI
><P
>                    만약 0이라면 종료(exit)한다.
                </P
></LI
><LI
><P
>                    현재 위치를 1증가 시킨다(%edi) 
                </P
></LI
><LI
><P
>                    다음 값을 읽어 와서 %eax 레지스터에 값을 저장한다.  
                </P
></LI
><LI
><P
>                    현재 값 %eax와 가장 큰 값 %ebx를 비교한다.   
                </P
></LI
><LI
><P
>                    만약 현재 값이 최근의 가장 큰 값 보다 크다면 현재 값을 
                    %ebx에 저장한다.  
                </P
></LI
><LI
><P
>                    반복한다.
                </P
></LI
></OL
>
            이것을 프로시져(procedure, 의사진행)이라고 한다. 프로시져를 
            작성하다 보면 매우 자주 <B
CLASS="EMPHASIS"
>만약(if)</B
>라는 단어가 
            등장함을 볼 수 있다. 이것은 진행(흐름)을 분기 시키기 위해서 
            사용한다. if 다음에 주어진 조건을 만족하느냐 그렇지 않느냐에 
            따라서 수행하는 명령이 달라지게 된다. 
            2 번을 보면 %eax의 값이 0인지 아닌지에 따라 흐름을 분기 시키고 
            있음을 알 수 있다. %eax가 0이라는 것은 우리가 처음 설정했던 
            데로 목록을 끝을 나타내는 것이므로 더이상 흐름을 진행 시킬 
            필요가 없기 때문이다. 0이 아니라면 목록의 다음 값을 가리키도록 
            하고 4, 5, 6을 진행하면서 
            이전의 가장 큰값과 비교해서 더 큰 값을 %ebx에 저장한다. 
            그리고 프로그램은 아직 목록의 마지막까지 숫자들을 조사하지 않았
            으므로 다시 2 번으로 가서 지금까지의 비교작업을 반복한다.  
        </P
><P
>            if 의 흐름을 분기한다는 특성 때문에 
            <B
CLASS="EMPHASIS"
>흐름제어(flow control)</B
>명령이라고 
            부른다. 이전에 다루었던 첫번째 어셈블리 프로그램은 어떠한 
            흐름제어 명령도 포함하고 있지 않았다. 단지 하나의 흐름만이 
            존재했었기 때문이다. 그러나 이 프로그램은 좀더 다양한 방법으로 
            데이터를 다루어야 하기 때문에 흐름제어 명령이 필요해 지게 된다.  
        </P
><P
>            흐름제어 명령 외에도 이프로그램이 완성되기 위해 2개의 다른 
            새로운 명령들이 사용될 것이다. conditional jump와 unconditional jump가
            그것인데, conditional jump는 조건 점프로 조건을 만족하는지를 판단해서 
            특정 루틴으로 이동하기 위해서 사용한다. uncoditional jump는 무조건 점프로 
            조건의 만족과 관계없이 지정한 루틴으로 이동시킨다. 이들 jump에 대한 
            자세한 내용은 다음 장에서 다루게 될 것이다. 
        </P
><P
>            흐름제어를 위해 사용되는 또다른 장치는 루프(loop)이다. 루프는 
            반복적으로 실행되는 코드의 조각을 말한다. 예를 들어 우리가 
            작성할 프로그램은 처음에 0과 목록의 첫번째 값을 비교해서 
            가장 큰값으로 목록의 첫번째 값을 최고값으로 등록시키고 
            그 다음에는 목록의 두번째 값과 현재 최고값을 비교하는 식으로 
            동일한 일을 계속(목록의 마지막 숫자인 0에 도달할 때까지) 반복할 것이다. 
            이러한 반복작업의 처리를 위해서 루프를 사용하게 된다. 
            루프의 반복을 위해서 여기에서는 unconditional jump를 사용하고 있다. 
             루프 코드 영역의 마지막에 도달하면 무조건 루프 코드의 처음으로 돌아간다. 
            루프코드의 처음에서는 목록에서 숫자를 가져오고 0인지 아닌지를 판단한다음 
            0이라면 루프를 빠져나가기 위해서 jump를 시도할 것이다. 이때의 jump는 조건의 
            판단후에 이루어 지므로 conditional jump가 필요하게 된다.
        </P
><P
>            다음장에서는 지금까지의 계획을 실제 프로그램의 작성에 적용할 것이다. 
            이 프로그램은 간단하지만 프로그램으로써 가져야할 대부분의 기본요건을 
            가지고 있으므로 제대로 이해한다면 앞으로 이 문서를 읽는데 큰 도움이 
            될것이다.  
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="FINDMAXNUMBER"
></A
>3.4. 최대 숫자 찾기</H2
><P
>            코드의 이름은 maximum.s로 한다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># data_items에 있는 숫자의 목록중 가장 큰
# 데이터를 얻어와서 리턴한다.
#

# 변수들 : 프로그램의 작동을 위해서 사용되는 레지스터들
# %edi - 데이타 목록에서 조사할 숫자의 인덱스 저장용
# %ebx - 가장 큰 숫자 저장용
# %eax - 현재 비교할 숫자 저장용
#

# The following memory locations are used:
#
# data_items - 비교할 숫자데이터들 0은 마지막을 나타낸다.
#

.section .data

data_items:                         # 숫자 데이터들
    .long 3,67,34,222,45,75,54,34,44,33,22,11,66,0 
    .section .text
    .globl _start

_start:
    movl $0, %edi                   # move 0 into the index register
    movl data_items(,%edi,4), %eax  # load the first byte of data
    movl %eax, %ebx                 # since this is the first item, %eax is
                                    # the biggest

start_loop:                         # start loop
    cmpl $0, %eax                   # check to see if we ve hit the end
    je loop_exit
    incl %edi                       # load next value
    movl data_items(,%edi,4), %eax
    cmpl %ebx, %eax                 # compare values
    jle start_loop                  # jump to loop beginning if the new
                                    # one isn t bigger
    movl %eax, %ebx                 # move the value as the largest
    jmp start_loop                  # jump to loop beginning
loop_exit:                          # %ebx is the return value,
                                    # and it already has the number

    movl $1, %eax                   #1 is the exit() syscall
    int $0x80
            </PRE
></TD
></TR
></TABLE
>
        </P
><P
>            이제 어셈블과 링크를 이용해서 실행파일을 생성하자.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># as maximum.s -o maximum.o
# ld maximum.o -o maximum
            </PRE
></TD
></TR
></TABLE
>
            실행 후 결과를 확인해보도록 하자. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># ./maximum
# echo $?
            </PRE
></TD
></TR
></TABLE
>
            222가 출력된것으로 위의 프로그램이 최대 숫자를 제대로 골라낸 걸 
            확인할 수 있을 것이다. 그럼 위의 코드를 한줄씩 분석해 보도록 하자. 
            데이터 섹션에서 가장 먼저 만나는 코드는 아래와 같다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>data_items:                         # 숫자 데이터들
    .long 3,67,34,222,45,75,54,34,44,33,22,11,66,0 
            </PRE
></TD
></TR
></TABLE
>
            <B
CLASS="EMPHASIS"
>data_items</B
>는 숫자 데이터들이 저장된 위치에 
            대한 참조라벨이다. 실제 데이터가 정의된 코드에서는 .long 를 이용해서 
            저장될 데이터의 형(type)를 명시하고 있다. 그래야 제대로된 메모리 할당이
            이루어질 수 있기 때문이다. 이제부터 data_items는 데이터의 첫번째 영역을 
            가리킨다. data_items가 데이터의 첫번째 영역을 가리키고 있기 때문에 
            우리는 data_items에 대한 간단한 연산으로 숫자 데이터들을 이용할 수 있다. 
            예를 들어서 movl data_items, %eax 명령을 내리면 3이 %eax 레지스터에 
            저장된다. 어셈블리어는 .long 외에도 다음과 같은 여러가지 데이터형을 
            제공한다. 
            <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>.byte</DT
><DD
><P
>                    1byte의 데이터값을 명시한다. 0-255범위의 값을 사용할 수 있다. 
                    </P
></DD
><DT
>.int</DT
><DD
><P
>                    2byte의 데이터값을 명시한다. 0-65535범위의 값을 사용할 수 있다.    
                    </P
></DD
><DT
>.long</DT
><DD
><P
>                    4byte의 데이터값을 명시한다. 0-4294967295범위의 값을 사용할 수 있다.    
                    </P
></DD
><DT
>.ascii</DT
><DD
><P
>                    메모리에 문자열을 직접 저장하기 위해서 사용한다. 각각의 문자는 
                    1byte의 공간을 차지한다. 만약 .ascii "Hello there\0" 로 
                    정의 했다면 어셈블러는 12byte의 공간을 확보하고 확보된 공간에 위의 
                    문자열을 저장하게 된다. 첫번째 위치에는 <B
CLASS="EMPHASIS"
>H</B
>가 
                    두번째 위치에는 <B
CLASS="EMPHASIS"
>e</B
>가 저장된다. 제일 마지막에는 
                    '\0'이 저장되는데, 이 값은 화면에 출력되지 않고 단지 문자열의 
                    마지막 이라는 것을 알려주기 위해서 사용한다. 이외에도 탭과 
                    개행문자를 표시하기 위해서 '\t'와 '\n'같은 문자들도 사용된다.  
                    </P
></DD
></DL
></DIV
>
            위의 예제의 경우 어셈블러는 숫자의 목록을 저장하기 위해서 4byte * 14 만큼의
            메모리 공간을 확보게 된다.  
        </P
><P
>            숫자의 목록을 저장하는데 있어서 마지막에 0을 사용했다는 것을 주목하기 
            바란다. 이 프로그램에서는 숫자 목록의 마지막이라는 것을 알려주기 
            위해서 0을 사용하고 있다. 숫자 목록의 갯수를 명확히 하기 위해서 
            이밖에도 숫자 목록의 처음에 전체 숫자의 갯수를 적어준다거나 프로그램내에 
            전체 숫자의 갯수를 직접 넣는 방법이 있을 수 있다. 이 외에도 여러가지 
            방법을 통해서 숫자의 갯수를 명시할 수 있을 것이다. 
            이 처럼 목록의 끝을 나타내기 위해서 여러가지 방법들이 동원되는 이유는 
            컴퓨터의 경우 우리가 명확하게 끝을 지정해 주기 전에는 
            목록의 끝이 어딘지 측정 할 수 없기 때문이다. 
        </P
><P
>            이제<B
CLASS="EMPHASIS"
>.globl</B
>에 대해 알아보도록 하자. 이것은 
            어떠한 데이터도 가지지 않으며 단지 프로그램이 시작되는 실행 위치를 
            알려주기 위한 목적으로 사용된다. Linux는 프로그램을 시작하기 위해서 
            어디부터가 실행영역인지를 알고 있어야 하며 _start 부터 실행한다. 
            .globl은 _start를 참조시킨다. 
            .globl을 생략할 경우 링크시 다음과 같은 에러가 발생할 것이다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># ld maximum.o -o maximum
ld: warning: cannot find entry symbol _start; defaulting to 08048074
            </PRE
></TD
></TR
></TABLE
>
        </P
><P
>            이 걸로 해서 우리가 사용할 모든 데이터의 준비를 마쳤으니, 이제 본격적으로 
            데이터를 이용해서 필요한 작업(가장 큰 숫자를 가려내는)을 해야 한다. 
            위 코드를 보면 <B
CLASS="EMPHASIS"
># 변수들</B
>라고 되어 있는 주석을 
            볼 수 있을 것이다. 이들 변수는 작업을 위해서 사용되는 데이터들을 
            저장하기 위한 용기로 사용한다. 이 프로그램은 다음과 같은 변수들이 
            사용된다.  
            <P
></P
><OL
TYPE="1"
><LI
><P
>                    최근의 최대값을 저장하기 위한 변수 
                </P
></LI
><LI
><P
>                    숫자 목록에서 가져와야할 숫자의 위치를 저장하기 위한 변수 
                </P
></LI
><LI
><P
>                    숫자 목록에서 가져온 숫자를 저장하기 위한 변수
                </P
></LI
></OL
>
            우리가 만든 프로그램은 매우 간단하므로 단지 몇개의 변수만 하용하면 되며, 
            레지스터리만으로 이들 변수를 담아낼 수 있다. 그러나 프로그램이 커지고
            거기에 따라서 다루어야하는 데이터양이 커질 경우 레지스터만으로 모든 
            작업을 할 수 없게 된다. 여기에 대해서는 나중에 다루게 될것이다.  
        </P
><P
>            이 프로그램에서 가장 큰 숫자를 저장하기 위해서 %ebx를 사용했다. %edi는
            현재 가져와야할 숫자의 위치(index)를 저장하기 위해서 사용한다. %edi를 
            이용해서 우리는 data_items로 부터 몇 번째 숫자를 읽어와야 할지를 
            결정할 수 있게 된다. 프로그램이 막 시작했을 때는 data_items의 첫번째 
            숫자를 가져와야 되므로 %edi는 0이 입력된다. 첫번째 숫자를 가져왔다면 
            %edi에는 1이 들어가고, 다음 숫자를 가져올 때는 data_items의 두번째 
            숫자를 가져오게 된다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl  $0, $edi
            </PRE
></TD
></TR
></TABLE
>
            %edi는 데이터 목록의 몇번째 데이터를 가져와야 하는지만을 알려주는 
            인덱스 이다. 우리는 이 인덱스 값을 이용해서 data_items로 부터 값을 
            가져와야 하는데 다음과 같은 같단한 연산이 사용된다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl data_items(,%edi,4), %eax
            </PRE
></TD
></TR
></TABLE
>
            다음은 목록으로 부터 숫자를 가져오고 최고값을 저장하는 루틴이다. 
            <P
></P
><OL
TYPE="1"
><LI
><P
>                    <B
CLASS="EMPHASIS"
>data_items</B
>는 우리가 계산에 사용할 숫자 목록의 
                    첫번째 숫자를 가르킨다.
                </P
></LI
><LI
><P
>                    숫자목록의 숫자들은 .long 형이므로 4byte의 크기를 차지한다.         
                </P
></LI
><LI
><P
>                    각 숫자가 차지하는 공간이 4byte인 것을 이용해서 다음 숫자를 
                    가져올 수 있다.  
                </P
></LI
><LI
><P
>                    우리는 지금 숫자와 다음 숫자를 비교해서 최고 큰 숫자를 알아낼 수 있다. 
                </P
></LI
><LI
><P
>                    가장 큰 숫자는 우리가 준비한 레지스터에 복사한다.    
                </P
></LI
><LI
><P
>                    다시 처음으로 되돌아 간다.
                </P
></LI
></OL
>
            위의 루틴을 보면 처음으로 되돌아 간다고 되어 있다. 처음이라 함은 
            루프의 처음인 <B
CLASS="EMPHASIS"
>start_loop</B
>이 된다. 루프의 처음으로 
            되돌아 간다. 루프의 처음에는 다음과 같은 명령이 들어 간다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cmpl  $0, %eax 
je    end_loop
            </PRE
></TD
></TR
></TABLE
>
            <B
CLASS="EMPHASIS"
>cmpl</B
>은 2개의 값을 비교하기 위한 명령이다. 
            여기에서 우리는 0과 %eax에 저장된 값을 비교하고 있다. 비교를 했다면 
            비교에 대한 결과가 있을 것이다. 이 결과는 %eax레지스터가 아닌 
            <B
CLASS="EMPHASIS"
>%eflags</B
>레지스터에 들어간다. 이 레지스터는 
            상태(status) 레지스터라고도 불리우운다. 자세한 내용은 
            나중에 다루도록 하겠다. 어쨋든 비교된 결과는 %eflags에 저장되고 
            저장된 값은 다음 코드에서 점프를 할지 안할지를 판단하기 위해서 사용된다. 
            여기에서는 je가 사용되고 있는데, je는 값이 같을 경우를 참으로 판단한다.
            그래서 %eax의 값이 0으로 서로 같다면 end_loop로 점프를 하게 되고, 그렇지 
            않다면 그냥 다음 라인으로 넘어가게 된다. 여기에서는 점프를 위한 비교 명령으로
            <B
CLASS="EMPHASIS"
>je</B
>를 사용하고 했는데, 이외에도 다양한 비교점프 명령들이 
            존재한다.  
            <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>je</DT
><DD
><P
>                        두개의 값이 같으면 점프하라.
                    </P
></DD
><DT
>jg</DT
><DD
><P
>                        두번째 값이 첫번째 값보다 크면 점프하라.
                    </P
></DD
><DT
>jge</DT
><DD
><P
>                        두번째 값이 첫번째 값보다 크거나 같으면 점프하라.
                    </P
></DD
><DT
>jl</DT
><DD
><P
>                        두번째 값이 첫번째 값보다 작으면 점프하라.
                    </P
></DD
><DT
>jle</DT
><DD
><P
>                        두번째 값이 첫번째 값보다 작거다 같다면 점프하라.
                    </P
></DD
><DT
>jmp</DT
><DD
><P
>                        무조건 점프한다.
                    </P
></DD
></DL
></DIV
>
            이들 점프와 관련된 명령들의 목록은 Appendix B를 참고하기 바란다. 
            우리가 만든 프로그램에서는 0과 %eax의 값이 같을 경우 점프하도록 
            코딩되어 있다. %eax가 0과 같다면 즉 목록의 마지막 이라면 loop_exit로
            점프한다.  
        </P
><P
>            만약 숫자목록에서 가져온 숫자가 0이 아니라면 다음 명령이 실행된다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>incl  %edi 
movl  data_item(,%edi,4),   %eax
            </PRE
></TD
></TR
></TABLE
>
            이전의 내용들을 주의 깊게 읽어왔다면 %edi가 data_items의 목록의 
            인덱스를 저장하고 있다는 것을 기억할 것이다. 이제 다음 데이터 값을 
            인덱스 해야 하므로 %edi를 1만큼 증가 시켰다. 이쯤 되었다면 movl로 하는
            일을 짐작했을 것이다. data_item에서 %edi 위치만큼 이동해서 데이터를 
            가져오고 이것을 %eax에 복사하는 일을 한다. data_item에 있는 각 데이터의
            크기는 4바이트 이므로 4바이트만큼을 %eax에 복사하고 있다.  
        </P
><P
>            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cmpl %ebx, %eax
jle  start_loop
            </PRE
></TD
></TR
></TABLE
>
            이제 %ebx와 %eax를 비교한다. %ebx는 현재까지 찾아낸 가장큰 숫자가 들어 
            있다. 만약 현재 값이 이전 최고값보다 작거나 같다면 
            <B
CLASS="EMPHASIS"
>start_loop</B
>로 점프한다.   
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl %eax, %ebx
jmp  start_loop
            </PRE
></TD
></TR
></TABLE
>
            만약 현재 값이 이전 최고값보다 크다면 %ebx에 복사하고 
            <B
CLASS="EMPHASIS"
>start_loop</B
>로 점프한다.  
            이제 0을 만날때까지 위의 루틴을 반복한다. 만약 0을 만나면 
            <B
CLASS="EMPHASIS"
>loop_exit</B
>로 점프한다. 마지막 부분에서 
            이 프로그램은 리눅스 커널의 exit를 호출하게 된다. 시스템콜의 호출은 
            %eax에 저장되어 있는 번호를 통해서 호출된다. exit시스템콜의 번호는 
            1번이므로 다음과 같은 코드가 필요하다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl $1, %eax
int  0x80 
            </PRE
></TD
></TR
></TABLE
>
        </P
><P
>            이것으로 우리가 작성한 프로그램에 대한 모든 설명을 마쳤다. 매우 
            간단한 프로그램이였지만 상당히 많은 것을 배울수 있었다. 간단한 
            프로그램 이므로 이해에는 큰 어려움이 없었을 것이다. 이해가 되지 
            않는 부분이 있다면 주석과 함께 프로그램을 주의 깊게 읽어 보기 
            바란다. 좀더 완벽하게 이해하고 싶다면 프로그램의 각 스텝별로 
            레지스터의 값의 변화를 기록해가면서 코드를 확인해 보기 
            바란다. 
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="ADDRESSINGMODE"
></A
>3.5. Addressing mode</H2
><P
>            우리는 2장에서 어셈블리어가 2가지 종류의 데이터 접근 방법
            (Data Accessing Methods)를 가진다는 것을 배웠다. 이번 장에서는 
            이러한 어셈블리어에서 제공하는 어드레스 기반의 데이터 접근 방법에 
            대해서 알아보도록 하겠다.   
        </P
><P
>            메모리 주소를 참조하는 일반적인 형식은 다음과 같다.    
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>ADDRESS_OR_OFFSET(%BASE_OR_OFFSET, %INDEX, MULTIPLIER)
            </PRE
></TD
></TR
></TABLE
>
            위의 모든 필드들은 필수사항이 아닌 옵션사항들이다. 다음은 
            위의 필드들의 값을 이용해서 주소를 계산해내는 방법이다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>FINAL ADDRESS = ADDRESS_OR_OFFSET + %BASE_OR_OFFSET + MULTIPLIER * %INDEX
            </PRE
></TD
></TR
></TABLE
>
            <B
CLASS="EMPHASIS"
>ADDRESS_OR_OFFSET</B
>와 <B
CLASS="EMPHASIS"
>MULTIPLIER</B
>
            모두 상수로 레지스터다. 만약 어떤 값도 없다면, 0이 사용된다.
        </P
><P
>            Addressing mode는 2장의 Data Accessing Method에서 이미 언급한적이 
            있지만 복습차원에서 간단히 설명하도록 하겠다.
            <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>direct addressing mode</DT
><DD
><P
>                    이것은 단지 ADDRESS_OR_OFFSET 만 사용한다. 다음은 사용예이다.
                    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl ADDRESS, %eax
                    </PRE
></TD
></TR
></TABLE
>
                    %eax에는 메모리 주소 ADDRESS의 값이 직접 복사된다.
                    </P
></DD
><DT
>index addressing mode</DT
><DD
><P
>                    ADDRESS_OR_OFFSET과 %INDEX가 모두 사용된다. 인덱스 레지스터에는
                    어떤 종류의 일반목적(general-purpose) 레지스터라도 사용할 
                    수 있다. 인덱스 레지스터에는 1, 2, 4의 배수가 올 수 있는데, 
                    이렇게 되므로써 byte, double-byte, words의 어떠한 인덱스라도 
                    쉽게 계산할 수 있다. 예를 들어서 문자열이 들어 있는 
                    string_start 변수가 있는데 여기에서 3번째 문자를 가져오고 
                    싶다면 다음과 같이 코드를 만들면 된다.
                    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl string_start(,%ecx,1), %eax
                    </PRE
></TD
></TR
></TABLE
>
                    물론 이경우 %ecx에는 인덱스값인 3이 들어있어야 할것이다. 
                    ADDRESS_OR_OFFSET 필드가 비어 있으므로 여기에는 0이 들어간다. 
                    즉 string_start의 처음주소를 가리킨다. 인덱스인 %ecx가 3이므로  
                    string_start의 3번째 주소를 가리키고, MULTIPLIER가 1이므로 
                    1byte만큼 %eax로 복사된다.
                    </P
></DD
><DT
>(간접)indirect addressing mode</DT
><DD
><P
>                        레지스터의 주소로 부터 값을 직접 읽어들인다. 예를들어 
                        %eax의 값을 %ebx로 복사하고 싶다면 다음과 같이 하면 된다. 
                        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl (%eax), %ebx
                        </PRE
></TD
></TR
></TABLE
>
                        </P
></DD
><DT
>base-pointer addressing mode</DT
><DD
><P
>                            레지스터주소 값에 상수값을 더한다는 것을 제외하고는 
                            간접주소 지정방식과 매우 비슷한 방식이다. 예를 들어 당신이 
                            어떤 레코드로 부터 4바이트의  
                        </P
></DD
><DT
>immediate mode</DT
><DD
><P
>                        Immediate mode는 매우 간다하다. 원하는 값을 레지스터나 메모리 영역으로 
                        직접 저장하는 방식이다. 예를 들어 %eax에 12라는 값을 저장하기 원한다면 
                        다음과 같이 Immediate mode를 이용해서 간단하게 처리할 수 있다.  
                        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl $12,  %eax
                        </PRE
></TD
></TR
></TABLE
>
                        Immediate mode를 이용할 때 숫자 앞에 달러($)표시가 사용되고 있음을 
                        주목하도록 하자. 만약 달러표시를 생략하게 될경우 direct addressing mode로 
                        연산을 시도하게 된다. 이렇게 되면 12가 %eax에 저장되는게 아니고 12의 
                        메모리 위치에 있는 값이 저장되어서 전혀 엉뚱한 결과를 가져오게 된다. 
                        </P
></DD
><DT
>register addressing mode</DT
><DD
><P
>                        간단하게 하나의 레지스터를 다른 레지스터로 복사하기 위해서 
                        사용한다. 
                        </P
></DD
></DL
></DIV
>
            메모리의 데이터를 제어하는데 있어서 위의 모드들 중 하나가 사용되므로 
            어드레싱 모드에 대해서 이해하는 것은 매우 중요하다. Immediate mode를 제외한 
            모든 모드들은 소스(source)나 목적지 오퍼랜드를 모두 이용할 수 있다. 반면 Immediate 
            mode는 단지 소스 오퍼랜드만 이용한다. 
        </P
><P
>            각각의 모드들을 이용해서 메모리 복사와 같은 일을 하다 보면.. 
            다양한 크기의 데이터를 복사해야 하는 경우가 생길 것이다. 
            어셈블리는 이러한 경우를 대비하여서 자주 사용하는 데이터 크기에 대해서
            사용가능한 명령들을 준비하고 잇다. 워드 단위의 데이터 복사를 
            원한다면 <B
CLASS="EMPHASIS"
>movl</B
>를 사용하고, 바이트 단위로의 
            복사를 원하다면 <B
CLASS="EMPHASIS"
>movb</B
>를 사용할 수 있다. 그러나 
            앞에서 다루었다 시피 데이터를 저장하기 위한 최소단위로 레지스터를 
            사용하는데 크기가 워드단위이다. 그러므로 바이트단위로 다루고자 
            할경우 레지스터의 일정영역만을 사용할 수 있게된다(어떻게 보면 나머지 
            공간을 낭비하는 결과를 가져온다고 볼 수 있다).  
        </P
><P
>            %eax를 예로 들어보도록 하자. 만약 2바이트의 크기를 복사하고자 할때 
            %ax를 사용한다. %ax는 least-significant halt 간단히 말해서
            4바이트 크기의 워드(즉 %eax으)에서의 하위 2바이트의 영역을 가리킨다.
            %ax는 다시 1바이트씩 2개로 나뉠 수 있다. %al과 %ah가 그것으로 
            %al은 %ax의 마지막 바이트 %ah는 %ax의 처음 바이트를 가리킨다.        
            <DIV
CLASS="FIGURE"
><A
NAME="AEN394"
></A
><P
><B
>&#44536;&#47548; 3. %eax 레지스터의 모습</B
></P
><P
><IMG
SRC="http://www.joinc.co.kr/albums/album01/ahn.gif"></P
></DIV
>
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="ASSEMBLYLANGUAGEPROGRAM"
></A
>4. 함수에 대해서 다루기</H1
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="HANDLECOMPLEXPROG"
></A
>4.1. 복잡한 프로그램 다루기</H2
><P
>    
            <A
HREF="#COMPUTERSTRUCTURE"
>2&#51208;</A
>에서 다루었던 프로그램은 어셈블리의 기본적인 
            설명을 위한 매우 단순한 코드들로 이루어져 있으며 단지 하나의 섹션만을 
            가지고 있다. 프로그램이 단순하다면 관계 없지만. 만약 좀 규모있는 
            프로그램을 만들어야 한다면 수천, 수만라인을 작성해야 될지도 모른다. 
            이런 프로그램을 하나의 섹션으로 유지하면 유지보수가 매우 힘들 것이다. 
            특히 여러명의 프로그램이 하나의 프로젝트에 참가할 경우 프로그램의 
            유지 보두는 더욱 힘들게 될것이다.       
        </P
><P
>    
            이렇게 프로그램의 크기가 커지거나 두명이상의 프로그래머가 참가할 때는 
            코드를 하는일에 따라서 몇개의 조각으로 나누어서 관리하면 될것이다. 
            물론 이경우 나중에 조각을 하나로 합치기 편하도록 잘 정의된 
            인터페이스를 만들고 여기에 따라서 자신이 맡은 코드를 작성하도록 
            해야 한다. 이렇게 하면 각 프로그래머는 자신이 맡은 영역만을 
            독립적으로 테스트 할 수 있으므로 프로그래밍의 집중도를 높일 수 
            있게 되고, 다른 프로그래머와 좀더 효율적으로 협업할 수 있게 된다. 
        </P
><P
>    
            이러한 독립적인 개발을 위해서 프로그래머는 <B
CLASS="EMPHASIS"
>함수</B
>라고 
            불리우는 여러개의 코드조각을 만들게 된다. 워드 프로세서를 만든다고 
            가정해보자. 그럼 "가" 개발자는 사용자의 키입력을 처리하는 
            handle_type_chracter 함수를 만들도록 한다. 이 함수는 유저의 키입력을 
            읽어 들여서 그 값을 화면에 출력하는 일을 한다. "나"라는 개발자는 
            check_chracter_spell 이라는 오타검사 함수를 만들도록 한다. 
            이 함수는 handle_type_chracter에 의해서 입력된 문자를 검사해서 
            오타가 발생하는지를 확인하는 일을 한다. 함수는 이렇게 
            주어지는 데이터와 이의 처리하는 루틴단위로 만들어 지게 된다.  
        </P
><P
>            좀 규모있는 프로그램들은 수백에서 수천의 이러한 조그마한 함수들로 
            이루어지게 된다. 이러한 함수들 중에는 개발자가 필요에 의해서 그때 그때     
            만들어 지는 것들도 있지만 시스템에 의해서 제공되는 함수들도 있다. 
            당연하지만 이미 만들어진 함수는 사용자가 다시 만들어서 사용할 수 없다.
            이런 시스템에서 제공하는 함수들을 원시(primitive)함수라고 부른다. 
            예를 들어 그래픽 유저 인터페이스를 지원하는 프로그램을 작성한다고 
            가정해 보자. 여기에는 메뉴를 생성하기 위한 함수가 있을 것이다. 
            이 함수들은 글자를 쓰거나, 아이콘을 배치하거나, 배경의 색을 설정하거나 
            마우스의 위치를 계산하는 함수들이 있을 것이다. 그라나 이러한 함수들 
            외에도 기본적으로 선을 만들거나, 점을 찍거나 하는 등의 가장 기본적인 
            함수들이 있을 것이고 이것들은 운영체제 수준에서 지원하게 될것이다. 
            이러한 함수를 primitive함수라고 보면 된다. 최종적으로 여러분이 
            큰 규모의 프로그램을 작성한다면 이러한 primitive함수들을 가진 작은 
            (사용자 가 만든)함수들의 모임으로 이루어 질 것이다. 이상 일반 
            GUI 애플리케이션을 예로 들어서 설명했는데, GUI 에서의 primitive는 
            어셈블리에서는 시스템콜이다. 여기에서는 시스템콜에 대한 자세한 
            내용을 다루진 않을 것이다. 시스템 콜에 대한 내용은        
            <A
HREF="http://www.joinc.co.kr/modules/moniwiki/wiki.php/article_linux_systemcall_quick_reference"
TARGET="_top"
>리눅스 시스템 콜 퀵 레퍼런스</A
>와
            <A
HREF="http://www.joinc.co.kr/modules/moniwiki/wiki.php/article_Linux_Assembler_하우투"
TARGET="_top"
>리눅스 어셈블리 하우투</A
>를 참고해 보기 바란다.
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="MAKEFUNCTION"
></A
>4.2. 함수 만들기</H2
><P
>            함수는 다음과 같은 요소들에 의해서 만들어진다.
            <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>함수 이름</DT
><DD
><P
>                        어셈블리어에서 함수의 이름은 함수의 코드가 시작하는 
                        주소를 가리키는    심볼(symbol)로 선언되며, 심볼은 함수의 이름 
                        다음에 콜론(":")을 붙이는 걸로 선언된다. 이 뒤에 있는 코드는
                        모두 함수의 코드가 된다. 점프를 위해서 사용되는 라벨과 
                        매우 비슷하게 사용된다.    
                    </P
></DD
><DT
>함수 인자</DT
><DD
><P
>                        함수 인자(parameter)은 함수가 처리해야 하는 데이터 아이템이다.     
                        예를 들어 사칙연산을 수행하는 함수가 있다고 가정해 보자.
                        사칙연산을 위해서는 2개의 피연산자가 필요하다. 그러므로 
                        함수에 2개의 (숫자)데이터를 넘겨줄 수 있어야 한다. 
                        이 함수는 2개의 데이터를 넘겨 받기 위해서 2개의 인자를 
                        필요로 하게 된다.  
                    </P
></DD
><DT
>지역 변수</DT
><DD
><P
>                    지역변수는 함수에셔 연산을 위해 사용되는 데이터를 저장하기 
                    위해서 함수안에서만 사용되는 변수다.   
                    </P
></DD
><DT
>전역 변수</DT
><DD
><P
>                    전역변수는 함수외부에서 관리되어 지는 데이터 저장영역이다.
                    예를 들어 간단한 텍스트 편집기를 만들경우 편집기에서 불러들인 
                    파일의 내용은 저장, 편집, 찾기, 치환등과 관련된 다양한 함수에서 
                    사용될 것이므로 모든 함수에 걸쳐서 (전역적)으로 관리되어져야 할 
                    필요가 있다. 만약 전역 변수가 아니라면 각 함수마다 파일을 열어서 
                    내용을 메모리에 저장하고 작업을 해야 하는 번거로운 코드가 추가 되어야
                    할 것이다.       
                    </P
></DD
><DT
>리턴 주소</DT
><DD
><P
>                    "리턴 값"과 혼동하지 않도록 한다. 리턴 주소는 보이지 않는 인자로 
                    사용되며 함수에서 직접다루지 못하는 값이다. 리턴 어드레스는 함수가 
                    종료된 완전히 종료된 후 실행되어야할 영역의 주소값을 알려준다. 
                    대부분의 프로그래밍 언어에서 리턴 주소는 자동적으로 계산되어서 
                    사용하므로 프로그래머가 특별히 신경쓸 필요가 없다. 반면 
                    어셈블리어에서의 경우 <B
CLASS="EMPHASIS"
>call</B
>명령을 이용해서 
                    제어를 해주어야 한다.  
                    </P
></DD
><DT
>리턴 값</DT
><DD
><P
>                    함수에서 일을 수행한 후의 결과를 메인 프로그램에 전달하기 위해서 
                    사용한다. 대부분의 프로그래밍 언어는 하나의 함수에 대해서 단지 
                    하나의 값만을 리턴할 수 있도록 허용한다.     
                    </P
></DD
></DL
></DIV
>
            이들 특징들은 어셈블리어뿐만 아니라 다른 모든 언어들도 공통적으로 가지고 있다. 
        </P
><P
>            변수를 만들어서 저장하고, 인자를 사용하고, 값을 리턴하는 표현하는 방법은 
            언어마다 다르긴 하지만 언어에 관계없이 공통적으로 사용되어 진다. 그러므로 
            언어에 관계없이 일반적으로 표현이 가능할 것이다. 이러한 표현의 방법을 
            <B
CLASS="EMPHASIS"
>calling convention</B
>라고 부른다. 
        </P
><P
>            calling convention은 매우 다양하며, 자신만의 calling convention을 만들어서
            사용할 수 도 있다. 그렇긴 하지만 다른 만들어진 함수가 다른 언어로 포팅되는 
            것을 고려해야 되는 경우도 있으므로 가능하면 표준적인 calling convention을 
            따르는 것이 좋을 것이다. 여기에서는 C 언어의 calling convention을 따를 것이다.
            왜냐하면 가장 널리 사용되어지는 언어이며 또한 가장 많은 예제 코드를 가지고 
            있기 때문이다. 
            <DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/docbook/images/note.gif"
HSPACE="5"
ALT="&#52280;&#44256;"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>                과거에는 파스칼, C의 calling convention을 주로 사용했지만
                지금은 상황이 좀달라져서 java, c++, python등의 다양한 
                calling convention이 사용되어지고 있다.
            </P
></TD
></TR
></TABLE
></DIV
>
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="ASSEMBLYFUNCTION"
></A
>4.3. C calling convention을 이용한 어셈블리어 함수설명</H2
><P
>            만약 당신이 컴퓨터의 스택이 어떻게 작동하는지에 대한 이해를 가지고 있지 
            않다면 어셈블리어에서 함수를 작성할 수 없을 것이다. 우리가 컴퓨터에서 
            프로그램을 실행시키면, 프로그램은 각각의 함수를 수행하기 위해서 스택영역을 
            확보한다. 스택은 말그대로 더미란 뜻인데, 당신의 작업책상위에 놓인 
            처리해야될 서류더미를 연상하면 된다. 당신은 처리해야할 서류를 서류더미에 
            올려놓고 처리해야될 경우 가장 위에 있는 서류부터 처리하게 될것이다. 
            처리된 서류는 다른 한쪽으로 치우거나.. 기분나쁜 서류의 경우 스레기통에 
            버릴 것이다.
        </P
><P
>            컴퓨터도 마찬가지로 이러한 스택을 가지고 있다. 컴퓨터에서 스택은 메모리의 
            처음위치에 존재한다. 당신은 <B
CLASS="EMPHASIS"
>pushl</B
>명령을 이용해서 스택의
            가장 위에 값을 밀어 넣을 수 있다. 스택의 가장 위에는 레지스터와 다른 값들이 
            들어 갈 수 있다. 우리는 말할 수 있을 것이다. "왜 하필 가장 위에 저장해야하죠?"  
            그 이유는 간단하다. 접시를 씻기 위해서 쌓아 두었을 때 위에서 부터 꺼내서 
            씻는 이유를 생각해보면 된다. 혹은 책상에 쌓여있는 서류의 처리를 생각해 보라. 
            위에서 부터 꺼내어서 처리하는게 아래, 혹은 중간에서 꺼내어서 처리하는 것보다 
            훨씬 쉽다. 컴퓨터에서의 메모리 관리 역시 위에있는 것부터 꺼내어서 가져오는게 
            구조상 훨씬 쉽도록 되어 있다. pushl을 이용해서 스택의 가장 위에 데이터를 
            올렸다면, 이 데이터는 popl을 통해서 가져올 수 있다. popl명령을 이용하면 
            스택의 가장 위에 있는 데이터를 가져오게 된다.
        </P
><P
>            스택에 값을 밀어 넣게되면 현재 스택의 제일 윗부분의 주소를 계산해서 그 위치에
            값을 추가한다. 스택의 제일 위의 위치값은 %esp 레지스터를 통해서 알아올 수 
            있다. 참고로 스택은 언제나 연속적으로 위치하게 되므로 데이터의 크기만 알고 
            있다면 위치를 정확하게 계산할 수 있다.
        </P
><P
>            pushl을 통해서 스텍에 어떤 값을 넣게 되면 스택의 제일 위를 가르키는 포인터에 
            4가 더해져야 한다. 고로 %esp에서 4를 빼면 가장 최근에 저장된 데이터를 읽어올 
            수 있게 된다. (저장되는 데이터는 워드(word)즉 4바이트임을 기억하라).
            만약 스택으로 부터의 데이터 삭제는 <B
CLASS="EMPHASIS"
>popl</B
>명령을 수행하면 
            된다. pushl과 popl은 하나의 오퍼랜드만을 가진다.  
        </P
><P
>            만약 스택의 가장위에 접근하길 원한다면, %esp 레지스터를 
            indirect 어드레스 모드로 접근하면 된다. 다음은 스택의 가장 위에 있는 값을 
            %eax 레지스터로 옮기는 예이다.    
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>    
movl (%esp), %eax
# 혹은
movl %esp, %eax
            </PRE
></TD
></TR
></TABLE
>    
            위의 예는 indirect 모드 이므로 %eax에는 스택의 위에 있는 값이 아닌 스택의
            위의 위치주소가 저장된다. 만약 주소에 저장된 값을 가져오길 원한다면 
            아래와 같이 하면 된다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl 4(%esp), %eax
            </PRE
></TD
></TR
></TABLE
>
            위의 예제를 보면 base pointer 주소모드를 이용해서 가져오고 있음을 알 수 있다.
            %esp에서 4만큼 이동한 위치에 저장된 값을 %eax에 복사한다.   
        </P
><P
>            C언어의 calling convention에서 스택은 함수의 로컬변수, 인자, 리턴주소들을 
            구현하는데 중요하게 사용된다.  
        </P
><P
>            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>subl  $8, %esp
            </PRE
></TD
></TR
></TABLE
>
            위의 명령은 %esp로 부터 8을 뺀다(word는 4바이트 크기를 가짐을 기억하라). 
            이런식의 사용은 함수를 호출해서 스택에 값을 저장하는데, 이런 저런 거추장 
            스러운 것들(레지스터 주소등..)을 이용하지 않고도 간단히 사용할 수 
            있다는 장점을 가진다. 일단 함수가 호출되어서 스택이 할당되면 함수가 
            종료할때까지 계속 남아 있게 된다. 우리가 함수에서 리턴하면 
            스택 프래임과 여기에 있는 변수가 제거된다. 이렇게 특정한 함수의 내부에서만 
            사용되는 특징으로 이들을 로컬변수라고 부른다. 우리가
            2 word의 로컬 저장소를 만들었고 스택은 다음과 같이 보일 것이다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>Parameter  #N    &#60;--- N*4+4(%ebp)
...
Parameter  2     &#60;--- 12(%ebp)
Parameter  1     &#60;---  8(%ebp)
Return Address   &#60;---  4(%ebp) 
Old %ebp         &#60;---   (%ebp)
Local Variable 1 &#60;--- -4(%ebp) 
Local Variable 2 &#60;--- -8(%ebp)  and (%esp)
            </PRE
></TD
></TR
></TABLE
>
            이제 우리는 base pointer addressing 방법을 이용해서 %ebp로 부터 원하는 모든 
            값에 접근할 수 있게 되었다. 물론 여러분은 base pointer addressing 모드를 
            위해서 다른 레지스터를 이용할 수도 있긴하지만, 일반적은 x86에서 %ebp레지스터가
            가장 빠른 관계로 %ebp가 선호된다.     
        </P
><P
>            이번장을 통해서 우리는 전역변수와 static 변수를 메모리상에서 어떻게 
            접근할 수 있는지를 배웠다. 전역변수와 static의 차이점은 static가 오직 
            함수내에서만 사용되고 전역변수는 여러함수에서 사용될 수 있다는 점이다.
            다른 모든 언어에서와 마찬가지로 어셈블리어에서도 이들 변수를 다루는 방법은 
            동일하다. 
        </P
><P
>            함수는 실행될때  기본적으로 3가지일을 해주어야 한다. 첫번째로 %eax에 리턴 값을 
            저장한다. 두번째로 호출되기 전에 스택을 초기화(reset)한다. 마지막으로 
            리턴의 제어는 <B
CLASS="EMPHASIS"
>ret</B
> 명령을 통해서 이루어진다. 이것은 
            스택의 제일 위의 값을 가져오는(pop)하는 일을 하고, 명령의 포인터인 %eip를 
            설정한다.   
        </P
><P
>            함수는 리턴할 때 그것을 호출한 코드에게 제어권을 되돌려 주어야만 하는데, 
            그러기 위해서는 반드시 이전의 스택프레임을 복구해 주어야만 한다. 그러나 
            ret 명령은 이러한 일을 하지 않는다. 왜냐하면 우리의 최근 스택프레임에 있는 
            리턴 주소는 스택의 제일 위를 가리키지 않기 때문이다. 그러므로 
            함수를 수행하기 전에 리턴할 스택포인터인 %esp와 베이스 포인터 %ebp를 
            리셋해주어야 한다. 그러므로 함수로 부터 리턴하기 위해서 다음과 과정이 
            필요하게 된다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>    
movl   %ebp,  %esp
popl   %ebp
ret 
            </PRE
></TD
></TR
></TABLE
>
            함수가 리턴할 때 여러분이 사용했던 모든 로컬변수는 처분되어 버리게 됨을 
            주목하기 바란다. 왜냐하면 여러분이 스택 포인터를 뒤로 이동하게 되면, 
            그 앞의 스택을 다른 값들이 덮어써 버리기 때문이다. 결국 지역 변수들은 
            함수가 생성되어서 작동하고 있을 때만 유효하게 된다. 함수가 리턴하게 되면 
            이제 프로그램의 제어권은 함수를 호출한 코드로 넘어오고, 제어권을 가진 코드는
            %eax를 이용해서 리턴값을 검사할 수 있게 된다. 
        </P
><P
>            page 47에 대한 자세한 해석이 필요.
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="SAMPLEFUNCTION"
></A
>4.4. 함수 예제</H2
><P
>            이제 실제 프로그램에서 어떻게 함수를 호출하는지 예를 들어서 알아보도록 하겠다.    
            우리는 <B
CLASS="EMPHASIS"
>power</B
>(거듭제곱)연산을 하는 이다. power 함수는 
            2개의 숫자를 필요로 한다. 예를 들어 2, 3이 들어 갔다면 2 * 2 * 2 연산을 하게 
            되고 8을 리턴하게 된다. 
        </P
><P
>            다음 코드는 완전한 프로그램이다. 파일의 이름은 power.s로 하겠다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># 하는일 : 2^3 + 5^2의 값을 계산후 되돌려준다.
#

.section .data
.section .text

.globl _start
_start:
pushl $3                    # 두번째 인자에 3을 넣는다.
pushl $2                    # 첫번째 인자에 2를 넣는다.

call power                  # power 함수를 호출한다. 

addl $8, %esp               # 스택의 포인터를 이동한다. 

pushl %eax                  # 함수호출 결과값을 저장한다.

pushl $2                    # 두번째 인자에 2를 넣는다. 
pushl $5                    # 첫번째 인자에 5를 넣는다.
call power                  # power 함수를 호출한다.
addl $8, %esp               # 스택포인터를 이동한다. 

popl %ebx                   # 두번째 호출한 pow함수의 리턴값은 
                            # 이미 %eax에 저장되어 있다. 
                            # 우리는 첫번째 pow함수의 결과값을 스택에서 
                            # 가져온다음 %ebx에 저장한다.  

addl %eax, %ebx             # 각 결과값들을 더한다. 
                            # 더한 결과값은 %ebx에 저장된다.

movl $1, %eax               # exit (%ebx 값이 리턴된다)   
int  $0x80                  # exit 시스템 호출을 위해서 인터럽트를 건다.


# 함 수 명 : power
# 하 는 일 : 주어지는 인자를 이용해서 거듭제곱 연산을 한후
#            되돌려준다.   
#
# 입    력 : 첫번째 인자 - 기본숫자 
#            두번째 인자 - 거듭제곱 숫자 
#
# 출    력 : 연산의 결과 
#
# 주    의 : 인자는 반드시 1보다 커야 한다.
#
# 변 수 들 : 
#            %ebx - 기본 숫자
#            %ecx - 거듭제곱 숫자 
#
#            -4($ebp) - 최근 결과값 
#
#            %eax 는 임시저장소로 사용된다.
#

.type power, @function
power:
    pushl %ebp           # 이전의 베이스 포인터를 저장한다. 
    movl %esp, %ebp      # 스택포인터를 베이스 포인터로 만든다.
    subl $4, %esp        # 지역 저장소를 위한 공간을 만든다.
    
    movl 8(%ebp), %ebx   # 첫번째 인자를 %eax에 저장한다.
    movl 12(%ebp), %ecx  # 두번째 인자를 %ecx에 저장한다.

    movl %ebx, -4(%ebp)  # 최근값을 저장한다. 

power_loop_start:
    cmpl $1, %ecx        # 만약 power이 1이면 end_power로 점프한다. 
    je end_power
    movl -4(%ebp), %eax  # 최근 결과값을 %eax에 저장한다.
    imul %ebx, %eax      # 최근 결과값에 기본 숫자를 곱한다.
    
    movl %eax, -4(%ebp)  # 최근 결과값을 저장한다.
    decl %ecx            # power을 감소시킨다.

    jmp power_loop_start # 다음 거듭제곱(power)를 실행한다.

end_power:                 
    movl -4(%ebp), %eax  # 리턴값을 %eax에 저장한다.
    movl %ebp, %esp      # 스택포인터를 복구한다.
    popl %ebp            # 베이스 포인터를 복구한다.  
    ret
            </PRE
></TD
></TR
></TABLE
>
        </P
><P
>            위의 코드를 작성하고 컴파일 시킨다음 실행시켜 보도록 하자. 
            그리고 power함수를 다른 인자를 주어서 호출해서 결과값이 제대로 
            나오는지 확인해 보도록 하자. 이때 결과값은 256을 넘기지 않도록 
            적당히 인자를 조절하도록 해야 한다. 테스트가 끝났다면 
            두개의 결과값을 뺀값을 리턴하도록 코드를 수정해 보도록 하자. 
            power 함수를 3번 호출하고 그 값을 리턴하는 코드도 만들어 보자.     
        </P
><P
>            프로그램의 코드는 매우 간단하다. 당신이 인자를 스택에 집어 넣고 
            함수를 호출하면, 함수는 스택 포인터를 뒤로 되돌리고 스택에 
            있는 인자를 읽어와서 연산을 하고 결과값을 %eax에 저장한다. 
            위 프로그램에서는 pow함수를 두번 호출하는데, 우리는 첫번째 값을 
            스택에 저장했다. 이유는 레지스터에 단지 한번에 하나의 값만 저장될
            수 있기 때문이다. 우리는 첫번째 pow함수 리턴값을 스택에 저장하고 
            나중에 두번째 함수의 결과가 나왔을때 스택의 값을 가져와서(pop)
            두번째 결과와 더해서 원하는 결과를 얻어 올 수 있다.    
        </P
><P
>            이제 함수 코스드에 대해서 알아보자. 함수에서 주목해야될 
            부분은 함수가 어떻게 선언되는지, 그리고 인자가 어떻게 넘어가고
            리턴값을 넘겨주는지 하는 부분이다. 이러한 입력부분과 출력부분은 
            프로그래머가 함수를 설계할 때 가장 일차적으로 고려하는 부분으로 
            흔히 함수의 인터페이스(Interface)라고 한다. 인터페이스를 
            제대로 구성하기 위해서 프로그래머는 스택과 %eax에 대해서 
            이해하고 있어야 한다. 스택은 입력, %eax는 출력(리턴)을 위해서 
            사용된다.       
        </P
><P
>            가장 먼저 해야 할일은 함수의 이름을 정하는 일이다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.type power,@function
            </PRE
></TD
></TR
></TABLE
>
            이것은 함수의 이름 power을 함수에 연결 시키는 일을 한다. 우리는
            power을 이용해서 실제 함수를 실행 시킬수 있다. 이러한 선언은 
            현재로써는 그리 유용하지 않지만 만약 프로그램의 크기가 커져서 
            여러개의 파알로 나뉘어서 유지되어야 한다면 매우 유용하게 
            사용할 수 있다. 이겨에 대한 장보는 나중에 자세히 
            설명하도록 하겠다. 함수를 선언했으니 실제 함수 코드를 
            적어야 할것이다. 함수코드가 시작되는 위치는 다음과 같이power 
            라벨을 이용해서 명시할 수 있다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>power:
            </PRE
></TD
></TR
></TABLE
>
            이렇게 해서 우리가 최초 선언한 power은 이 라벨이 있는 주소를 
            가리키게 된다. 이제부터 실제 함수의 실행부를 작성하면 된다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>pushl  %ebp
movl   %esp, %ebp
subl   $4, %esp
            </PRE
></TD
></TR
></TABLE
>
            가장 먼저 스택을 제어하기 위한 명령이 실행되는데, 위의 명령을
            수행한후 스택의 구조는 아래와 같다.    
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>Base Number    &#60;------- 12(%ebp)
Power          &#60;-------  8(%ebp)
Return Address &#60;-------  4(%ebp)
Old %ebp       &#60;-------   (%ebp) 
Current result &#60;-------  -4(%ebp) and (%esp)
            </PRE
></TD
></TR
></TABLE
>
            이 프로그램은 base number와 연산에 사용할 피연산자를 저장하기 위한
            %ebx, 현재 값을 저장하기 위한 레지스터(-4(%ebp))를 가지고 시작한다.
            그리고 몇번의 거듭제곱을 해야하는지는 %ecx에 저장된다. %ecx는 한번의
            거듭제곱이 일어나면 1씩 감소되고 1이되면 루프에서 벗어난다.   
        </P
><P
>            거듭제곱 함수를 보면 <B
CLASS="EMPHASIS"
>imul</B
>와 <B
CLASS="EMPHASIS"
>decl</B
>가 등장한다.
            imul은 곱셈연산을 한다. 연산의 결과는 두번째 오퍼랜드에 저장된다.
            decl은 레지스터의 값을 1감소시킨다. 명령에 대한 자세한 내용은
            Appendix B를 참고하기 바란다.     
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="RECURSIVEFUNCTION"
></A
>4.5. 재귀 함수</H2
><P
>            다음 프로그램은 머리를 좀더 굴려줘야 한다. 이 프로그램은 
            팩토리얼(factorial)을 구한다. 팩토리얼 연산은 자신과 1사이의 모든 숫자를
            곱하는 연산을 한다. 예를 들어서 7의 팩토리얼은 7*6*5*4*3*2*1이고 
            4의 팩토리얼은 4*3*2*1이다. 팩토리얼 연산을 할때 여러분은 하나의 규칙을
            발견할 수 있을 것이다. 4팩토리얼의 경우 3팩토리얼이 4번 발생하는 것이고, 
            3팩토리얼은 2팩토리얼이 3번 발생하고, 2팩토리얼은 1팩토리얼이 2번
            발생한다. 1팩토리얼은 1번발생으로 끝난다. 이러한 형태의 정의를 
            재귀(recursive)정의 라고 한다. 팩토리얼 함수를 구현할때 이 재귀 정의를 
            사용하면 문제를 더 쉽게 풀 수 있다. 
        </P
><P
>            팩토리얼 함수는 함수자신을 포함하는 재귀적 구조를 가진다. 
            함수가 함수 자신을 포함한다면 무한히 자신을 호출할 수도 있으므로 
            <B
CLASS="EMPHASIS"
>base case</B
> 가 정의되어 있어야만 한다. base case는
            재귀가 종료되는 시점을 결정한다. base case가 없다면 함수는 무한히 
            호출될 것이고 결국 stack 공간을 모두 소비하게 될 것이다. 팩토리얼의 
            경우 base case는 숫자 1이 된다. 팩토리얼 함수를 재귀호출하게 되면 
            번호는 1씩 줄어들고 base case와 같은 수가 된다면 함수를 빠져나오게 
            된다.  
            <P
></P
><UL
><LI
><P
>                        숫자를 평가한다.    
                    </P
></LI
><LI
><P
>                        숫자가 1인가?
                    </P
></LI
><LI
><P
>                        그렇다면 팩토리얼 연산을 종료하고 값을 리턴한다.
                    </P
></LI
><LI
><P
>                        그렇지 않다면 숫자를 1감소 시키고 팩토리얼 함수를 재 호출한다. 
                    </P
></LI
></UL
>
        </P
><P
>            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># 팩토리얼 연산을 한다.
# 예를 들어 3은 3 * 2 * 1 
#           4는 4 * 3 * 2 * 1
# 이 된다.
.section .data

.section .text


.global _start
.global factorial

_start:
pushl  $4            # 팩토리얼 함수에 넘길 인자를 복사한다.

call   factorial     # 팩토리얼 함수를 실행한다.
addl   $4, %esp
movl   %eax, %ebx    # 팩토리얼 함수의 리턴값은 %eax에 저장되지만
                     # 프로그램 리턴값으로 넘길 필요가 있으므로 %ebx에 복사한다. 

movl   $1, %eax      # exit 시스템 콜을 호출한다.
int    $0x80

# factorial 함수 정의
factorial:
pushl  %ebp          # 리턴하기 전에 이전의 스택 포인터를 저장해야 한다. 
                     # 그래서 이전의 스택포인터를 저장한다. 
                     # 함수를 위한 기본 요소 
movl   %esp, %ebp    

movl   8(%ebp), %eax # 첫번째 인자를 %eax에 복사한다. 
                     # 4(%ebp)는 리턴어드레스 이고 
                     # 8(%ebp)는 첫째 인자의 어드레스이다. 

cmpl   $1, %eax      # 재귀에서 벗어나기 위한 base case 값은 1이다. 
                     # 여기에서 인자의 값이 1인지를 검사한다.
                     # 만약 1 이라면 end_factorial로 점프한다.  
je     end_factorial
decl   %eax          # 그렇지 않다면 %eax를 1 감소 시킨다.
pushl  %eax          # 이 값은 다음 factorial함수를 호출하면서 전달되어야 하므로 
                     # 스택에 밀어 넣는다.
call   factorial     # factorial을 실행한다. 

movl   8(%ebp), %ebx 

imul   %ebx, %eax    # 최근 호출했던 factorial의 리턴값과 곱한다.(%eax에 저장되어 있음)
                     # 곱한결과는 %eax에 저장한다.


end_factorial:
movl  %ebp, %esp    # 함수리턴을 위한 기본요소
popl  %ebp          # 리턴하기 전에 이전 함수의 시작포인터를 복구한다. 

ret                 # 함수를 리턴한다.
            </PRE
></TD
></TR
></TABLE
>
        </P
><P
>            어셈블, 링크 과정을 거쳐서 실행시키고 리턴결과를 확인한다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># as factorial.s -o factorial.o
# ld factorial.o -o factorial
# ./factorial
# echo $? 
            </PRE
></TD
></TR
></TABLE
>
            프로그램의 리턴값이 24임을 확인할 수 있을 것이다. 24는 4의 팩토리얼 연산
            값으로 4*3*2*1의 결과다. 
        </P
><P
>            여러분이 C와 같은 언어를 통해서 재귀호출을 경험해 보지 않았다면 
            위의 코드를 이해하는 데에 약간의 어려움이 있을 수도 있다. 이제 어떻게 
            이러한 계산이 가능한지를 알아보도록 하자.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>_start:
pushl   $4
call    factorial
            </PRE
></TD
></TR
></TABLE
>
            이 프로그램은 4의 팩토리얼을 계산한다. 호출될 함수에 이 값을 인자로 넘기기 
            위해서 함수 호출전에 스택에 밀어 넣었다. 함수의 인자는 함수에서 작업에 사용될
            데이터라는 점을 기억하기 바란다. 이경우 함수는 하나의 인자를 가진다.     
        </P
><P
>            pushl 명령은 값을 스택의 가장위에 밀어 넣는다. <B
CLASS="EMPHASIS"
>call</B
>명령은
            함수를 호출하기 위해서 사용한다.
        </P
><P
>            다음 줄을 분석해 보도록하자.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>addl   $4,    %esp
movl   %eax,  %ebx
movl   $1,    %eax
int    $0x80
            </PRE
></TD
></TR
></TABLE
>
            <B
CLASS="EMPHASIS"
>factorial</B
>함수가 끝났으니, 4의 팩토리열의 값을 가져와야 
            할것이다. 우선 스택을 청소해야 한다. <B
CLASS="EMPHASIS"
>addl</B
>
            명령을 이용해서 스택포인터를 $4만큼 뒤로 옮긴다. 팩토리얼 함수를 호출했다면 
            당신은 호출한 함수가 리턴된후 반드시 스택인자를 청소해 주어야 한다.      
        </P
><P
>            다음 %eax를 %ebx로 복사한다. %eax는 factorial함수의 리턴값이다. 이경우 
            리턴값은 팩토리얼 연산결과이다. 팩토리얼 함수를 호출할 때 인자를 4를 줬으므로 
            리턴값은 24가 될것이다. 리턴값은 언제나 
            <B
CLASS="EMPHASIS"
>%eax</B
>에 저장된다는 것을 기억하기 바란다. 우리는 프로그램이
            종료할 때 운영체제에 24를 되돌려 주어야한다. 리눅스의 경우 프로그램의 
            종료값은 %eax가 아닌 %ebx에 저장한다. 이제 exit() 시스템 호출을 실행하면 된다. 
        </P
><P
>            함수를 사용하면 우리는 크고 복잡한 프로그램을 만들 때 상대적으로 간단하고 
            이해하기 쉬운 여러개의 조각으로 코드를 만들 수 있는 잇점을 얻을 수 있다. 
            실질적으로 아주 간단한 경우를 제외하고, 대부분의 프로그램은 여러개의 함수로 
            이루어진다.
        </P
><P
>            위의 에제를 통해서 우리는 함수를 어떻게 사용하는지 알게 되었다. C에서와 
            마찬가지로 어셈블리어에서도 함수는 선언과 정의 부로 나뉘게 된다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.type  factorial, @function
factorial:
            </PRE
></TD
></TR
></TABLE
>
            함수는 보통 위와 같은 방법으로 만들 수 있다. .type는 factorial 함수를
            가리키기 위한 링커의 용도로 사용되는데, 생략할 수 있다. 우리가 만든 
            프로그램에는 .type를 사용하고 있다. facorial: 은 factorial이 가리키는
            실제 함수코드가 이곳에 위치한다는 것을 정의 한다. 다음 줄부터 우리는 
            factorial의 실제적인 코드 내용을 기술하면 된다. 기술된 factorial 함수는
            call 명령을 통해서 실행 시킬 수 있다. 
        </P
><P
>            factorial함수의 첫라인에는 다음과 같은 코드가 들어가 있다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>pushl   %ebp
movl    %esp, %ebp
            </PRE
></TD
></TR
></TABLE
>
            이 두줄은 함수에서 사용할 스택영역을 생성한다. 이 두줄은 모든 함수의 
            시작부분에 포함된다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl    8(%ebp), %eax
            </PRE
></TD
></TR
></TABLE
>
            베이스 포인터 어드레스를 함수의 첫번째 인자로 이동한다음 
            이곳의 값을 %eax에 보가한다. 4(%ebp)는 리턴어드레스를 
            가지고 있으며, 8(%ebp)는 함수의 첫번째 인자를 가리키고 있음을 
            기억하기 바란다. 
        </P
><P
>            다음 라인에서 함수의 인자가 base case에 도달했는지 검사한다. 
            만약 base case 즉 1이라면 팩토리얼 연산을 끝내고 end_factorial로 점프
            한다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cmpl    %1,  %eax
je      end_factorial
            </PRE
></TD
></TR
></TABLE
>
            만약 base case에 도달하지 않았다면, 우리는 factorial 함수를 다시 호출 
            해야 한다. 호출할 때는 인자값(%eax)를 1만큼 감소 시켜야 한다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>decl    %eax
            </PRE
></TD
></TR
></TABLE
>
            <B
CLASS="EMPHASIS"
>decl</B
>는 메모리 영역이나 레지스터의  값을 1감소시키기 
            위해서 사용한다. 인자를 1 감소한 다음에는 이값을 스택에 밀어 넣고 
            다시 factorial함수를 호출한다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>pushl   %eax
call    factorial
            </PRE
></TD
></TR
></TABLE
>
            이제 factorial함수를 재귀호출 했다. 일단 함수를 호출하고 나면 우리는 %esp와 
            %ebp를 제외하고는 다른 값들을 알 수 없게된다. 그래서 우리는 주어진 인자 값을 
            %ebx에 복사하도록 한다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl    8(%ebp),  %ebx
            </PRE
></TD
></TR
></TABLE
>
            이제 인자와 팩토리얼 함수를 곱하면 된다. 앞에서 우리는 함수의 리턴값은 %eax
            를 통해서 가져올 수 있다는 것을 배웠었다. 그러므로 %ebx와 %eax를 서로 
            곱하면 된다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>imul    %ebx, %eax
            </PRE
></TD
></TR
></TABLE
>
            곱한 값은 %eax에 저장된다. 이값은 함수가 종료할 때 그대로 리턴된다. 앞서 
            우리가 함수를 시작할 때 %ebp를 밀어 넣고, %esp를 %ebp로 복사해서 지금의 
            스택포인터를 만들었다. 그렇다면 함수가 종료할때 이것을 원래 상태로 만드는 
            작업이 필요할 것이다. 우리는 아래와 같은 코드를 이용해서 현재 스택프레임을 
            되돌릴 수 있다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>end_factorial:
movl   %ebp, %esp
popl   %ebp
            </PRE
></TD
></TR
></TABLE
>
            이제 ret명령을 이용해서 리턴하면 된다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>ret
            </PRE
></TD
></TR
></TABLE
>
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="USEDFILE"
></A
>5. 파일 다루기</H1
><P
>        컴퓨터 프로그래밍의 많은 부분은 파일을 다루는 작업이다. 컴퓨터가 일단 리붓되면 
        이전의 작업내용은 단지 파일로만 남기 때문에, 어떤 데이터를 보존하기 위해서 
        디스크상에 파일로 저장하는 일은 매우 중요한 작업이다. 마찬가지로 프로그램역시 
        종료하게 되면 메모리에 가지고 있던 모든 내용을 잃어 버리기 때문에, 지속적으로 
        남겨두어야할 데이터(persistent data 라고 부른다)는 파일로 남겨두어야 한다.
    </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="INTROFILE"
></A
>5.1. 유닉스 파일 소개</H2
><P
>            모든 운영체제는 나름대로의 파일을 다루는 방법을 가지고 있다. 리눅스는 
            유닉스의 파일 다루기 방법을 채택하고 있다. 유닉스 파일을 따르는 이유는 
            매우 단순하고, 가장 오래, 그리고 널리 사용되고 있는 형식이기 때문이다. 
            유닉스 파일은 프로그램에 의해서 생성되며, 바이트의 연속된 스트림으로 
            읽을 수 있다. 시스템 관리자나 프로그래머는 파일에 주어진 고유한 이름으로 
            파일에 접근할 수 있다. 반면 운영체제는 파일을 이름이 아닌 
            <B
CLASS="EMPHASIS"
>file descriptor</B
>라고(이하 파일지정번호) 불리우는 
            숫자로 인식한다.  프로그램상에서 여러분은 파일지정번호를 이용해서 읽거나 
            쓰는 작업을 할 수 있다. 
        </P
><P
>            우리가 작성한 프로그램은 다음과 같은 방법으로 파일을 다룬다.     
            <P
></P
><OL
TYPE="1"
><LI
><P
>                    먼저 리눅스에 어떤 파일이름을 열(open)것인지를 요청한다. 파일을 
                    열때는 읽기전용,쓰기전용,읽기/쓰기모두 가능,파일이 존재하지 않을 경우
                    새로 생성등 다양한 방법으로 열 수 있다. 이러한 것은 open(2) 시스템콜
                    을 이용해서 이루어진다. open은 파일의 이름, 모드, 권한등을 인자로 
                    입력받는다. open은 시스템 콜 번호로 5번이다. 파일이름의 첫번째 문자는 
                    %ebx에 저장하면 된다. 두번째 인자인 모드는 %ecx에 저장한다. 만약 
                    읽기로 연다면 0을 쓰기위해서 연다면 03101을 저장하면 된다(반드시 
                    가장 앞에 0을 써줘야 한다). 세번째 인자는 권한(permission)과 관련된 
                    설정을 넘기기 위해서 사용하는데, %edx에 해당 값을 저장하면 된다. 
                    만약 모든 유저에게 읽기/쓰기가 가능하도록 하고 싶다면 0666을 넘기면 
                    된다.  
                </P
></LI
><LI
><P
>                    open작업이 성공적으로 이루어졌다면 파일 지정자를 리턴하게 된다. 
                    리턴값은 %eax를 통해서 읽어올 수 있다. 리턴된 번호는 파일을 가리키는 
                    역할을 한다. 
                    </P
></LI
><LI
><P
>                    이제 파일 지정자를 이용해서 읽거나 쓰는 작업을 하면 된다. 
                    read(2)는 시스템콜 번호 3번이다. 이 시스템콜은 3개의 인자를 필요로 
                    한다. 첫번째 인자는 읽기 원하는 파일의 지정자이며 %ebx에 저장하면 된다.
                    두번째 인자는 읽어들인 데이터가 저장될 버퍼의 주소를 가리키며 %ecx에 주소값을
                    저장한다. 마지막 인자는 버퍼의 크기로 %edx에 저장한다. 버퍼는 section 
                    .bss를 이용해서 지정할 수 있다. read는 파일로 부터 읽어들인 문자의 갯수를 
                    리턴하거나, 에러 코드를 리턴한다. 에러코드는  (-)값 이므로 정상리턴값과 
                    쉽게 구분할 수 있다.  
                    </P
><P
>                    write(2)는 시스템콜 번호 4번으로 버퍼에 파일에 쓸 내용을 채워서 전달하는 것을 
                    제외하고 인자는 read와 동일하다. write 시스템콜은 파일에 쓴 데이터의 크기 혹은
                    에러코드를 리턴한다. 
                    </P
></LI
><LI
><P
>                    파일관련된 모든 작업을 마쳤다면, 열린파일을 닫아야 한다. 파일을 닫을 때 사용되는 
                    시스템콜은 6번 번호를 가지는 close(2)이다.단지 닫고자 하는 파일의 지정자만
                    인자로 넘기면 된다.   
                    </P
></LI
></OL
>
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="BUFFERANDBSS"
></A
>5.2. 버퍼와 .bss</H2
><P
>            이전장에서 버퍼에 대해서 언급했는데, 자세히 설명하지는 않았다. 이번 장에서는 버퍼에 
            대해서 자세히 설명해보도록 한다. 버퍼는 대량의 데이터를 전달하기 위해서 사용되는 
            연속되는 블럭영역이다. 당신이 파일로 부터 데이터를 읽기를 원한다면, 요청은 
            운영체제로 전달되는데, 이때 읽은 데이터를 어디엔가에 저장할 수 있어야 한다. 이러한 
            장소를 버퍼라고 한다. 일반적으로 버퍼는 데이터의 임시 저장장소로 사용되며, 버퍼를 
            이용함으로서 프로그램은 데이터를 좀더 쉽게 다룰 수 있게 된다.  
        </P
><P
>            버퍼를 생성할때 여러분은 고정된 크기의 버퍼를 만들지 아니면 필요에 따라 크기가 
            변하는 버퍼를 생성해야 할지 선택해야 한다. 고정된 크기의 버퍼 생성은 간단하다. 
            .long 나 .byte 를 이용해서 버퍼로 사용될 크기를 직접 지장하면 된다. 반면 동적으로 
            변하는 버퍼의 생성은 다루어야할 내용이 많으므로 ??장에서 따로 다루도록 하겠다.   
            버퍼공간을 확보하는건 간단하긴 하지만 공간확보를 위한 단위로 .byte를 사용해야 한다는 
            것 때문에 몇가지 문제점이 발생하다. 첫번째는 공간의 크기를 계산해야 하는 문제다. 
            문자 500자를 저장하는 것과 int형 숫자 500개를 저장하기 위한 예에서 보듯이 
            저장되는 원소의 갯수는 동일하지만, 원소가 차지하는 크기가 다름으로 필요한 공간계산에서
            실수가 발생할 수 있다. 특히 어셈블러나 C와 같은 중/저 수준의 언어를 이용할경우 
            이러한 실수는 일상적으로 발생할 수 있다.  
        </P
><P
>            두번째.. 이러한 공간은 프로그램 실행시 생성된다. 중간에 필요 없다고 해서 없앨 수 없다. 
            이는 공간이 낭비될 수 있음을 의미한다. 
        </P
><P
>            물론 이들 문제에 대한 해법도 존재하는데 .text, .data 섹션을 사용하는 것이다. 
            .bss 색션은 저장공간을 확보할 수 있지만 초기화 할수는 없다. .data 섹션의 경우
            공간을 확보하고 값을 초기화 할 수 있다. 이러한 특성 때문에 값을 초기화할 필요없는 
            공간을 확보하고자 할때 주로 사용한다. .bss는 다음과 같이 사용할 수 있다.   
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.section    .bss
  .lcomm  my_buffer, 500
            </PRE
></TD
></TR
></TABLE
>
            <B
CLASS="EMPHASIS"
>.lcomm</B
>은 500byte의 공간을 할당하고, 공간을 가리키기위한 심볼로 
            my_buffer을 생성한다. 만들어진 공간은 다음과 같이 사용할 수 있다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl  $my_buffer,  %ecx
movl  500, %edx
movl  3, %eax
int   $0x80
            </PRE
></TD
></TR
></TABLE
>
            위의 코드는 read 시스템콜을 실행시킨 예로, 500바이트만큼의 데이터를 읽어서 my_buffer로 
            복사한다. C스타일로 바꿔 보자면 아래의 코드 정도가 될것이다.    
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>read(fd, my_buffer, 500);
            </PRE
></TD
></TR
></TABLE
>
            my_buffer을 사용할 때 가장 앞에 달러($)표시가 있음을 주목하기 바란다. $표시가 
            사용할 경우  immediate 모드 어드레스 상태가 되고 버퍼의 시작위치를 가리키게 된다. 
            결과적으로 %ecx는 my_buffer의 저장공간의 시작 주소를 가리키게 된다. C언어를 
            해봤다면 결국은 포인터와 비슷한 개념이라는 생각이 들 것이다.
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="FILETYPE"
></A
>5.3. 표준파일과 특수 파일들</H2
><P
>            당신이 프로그램을 실행시키면 기본적으로 여는 파일들이 몇게 있다. 리눅스는 
            다음과 같은 3개의 파일을 기본적으로 생성시킨다.  
            <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>STDIN</DT
><DD
><P
>                        표준 입력(standard input)으로, 읽기 전용이다. 보통 키보드로부터의 
                        입력을 받아들인다. 표준 입력을 위한 파일지정자는 언제나 0이다.
                    </P
></DD
><DT
>STDOUT</DT
><DD
><P
>                        표준 출력(standard output)으로, 쓰기 전용이다. 모니터 화면에 
                        출력하기 위해서 사용된다. 표준 출력을 위한 파일지정자는 언제나 1이다.  
                    </P
></DD
><DT
>STDERR</DT
><DD
><P
>                        표준 에러(standard error)으로, 쓰기 전용이다. 모니터 화면에 
                        출력(쓰기)하기 위해서 사용된다. 에러 메시지를 출력한다. 어차피 모니터 화면에
                        출력하는 거라면 STDOUT와 다를게 뭐가 있느냐라고 새각할 수도 있을것 같다. 
                        만약 화면출력을 하는데, 정상적인 메시지와 에러 메시지가 같은 파일지정자를 
                        쓴다면 이를 구분해 내기가 매우 짜증날 것이다. 표준에러를 따로 분리하므로써 
                        에러메시지를 일반메시지와 쉽게 분리할 수 있다.  
                    </P
></DD
></DL
></DIV
>
            키보드 입력과 화면 출력같은 것들을 파일로 다룸으로 이들 입/출력을 쉽게 실제파일로 
            보낼 수도 있다. 이러한걸 재지향(redirected)이라고 한다. 재지향과 관련된 내용은 
            이 문서의 범위를 벗어나므로 자세히 설명하진 않겠다. 재지향과 관련된 내용은 
            UNIX 사용과 관련 다른 책들을 참고하기 바란다.  
        </P
><P
>            키보드, 모니터와 같은 것들 외에도 유닉스는 다른 모든 장치들 예를 들면 
            시리얼 포트, 오디오 장치, 네트워크 연결들까지도 파일로 다룬다. 
            뿐만 아니라 프로세스간의 통신을 위해서 사용되는 pipe와 같은 것들 역시 파일로 
            다룬다. 모든것을 파일로 다루게 되므로써 동일한 방법을 써서 이들 장치를 제어할 수
            있게 된다. 기본적으로 read, write를 이용하는 정도로 이들 모든 장치의 입출력을 
            해결할 수 있다.  
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="USEDFILEINPROG"
></A
>5.4. 프로그램에서 파일의 이용</H2
><P
>            이번에는 파일을 다루는 간단한 프로그램을 만들어 보도록 하겠다. 이 프로그램은 
            두개의 파일을 이용한다. 하나의 파일로부터 문자를 읽어 들이고 읽어들인 문자를 
            영문 대문자로 변경하는 일을 한다. 이 프로그램의 아래의 주요 부분으로 이루어진다. 
        </P
><P
>            <P
></P
><UL
><LI
><P
>                    메모리의 블럭에 있는 문자데이터를 대문자로 변경하는 함수를 가진다. 
                    이 함수는 데이터가 있는 메모리블럭의 주소와 크기를 인자로 받는다.         
                    </P
></LI
><LI
><P
>                    주요 코드중의 하나는 파일로 부터 데이터를 버퍼로 읽어들이는 코드이다. 
                    이 코드는 파일에 더이상 데이터가 없을 때까지 버퍼로 읽어 들이고 위의 
                    대문자 변경함수에 버퍼를 인자로 넘기고 실행해서 결과값을 다른 파일로 
                    저장한다.    
                    </P
></LI
></UL
>
        </P
><P
>            조금 복잡한 프로그램을 작성하다 보면 프로그램 전역적으로 고정되어서 사용해야할 
            많은 상수 값들이 필요해진다. 예들들어 시스템 콜번호는 변하지 않는 숫자로 구성되어 
            있는데, 사용할 때마다 숫자로 기억해내서 쓰는건 매우 귀찮은 일일 것이다. 이럴경우
            <B
CLASS="EMPHASIS"
>.equ</B
>를 이용한다. .equ는 일종의 별칭을 만들어주기 위해서 사용하는
            지시어로 C의 #define과 비슷한 일을 한다.    
        </P
><P
>            .equ의 실질적인 사용용도를 알아보도록 하자. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.equ LINUX_SYSCALL  0x80
            </PRE
></TD
></TR
></TABLE
>
            위와 같이 하면 코드내에서 시스템콜을 호출할 때, 보기 힘든 0x80대신 LINUX_SYSCALL을 
            사용할 수 있다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>int  $LINUX_SYSCALL
            </PRE
></TD
></TR
></TABLE
>
            0x80보다는 훨씬 읽고 기억해내기 쉽다. 복잡한 코드에서 .equ는 가독성을 높이는데 
            중요한 역할을 한다. 
        </P
><P
>            다음은 실제 작동가능한 문자변한 프로그램이다. 파일명은 file.s로 저장하도록 하자.   
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># 하 는 일 : 파일로 부터 문자를 읽어들이고 대문자로 바꾼후 다른 파일로 저장한다.
# 프로세스 : 1. 읽을 파일을 연다.
#            2. 쓸 파일을 연다.
#            3. 파일의 끝이 아니라면 다음의 프로세스를 반복한다.
#               1) 파일로 부터 문자열을 읽어서 메모리에 넣는다.
#               2) 메모리로 부터 각 문자를 대문자로 변경한다.
#               3) 변경된 문자는 파일로 저장한다.

.section .data

# 상수들 
.equ  SYS_OPEN,  5
.equ  SYS_WRITE, 4 
.equ  SYS_READ,  3
.equ  SYS_CLOSE, 6
.equ  SYS_EXIT,  1

# open()에 사용할 옵션 
# 이들에 대한 내용은 open()함수의 man페이지를 참고한다. 
.equ  O_RDONLY,  0
.equ  O_CREAT_WRONLY_TRUNC,  03101

# 표준 파일 지정자
.equ  STDIN,  0
.equ  STDOUT, 1
.equ  STDERR, 2

# 시스템 콜 중단(interrupt)
.equ  LINUX_SYSCALL, 0x80

.equ  END_OF_FILE,       0  # 파일의 끝을 검사하기 위해서 사용한다.
                            # read()의 리턴값과 비교한다.

.equ  NUMBER_ARGUMENTS,  2

.section .bss
# 버퍼 - 파일로 부터 데이터를 읽어들인 데이터를 저장하기 위한 
#        목적으로 사용된다. 
#        버퍼의 크기는 여러가지 이유로 16,000을 초과할 수 없다.
.equ  BUFFER_SIZE,  500
.lcomm BUFFER_DATA, BUFFER_SIZE

.section .text

# 스택 위치
.equ  ST_SIZE_RESERVE, 8
.equ  ST_FD_IN,    -4
.equ  ST_FD_OUT,   -8
.equ  ST_ARGC,     0      # 인자의 갯수
.equ  ST_ARGV_0,   4      # 프로그램의 이름
.equ  ST_ARGV_1,   8      # 읽어들일 파일의 이름 
.equ  ST_ARGV_2,   12     # 저장할 파일의 이름 

.globl _start

_start:
### 초기화 관련 ### 
# 스택포인터를 저장한다.
movl  %esp, %ebp
# 스택에 파일 지정자를 저장하기 위한 공간을 할당한다. 
subl  $ST_SIZE_RESERVE, %esp

open_files:
open_fd_in:
### 읽어들일 파일을 연다 ###
movl  $SYS_OPEN, %eax             # syscall을 연다. 
movl  ST_ARGV_1(%ebp), %ebx       # %ebx에 파일이름을 넣는다. 
movl  $O_RDONLY, %ecx             # read-only 플래그
movl  $0666, %edx                 # 파일 권한을 0666으로 한다. 누구든지 읽고쓸수 있다.
int   $LINUX_SYSCALL              # 리눅스 호출

store_fd_in:
movl  %eax, ST_FD_IN(%ebp)        # 리턴된 파일 지정자를 저장한다. 

open_fd_out:
### 저장할 파일 열기 ###
movl  $SYS_OPEN, %eax             # 파일 열기
movl  ST_ARGV_2(%ebp), %ebx       # 열 파일이름을 지정한다.
movl  $O_CREAT_WRONLY_TRUNC, %ecx # 쓰기위한 플레그의 설정
movl  $0666, %edx                 # 파일권한 설정
int   $LINUX_SYSCALL              # 리눅스 호출


store_fd_out:
movl  %eax, ST_FD_OUT(%ebp)       # 파일 지정자를 저장한다.

### 주요 루프 시작 ###
read_loop_begin:

### 파일로 부터 읽어들이는 부분 ###
movl $SYS_READ, %eax
movl ST_FD_IN(%ebp), %ebx         # 읽어들일 파일 지정자 
movl $BUFFER_DATA, %ecx           # 읽어들인 데이터를 저장할 버퍼
movl $BUFFER_SIZE, %edx           # 읽어들일 크기
int  $LINUX_SYSCALL               # 시스템콜의 실행
                                  # 리턴값은 %eax에 저장된다.

cmpl $END_OF_FILE, %eax           # 파일의 끝인지 검사한다.
jle  end_loop                     # 만약 그렇다면 end_loop로 점프한다.

continue_read_loop:
### 입력된 문자를 대문자로 변경하는 부분 ###
pushl $BUFFER_DATA                # 버퍼의 위치
pushl %eax                        # 버퍼의 사이즈
call  convert_to_upper            # 대문자 변경함수의 호출
popl  %eax                        
addl  $4, %esp

### 변경된 문자를 파일에 쓴다 ### 
movl  %eax, %edx                  # 버퍼의 크기
movl  $SYS_WRITE, %eax
movl  ST_FD_OUT(%ebp), %ebx       # 저장에 사용할 파일 지정자
movl  $BUFFER_DATA, %ecx          # 버퍼의 위치
int   $LINUX_SYSCALL              # write()를 호출한다. 

### 루프를 계속수행한다. ###
jmp  read_loop_begin


end_loop:
### 파일을 닫는다. ###
# 여기에서는 에러체크는 하지 않는다.
movl  $SYS_CLOSE, %eax
movl  ST_FD_OUT(%ebp), %ebx
int   $LINUX_SYSCALL

### 종료 코드 ###
movl  $SYS_EXIT, %eax
movl  $0, %ebx
int   $LINUX_SYSCALL


# 하 는 일 : 이 함수는 소문자를 대문자로 변경한다.
#       
.equ  LOWERCASE_A, 'a'
.equ  LOWERCASE_Z, 'z'
.equ  UPPER_CONVERSION, 'A' - 'a'

.equ  ST_BUFFER_LEN,  8
.equ  ST_BUFFER, 12


convert_to_upper:
  pushl %ebp
  movl  %esp, %ebp
  movl  ST_BUFFER(%ebp), %eax
  movl  ST_BUFFER_LEN(%ebp), %ebx
  movl  $0, %edi

  cmpl  $0, %ebx
  je  end_convert_loop

convert_loop:
movb  (%eax, %edi, 1), %cl

cmpb  $LOWERCASE_A, %cl
jl    next_byte
cmpb  $LOWERCASE_Z, %cl
jg    next_byte

addb  $UPPER_CONVERSION, %cl
movb  %cl, (%eax, %edi, 1)
next_byte:
incl  %edi
cmpl  %edi, %ebx
jne   convert_loop

end_convert_loop:
movl  %ebp, %esp
popl  %ebp
ret
            </PRE
></TD
></TR
></TABLE
>
        </P
><P
>            위 프로그램을 touuper.s 로 저장하고 다음과 같은 방법으로 컴파일 하도록 하자.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># as toupper.s -o toupper.o
# ld toupper.s -o toupper
            </PRE
></TD
></TR
></TABLE
>
            이 프로그램을 실행 시키면 모든 소문자를 대분자로 변경시킨다. 예를 들어서 
            toupper.s 를 대문자로 변환시키고 한다면 다음과 같이 하면 된다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># ./toupper toupper.s toupper.uppercase:
            </PRE
></TD
></TR
></TABLE
>
            touuper.uppercase 를 읽어보면 원래의 파일의 모든 내용이 대문자료 변경된걸 
            확인할 수 있을 것이다. 
        </P
><P
>            그럼 프로그램에 대해서 좀더 자세히 알아보도록 하자.
        </P
><P
>            프로그램의 첫번째 섹션은 <B
CLASS="EMPHASIS"
>CONSTANTS.</B
>로 시작한다. 
            프로그램에서 상수(constant)는 프로그램이 어셈블 혹은 컴파일 될때 할당되는
            값으로 변경될 수 없는 값이다. 상수를 언제 할당해서 쓰느냐는 프로그래머의 
            취향에 따라 달라질 수 있지만, 일반적으로 프로그램의 가장 처음에 두는 것을 
            원칙으로 한다. 프로그램 전역적으로 영향을 미친다는 상수의 특정상 
            쉽게 확인 가능한 위치에 두는게 관리하기에 좋기 때문이다. 위의 프로그램에서는
            파일 지정자와 인자접근, 버퍼크기, 시스템콜 번호 등 결코 바뀌지 않는 모든 
            값들을 상수로 선언해서 사용하고 있다.  
        </P
><P
>            어셈블리어에서 상수의 선언은 <B
CLASS="EMPHASIS"
>.equ</B
>를 이용한다. 
            C/C++의 #define 문이라고 볼 수 있다. 상수의 이름을 앞에 쓰고 그다음 
            값을 쓰면 된다.      
        </P
><P
>            다음은 <B
CLASS="EMPHASIS"
>BUFFERS.</B
> 섹션으로 프로그램의 버퍼와 관련해서 
            사용한다. 여기에서도 버퍼의 크기는 BUFFER_SIZE. 상수로 정의해서 사용하고 
            있다. 만약 버퍼의 크기를 바꾸고 싶다면 BUFFER_SIZE. 상수의 값만 변경해 
            주면 된다. 버퍼의 이름은 BUFFER_DATA 로 했다. 여기에서 상수를 사용하면서 얻
            을 수 있는 잇점이 하나 나왔는데. 특정 값을 일관되게 관리할 수 있다는 
            점이다. 만약 상수를 사용하지 않았다면 버퍼의 크기를 바꿀 때 일일이 
            버퍼의 크기를 찾아서 바꿔줘야 할것이다. 그만큼 실수를 확률도 많은데 상수의 
            사용은 이러한 실수도 줄여준다.  
        </P
><P
>            다음은 _start. 섹션인데, 우선은 코드의 마지막에 있는 convert_to_upper정의를 
            먼저 보도록 하자. 여기는 실제로 문자의 변경을 위해 사용되는 코드 영역이다.  
            역시 함수의 처음은 함수내에서 사용될 각종 상수를 정의하는 코드가 
            들어가 있다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.equ  LOWERCASE_A,   'a'              # a와 z는 소문자인지 체크하기 위한
.equ  LOWERCASE_Z,   'z'              # 용도로 사용된다.
.equ  UPPER_CONVERSION, 'A' - 'a'     # 대문자와 소문자간의 크기교정을 위한 용도
            </PRE
></TD
></TR
></TABLE
>
            위의 두개의 정의는 변환할 영문이 소문자인지를 체크하기 위한 용도로 사용한다.
            ASCII(12) 테이블에서 문자 'a'와 'z'가 연속적으로 구성되어 있다는 것에 착안한 
            코드다. 만약에 우리가 받아들인 문자가 소문자라면 대문자로 변경시켜줘야 
            하는데, 대문자로 변경하기 위해서는 'A'에서 'a'의 차이 만큼만 더해주면 된다. 
            다음의 C코드를 확인해 보기 바란다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>#include &#60;stdio.h&#62;

int main()
{
    printf("%d\n", 'A' - 'a');
    printf("%c\n", 'a' + ('A' - 'a'));
    return 0;
}
            </PRE
></TD
></TR
></TABLE
>
        </P
><P
>            다음 라인은 스택의 위치를 가리키기 위한 몇개의 상수를 선언하고 있다. 
            이는 함수에서 인자를 사용하기 위해서는 함수 호출전 스택에 인자를 밀어 넣는데,
            함수내에서는 이 스택의 위치를 이용해서 인자의 값을 얻어올 수 있기 때문이다.
            하기 때문이다. 이들 상수는 접두사를 ST로 하고 있는데, 리턴 주소는 4, 
            버퍼의 길이는 8, 그리고 버퍼의 주소는 12로 결정했다. 이렇게 정의해 놓은 
            스택주소의 사용용도는 convert_to_upper: 을 보면 좀더 쉽게 이해할 수 있을 
            것이다.    
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl  ST_BUFFER(%ebp), %eax
movl  ST_BUFFER_LEN(%ebp), %ebx
            </PRE
></TD
></TR
></TABLE
>
            위코드는 함수의 인자의 값을 스택에서 읽어들이는 일을 한다. 그다음 %edi에 0을
            복사한다. %edi는 버퍼의 위치를 가리키는 이터레이터용도로 사용된다. 
            버퍼의 위치는 %eax + %edi 로 계산한다(이를테면 배열에서 첨자를 증가시켜서 
            위치를 가져오는 방식이다)
        </P
><P
>            만약에 %ebx 즉 버퍼에 있는 데이터의 길이가 0이라면 루프를 종료시킨다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cmpl  $0, %ebx
je  end_convert_loop
            </PRE
></TD
></TR
></TABLE
>
            그렇지 않고 데이터의 길이가 0보다 크다면 convert_loop:를 돌면서 문자 변환 
            작업을 수행한다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>    
movb  (%eax, %edi, 1), %cl

cmpb  $LOWERCASE_A, %cl
jl    next_byte
cmpb  $LOWERCASE_Z, %cl
jg    next_byte
            </PRE
></TD
></TR
></TABLE
>    
            여기에는 movb, cmpb 명령이 사용되고있다. 뒤에 b가 붙었는데, 이는 바이트 
            단위로 연산을 실시하라는 뜻이 되겠다. %eax로 부터 %edi 만큼 이동한후 
            1바이트를 %cl로 복사한다. 그후 %cl이 소문자면 대문자로 변경하게 된다.  
        </P
><P
>            이렇게 해서 문자변경과 관련된 코드는 모두 이해하게 되었다. 이제 남은 것은 
            파일로 부터 읽어들이고 쓰는 부분이다. 이부분을 다루기 위해서는 
            UNIX의 open() 시스템콜을 어떻게 사용하는지 알아야 한다. 다음은 open() 
            시스템콜을 사용하기 위한 시스템 콜번호와 인자를 위한 레지스터들 이다.
            <P
></P
><OL
TYPE="1"
><LI
><P
>                    %eax 는 시스템 콜 번호를 저장한다. open의 시스템 콜번호는 5이다.
                </P
></LI
><LI
><P
>                    %ebx 에는 열고자 하는 파일의 이름이 들어간다. 파일이름은 반드시 
                    끝이 null로 끝나는 문자열이어야 한다.
                </P
></LI
><LI
><P
>                    %ecx 에는 파일을 열때 사용할 옵션이 들어간다. 읽기 전용, 쓰기전용, 
                    읽기/쓰기중 선택할 수 있다. 또한 파일이 존재하지 않을 경우 파일을 
                    생성할것인지, 존재할 경우에는 존재하는 파일을 열건지 아니면 
                    에러를 리턴할 건지 등도 결정할 수 있다.
                </P
></LI
><LI
><P
>                    %edx 는 파일의 권한을 설정하기 위해 사용한다. 여기에는 일반적인 
                    유닉스 권한을 사용할 수 있다. 
                </P
></LI
></OL
>
            이 시스템 콜이 실행 후, 우리는 읽기 전용의 파일 지정자를 얻을 수 있다. 이 
            파일 지정자는 %eax를 통해서 얻어올 수 있다. 
        </P
><P
>            그럼 이제 파일을 열어야 할건데, 이 프로그램의 경우 열어야될 파일 이름을 
            프로그램 실행인자로 넘겨 받고 있다. 다행스럽게도 프로그램의 실행인자는 
            쉽게 읽어들일 수 있는 위치에 null-terminate 처리까지 마친 깔끔한 상태로 
            저장되어 있다. 리눅스에서 프로그램이 실행인자의 저장된 위치를 가리키는 
            포인터는 스택에 저장이 된다. 인자의 수가 저장된 포인터의 위치는 8(%esp)에
            프로그램의 위치는 12(%esp) 그리고 실제 인자는 16(%esp)에 저장된다. 
            C 프로그래밍 언어의 경우에는 argv 배열 값을 통해서 얻어오게 된다.
        </P
><P
>            우리의 첫번째 프로그램에서 최근의 스택 위치는 %ebp에 저장하도록 했다. 그리고 
            파일 지정자를 저장하기 위한 스택공간을 할당하고 있다. 나중에 여기에 
            열린파일 지정자가 들어가게 된다.
        </P
><P
>            이 프로그램은 우선 첫번째 실행인자를 얻어온다. 이 실행인자는 우리가 읽어들이기 
            위한 원본 파일의 이름이된다. 원본 파일의 경우에는 단지 읽기만 하면 되므로 
            읽기 전용으로 열었다. 파일의 권한은 $0666로 %edx를 를 통해서 넘겼다. 그 후 
            %eax에 시스템콜의 번호를 저장하고 시스템콜을 실행한다. 실행이 성공적으로 
            끝나게 되면, 우리는 스택에 있는 파일지정자를 읽어 올 수 있게 된다. 
        </P
><P
>            지금까지와 같은 방법으로 복사될 파일 이름을 쓰기 전용으로 연다. 
        </P
><P
>            이제 파일을 읽고/쓰는 주요 부분에 대해서 알아보자. 우리는 입력된 파일로 부터 
            고정된 크기의 데이터를 읽어오고, 이것을 대/소문자 변환 함수에 넘긴 후, 
            그 결과 값을 출력 파일에 쓰게 된다. 대/소문자 변환은 문자하나하나를 차례대로 
            검사해서 변환하게 된다.   
        </P
><P
>            데이터를 읽기 위해서 우리는 read 시스템 콜을 사용하고 있다. 이 시스템 콜은 
            파일 지정자로 부터 데이터를 읽어들여서 버퍼에 지정된 크기만큼 복사한다. 
            이 시스템콜은 실행을 마친후 읽어들인 데이터의 크기를 리턴한다. 만약 
            파일의 끝을 만나게 되면 0을 리턴한다.
        </P
><P
>            읽기 코드영역은 %eax의 값이 파일의 끝(0)을 가리키게 되면 빠져나오게 된다.   
        </P
><P
>            만약 파일의 끝이 아니라면 읽어들인 데이터를 convert_to_upper함수로 넘겨서 
            문자를 변환하게 된다. 
        </P
><P
>            마지막으로 write 시스템콜을 이용해서 변환된 문자데이터를 복사할 파일에 쓰게 
            된다. 모든 데이터의 처리가 다 끝나고 루프를 벗어나면 마지막으로 열린 
            파일 지정자들을 모두 닫아준다. 파일을 닫기 위해서는 close시스템콜 호출한다. 
            이 시스템 콜은 %ebx에 닫을 파일지정자를 넘긴다음 호출하면 된다.  
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="LASTSTUDY"
></A
>5.5. 복습</H2
><P
>            <P
></P
><UL
><LI
><P
>                        버퍼란 무엇인가 ?
                    </P
></LI
><LI
><P
>                        표준 파일 지정자는 무엇이며, 어디에 사용할 수 있는가 ?
                    </P
></LI
><LI
><P
>                        .data 섹션과 .bss 섹션의 차이는 무엇인가 .
                    </P
></LI
><LI
><P
>                        파일로 부터 읽고 쓰기 위해서 사용하는 시스템콜에 대해서 설명하시오.
                    </P
></LI
></UL
>
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="RECORDREADANDREAD"
></A
>6. 레코드 단위의 읽기와 쓰기</H1
><P
>        <A
HREF="#USEDFILE"
>5&#51208;</A
>장의 파일다루기는 파일을 다루는 기본적인 규칙을 
        알려주었다는 점에서는 쓸만한 내용이긴 하지만, 실제 애플리케이션에 
        적용시키기에는 부족한 점이 있다. 5장의 예는 그냥 문자열을 단순하게 읽어들이는 
        정도였지만, 대부분의 응용 애플리케이션은 파일에 구조화된 데이터를 사용하게 
        된다. 보통 C언어에서 데이터를 다루기 위해서 흔히 볼 수 있는 구조체 데이터를 
        연상하면 될것이다.   
    </P
><P
>        이러한 구조화된 데이터는 컴퓨터상에서 효율적으로 다룰 수 있다. 
        이들 구조화된 데이터는 데이터를 레코드 단위로 저장하게 되는데 각각의 
        레코드는 여러개의 필드로 구성이된다. 프로그래머는 각 레코드의 크기를 쉽게 얻어
        올 수 있으므로, 원하는 데이터에 빠르게 접근할 수 있게 된다.
    </P
><P
>        이러한 레코드는 두가지 정도를 생각할 수 있을 것 같다. 하나는 레코드의 
        각필드의 크기가 고정되어 있는 고정길이를 가진 레코드이고, 또하나는 필드의 
        크기가 변동되는 변동레코드이다. 고정 레코드를 다루는 프로그램은 대체적으로 
        가볍고 빠르게 작동할 수 있을 뿐아니라 코딩하기도 쉽다라는 점 때문에 
        아주 복잡하지 않은 애플리케이션을 작성하기 위한 방법으로 널리 사용되고 있다. 
    </P
><P
>        반면 변동길이 레코드의 경우에는 다양한 데이터를 다루어야 하는 DB 프로그램과 
        같은 좀더 강략한 애플리케이션을 만들기 위해서 사용할 수 있다. 물론 그만큼 
        프로그램 작성시 생각할 요소가 많아 질 것이다. 
    </P
><P
>        이번 장에서는 고정길이를 가진 레코드를 다루는 프로그램을 작성할 것이다. 
        우리가 다루는 레코드는 개인정보를 가지게 될 것이며, 이를 위해서 
        다음과 같은 필드들을 사용할 것이다.           
        <P
></P
><UL
><LI
><P
>                    성 - 8byte
                </P
></LI
><LI
><P
>                    이름 - 16byte 
                </P
></LI
><LI
><P
>                    주소 - 240byte
                </P
></LI
><LI
><P
>                    나이 - 4byte
                </P
></LI
></UL
>
        위의 필드중 나이를 제외한 모든 필드는 문자열 데이터가 된다. 나이는 숫자 
        이므로 4byte정도를 할당하는 것으로 충분 할 것이다. (물론 인간의 최대 수명이
        120세 정도라고 볼 수 있으므로 1byte만 할당하는 정도로도 충분할 것이다. 
        그러나 우선은 간단하게 4byte로 하겠다.)  
    </P
><P
>        지금까지 우리가 작성한 어셈블리 예재들은 단지 하나의 프로그램 파일로 이루어져
        있었으나 여기에서는 여러개의 파일로 분리해서 작성하도록 할것이다. C에서 흔히 말하는
        모듈별 분할 컴파일을 위함인데, 이렇게 하면 기능별로 소스코드 파일을 유지할 수 
        있으므로 프로그램의 유지/보수가 수월해 지는 장점을 가진다. 이렇게 모듈별로 프로그램을
        나누어서 유지할경우 프로그램 전역에 걸쳐서 사용되는 공통된 값들을 유지할 필요가 
        있다. C에서는 include파일을 통해서 이러한 문제를 해결하는데, 어셈블리역시 비슷한 
        방법을 이용해서 선언과 정의를 분리해낼 수 있다.     
    </P
><P
>        다음은 프로그램에서 사용할 유저정보 구조체를 위한 선언파일로 record-def.s로 
        저장하도록 하겠다.
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.equ RECORD_FIRSTNAME,      0
.equ RECORD_LASTNAME,          8 
.equ RECORD_ADDRESS,           24 
.equ RECORD_AGE,           264     
.equ RECORD_SIZE,          268
        </PRE
></TD
></TR
></TABLE
>
        이와 함께 프로그램 전역적으로 사용될 각종 상수를 정의했다. 이들 상수는 
        시스템 콜 번호와 표준입출력과 같은 값들을 명시하도록 할것이며, linux.s에 
        저장하도록 하겠다.
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>#System Call Numbers
.equ SYS_EXIT, 1
.equ SYS_READ, 3
.equ SYS_WRITE, 4
.equ SYS_OPEN, 5
.equ SYS_CLOSE, 6
.equ SYS_BRK, 45

#System Call Interrupt Number
.equ LINUX_SYSCALL, 0x80 #Standard File Descriptors
.equ STDIN, 0 
.equ STDOUT, 1
.equ STDERR, 2

#Common Status Codes
.equ END_OF_FILE, 0
        </PRE
></TD
></TR
></TABLE
>
    </P
><P
>        이제 우리는 정의된 구조체를 이용해서 3개의 프로그램을 만들도록 하겠다. 첫번째 
        프로그램은 구조체를 레코드로해서 파일로 저장하는 프로그램이다. 두번째 프로그램은 
        파일의 레코드 내용을 출력하는 프로그램이며, 세번째 프로그램은 모든 레코드의 
        나이를 더해서 출력하는 프로그램이다.
    </P
><P
>        이들 프로그램은 구조체와 더불어 프로그램을 가로질러서 사용되는 상수를 정의하고 
        있는 linux.s를 포함하게 될 것이다.  
    </P
><P
>        이러한 일을 하는 프로그램을 만들기 위해서 우리는 함수를 작성할 것이다. 함수를 
        작성하기 위해서 함수가 어떠한 인자를 필요로 할지를 생각해 보도록 하자. 
        <P
></P
><UL
><LI
><P
>                    레코드의 읽은 데이터를 저장하기 위한 버퍼의 위치
                </P
></LI
><LI
><P
>                    읽거나 쓰기 위한 파일 지정자
                </P
></LI
></UL
>
    </P
><P
>        다음은 파일 지정자로 부터 읽기 위한 함수다.
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># 하는일 : 이 함수는 파일 지정자로 부터 레코드를 읽어 들인다. 
# 입  력 : 파일 지정자와 버퍼 
# 출  력 : 함수는 버퍼에 레코드의 내용을 쓰고 상태값을 리턴한다.

# 상수를 정의한 파일들을 포함 시킨다.
.include "record-def.s"
.include "linux.s"

# 스택 지역 변수
.equ ST_READ_BUFFER,    8
.equ ST_FILEDES,        12
.section .text
.globl read_record
.type read_record, @function
read_record:
pushl %ebp
movl  %esp, %ebp

push %ebx
movl ST_FILEDES(%ebp), %ebx
movl ST_READ_BUFFER(%ebp), %ecx
movl $RECORD_SIZE, %edx
movl $SYS_READ, %eax
int  $LINUX_SYSCALL

# %eax는 리턴 값으로, 함수의 실행 결과를 호출한 프로그램에게 
# 되돌려주기 위해서 사용한다.
popl %ebx

movl %ebp, %esp
popl %ebp
ret
        </PRE
></TD
></TR
></TABLE
>
        이 함수는 매우 간단하다. 인자로 주어진 파일 지정자로 부터 레코드 크기(RECORD_SIZE)
        만큼의 데이터를 읽어 들이고, 버퍼에 저장하는 일을 한다.  
    </P
><P
>        버퍼의 내용을 레코드에 쓰는 함수 역시 간단하게 작성할 수 있다. 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># 하는일 : 파일 지정자에 레코드를 쓴다. 
# 입  력 : 파일지정자와 버퍼
# 출  력 : 함수의 실행 결과 
.include "linux.s"
.include "record-def.s"

# 스택 로컬 변수
.equ ST_WRITE_BUFFER, 8
.equ ST_FILEDES, 12
.section .text
.globl write_record
.type write_record, @fundtion

write_record:
pushl %ebp
movl %esp, %ebp


pushl %ebx
movl $SYS_WRITE, %eax
movl ST_FILEDES(%ebp), %ebx
movl ST_WRITE_BUFFER(%ebp), %eax
movl $RECORD_SIZE, %edx
int  $LINUX_SYSCALL

# %eax는 리턴 값으로 호출한 프로그램에게 실행 결과값을 
# 넘겨준다.
popl %ebx

movl %ebp, %esp
popl %ebp
ret
        </PRE
></TD
></TR
></TABLE
>
    </P
><P
>        이걸로 기본적인 함수를 만들었으므로 이제 본격적으로 프로그램을 작성할 시간이다. 
    </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="RECORDWRITE"
></A
>6.1. 레코드 쓰기</H2
><P
>            이 프로그램은 레코드를 파일에 쓰는 프로그램인데, 간단하게 작성하기 위해서 
            레코드의 필드 값은 하드코딩 하도록 하겠다. 
        </P
><P
>            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>    
.include "linux.s"
.include "record-def.s"

.section .data

record1:
.ascii "yun\0"
.rept  4    #padding 
.byte  0
.endr

.ascii "dream\0"
.rept  10 
.byte  0
.endr

.ascii "Seoul city Chun-dam dong\0" 
.rept   215
.byte   0
.endr

.long 25

record2:
.ascii "yun\0" 
.rept  4
.byte  0
.endr

.ascii "mung\0"
.rept  11
.byte  0 
.endr
.ascii "Seoul city joinc dong\0"
.rept  218
.byte  0
.endr

.long 27

file_name:
.ascii "test.dat\0"
.equ ST_FILE_DESCRIPTOR, -4
.globl _start


_start:
movl %esp, %ebp
subl $4, %esp

movl $SYS_OPEN, %eax
movl $file_name, %ebx
movl $0101, %ecx
movl $0666, %edx
int   $LINUX_SYSCALL

movl %eax, ST_FILE_DESCRIPTOR(%ebp)

pushl ST_FILE_DESCRIPTOR(%ebp)
pushl $record1
call  write_record
addl  $8, %esp

pushl ST_FILE_DESCRIPTOR(%ebp)
pushl $record2
call  write_record
addl  $8, %esp

movl $SYS_CLOSE, %eax
movl ST_FILE_DESCRIPTOR(%ebp), %ebx
int  $LINUX_SYSCALL

movl $SYS_EXIT, %eax
movl $0, %ebx 
int  $LINUX_SYSCALL
            </PRE
></TD
></TR
></TABLE
>
        </P
><P
>            이 프로그램은 매우 간단하다. 단지 몇개의 상수들이 사용되었으며, .data 섹션에 
            저장해야될 레코드가 있는 것외의 다른 것들(읽기/쓰기)는 이미 다룬 적이 있는 
            내용들이다. 
        </P
><P
>            프로그램의 가장 처음에는 상수가 선언된 파일을 포함(include)시키는 
            코드가 들어갔다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.include "linux.s"
.include "record-def.s"
            </PRE
></TD
></TR
></TABLE
>
            C언어를 해봤다면 굳이 설명할 필요 없는 코드로, 프로그램 전역적으로 사용되어야 할 
            상수나 함수들을 별도의 파일에 선언해 놓고 이를 사용하기 위한 목적으로 사용한다.
        </P
><P
>            다음 레코드의 값을 정의 하는 부분이 나오는데 여기에서 .rept라는 
            새로운 지시어를 만나게 된다. 이 지시어는 .endr 지시어와 함께 사용되는데, 
            .rept에서 지정된 숫자 만큼 중간에 오는 값으로 채우는 일을 한다. 위 코드에서는 
            문자열 필드의 나머지 부분을 '\0'으로 채우기 위한 목적으로 사용하고 있다. 
            C에서 메모리 영역을 특정 값으로 채우기 위해서 사용하는 memset(2)과 비슷한 용도로 
            사용할 수 있을 것이다.    
        </P
><P
>            이제 컴파일과 링크 과정을 거쳐서 실행 파일을 만들어 보도록 하자.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># as write-records.s -o write-records.o
# as write.s -o write.o
# ld write-records.o write.o -o write-records
            </PRE
></TD
></TR
></TABLE
>
            우리가 만든 프로그램은 2개의 파일로 나뉘어져 있다. 그러므로 이들을 하나로 
            묶어주는(link)과정이 필요하게 된다. 링크는 ld linker를 이용하면 된다. 만들어진 
            실행파일은 다음과 같이 실행 시킬 수 있다.    
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># ./write-records
            </PRE
></TD
></TR
></TABLE
>
            실행되고 나면 test.dat라는 파일이 만들어 진다. 이 파일을 vi에디터로 확이해 보면 
            일반 텍스트 파일과는 좀 다르게 출력될 것이다. 이유는 NULL과 같은 출력될 수 없는 
            문자들이 포함되어 있기 때문이다. 어쨋든 레코드를 성공적으로 썼으니, 이제 
            레코드로 부터 읽어들이는 프로그램을 만들어 보도록 하자.  
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="RECORDREAD"
></A
>6.2. 레코드 읽기</H2
><P
>            여기에서는 저장된 레코드로 부터 이름, 주소, 나이를 읽어와서 출력하는 프로그램을
            만들어 보도록 하겠다.     
        </P
><P
>            우리가 출력하고자 하는 레코드의 필드중 이름과 주소는 고정된 길이를 가지고 있지 
            않다. 그러므로 몇개의 문자를 써야하는지를 계수할 수 있어야 한다. 다행히도 우리는 
            레코드를 적을 때, 필드의 끝을 '\0'로 포맷했음으로, '\0'을 만날때까지 읽어들인 
            문자만 계수하면 된다. 가정 먼저 문자의 갯수를 계수하는 프로그램을 만들어 
            보도록 하겠다. 이 프로그램의 이름은 count-chars.s로 하겠다.     
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># 목    적 : null byte를 만날 때까지 문자의 갯수를 검사한다.
# 입    력 : 문자열의 주소  
# 출    력 : 문자열의 갯수를 %eax로 
# 프로세스 :
#   %ecx  -  문자 카운트
#   %al   -  현재 문자
#   %edx  -  현재 문자 주소 

.include "linux.s"
.include "record-def.s"

.type count_chars, @function
.globl count_chars

# 첫번째 인자가 들어 있는 스택 
.equ ST_STRING_START_ADDRESS, 8

count_chars:
pushl %ebp
movl  %esp, %ebp

# 0부터 카운트를 시작한다.
movl $0, %ecx
movl ST_STRING_START_ADDRESS(%ebp), %edx

count_loop_begin:
# 최근 문자를 가져온다.
movb (%edx), %al 

# null인지 검사한다.
cmpb $0, %al
# 만약 null이라면 루프를 끝낸다.
je count_loop_end

# 널이 아니라면 포인터와 카운트를 1씩 증가 시킨다. 
incl %ecx
incl %edx

# 루프의 처음으로 되돌아 간다.
jmp  count_loop_begin

count_loop_end:
# 카운트 결과를 %eax로 복사한다.  
movl %ecx, %eax

popl %ebp
ret
            </PRE
></TD
></TR
></TABLE
>
            이해하기에 별 어려운 점이 없는 간단한 코드다. 이 코드는 데이타 주소로 부터 
            1바이트씩 읽어 나가면서 +1을 한다. 만약 읽은 바이트가 '\0'이라면 지금까지 계수한
            수를 리턴한다.
        </P
><P
>            이제 실제 파일로 부터 레코드를 읽어들이는 코드를 만들어 보도록 하자. 
            이 프로그램은 다음과 같은 흐름을 가질 것이다.  
            <P
></P
><UL
><LI
><P
>                        파일을 연다
                    </P
></LI
><LI
><P
>                        레코드를 읽는다.
                    </P
></LI
><LI
><P
>                        이름 문자열의 크기를 계수한다. 
                    </P
></LI
><LI
><P
>                        이름을 표준 출력한다.
                    </P
></LI
><LI
><P
>                        개행문자를 출력한다.    
                    </P
></LI
><LI
><P
>                        다른 레코드를 읽는다.    
                    </P
></LI
></UL
>
        </P
><P
>            이제 우리는 개행문자를 출력하는 간단한 프로그램을 만들 것이다. 이것은 
            각 필드의 값을 출력한 후 필드를 구분해서 보기 좋게 만들기 위한 목적으로 사용한다. 
            프로그램의 이름은 read-records.s로 하겠다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.include "linux.s"
.globl write_newline
.type write_newline, @function
.section .data

newline:
.ascii "\n"
.section .text
.equ ST_FILEDES, 8

write_newline:
pushl %ebp
movl  %esp, %ebp

movl $SYS_WRITE, %eax
movl ST_FILEDES(%ebp), %ebx
movl $newline, %ecx
movl $1, %edx
int  $LINUX_SYSCALL
movl %ebp, %esp 
popl %ebp
ret
            </PRE
></TD
></TR
></TABLE
>
        </P
><P
>            이제 실제 레코드로 부터 데이터를 읽어오는 메인프로그램을 작성한다. 프로그램의 
            이름은 read-records.s로 하겠다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.include "linux.s"
.include "record-def.s"

.section .data

file_name:
.ascii "test.dat\0"

.section .bss
.lcomm record_buffer, RECORD_SIZE

.section .text

# Main 프로그램 
.globl _start

_start:
# 입력과 출력을 위한 파일지정자의 스택위치를 
# 계산
.equ ST_INPUT_DESCRIPTOR, -4
.equ ST_OUTPUT_DESCRIPTOR, -8

# 스택 포인터를 %ebp로 복사한다.
movl %esp, %ebp
# 파일지정자를 위한 공간을 할당한다.
subl $8, %esp

# 파일을 연다.
movl $SYS_OPEN, %eax
movl $file_name, %ebx
movl $0, %ecx        # 읽기 전용으로 연다.
movl $0666, %edx
int  $LINUX_SYSCALL

# 입력을 위한 파일 지정자를 저장한다.
movl %eax, ST_INPUT_DESCRIPTOR(%ebp)

# 표준 출력(1)을 위한 파일지정자를 저장한다. 
movl $STDOUT, ST_OUTPUT_DESCRIPTOR(%ebp)

record_read_loop:  
pushl ST_INPUT_DESCRIPTOR(%ebp)
pushl $record_buffer
call  read_record 
addl  $8, %esp

# 읽어들인 데이터의 길이가  
# 레코드 크기와 같은지 확인한다. 
# 레코드 크기와 다르다면 루프를 벗어난다. 
cmpl  $RECORD_SIZE, %eax
jne   finished_reading

# 그렇지 않다면 레코드의 이름을 출력한다. 
# 이름을 출력하기 위해서는 문자열의 크기를 
# 읽어와야 한다.
pushl $RECORD_FIRSTNAME + record_buffer
call  count_chars
addl  $4, %esp

movl  %eax, %edx
movl  ST_OUTPUT_DESCRIPTOR(%ebp), %ebx
movl  $SYS_WRITE, %eax
movl  $3, %ecx
int   $LINUX_SYSCALL
ret

pushl ST_OUTPUT_DESCRIPTOR(%ebp)
call  write_newline
addl  $4, %esp

jmp   record_read_loop

finished_reading:
movl $SYS_EXIT, %eax
movl $0, %ebx
int  $LINUX_SYSCALL
            </PRE
></TD
></TR
></TABLE
>
        </P
><P
>            이제 지금까지의 프로그램을 컴파일하고 링크해서 실행가능한 파일로 만들어 보자.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># as count-chars.s -o count-chars.o
# as write-newline.s -o write-newline.o 
# as read-records.s -o read-records.o
# as read.s -o read.o
# ld read.o read-records.o write-newline.o count-chars.o -o read-records
            </PRE
></TD
></TR
></TABLE
>
            프로그램은 ./read-records 로 실행시킬 수 있다. 
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="RECORDEDIT"
></A
>6.3. 레코드 수정</H2
><P
>            이 프로그램은 다음과 같은 코드영역을 가진다.
            <P
></P
><UL
><LI
><P
>                        입력파일과 출력파일을 연다.
                    </P
></LI
><LI
><P
>                        입력파일로 부터 레코드를 읽는다.
                    </P
></LI
><LI
><P
>                        나이를 증가 시킨다.
                    </P
></LI
><LI
><P
>                        출력파일에 쓴다.
                    </P
></LI
></UL
>
        </P
><P
>            다음은 레코드의 값을 수정해서 다른 파일로 저장하는 프로그램이다. 프로그램의 
            이름은 add-year.s로 하겠다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.include "linux.s"
.include "record-def.s"

.section .data
input_file_name:
.ascii "test.dat\0"

output_file_name:
.ascii "testout.dat\0"

.section .bss
.lcomm record_buffer, RECORD_SIZE

.equ ST_INPUT_DESCRIPTOR, -4
.equ ST_OUTPUT_DESCRIPTOR, -8


.section .text
.globl _start


_start:
movl %esp, %ebp
subl $8, %esp 

movl $SYS_OPEN, %eax
movl $input_file_name, %ebx
movl $0, %ecx
movl $0666, %edx
int  $LINUX_SYSCALL

movl %eax, ST_INPUT_DESCRIPTOR(%ebp)

# 쓰기 위해서 파일 열기
movl  $SYS_OPEN, %eax
movl  $output_file_name, %ebx
movl  $0101, %ecx
movl  $0666, %edx
int   $LINUX_SYSCALL

movl  %eax, ST_OUTPUT_DESCRIPTOR(%ebp)


loop_begin:
pushl ST_INPUT_DESCRIPTOR(%ebp) 
pushl $record_buffer
call  read_record 
addl  $8, %esp

# read로 부터의 리턴값과 레코드크기를 비교한다.
# 만약 레코드 크기와 같지 않다면 루프를 종료한다. 
cmpl  $RECORD_SIZE, %eax
jne   loop_end

# 나이를 증가시킨다.
incl  record_buffer + RECORD_AGE

pushl ST_OUTPUT_DESCRIPTOR(%ebp)
push  $record_buffer
call  write_record
addl  $8, %esp

jmp   loop_begin

loop_end:
movl  $SYS_EXIT, %eax
movl  $0, %ebx
int   $LINUX_SYSCALL
            </PRE
></TD
></TR
></TABLE
>
        </P
><P
>            코딩을 마쳤다면 다음과 같은 방법으로 실행파일을 생성하도록 하자. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># as add-year.s -o add-year.o
# ld add-year.o read.o write.o -o add-year
            </PRE
></TD
></TR
></TABLE
>
            이 프로그램을 ./add-year로 실행시킬 수 있다. 실행시키고 나면 testout.dat라는 
            파일이 생성된걸 확인할 수 있을 것이다. 
        </P
><P
>            지금까지의 내용을 통해서 우리는 고정된 길이의 레코드를 제어하는 프로그램은 
            간단하게 작성할 수 있다는 것을 배웠다. 단지 지정된 크기만큼 데이터를 읽어서 
            버퍼에 쌓고, 이런 저런 작업을 해서 출력하기만 하면 된다.  
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="ENDINGCHAPTER"
></A
>6.4. 마치며</H2
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="AEN724"
></A
>6.4.1. 복습</H3
><P
>                <P
></P
><UL
><LI
><P
>                            레코드란 무엇인가 ?
                        </P
></LI
><LI
><P
>                            고정된 길이를 가진 레코드가 그렇지 않은 레코드에 대해서 
                            얻을 수 있는 장점은 무엇인가.
                        </P
></LI
><LI
><P
>                            여러개의 파일로 분리된 어셈블리 소스에서 상수를 포함시키는 
                            방법에 대해서 설명하시오.
                        </P
></LI
><LI
><P
>                            왜 여러개의 프로그램 파일로 나누어서 프로그램을 작성하는가.
                        </P
></LI
><LI
><P
>                            record_buffer + RECORD_AGE 가 의미하는 바를 설명하시오. 
                            왜 어드래스 모드를 사용하고 있는가 ?
                        </P
></LI
></UL
>
            </P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="AEN738"
></A
>6.4.2. 연습문제</H3
><P
>                <P
></P
><UL
><LI
><P
>                        프로그램의 실행인자로 파일이름을 받도록 예제 
                        프로그램들을 수정해 보자.    
                        </P
></LI
><LI
><P
>                            lseek(2) 시스템 호출에 대해서 연구해 보도록하자. lseek를 
                            이용해서 읽은 파일의 나이를 수정한 후 다시 저장하도록 
                            add-year 프로그램을 수정해보자.
                        </P
></LI
><LI
><P
>                            키보드로부터 레코드 값을 입력받아서 파일로 쓰는 프로그램을 
                            만들어 보도록 한다. 
                        </P
></LI
></UL
>
            </P
></DIV
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="ROBUSTPROGMAKE"
></A
>7. 견고한 프로그램 작성하기</H1
><P
>        이번장에서는 견고한 프로그램을 작성하는 방법에 대해서 알아보도록 하겠다. 
        견고한 프로그램이란 어떠한 문제도 발생시키지 않는 프로그램이 아니다. 
        물론 가능한 문제를 발생시키지 않도록 만들어야 겠지만, 문제 발생시 이를 
        깔끔하게 처리해서 심각한 문제로 가지 않도록 하는 프로그램을 말한다. 
        문제의 처리를 위해서는 에러코드를 제대로 검사하는 프로그램의 작성이 필요하다.
    </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="WHYLATE"
></A
>7.1. 왜 시간이 지연되는가 ?</H2
><P
>            프로그래머의 공통된 의견 중 하나는 언제나 시간 부족에 시달린다는 점이다. 
            이러한 사실을 잘 알고 있는 (경험있는) 프로그래머들은 프로젝트 기간을 
            산정하는데 있어서 자신이 예상하는 시간의 2배 길게는 4배까지를 잡는다. 
            그러나 그럼에도 불구하고 여전히 시간은 부족하다. 이러한 문제가 발생하는 
            원인은 다음과 같다.
        </P
><P
>    
            <P
></P
><UL
><LI
><P
>                    프로젝트 코드와 관련되지 않는 미팅과 모임, 다른 (틈틈이 발생하는) 
                    업무들이 발생하고 여기에 시간을 빼앗긴다.
                </P
></LI
><LI
><P
>                    프로그래머는 종종 프로젝트에 대한 이해가 부족한 상태에서(물론 자신은
                    완전히 이해했다고 생각을 하지만) 프로젝트를 실행한다.
                </P
></LI
><LI
><P
>                    프로그래머가 만들어야 하는 제품의 모든 제반사항을 이해할 수 있는건 아니다. 
                </P
></LI
><LI
><P
>                    프로그래머는 종종 이전에 수행했던 비슷한 종류의 프로젝트를 경험삼아서 
                    지금 수행하는 프로젝트에 대한 시간을 산출한다(보통 더 짧게). 
                    그러나 수행하다 보면 이전 프로젝트와 지금 프로젝트는 전혀 별개라는 것을 
                    뒤늦게 깨닫게 된다.
                </P
></LI
><LI
><P
>                    프로그래머는 시간을 기간을 계산할 때 프로그램 안정화와 관련된 부분을 빼고 
                    시간을 계산한다. 프로젝트 기간을 초과했을 때 "예전에 말한 프로젝트 시간은 
                    안정화(디버깅및 테스트)와 관련된 부분은 제외한 겁니다."라고 프로젝트 지연을 
                    책망하는 관리자에게 지연이유를 설명하는 모습을 흔히 볼 수 있다.  
                </P
><P
>                    막상 프로젝트 종반에 다다르면 디버깅과 테스트에 상당히 많은 시간이 소요된다는 
                    것을 알게된다 - 사실 누구나 다 알지만 막상 프로젝트가 닥치면 무시하는 경우가 많다 -.
                </P
></LI
></UL
>
            이러한 지연요소 중 마지막 요소인 "견고한 프로그램 작성"에 관련된 내용을 다룰 것이다. 
            프로그램 작성시에 견고한 (방식의)코딩을 한다면 나중에 디버깅과 테스트 시간을 상당히 
            줄일 수 있을 뿐더러, 질 좋은 제품을 만들어 낼 수 있다. 
        </P
><P
>            대문자 변환(toupper) 프로그램은 분명히 잘 작동하긴 하지만, 그것은 조건이 완벽하게 
            맞아들어가는 경우가 된다. 예를 들면 파일이 존재하지 않는다거나 존재하지만 권한문제 
            등으로 읽어들이지 못하는 경우가 발생할 수도 있다. 우리가 만든 프로그램은 이러한 
            예외 상황에 대처하지 못하고 있다. 문제가 발생할 경우 어디에서 발생했는지 알아 
            내기 힘들 수도 있다.
        </P
><P
>            그래도 toupper 프로그램은 꽤나 작은 프로그램이기 때문에 문제가 좀 발생해도 
            사후 처리를 하는데 그리 문제가 되지 않겠지만, 프로그램의 크기가 커지면 심각한 
            문제가 될 수 있다. 수천 수만라인의 프로그램이 돌다가 갑자기 "암런 에러메시지도 없이"
            작동이 중단되어 버린다면 난감할 것이다. 그러므로 프로그램을 만들 때는 
            상태체크하고 이를 제어하는데 많은 시간을 할애해야 한다. 만약 여러분이 프로그램의 완성 
            한데 2주의 시간이 걸린다고 하면 최소한 그중 2일정도를 견고한 프록램을 만드는데 
            사용해야 한다. 모든 에러메시지들은 항상 화면에 출력 될 수 있어야 함을 기억하라. 
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="TIPFORROBUSTPROG"
></A
>7.2. 견고한 프로그램을 만들기 위한 몇가지 팁</H2
><DIV
CLASS="SECTION"
><H3
CLASS="SECTION"
><A
NAME="AEN771"
></A
>7.2.1. 사용자 테스트</H3
><P
>                테스트는 프로그래머가 해야될 가장 기본적인 업무중 하나다. 만약 충분한 테스트가 
                이루어지지 않는다면, 제대로된 작동을 보장할 수 없게된다. 예를 들어 여러분의 
                프로그램이 양수를 입력받아서 처리해서 결과를 알려주는 프로그램이라고 가정해 보자. 
                그런데 어떤 이유로 음수가 들어올 수도 있을 것이다. 혹은 숫자 대신에 문자가 출력된다
                든지 지나치게 큰 수가 입력되거나 0이 입력되는 등의 일이 발생할 수 있을 것이다. 
                이런 경우에 대해서 충분히 테스트가 이루어 져야 한다. 또한 처음과 마지막에 
                공백문자가 입력된 경우, 중간에 공백문자가 입력된 경우 아뭏든 발생가능 할거라고 
                생각되는 모든 경우에 대해서 테스트 해야 한다. 사용자는 어떤 입력을 할지 예측할 
                수 없기 때문이다.
            </P
><P
>                문제가 발생되는 경우를 확인했다면, 재입력을 요구할 건지, (공백 등을 제거해서) 
                제대로된 데이터로 만들어 줄건지, 프로그램의 다시 실행시킬 건지를 결정해줘야 한다. 
                이런 테스트가 충분하지 않다면, 실제 제품이 출시되고나서 고객들로 부터 테스트를 
                받게 될 것이다. 물론 상당한 스트레스가 될 것이다.
            </P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="AEN775"
></A
>7.2.2. 데이터 테스트</H3
><P
>                프로그램을 디자인 할때, 당신이 사용하는 각각의 함수는 받아들여야할 데이터의 범위에 
                대해서 명확히 해야 한다. 이를 위해서 프로그래머는 함수에 입력되는 데이터에 대한 
                테스트를 해야 한다. 가장 중요한 테스트는 <B
CLASS="EMPHASIS"
>corner case</B
>와 
                <B
CLASS="EMPHASIS"
>edge case</B
> 테스트다. 간단히 말해서 경계값을 입력했을 때 
                어떤 문제가 발생하는지를 테스트 하는 것이다.   
            </P
><P
>                다음은 이러한 테스트를 위해서 특별히 다음과 같은 값들을 중요하게 테스트 해야 한다.
                <P
></P
><UL
><LI
><P
>                            숫자 0
                        </P
></LI
><LI
><P
>                            숫자 1 
                        </P
></LI
><LI
><P
>                            범위에 들어가는 숫자
                        </P
></LI
><LI
><P
>                            범위를 초과하는 숫자
                        </P
></LI
><LI
><P
>                            범위에서 가장 큰 숫자
                        </P
></LI
><LI
><P
>                            범위에서 가장 작은 숫자
                        </P
></LI
><LI
><P
>                            범위에서 가장 작은 숫자보다 한단계 작은 숫자
                        </P
></LI
><LI
><P
>                            범위에서 가장 큰 숫자보다 한단계 큰 숫자 
                        </P
></LI
></UL
>
                예를 들어서 5와 200사이의 값을 받아들이는 프로그램이라고 한다면 개인적으로 0, 1, 4, 
                5, 153, 200, 201, 255등에 대해서 테스트를 할것이다.
                그리고 어떤 수들에 대해서 중점적으로 테스트를 해야 하는지에 
                대해서도 결정할 필요가 있다. 예를들어서 프로그래머의 나이를 받아들여서 테스트하는 
                프로그램을 작성한다고 하면 20에서 40사이의 수에 대해서 집중적으로 테스트할 필요가 
                있기 때문이다.
            </P
><P
>                특히 0에 대해서는 각별히 테스트할 필요가 있는데, 만약 함수가 입력된 값으로 나누는 
                연산이 있는데, 이 때 0이 
                입력되면 프로그램의 작동이 아예 종료되어 버리는 경우가 발생할 수도 있기 때문이다. 
            </P
><P
>                이런 이유로 내부에서 사용되는 함수들은 올바른 데이터인지, 혹은 좋은 데이터인지를 
                확인하기 위해서 (값의 범위가 0-255까지라고 했을 때, 사람의 나이를 체크하는 프로그램
                이라면, 244가 비록 올바른 데이터라고 하더라도 좋은 데이터라고는 할 수 없다),
                대소 관계를 이용하게 된다. 만약 입력된 값이 범위를 벗어난다면 에러메시지를 출력하거나
                프로그램이 종료하도록 하면 될것이다. 
                C언어에서는 assert라는 매크로 함수를 이용하면 이러한 체크과정을 좀더 수월하게 할 수 
                있다. assert함수는 조건을 테스트해서 조건에 맞지 않으면 에러메시지를 출력하고, 
                내부적으로 abort()함수를 호출해서 프로그램을 종료 시킨다. 만약에 assert함수가 
                활성화 되지 않도록 할려면 컴파일시 NDEBUG옵션을 주면 된다.  
                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>#include &#60;assert.h&#62;

int main()
{
  int a=3, b=4;
  assert(a &#62; b);
}
                </PRE
></TD
></TR
></TABLE
>
                위 프로그램을 컴파일해서 실행 시키면 에러가 발생하고 프로그램이 종료된다. 
                만약 assert함수를 무시하고 싶다면 아래와 같이 컴파일 하면 된다. 
                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># gcc -DNDEBUG -o assert assert.c
                </PRE
></TD
></TR
></TABLE
>
                이렇게 코드를 만들어 놓으면 디버깅 코드와 실제 배포될 코드를 구분지을 수 있다는 
                장점을 가진다. 어쨋든 고객에게 배포되는 코드에 디버깅 메시지가 출력되거나 해서는 
                난감하기 때문이다. 
            </P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="AEN802"
></A
>7.2.3. 모듈 테스트</H3
><P
>                어떤 테스트를 할때 반드시 프로그램의 모든 함수와 흐름에 대해서 테스트를 할 필요는 
                없을 것이다. 이런식의 테스트는 보통 시간도 많이 걸리고 체크범위가 넓어져서 문제점을
                찾아내기도 힘들기 때문이다. 그래서 보통은 각 모듈(함수)단위로 테스트를 하고, 어느정도
                테스트가 끝나면 전체 테스트를 하게 된다. 함수단위로 테스트를 하면 아무래도 
                좀더 빠르고 명확하게 문제점을 확인하고 예측할 수 있기 때문이다. 
            </P
><P
>                프로그램은 어떤 문제를 풀기위해서 여러개의 함수를 호출하며, 프로그래머는 이 함수들을 
                단계별로 체크함으로써 테스트를 수행하게 된다. 함수에 대한 체크는 입력값과
                결과(return 값)을 확인함으로써 이루어진다. 프로그램의 테스트를 단위 함수별로 
                분리시켜서 쉽게 테스트 할 수 있다는 것도 프로그램을 여러개의 조그만 함수들로 쪼개서 
                개발하는 이유이기도 하다.
            </P
><P
>                또한 함수단위로 테스트는 프로그램이 완전히 개발되지 않은 상태에서도 가능하다. 
                전자 상거래 관련 애플리케이션을 만든다고 한다면 is_ready_to_checkin이라는 함수를 
                만들어서 고객의 인증관련 함수를 먼저 만들어서 이부분만 따로 떼어내서 테스트 할 수 
                있을 것이다. 만들어지고 테스트된 함수는 레고블럭 쌓듯이 전체 프로그램에 가져다 
                붙이기만 하면 된다. 
            </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="ERRHANDLING"
></A
>7.3. 에러 핸들링의 기본</H2
><P
>            테스트가 중요하다는 것은 말할 필요도 없을 것이다. 여기에서는 테스트를 통해서 
            에러를 찾아내고 이를 처리하는 방법에 대해서 알아보도록 하겠다. 
        </P
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="AEN810"
></A
>7.3.1. 모든 것은 에러코드를 가진다.</H3
><P
>            </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="LORDOFROBUSTPROG"
></A
>7.4. 견고한 프로그램으로 만들기</H2
><P
>            이번장에서는 <A
HREF="#RECORDEDIT"
>6.3&#51208;</A
>에서 다루었던 add-year.s 프로그램을 견고하게 
            만들어 보도록 하겠다. 
        </P
><P
>            이 프로그램은 간단하기 때문에 단지 하나의 recovery 포인터를 가지도록 제한하겠다.
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="USEDLIBRARY"
></A
>8. 라이브러리를 통한 함수 공유</H1
><P
>    
        지금까지의 내용을 통하여 단순히 사칙연산을 하는 간단한 프로그램 조차도, 컴퓨터를 
        통해서 구현시킬려면 상당히 많은 일을 해야한다는 것을 느꼈을 것이다.
        게다가 우리가 앞으로 만들어야 할 프로그램들은 지금까지 만들어왔던 (간단한)프로그램들 
        보다 훨씬 복잡할 확률이 많다. 
        그러므로 가능한한 프로그램을 쉽게 만들 수 있는 어떤 프로세스의 정립이 필요하게 
        된다. 여기에는 다음과 같은 몇가지 방법이 있다. 
        <P
></P
><UL
><LI
><P
>                    어셈블리 대신 고급언어를 이용해서 코드를 작성한다. 
                </P
></LI
><LI
><P
>                    프로그램을 만들기 전에 여러개의 (간단한) 코드를 만들고, 이걸 
                    조합해서(가져다 붙이기로) 프로그램을 작성한다.
                </P
></LI
><LI
><P
>                    프로그램들 사이에 공통적으로 사용하는 함수의 모음을 따로 관리해서 
                    공유할 수 있도록 한다. 
                </P
></LI
></UL
>
        위의 방법들은 모두 프로젝트를 수행함에 있어서 실질적으로 필요한 것들이다. 
        첫번째 방법인 고급언어를 이용하는 것에 대해서는 11장에서 다루도록 하겠다. 
        두번째 방법은 유용한 방법이긴 하지만 다음과 같은 문제점들을 가진다. 
        <P
></P
><UL
><LI
><P
>                    복사된 코드는 실제 코드에서 종종 크게 수정되곤 한다.
                </P
></LI
><LI
><P
>                    보통 복사되는 코드는 프로그램에 여러번 포함이 된다. 
                    이것은 낭비를 초래할 뿐 아니라, 코드의 수정을 어렵게 만든다.    
                </P
></LI
><LI
><P
>                    만약 복사된 코드에서 문제가 발생했다면 이 코드를 사용하는
                    모든 응용의 코드를 수정해서 다시 배포해야만 한다.
                </P
></LI
></UL
>
        그러므로 두번째 방법은 꼭 필요한 부분에서만 사용하도록 한다. 세번째 방법은 가장 
        자주 이용한다. 이것은 공통으로 사용되는 코드를 재작성 하지 않고 이미 저장되어 있는 
        코드를 읽어오는 방식을 취한다 - 정확하게는 호출된 함수의 위치를 가져와서 실행한다 -. 
        이것은 동일한 함수를 복사해서 사용해야 하는 낭비를 없애준다. 
        또한 코드에 버그가 발생했을 경우에도 일일이 프로그램을 수정할 필요 없이 
        공통으로 호출하는 함수만 수정하면 되기 때문에 버그도 쉽게 관리할 수 있게 된다.
        물론 이 방법도 몇가지 문제를 가지고 있다.
        <P
></P
><UL
><LI
><P
>                    만약 여러개의 프로그램이 함수파일(라이브러리)를 공유하고 있을 때, 
                    과연 이 함수파일을 지워도 괜찮을지 어떻게 판단할 수 있을 까 ?
                    더이상 필요 없다고 판단해서 지웠는데, 다른 프로그램이 이를 사용하고 있어서 
                    그 프로그램이 실행되지 않는 경우를 예상할 수도 있을 것이다. 
                </P
></LI
><LI
><P
>Some programs inadvertantly rely on bugs within shared functions. Therefore, if upgrading the shared program fixes a bug that a program depended on, it could cause that application to cease functioning.
                </P
></LI
></UL
>
        이러한 문제를 "DLL hell"이라고 부른다. 그렇지만 이러한 단점보다는 얻는 이득이 
        훨씬 크기 때문에 이 방법을 주로 사용한다.
    </P
><P
>    
        프로그래밍에서 이러한 공유되는 코드 파일을 <B
CLASS="EMPHASIS"
>shared libraries, shared objects,
        dynamic-link libraries, DLLs 혹은 .so 파일</B
> 이라고 한다.
        여기에서는 공유라이브러리(shared libraries)라고 부르도록 하겠다.
    </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="SHAREDLIBRARYUSED"
></A
>8.1. 공유 라이브러리의 이용</H2
><P
>            공유라이브러리를 테스트 하기 위해서 간단한 예를 들어보도록 하겠다. 
            이 프로그램은 화면에 hello world를 출력하는 프로그램으로 
            이름은 helloworld-nolib.s로 하겠다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.include "linux.s"
.section .data

helloworld:
    .ascii "hello world\n"
helloworld_end:

    .equ helloworld_len, helloworld_end - helloworld

    .section .text
    .globl _start

_start:
    movl  $STDOUT, %ebx
    movl  $helloworld, %ecx
    movl  $helloworld_len, %edx
    movl  $SYS_WRITE, %eax
    int   $LINUX_SYSCALL

    movl  $0, %ebx
    movl  $SYS_EXIT, %eax
    int   $LINUX_SYSCALL
            </PRE
></TD
></TR
></TABLE
>
            간단한 코드임으로 설명은 생략하겠다. 다음은 위 프로그램의 공유 라이브러리 
            호출 버젼으로 이름은 helloworld-lib.s이다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.section .data

helloworld:
    .ascii "hello world\n\0"

    .section .text
    .globl _start

_start:
    pushl $helloworld
    call printf

    pushl $0
    call exit
            </PRE
></TD
></TR
></TABLE
>
            공유 라이브러리 호출 버젼은 코드가 더욱 단순해 졌다. 이유는 간단하다. 출력과 
            관련된일을 시스템 호출을 통하여 직접 코딩하지 않고, 라이브러리에서 제공하는 
            printf함수를 사용했기 때문이다.
            첫번째 프로그램은 다음과 같이 컴파일 해서 실행시키면 된다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># as helloworld-nolib.s -o helloworld-nolib.o
# ld helloworld-nolib.o -o helloworld-nolib
            </PRE
></TD
></TR
></TABLE
>
            그러나 두번째 프로그램의 경우 printf를 어떤 공유 라이브러리에서 호출하도록 
            했는지 링크과정에서 알려줄 필요가 있다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># as helloworld-lib.s -o helloworld-lib.o
# ld -dynamic-linker /lib/ld-linux.so.2 -o helloworld-lib helloworld-lib.o -lc
            </PRE
></TD
></TR
></TABLE
>
            공유 라이브러리를 링크 시키기 위해서 -dynamic-linker 옵션을 사용하고 있다. 
            리눅스 상에서 공유 라이브러리 링크를 위해서는 항상 
            -dynamic-linker /lib/ld-linux.so.2이 프홈되어야 한다. 이것은 프로그램이 
            실행될때 운영체제로 부터 /lib/ld-linux.so.2를 이용해서 외부 라이브러리를 
            링크 시킬 수 있도록 만들어 준다. 
        </P
><P
>            -lc 는 c 라이브러리를 링크시켜란 뜻이다. c라이브러리는 
            GNU/Linux의 경우 libc.so라는 이름을 가지고 있다. 여기에서 처음의 lib와 마지막의 
            .so를 제거시킨 이름을 -l뒤에 붙여줌으로써 필요한 라이브러리를 링크시키게 된다. 
            libc에는 printf(3)와 exit(3)를 비롯한 다양한 함수를 가지고 있다. 
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="ABOUTMEMORY"
></A
>9. 메모리에 대하여</H1
><P
>        여기에서 다루는 주제는 실질적인 프로그래밍 기술과는 관계없어 보일 
        수도 있을 것이며, 지극히 이론적인 것들이라서 재미없을 수도 있을 것이다.
        그렇지만 여기에서 다루는 내용들은 당신이 성공적인 프로그래머가 되기 위한
        든든한 후원자가 되어줄 것이다. 
    </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="SEECOMPUTERMEMORY"
></A
>9.1. 컴퓨터는 메모리를 어떻게 바라보는가</H2
><P
>            우리는 이미 2장<A
HREF="#COMPUTERSTRUCTURE"
>2&#51208;</A
>에서 컴퓨터가 메모리를 어떻게 
            보는지에 대해서 간단히 알아보았다. 컴퓨터는 메모리의 각 저장영역을 
            최소단위로 나누고, 여기에 일련의 연속된 번호를 붙여서 관리하게 된다. 
            최근의 컴퓨터들은 기본 512M이상의 크기를 가지게 되므로 기본 수백만 단위의 
            일련번호가 붙게 될것이다.
        </P
><P
>            당신이 만든 프로그램은 필연적으로 데이터에 대한 조작을 필요로 하며,
            이러한 데이터는 메모리에 쓰여지고 읽혀지게 된다. 기본적으로 컴퓨터는  
            데이터가 어느위치에 놓여야 하는지, 데이터가 어느정도의 저장영역을 
            필요로 하는지에 대해서 아는 바가 전혀 없으므로, 데이터가 어디에 
            어떻게 저장될지를 명령(instruction)을 통해서 컴퓨터에게 알려줘야 한다. 
            이런 명령역시 저장영역에 쓰여진후 메모리에 저장된다음 컴퓨터가 읽어가게 된다. 
            한마디로 모든게 메모리영역에 들어간다음 컴퓨터에 의해서 읽혀지고 실행되어진다.  
        </P
><P
>            필요로 하게 된다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl data_items(, %edi, 4), %ebx
            </PRE
></TD
></TR
></TABLE
>
            예를 들어 위의 명령은 7의 저장영역을 필요로 한다. 처음 명령은 2바이트, 다음 레이지스터의 사용을 위해서 1바이트, 마지막으로 data_items영역을 위해서 4바이트를 사용하게 된다. 메모리상에서는 이러한 위치를 일련의 숫자를 통해서 찾아내게 된다. 메모리와 관련되어서 몇가지 용어를 정리해 보도록 하자. 
            <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Address</DT
><DD
><P
>                        Address(주소)는 저장위치를 가리키기 위한 숫자다. 컴퓨터는 
                        메모리의 첫번째 주소가 0이 되며, 계속 1씩 증가하며 메모리의
                        위치를 결정한다. 이러한 주소는 컴퓨터가 사용하기에는 
                        편리하지만 인간이 보기에는 문제가 있기 때문에, 숫자 대신
                        이해하기 쉬운 심볼 (data_items 와 같은)을 사용한다. 
                    </P
></DD
><DT
>Pointer</DT
><DD
><P
>                    포인터는 주소값을 가지고 있는 메모리 혹은 레지스터영역이다.
                    위의 예제에서 <B
CLASS="EMPHASIS"
>%ebp</B
>가 포인터로, 현재의 
                    stack영역을 point(<B
CLASS="EMPHASIS"
>가리킨다</B
>)한다.
                    대부분의 프로그래밍과정에 있어서 많은 수의 포인터를 사용하게 된다. 
                    </P
></DD
><DT
>Byte</DT
><DD
><P
>                        저장을 위한 최소단위다. x86프로세스의 경우 한바이트는 8bit로                        0에서 255사이의 값을 가진다. 
                    </P
></DD
><DT
>Word</DT
><DD
><P
>                    레지스터의 일반적인 크다. x86 프로세스의 경우, 1 word는 
                    4만큼의 저장영역(4byte)의 크기를 가진다. 
                    </P
></DD
></DL
></DIV
>
            앞으로는 저장영역이라는 단어대신에 위에서 정의 한 단어들을 쓰게 
            될 것이다.
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="INSTRUCTIONPOINTER"
></A
>9.2. Instruction Pointer</H2
><P
>            일단 레지스터가 무언지 그러고 어떤일을 하는지에 대해서 좀더 
            자세히 알아보도록 하겠다. 일단 우리는 몇가지 레지스터들에 
            대해서 배웠는데, 여기에서는 instruction pointer을 다루는 좀더 
            특별한 레지스터에 대해서 알아보도록 하겠다. 이 레지스터는 %eip로 
            사용할 수 있다. 우리는 컴퓨터는 모든걸 동일한 데이터로 
            취급하며 명령(instruction)도 예외가 없음을 알고 있다. 컴퓨터는
            이게 명령이든지 아니면 일반 데이터든지 동일하게 처리를 하며, 
            또한 이들을 구분할 능력을 가지고 있지 않다. 
            그렇다면 컴퓨터는 어떻게 이러한 일련의 데이터에서 명령을 찾아내어서
            그걸 실행을 시키게 되는 것일까 ? 해답은 instruction pointer에 있다. 
            이 instruction pointer라는 이름에서 우리는 이 포인터가 무언가를 
            가르킨다는 것을 알 수 있다. instruction pointer은 다음 
            명령(instruction)을 가르킨다.    
            컴퓨터는 instruction pointer를 살펴봄으로써, 다음에 어떤 명령을 실행해야 될지를 알수 이겠된다.
            해당 명령을 실행하게 되면 instruction pointer는 다음 명령의 위치를 
            가리키도록 값이 증가가되며, 현재 실행해야될 명령을 마치게 되면, 
            다시 instruction pointer의 값을 살피게 된다. 이러한 명령실행 방식은 
            대부분의 경우에 유효할 것이다. 그러나 jmp등을 이용해서 명령을 
            점프하게 될경우는 어떻게 될가 ? 이럴 경우에 컴퓨터는 다음 명령이 아닌 
            다른 위치의 명령을 실행해야 할것이다. 이럴경우 우리는 일반적으로 아래와 
            같은 코드를 사용하게 될것이다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>jmp somewhere
            </PRE
></TD
></TR
></TABLE
>
            이 코드는 아래의 코드와 동일한 일을 한다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl $somewhere, %eip
            </PRE
></TD
></TR
></TABLE
>
            알다시피 <B
CLASS="EMPHASIS"
>somewhere</B
>는 프로그램의 영역을 참조하기 위한 
            상징이다. 그러므로 %eip가 직접 somewhere를 참조하도록 하는 것은 허용이 
            되지 않는다. 그러나 '$'표시를 이용하게 될경우 이를 허용할 수 있게 된다.
            이는 $표시가 immediate mode addressiong모드로 somewhere를 값으로 
            다룰 수 있도록 해주기 때문이다. 만약 '$'표시를 사용하지 않을 경우 
            direct addressing mode가 되는데, 그럴경우 somewhere의 주소에 있는 값이
            %eip로 이동이 되어버린다. 이것은 우리가 원하는 결과가 아니다.  
            아래는 실제 자주 사용되는 코드다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl $0, $ebx
            </PRE
></TD
></TR
></TABLE
>
            0앞에 $표시가 붙어 있는데, 이것은 immediate-mode instruction를 의미하는 
            것이므로 0을 ebx에 집어 넣게 된다. 
            만약 $표시를 제거하게 되면 direct addressing mode가 되어서 
            0번주소의 값이 %ebx에 밀어넣어지게 된다. 
            메모리의 어드레싱 모드에 대한 자세한 내용은 2장을 참고하기 바란다.
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="MEMORYSTRUCTUREFORLINUX"
></A
>9.3. 리눅스 프로그램에서의 메모리 구조</H2
><P
>            이번 장의 내용은 konstantin Boldyshev의 "Startup state of a Linux/i386 ELF binary"문서에 기반을 두고 있다. 
            관련된 문서는 http://linuxassembly.org/start.html을 참고하기 바란다.
        </P
><P
>            당신이 만든 프로그램이 메모리에 적재될때, 각각의 .section의 이름이 가리키는 
            지점이 로드된다. 실제코드 (.text section)은 0x0848000 주소에 
            로드된다. .data섹션이 그다음에 위치하게 되고, 그뒤에 .bss 섹션이 위치하게 된다.    
            .bss 는 버퍼영역으로 우리가 사용할 메모리의 영역을 미리확보할 수 있게 도와준다. 
            우리는 run-time전까지는 .bss에 값을 밀어 넣을 수 없다. .data섹션의 경우에는 
            공간을 할당(.long 등을 이용해서)하고 거기에 필요한 값을 즉시 밀어 넣을 수 있다. 
            이 값들은 프로그램이 컴파일되어서 만들어 질때, 프로그램 파일에 직접 들어가게 된다.
            반면 .bss 섹션의 경우 프로그램이 실행전에는 초기화 되지 않는다. 그러므로 프로그램
            파일 자체에 어떠한 값을 저장할 수 없다. 여기에는 단지 어느정도의 저장공간이 필요한지
            에 대한 정보만이 있을 뿐이다. 이에 대한 내용은 뒤에 자세히 알아보록 할것이다. 
        </P
><P
>            마지막 저장영역은 0xbffffffff의 주소를 가진다. .text, .data, .bass 섹션은 0x0804800
            이후에 위치하게 된다. .start 섹션은 위의 주소영역 사이에 위치하게 되며,
            처음 두바이트는 0으로 채워지고 그다음에 프로그램의 이름이 온다. 프로그램의 이름의 
            끝은 NULL 문자 (\0)까지로 결정된다. 프로그램이름 다음에는 환경변수(12)가 위치하게 
            된다. 그다으 프로그램의 인자가 오게 된다. 프로그램인자는 프로그램을 실행시킬 때 
             유저에 의해서 프로그램에 전달되는 값이다. 예를 들어서 "maximum"이란 프로그램을 
            실행시킨다라고 하면, ./maximum 을 타이핑 해서 실행하게 되는데 ./maximum 이 프로그램
            인자가 된다. 이경우으넨 단지 하나의 인자가 프로그램으로 전달될 것이다. 
            하지만 필요에 따라서 ."/maximum 48 59"와 같이 하나이상의 인자가 들어갈 수도 있다.
            다음으로 stack(12) 영역이 있다. 스택은 임시로 자료를 저장하기 위한 영역으로 
            필요한 데이터를 밀어넣거나 가져올 수 있다. 스택의 제일 처음(꼭대기)는 %esp를 
            이용해서 가리킬 수 있으며, 값을 증가시킴으로써, 스택을 탐색할 수 있다. 스택에 
            어떤 값을 입력하면, 스택은 자연스럽게 다음 값을 가리킨다. 즉 값을 밀어넣게 되면 
            스택포인터가 감소하고 값을 가져오면(pop) 스택포인터가 증가하는 방식이다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>pushl %eax
            </PRE
></TD
></TR
></TABLE
>
            위의 코드는 아래와 동일하다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl %eax, (%esp)
subl $4, %esp
            </PRE
></TD
></TR
></TABLE
>
            %eax는 4바이트의 크기를 가진다. 이것을 스택에 밀어 넣었으니, 다음값을 넣을 때에는
            4바이트 만큼 뒤로 밀려서 값을 넣어야 할 것이다. 이를 위해서 subl을 이용해서 %esp에서
            4만큼을 빼주었다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>popl %eax
            </PRE
></TD
></TR
></TABLE
>
            위의 코드는 pop을 한경우인데, 아래와 동일하다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl (%esp), %eax
addl $4, %esp
            </PRE
></TD
></TR
></TABLE
>
            %esp에 괄호가 있는 이유는 %esp의 주소값이 아닌 %esp가 가리키는 곳의 값을 가져오길 
            원하기 때문이다. 4바이트 크기의 값을 꺼내왔기 때문에, 
            %esp에서 4만큼을 더해줘서 스택의 다음 값을 가리키도록 해주었다.
        </P
><P
>            이렇게 해서 stack는 값을 감소시키고, .bss섹션은 값을 증가시킨다는 것을 알게 되었다. 
            이들 중간영역은 break 라고 불리우며, 커널은 break을 벗어나서 서로의 영역을 침범하지
            않도록 관리를 하고 있다. 만약 서로의 영역을 침범하게 되면 프로그램은 
            "segmentation falut" 에러 메시지를 출력하고 종료된다. 마찬가지로 당신의 프로그램이
            0x08048000이전의 데이터영역에 접근할경우에도 동일한 에러메시지와 함께 종료가 
            된다.
        </P
><P
>&#13;        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="ADDRESSISLIE"
></A
>9.4. Every Memory Address is Lie</H2
><P
>            그럼 왜 컴퓨터는 break 영역을 엑세스 하는걸 허용하지 않는 것일까 ?
            이데 대한 답을 얻기 위해서는 컴퓨터가 메모리를 어떻게 다루는지에 대한
            좀더 깊은 이해가 필요하다.
        </P
><P
>            여기에서 여러분은 모든 프로그램이 같은 메모리 영역을 사용하는지에 대한
            궁금증이 생길 것이다. 그런데 이렇게 될경우 다른 프로그램이 데이터를 
            덮어쓰거나 삭제하는게 가능해질 것이므로, 이는 프로그램의 작동에 
            치명적인 영향을 끼치게 될 것이다. 앞 장을 보더라도, 모든 프로그램은 동일한 
            주소에서 시작하는 것으로 보인다. 
            그러나 실제 이런일은 발생하지 않는다. 당신의 프로그램은 단지 virtual_memory(12) 에만 
            접근 가능하기 때문이다. 여러분이 사용하는 PC(12)를 포함한 거의 대부분의 프로그램은 
            물리적인 RAM(12)을 가지고 있을 것이다. 보통 256에서 1024Megabyte 좀 더 부유한 경우 
            그 이상의 램을 가지고 있을 것이다. 우리가 말하는 물리적 메모리 주소란 이러한 메모리의
            칩에 직접적으로 부여된 영역을 말한다. 그렇다면 가상 메모리란 무엇인가 ? 
            가상의 메모리란 프로그램이 생각하는 메모리라고 간단히 생각할 수 있다.
            여러분이 프로그램을 실행시키면, 프로그램이 로드되기 전에 Linux(12)는 물리적 
            메모리영역에서 사용가능한 비어있는 지역을 찾아내어서, 할당해 주고, 
            이 할당된 메모리의 주소를 0x0804800 이라고 알려주게 된다. 즉 프로그램마다 자신의 
            독립적인 가상의 공간을 만들어 주는 것이다. 
        </P
><P
>            이렇게 프로그램은 자신만의 가상의 공간을 만들고, 이 공간에서 놀게 된다.
            당신의 컴퓨터에서 실행되는 모든 프로그램은 이 가상의 공간의 0x0804800 주소에
            올려지고, 스택은 0xbffffff에서 시작이 된다. 이러한 가상의 공간에 주어지는 
            가상의 주소를 virtual address라고 한다. 모든 프로그램은 가상의 주소를 이용해서
            데이터를 쓰거나 읽지만, 실제 데이터는 가상의 주소에 맵핑되는 물리적인 주소에
            쓰여지게 된다. 이렇게 가상의 주소를 물리적인 주소에 대응시켜주는 과정을 
            <B
CLASS="EMPHASIS"
>mapping</B
> 이라고 한다.
            이전장에서 우리는 bss와 stack사이의 메모리 영역을 break라고 정의한다고 배웠었다. 
            그러나 이러한 break가 존재하는 이유에 대해서 설명하진 않았는데, 그 이유에 대해서
            알아보도록 하자.
            가상메모리 세그먼트는 기본적으로 완벽하게 물리적 메모리 세그먼트와 맵핑을 시킬 수는 
            없다. 맵핑될 시간과 공간을 정확히 고려할 수 없기 때문이다. 그러다 보니 bss와 stack 
            사이에 가상메모리 주소로 매핑이 되지 않는 영역이 생겨날 수 있다. 이 부분은 
            프로그램에서 제어할 수 없는 영역이기 때문에 break영역이 되는 것이다. 
        </P
><P
>            가상 메모리를 이용함으로 써 얻을 수 있는 다른 이득도 있다. 굳이 물리적인 메모리가 
            아닌 하드디스크등도 메모리영역으로 사용할 수 있기 때문이다. 맵핑만 시켜주면 간단한 
            문제다. 당신의 컴퓨터가 16Mega의 메모리를 가지고 있다고 가정해보도록 하자. 
            이중 8Mega 정도는 Linux와 몇 가지 기본적인 응용프로그램들이 사용하고 있다.
            그리고 당신은 gimp를 실행시켜서 그래픽 작업을 하기 원하는데, 최소한 20Mega 정도의 
            공간을 필요로 한다. 그런데 실제 남은 공간은 8Mega 정도로 gimp를 실행시킬만한 메모리
            공간이 남아있지를 않다. 그러나 우리는 물리적 메모리 공간이 부족하더라도 프로그램을 
            실행시키는 방법을 알고 있다. swap 파티션(혹은 스왑파일)을 이용하면 된다.
            그러면 Linux의 가상메모리 관리 프로세스는 부족한 양만큼을 swap영역에서 가져와서 쓰게 되므로
            문제없이 gimp를 실행시킬 수 있게 된다. 이렇게 가상 메모리기법을 적용함으로써,
            프로그램은 컴퓨터가 제공하는 이상의 메모리 공간을 사용할 수 있게 된다. 
        </P
><P
>            메모리는 <B
CLASS="EMPHASIS"
>pages</B
>라는 그룹으로 묶여서 나뉘게 된다. x86프로세스에서 
            실행되는 리눅스에서 한 페이지는 4096 byte의 크기를 가진다. 모든 메모리는 페이지단위로 
            매핑이 된다. 
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="GETTINGMOREMEMORY"
></A
>9.5. Getting More Memory</H2
><P
>            우리는 리눅스의 가상메모리가 리얼메모리와 swap를 함께 이용하고 있다는 것을 알고 있다.
            만약 당신이 만든 프로그램이 아직 맵핑되지 않은 가상메모리를 접근하려고 한다면, 
            segmentation fault 에러메시지를 출력하면서 종료되는 걸 확인할 수 있을 것이다.
            이러한 문제는 여러분이 data section에 여러분이 필요한 만큼의 충분한 메모리 공간을 미리 
            확보하도록 해서 break point를 침범하지 않도록 하면 해결이 가능하다. 
            그러나 어느정도의 메모리 공간을 할당해야 할지 알아내기 힘든 경우가 발생한다. 
            예를 들어서 vi(12)와 같은 편집기를 만들경우, 편집기의 사용자가 어느정도의 문자를 쓰게 될지 
            알 수 없게 된다. 한줄정도로 편집을 마치고 저장할 수 있지만, 수십메가 이상의 데이터를 
            쓸 수 도 있다. 물론 한 1기가 정도 메모리를 할당해 버리는 경우를 생각해볼 수 있지만 단지 80
            바이트의 문자를 쓰기를 원할경우 엄청난 낭비가 발생하게 된다. 
            Linux(12)는 이러한 문제의 해결을 위해서 break point를 이동할 수 있게끔 수단을 제공하고 있다. 
            만약 더 많은 메모리 공간이 필요할 경우 이를 리눅스에 요청을 하면, 리눅스는 필요한 만큼의 
            메모리를 맵핑시켜주고 break point를 이에 맞게 이동시켜 준다. 
        </P
><P
>            이렇게 메모리를 추적하면서 break point를 변경시키는 방법은 한가지 문제점을 가지고 있다.
            예를 들어 여러분이 파일을 열어서 데이터를 읽어들였다면, break point를 변경시켜서 필요한 
            만큼의 메모리 공간을 확보하게 될것이다. 여기에서 새로운 파일을 읽어들이기 위해서는 
            또 다시 break point의 이동이 필요하게 된다. 이 break point는 첫번째 파일의 영역을 벗어난 
            위치에 존재하게 될 것이므로, 맵핑은 되었지만 사용하지 않는 남는 공간이 생성되게 된다.
            이미 맵핑이 되어있으므로, 다른 프로그램은 이 영역을 사용할 수 없게 된다. 
            만약 이러한 일이 계속적으로 반복된다면, 메모리 누수 현상이 발생하게 될 것이다.
            그래서 메모리 관리가 필요하게 된다. 메모리 관리는 '''allocate'''와 '''deallocate'''의 두개의 
            기본적인 함수를 통해서 이루어지게 된다. 메모리가 필요하다면 allocate를 호출해서 필요한 
            공간을 할당받고, 필요 없을 경우 deallocate를 호출해서 이를 반환하게 된다.
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="MEMORYCONTROL"
></A
>9.6. 메모리 관리</H2
><P
>            그럼 어떤식으로 메모리를 관리하는지에 대해서 알아보도록 하자.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># 
.section .data

######### GLOBAL VARIABLE ###########
heap_begin:
.long 0

current_break:
.long 0

###### CONSTANTS ########
.equ UNAVAILABLE, 0
.equ AVAILABLE, 1
.equ BRK, 45                # brk(2) System Call
.equ LINUX_SYSTEMCALL, 0x80

###### STRCUTURE INFORMATION #######
.equ HEADER_SIZE, 8
.equ HDR_AVAIL_OFFSET, 0
.equ HDR_SIZE_OFFSET, 4
.section .text

######### FUNCTION ###########
## allcate_init
# PURPOSE : call this function initialize the functions
#           specifically, this sets heap_begin and current_break.
#           this has no parameters and no return value.
.globl allocate_init
.type allocate_init, @function

allocate_init:
pushl %ebp
movl  %esp, %ebp

# brk(2) system call
movl $BRK, %eax
movl $0, %ebx
int $LINUX_SYSCALL

incl %eax    # %eax now has last valid 
             # address, and we want the memory
             #location after that

movl %eax, current_break   #store the current break
movl %eax, heap_begin      #store the current break as our
                           #first address. this cause the allocate function
                           # to get more memory from Linux the first
                           #time it is run
movl %ebp, %esp            #exit function
popl %ebp
ret
##### END OF FUNCTION #####

##allocate##
#PURPOSE: This function is used to grab a section of memory.
#         It checks to see if there are any free blocks, and,
#         if not, it asks Linux for a new one.
#PARAMETERS: This function has one parameter - the size of the memory 
#            block we want allocate 
#RETURN VALUE:
#         This function returns the address of allocated
#         memory in %eax. if there is no memory available, it will
#         return 0 in %eax
##### PROCESSING ######
#Variables used;
#
#  %ecx - hold the size of requested memory
#  %eax - current memory segment being examined
#  %ebx - current break position
#  %edx - size of current memory segment
# We scan through each memory segment starting with heap_begin.
# We look at the size of each one, and if it has been allocated.
# If it's big enough for the requested size. and its available,
# if grabs that one. If it does not find a segment large enough,
# it asks Linux for more memory. In that case, it moves
# current_break up
.globl allocate
.type allocate,@function
.equ ST_MEM_SIZE, 8

allocate:
pushl %ebp
movl  %esp, %ebp

movl ST_MEM_SIZE(%ebp), %ecx # %ecx will hold the size we are
                             # looking for

movl heap_begin, %eax        # %eax will hold the current search 
                             # location
movl current_break, %ebx     # %ebx will hold the current break point

alloc_loop_begin:            #here we iterate through each
                             #memory segment
cmpl %ebx, %eax              #need more memory if these are equal
je move_break

movl HDR_SIZE_OFFSET(%eax), %edx  #grab the size of this memory
cmpl $UNAVAILABLE, HDR_AVAIL_OFFSET(%eax)  # If the space unavailable, go the
je next_location                           #next one

cmpl %edx, %ecx              #If the space is avalable, compare
jle allocate_here            #the size to the needed size. If its
                             #big enough, go to allocate_here

#may want to add code here to
#combine allocations

next_location:
addl $HEADER_SIZE, %eax      #The total size of the memory segment
addl $edx, $eax              #is the sum of the size requested
                             #(currently stored in %edx), plus another
                             #8 storage locations for the header
                             #(4 for the AVAILABLE/UNAVAILABLE flag,
                             #and 4 for the size of the segment). so
                             #adding %edx and $8 to %eax will get
                             #the address of the next memory segment

jmp alloc_loop_begin

allocate_here:

movl $UNAVAILABLE, HDR_AVAIL_OFFSET(%eax) #mark space as unavailable

addl $HEADER_SIZe, %eax

movl %ebp, %esp
popl %ebp
ret

move_break:

addl $HEADER_SIZE, %ebx      #noew we need to increase %ebx to
addl %ecx, %ebx              #where we _want_ memory to end, so we
                             #add space for the headers structure
                             #add space to the break for
                             #the data requested

                             #now its time to ask Linux for more
                             #memory

pushl %eax                   #save needed registers
pushl %ecx
pushl %ebx

movl %BRK, %eax

int $LINUX_SYSCALL

cmpl $0, %eax

jre error


popl %ebx                   #restore saved registers
popl %ecx
popl %eax

movl $UNAVAILABLE, HDR_AVAIL_OFFSET(%eax) #set this memory as
                                          #unavailable, since we're about to
                                          #give it away
movl %ecx, HDR_SIZE_OFFSET(%eax)          #set the size of the memory
addl $HEADER_SIZE, %eax                   #move %eax to the actual start of
                                          #usable memory. %eax now holds the
                                          #return value
movl %ebx, current_break

movl %ebp, %esp
popl %ebp

ret

error:
movl $0, %eax
movl %ebp, %esp
popl %ebp
ret

####### END OF FUNCTION #######



## deallocate ##
# PURPOSE : The Purpose of this function is to give back
#           a segment of memory to the poll after we're done
#           using it. 
#
# PARAMETERS : The only parameter is the address of the memory we want to 
#              return to the memory pool
# RETURN VALUE : There is no return value 
# PROCESSING :
#          If you remmember, we actually hand program the
#          start of the memory that they can use, which is
#          8 storage locations after the actual start of the
#          memory segment. All we have to do is go back
#          8 locations and mark that memory as available,
#          so that the allocate function knows it can use it.
.globl deallocate
.type deallocate, @function
.equ ST_MEMORY_SEG, 4    # stack position of 
deallocate: 
                         # since the function is so simple, we
                         #don't need any of the fancy function
                         # stuff
movl ST_MEMORY_SEG(%esp), %eax  # get the address of the memory to free
                                #(normally this is 8(%ebp), buf since
                                #we didn't push %ebp or move %esp to
                                #%ebp, we can just do 4(%esp)
subl $HEADER_SIZE, %eax         #get the pointer to real beginning
                                #of the memory
movl $AVAILABLE, HDR_AVAIL_OFFSET(%eax) #mark it as available

ret
####### ENF OF FUNCTION ##########</PRE
></TD
></TR
></TABLE
>
        위 코드는 그 자체가 완전한 프로그램이 아니다. 단지 program 섹션만 가지고 있으며, 때문에 _start 심볼을
        가지고 있지 않다는 점을 주목하기 바란다. 그러므로 단독으로 실행될 수 없으며, 다른 코드에 링크되어서
        해당 함수를 호출하는 형식으로만 사용될 수 있다. 아마도 C를 이용해서 다중소스 컴파일을 해보았다면 쉽게
        이해할 수 있을 것이다. 자세한 내용은 나중에 다루도록 할 것이다. 일단은 다음과 같이 object형식으로 
        만들도록 한다.       
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># as alloc.s -o alloc.o</PRE
></TD
></TR
></TABLE
>
        이제 코드를 분석해 보도록 하자. 
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="VARIABLEANDCONST"
></A
>9.7. 변수와 상수들</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>heap_begin:
.long 0

current_break:
.long 0</PRE
></TD
></TR
></TABLE
>
            위 코드는 프로그램의 첫 부분으로 heap영역을 가리키기위해서 사용한다.
            어셈블리 프로그램을 작성할 때 우리는 heap영역의 시작위치를 알 수가 없으며, 
            때문에 break point를 결정할 수도 없다. 그래서 0으로 일단 채워두었다. 주석을 보면
            <B
CLASS="EMPHASIS"
>global variable</B
>(전역변수)라고 해둔걸 볼 수 있을 것이다. 프로그램을
            작성하다보면 전역변수나 지역변수라는 말을 많이 들어 보았을 것이다.
            지역변수는 procedure가 실행될 때 스택에 할당되는 변수를 말한다. 반면 전역변수는 
            프로그램이 시작될 때, 정의와 할당이 이루어진다. 이러한 이유로 전역변수는 
            프로그램이 종료될 때까지 프로그램 전역에 걸쳐서 사용되어지며, 지역변수는 프로시져의 종료와
            동시에 사라지게 된다. 일반적으로 좋은 프로그램은 지역변수를 주로 사용하며, 전역변수는 
            제한적으로 사용한다. 지역변수에 대해서는 나중에 좀더 자세히 다루도록 하겠다.
        </P
><P
>            다음은 <B
CLASS="EMPHASIS"
>상수</B
>(constants)영역이다. 상수는 어떤 값을 사용하기 쉽도록 재정의 
            한 Symbol 이라고 보면 된다. 아래의 예를 보도록 하자. 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.equ UNAVAILABLE, 0
.equ AVAILABLE, 1</PRE
></TD
></TR
></TABLE
>
            이는 UNAVAILABE를 사용할경우 이는 숫자 0을 사용하며, AVAILABLE를 사용할 경우 숫자 1이 
            사용되어 짐을 의미한다. 만약 이러한 상수대신에, 코드 중에 0과 1을 직접 사용하게 될경우 
            의미를 제대로 파악하기가 힘들 것이다. 또한 AVAILABLE의 값을 2로 하고 싶다고 할 경우에도, 
            단지 상수만 찾아서 값을 바꿔주면 된다. 상수를 사용하지 않았을 경우에는 일일이 코드를 찾아가면서
            값을 바꿔줘야만 할 것이다.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.equ BRK, 45
.equ LINUX_SYSCALL, 0x80</PRE
></TD
></TR
></TABLE
>
        int $0x80을 사용하는 것보다는 int $LINUX_SYSCALL이 훨씬 이해하고 사용하기도 쉽다. 일반적으로
        상수는 프로그램상에 하드코딩 되는 값들을 관리하기 위해서 사용된다. 상수는 .equ를 이용해서
        정의할 수 있다.
        </P
><P
>            다음에서 구조체를 정의 하고 있다. 이 구조체는 메모리의 명확한 제어와 
            관련된 일련의 정보들로 이루어진다. 
            메모리를 사용하기 위한 가장 중요한 정보는, "시작위치"와 "크기"가 된다.
            이들 정보를 위해서 4byte의 크기를 가지는 2개의 값이 정의가 되어야 
            할 것이다. 그리고 헤더정보를 가지는데, 이 헤더는 구조체의 크기를 
            알려주기 위해서 사용한다. 2개의 4byte크기의 상수가 사용되고 
            있음으로 8로 정의되면 될 것이다. 
            최종적으로 다음과 같이 구조체를 정의하고 있다.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.equ HEADER_SIZE, 8
.equ HDR_AVAIL_OFFSET, 0
.equ HDR_SIZE_OFFSET, 4</PRE
></TD
></TR
></TABLE
>
            헤더에는 구조체의 크기를 가리키는 8이 정의되어 있다. available offset은 
            데이터가 저장되는 메모리상의 위치를 저장하기 위해서 사용한다. 
            Size Offset 에는 할당된 메모리의 크기가 들어가게 된다. 메모리의 
            시작위치와 크기를 알게 되므로 메모리관리를 위한 최소한의 정보를
            저장하기 위한 구색은 맞춘셈이다. 만약 메모리관리를 위해서 다른 어떤
            정보를 더 추가해야 한다면, 상수하나를 더 추가하고 HEADER_SIZE를 
            변경시켜 주기만 하면 된다. 이러한 구조체는 전역변수들과 마찬가지로
            코드의 가장 첫 부분에 위치하게 된다. 
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="ALLOCATEINIT"
></A
>9.8. allocate_init 함수</H2
><P
>            이 함수는 간단하다. heap_begin과 current_break 변수값을 설정하게 되는데,
            이들에 대한 내용은 이미 앞에서 다루었다. 이전 장의 내용을 주의깊게 
            읽어 보았다면, brk(2)시스템 호출을 이용해서 최근의 브레이크 포인터를 
            옮기는 아래의 코드를 쉽게 이해할 수 있을 것이다. 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>pushl %ebp
movl  %esp, %ebp

movl $BRK, %eax
movl $0, %ebx
int  $LINUX_SYSCALL

incl %eax</PRE
></TD
></TR
></TABLE
>
            int $LINUX_SYSCALL이 실행된 후에, %eax는 주소의 마지막값이 채워지게 된다.
            그러나 우리가 실제로 원하는 주소는 사용가능한 주소의 처음 값이다. 그래서
            incl %eax를 이용해서 %eax를 증가시켰다. 이제 우리는 heap_begin영역으로 이동하면
            된다. 아직 할당한 메모리가 없으므로 current_break와 heap_begin은 같은 값을 가지고 
            있을 것이다.  
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>incl %eax
movl %eax, current_break
movl %eax, heap_begin
movl %ebp, %esp
popl %ebp</PRE
></TD
></TR
></TABLE
>
        heap영역은 heap_begin과 current_break사이에 위치한다. 이 함수를 이용해서 힙의 처음 위치를
        얻어냈으니 이제 allocate함수를 이용해서 heap을 필요한 만큼 확장시키기만 하면 된다.  
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN931"
></A
>9.9. allocate 함수</H2
><P
>            이 함수는 다음과 같은 일들을 하게 된다.
            <P
></P
><UL
><LI
><P
>                        heap의 시작 위치로 간다.
                    </P
></LI
><LI
><P
>                        heap의 끝인지 아닌지를 체크한다. 
                    </P
></LI
><LI
><P
>                        만약 우리가 요청하는 메모리의 영역이 heap의 끝을 초과해 버린다면, unavailable(사용할수 없음)
                        을 리턴할 것이다. 
                    </P
></LI
><LI
><P
>                        요청된 최근의 메모리 영역이 <B
CLASS="EMPHASIS"
>unavailable</B
>이라면, 2단계로 되돌아간다.
                    </P
></LI
><LI
><P
>                        때로는 available상태이지만, 메모리 영역이 요청한 만큼 충분하지가 않을 경우가 있다. 이경우에도 
                        2 단계로 되돌아간다.
                    </P
></LI
><LI
><P
>                        현재 메모리 영역이 요청한 크기를 수용할만큼 충분히 크다면, <B
CLASS="EMPHASIS"
>unavailable</B
>를 
                        표기하고 리턴한다. 
                    </P
></LI
></UL
>
            위의 과정을 염두에 두고 코드를 다시 보게 되면, 아래의 코드의 내용이 쉽게 이해될 것이다.
        </P
><P
>            다시 다음 코드로 넘어가보자.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>pushl   %ebp
movl    %esp, %ebp
movl   ST_MEM_SIZE(%ebp), %ecx
movl   heap_begin, %ecx
movl   current_break, %ebx</PRE
></TD
></TR
></TABLE
>
            위 코드는 레지스터를 초기화 하는 일을 하다. 처음 두라인은 함수에 들어가는 전형적인 코드들이다. 
            다음 라인에서는 스택에 할당하기 원하는 메모리의 사이즈를 밀어 넣는데, 이것은 함수의 
            인자로 사용될 것이다. 다음 라인에서 heap의 시작주소와 끝주소를 입력한다.
        </P
><P
>            다음 섹션은 alloc_loop_begin이다. 여기에서는 우리가 필요로하는 메모리의 공간이 확보될 때까지, 
            지속적으로 메모리 영역을 체크하게 된다. 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cmpl   %ebx, %eax
je     move_break</PRE
></TD
></TR
></TABLE
>
            여기에서는 최근의 검사된 메모리의 영역인 %eax와 힙의 마지막 영역인 %ebx를 비교하게 된다. 
            검사한메모리의 여영역이, 마지막 힙의 영역과 같다면, 이는 우리가 필요로 요청한 메모리의 영역이상이 
            존재하고 있음을 의미한다. 그러므로 다음 단계는 건너 뛰고 바로 move_break로 점프하게 된다.  
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>move_break:
addl  $HEADER_SIZE, %ebx
addl  %ecx, %ebx
pushl %eax
pushl %ecx
pushl %ebx
movl $BRK, %eax
int  $LINUX_SYSCALL</PRE
></TD
></TR
></TABLE
>
            여기는 코드의 마지막 지점이다. %ebx에는 우리가 사용하기 원하는 메모리의 영역값이 들어가며, brk(2)
            시스템 호출의 인자로 사용될 것이다. 그리고 스택에 저장하기 원하는 다른 레지스터 값들을 모두 저장한다.      
            마지막으로 brk(2)을 호출하고, 리턴값을 검사한다. 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cmpl  $0, %eax
je    error</PRE
></TD
></TR
></TABLE
>
            brk 시스템 호출에 문제가 없었다면, 스택의 레지스터 값들을 다시 복구 시키고, 메모리에 unavailabe
            표시를 하고, 메모리사이즈를 기록한다음 %eax 의 포인터를 사용가능한 메모리의 처음으로 이동시킨다.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>popl  %ebx
popl  %ecx
popl  %eax
movl  $UNAVAILABLE, HDR_AVAIL_OFFSET(%eax)
movl  %ecx, HDR_SIZE_OFFSET(%eax)
addl  $HEADER_SIZE, %eax</PRE
></TD
></TR
></TABLE
>
            마지막으로 새로운 브레이크 포인터와 할당된메모리의 포인터를 저장하고 리턴한다.
        </P
><P
>            그럼 루프의 처음으로 다시 되돌아가서, 최근의 메모리가 힙의 마지막을 가리키지 않고 있을 경우 어떤일이
            발생하는지를 알아보도록 하자.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl HDR_SIZE_OFFSET(%eax), %edx
cmpl $UNAVAILABLE, HDR_AVAIL_OFFSET(%eax)
je   next_locaton
            </PRE
></TD
></TR
></TABLE
>
            처음 코드는 얻어낸 메모리영역의 크기를 %edx에 넣는 일을 한다. 그리고 나서 UNAVAILABLE표시가 되어
            있는지를 확인한다. 만약 UNAVAILABLE로 표시가 되어 있다면, 이미 사용중인 영역이므로 next_location
            으로 점프한다. 만약 AVAILABLE로 표시가 되어 있다면, 충분한 공간이 확보되어 있는지 아래의 코드로 
            확인하고, 충분한 공간이 확보되어 있다면 allocate_here로 점프하면 된다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cmpl %edx, %ecx
jle allocate_here
            </PRE
></TD
></TR
></TABLE
>
            allocate_here에서는 다음과 같은 일을 하게 된다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl $UNAVAILABLE, HDR_AVAIL_OFFSET(%eax)
addl $HEADER_SIZE, %eax
movl %ebp, %esp
popl %ebp
ret
            </PRE
></TD
></TR
></TABLE
>
            확보된 메모리는 다른, 코드가 사용할 수 없도록 unabailable표시를 해두고, 헤더사이즈만큼 포인터를
            이동하고, 필요한 값을 리턴하고 함수를 빠져나오면 된다. 헤더사이즈만큼 포인터를 이동하는 이유는,
            이 함수를 사용하는 일반사용자는 헤더를 사용할 필요가 전혀 없기 때문이다. 사용자에게는 
            단지 사용가능한 메모리의 포인터만 넘겨주면 된다.  
        </P
><P
>            만약 사용가능한 영역인데, 크기가 충분하지 않을 경우는 어떻게 될까 ? 이 경우에는 next_location
            코드영역(section) 으로 이동한다. 이 영역에서는, 현재 메모리 영역은 요청한 만큼의 메모리가
            없으므로 루프의 처음인 alloc_loop_begin으로 이동하는 코드가 들어가야 할 것이다. 이와 더불어 
            다음 header를 가리킬 수 있도록 HEADER_SIZE만큼을 이동시켜야 한다.    
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>addl $HEADER_SIZE, %eax
addl %edx, %eax
jmp  alloc_loop_begin
            </PRE
></TD
></TR
></TABLE
>
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN962"
></A
>9.10. deallocate 함수</H2
><P
>            <B
CLASS="EMPHASIS"
>deallocate</B
>는 allocate 함수에 비해서 매우 쉽게 만들 수 있다. 단지 현재 
            메모리 영역을 AVAILABLE로 표시만 하면 되기 때문이다. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl ST_MEMORY_SEG(%esp), %eax
subl $HEADER_SIZE, %eax
movl $AVAILABLE, HDR_AVAIL_OFFSET(%eax) 
ret
            </PRE
></TD
></TR
></TABLE
>
            하는 일은 간단하다. 현재 스택으로 부터 메모리영역의 주소를 얻어온다음, 헤더부분으로 이동해서 
            AVAILABLE표시를 하기만 하면 된다.
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN967"
></A
>9.11. 성능 및 다른 몇가지 문제들</H2
><P
>            여기에서 만든 코드는 실제 활용에는 문제가 있는 최소한의 기능만 구현한 학습용 코드일 뿐이다.
            좀더 그럴듯하게 만들기 위해서는 allocator함수에 몇가지 문제점들을 잡아주어야만 한다.
        </P
><P
>            이 함수의 가장 큰 문제점은 느리다라는 점이다. 만약 몇개의 메모리영역만 요청을 하게 된다면 
            속도는 그리 큰 문제가 되지 않을 것이다. 그러나 수천번의 메모리할당 요청이 들어오게 된다면
            속도문제가 발생한다. 1000번째 메모리할당 요청을 하게 된다면, 여러분은 요청한 크기를 가진
            사용가능한 메모리영역이 있는지를 확인하기 위해서 최대 999번의 검사를 해야 한다.
            게다가 리눅스는 메모리의 페이지 정보를 메모리가 아닌 디스크에서 관리한다. 이는 
            매번의 검사를 함에 있어서, 속도가 느린 디스크를 일일이 검사해야 함을 의미한다.
            당연히 매우 느려질 수 밖에 없다. 즉 이 프로그램은 할당요청이 늘어날때 마다 선형적으로 시간이 
            (linear time)늘어나게 된다. 모든 선형적인 시간이 소비되는 코드는 나쁜 코드이며, 가능한 
            상수시간(constant time)에 주어진 일을 해내는 코드를 만들어 내야 한다. 그러기 위해서는 
            메모리할당 요청을 관리할 수 있는 코드를 추가시켜야 한다. <B
CLASS="EMPHASIS"
>deallocate</B
>
            함수의 경우 단지 4개의 명령만 사용되는 간단한 코드이므로 할당요청의 갯수가 많아졌다고 해서
            특별히 문제될건 없다.    
        </P
><P
>            다른 또하나의 문제점은 brk(2) 시스템 호출을 자주한다는데 있다. 시스템 호출은 많은 시간이 
            소모되는 작업이다. 왜냐하면 단일한 프로세스의 mode 변환이 일어나기 때문이다. 
            거의 모든 kernel는 운영체제를 보호하기 위해서 user mode와 kernel mode로 모드를 
            분리해서 필요한 일을 하게 된다. 메모리 맵핑, 파일열기/쓰기와 같은 중요한 일을, 프로세스에게 
            전적으로 맡길경우 심각한 보안 위험을 가질 수 있기 때문으로, 위의 일들은 프로세스가 커널에게 
            요청하고 커널이 요청을 받아서 수행하는 식으로 이루어진다. 프로세스는 평상시에는 user mode로 
            작동을 하고, 커널에 어떤 요청을 해야 할경우 kernel mode로 변환을 하게 되고, 요청한 일을 끝냈을
            경우 다시 user mode로 작동하게 된다. 이러한 모드변환을 <B
CLASS="EMPHASIS"
>context switch</B
>라고 
            부르기도 한다. 이러한 context switch는 x86 프로세스에서 매우 느리게 일어난다. 그러므로 
            가능하면 context switch가 일어나지 않도록 해주어야 한다. brk(2)는 메모리 맵핑 관련일을 
            하는 것으로, user 모드에서는 필요한 작업을 수행할 수 없으며, 때문에 kernelmode로 context switch
            가 발생하게 된다. 우리가 만든함수는 매번 요청시 마다 brk 시스템호출을 해야하는 문제점을 
            가진다. 
        </P
><P
>            그리고 메모리를 비효율적으로 관리한다는 문제점을 가지고 있다. 예를 들어 5byte의 메모리 영역을 
            요청했는데, 사용가능한 영역으로?1000byte를 얻었다고 가능해보자. 우리가 요청한 
            메모리 영역보다 충분히 크므로, 문제 없이 리턴될 것이고 사용하는데도 문제는 없겠지만, 955 byte는 
            사용하지 않는 메모리 영역으로 낭비하게 된다. 이를 효율적으로 사용하기 위해서는 955 byte를 나중에
            사용가능하도록 break를 분리해주어야 한다.  
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN975"
></A
>9.12. Allocator 사용하기</H2
><P
>우리가 작성한 메모리관리자는 실제 사용하기에는 문제가 있지만, 작동
            테스트 정도는 해볼 수 있다. 그래서 6장에서 예제로 다루었던
            read-records.s 프로그램에 여기에서 만든 메모리관리자를 사용해 
            보도록 하겠다. 
        </P
><P
>			read-records.s 프로그램은 파일로 부터 읽어들인, 내용을 저장하기
            위해서 .bss section을?사용하고 있다.  
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.bss
            </PRE
></TD
></TR
></TABLE
>
            .bss section을 보면 <B
CLASS="EMPHASIS"
>record_buffer</B
>를 입출력
            버퍼로 이용하고 있는데, 고정된 크기로 할당되어 있음을 알 수 있다.
            이걸 우리가 만든 메모리 관리자를 이용해서 동적으로 할당하도록
            코드를 수정한 후 테스트 하면 된다. 우리가 수정할 부분의 
            원본 코드는 다음과 같다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>.section .bss
.lcomm, record_buffer, RECORD_SIZE
            </PRE
></TD
></TR
></TABLE
>
            우선 고정된 크기의 record_buffer는 필요가 없을 것이다.
            동적으로 할당된 버퍼의 시작주소를 저장할 수 있는 공간만 있으면 된다.
            시작주소를 저장하기 위한 공간은 4byte면 충분하다. 시작주소를 저장할 
            공간은 .data 영역에 선언하면 된다.
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>record_buffer_ptr:
.long 0
                </PRE
></TD
></TR
></TABLE
>
                다음으로 프로그램이 시작된 뒤, 메모리 관리자를 초기화 시키기 위해서 
                allocate_init 를 호출하는 코드를 추가한다.
                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>call allocate_init
                </PRE
></TD
></TR
></TABLE
>
                이제 메모리를 요청하기 위해서, 필요한 메모리의 크기와 함께 allocate 
                함수를 호출하면 된다.
                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>pushl $RECORD_SIZE
call  allocate
movl  %eax, record_buffer_ptr
                </PRE
></TD
></TR
></TABLE
>
                이제 read_record를 호출하게 되면, 동적으로 만들어진 메모리의 주소를 
                이용하게 될 것이다. 예전 코드에서 포인터는 immediate-mode 상태로 
                record_buffer를 가리키고 있었는데, 이제는 record_buffer_ptr의  
                주소가 가리키는 영역을 이용해야 하기 때문에, direct mode로 
                record_buffer_ptr의 값을 이용하도록 변경해야 한다.
                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>pushl $record_buffer    # 을
pushl record_buffer_ptr # 로 변경한다.
                </PRE
></TD
></TR
></TABLE
>
                다음으로 레코드에서 이름이 저장된 주소를 찾는 부분을 변경해야 한다. 
                예전 코드는 $RECORD_FIRSTNAME + record_buffer로 이름이 저장된 주소를 
                찾을 수 있었다. 새로운 코드는 record_buffer_ptr이 가리키는 주소로 부터
                이름이 있는 주소를 찾아내야 한다. 
                때문에 레지스터의 포인터를 record_buffer_ptr로 옮긴다음 
                $RECORD_FIRSTNAME만큼 포인터를 이동 시키는 일을 하도록 코드를 변경해야 한다.   
                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>pushl $RECORD_FIRSTNAME + record_buffer # 을
## 아래와 같이 변경한다.
movl record_buffer_ptr, %eax
addl $RECORD_FIRSTNAME, %eax
pusl %eax
                </PRE
></TD
></TR
></TABLE
>
                마찬가지로 아래의 코드도 변경해야 한다.
                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>movl $RECORD_FIRSTNAME + record_buffer, %eax #을
## 아래와 같이 변경한다.
movl record_buffer_ptr, %ecx
addl $RECORD_FIRSTNAME, %ecx
                </PRE
></TD
></TR
></TABLE
>
                마지막으로 할당된 메모리를 되돌려주기 위해서 record_buffer_ptr을 호출하면 
                된다.
                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>pushl record_buffer_ptr
call deallocate
                </PRE
></TD
></TR
></TABLE
>
                위에서 언급한 부분을 수정한 후 아래와 같이 실행파일을 만들면 된다.
                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>as read-records.s -o read-records.o
ld alloc.o read-record.o read-records.o write-newline.o count-chars.o -o read-records
                </PRE
></TD
></TR
></TABLE
>
                성공적으로 실행파일을 만들었다면, 실행시켜서 테스트해보도록 하자.
                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># ./read-records
                </PRE
></TD
></TR
></TABLE
>
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN991"
></A
>9.13. 더 많은 정보들</H2
><P
>            리눅스와 다른 운영체제 시스템에서의 메모리 관리에 대한 자세한 정보들은 아래의 링크들을 
            참고하기 바란다.
            <P
></P
><UL
><LI
><P
>                        <A
HREF="http://linuxassembly.org/startup.html"
TARGET="_top"
>http://linuxassembly.org/startup.html</A
> : 리눅스 프로그램의 메모리 Layout에 대한 정보 
                    </P
></LI
><LI
><P
>                        <A
HREF="http://cne.gmu.edu/modules/vm"
TARGET="_top"
>http://cne.gmu.edu/modules/vm</A
>다양한 운영체제에서의 가상메모리 시스템 정보
                    </P
></LI
><LI
><P
>                        <A
HREF="http://www.nongnu.org/lkdp/files.html"
TARGET="_top"
>http://www.nongnu.org/lkdp/files.html</A
> : 리눅스 가상메모리 시스템에 대한 상세 정보
                    </P
></LI
><LI
><P
>                        <A
HREF="http://gee.cs.oswego.edu/dl/html/malloc.html"
TARGET="_top"
>http://gee.cs.oswego.edu/dl/html/malloc.html</A
>
                    </P
></LI
><LI
><P
>                        <A
HREF="http://docs.freebsd.org/44doc/papers/malloc.html"
TARGET="_top"
>http://docs.freebsd.org/44doc/papers/malloc.html</A
> 4.4 BSD 메모리 할당자에 대한 설명
                    </P
></LI
></UL
>
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN1010"
></A
>9.14. 복습</H2
><P
>            <P
></P
><UL
><LI
><P
>                        리눅스 프로그램이 시작될 때의 메모리 구성에 대해서 설명하라.
                    </P
></LI
><LI
><P
>                        heap란 무엇인가.
                    </P
></LI
><LI
><P
>                        current break란 무엇인가.
                    </P
></LI
><LI
><P
>                        맵핑되지 않은 메모리에 접근을 시도할 경우 어떤 일이 발생하는가.
                    </P
></LI
><LI
><P
>                        운영체제는 어떻게 각각의 프로세스가 자신들에게 할당된 메모리를 초과해서 사용하지 막는가.
                    </P
></LI
><LI
><P
>                        메모리를 이용할때, 디스크상에서 어떤일이 발생하는지를 설명하라.
                    </P
></LI
><LI
><P
>                        메모리 할당자가 필요한 이유에 대해서 설명하라.
                    </P
></LI
></UL
>
        </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="OPTIMIZATION"
></A
>10. 최적화</H1
><P
>        <B
CLASS="EMPHASIS"
>최적화</B
>란 여러분이 만든 애플리케이션을 좀더 효과적으로 
        실행되게끔 만들기 위한 일련의 과정들을 말한다. 
        여러분은 속도, 메모리 사용공간, 디스크 사용공간등 많은 부분에 있어서 
        좀 더 효율적인 사용이 가능하도록 최적화 시킬 수 있다. 이번 장에서는 
        속도에 중점을 둔 최적화 방안에 대해서 토론해 보도록 하겠다.
    </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN1032"
></A
>10.1. 최적화가 필요한 시점</H2
><P
>    
            모든 경우에 반드시 최적화가 필요한 것은 아니다. 왜냐하면 더 나은 최적화는 
            그만큼 복잡한 과정을 필요로 하기 때문이다. 이러한 복잡한 과정은 필연적으로
            코드의 양을 늘리고, 코드를 이해하는데 전문성을 필요하도록 만든다. 
            높은수준으로 최적화된 코드는 보통, 이해하고 디버깅하기 힘들어 질 수 있다. 
            결국 프로젝트의 완료시간과 유지보수 시간을 증가시키는 요인이 된다. 
            그러므로 꼭 필요한 부분에 대해서 최적화를 해주어야 한다.
        </P
><P
>    
            그러나 프로그램의 어느부분에서 속력을 저하시키는 병목현상이 발생할지를 
            예측하는 것은 경험 많은 프로그래머라고 할지라도 예측하기가 쉽지 않다.
            심지어 프로그래머를 직접 실행 시켜보더라도, 병목현상이 발생하는 코드의 
            위치를 찾아낸다는 것은 결코 쉬운일이 아니다. 일반적으로 프로그램의 속도가
            저하되는 원인은 병목구간의 코드에 의한바가 많으므로, 병목을 일으키는 
            코드를 찾아내는 것은 매우 중요한일이며, 실제 속도관련 최적화는 병목구간을 
            찾아내는 일이 가장 중요하다. 
        </P
><P
>            당신이 프로그램을 개발할때, 당신은 다음의 원칙에 따라서 프로그램을 개발하도록
            노력해야 한다.
            <P
></P
><UL
><LI
><P
>                        모든 것을 문서화 한다.
                    </P
></LI
><LI
><P
>                        작업의 과정역시 문서화 한다.    
                    </P
></LI
><LI
><P
>                        코드는 모듈화시키고, 쉽게 보고, 이해할 수 있도록 작성한다.
                    </P
></LI
></UL
>
            문서화가 기본중의 기본이라는 것은 말할필요도 없으며, 특히나 그룹단위의 개발을 
            해야한다면, 그 중요성은 배가 된다. 프로그램의 함수화 역시 기본이다. 
            이쯤되면 위의 목록의 내용들이 중요한건 알겠는데, 애플리케이션의 속도와 무슨 관련이
            있지 ? 하고 의아해 할 수 있을 것이다. 
            일단 최적화는 초기 개발단계에서는 다음과 같은 이유 때문에 그리 필요하지 
            않은 작업이다. 
            <P
></P
><UL
><LI
><P
>                        약간의 속도의 문제는 더 좋은 하드웨어로 해결할 수 있다. 종종 더 좋은 
                        하드웨어를 구입하는게, 좋은 프로그래머를 고용하는 것 보다 저렴하다. 
                    </P
></LI
><LI
><P
>                        처음 만들어진 프로그램은 요구사항의 변경, 새로운 기술 도입, 알고리즘과 
                        프로세스 변경, 프로그래머의 능력향상 등의 이유로 80%정도 다시 만들어 진다.
                        즉 처음 구상한것과는 전혀 다른 프로그램이 될 가능성이 많다. 
                        변경될 가능성이 많은 코드를 그때 그때 최적화 하는건 시간낭비다. 
                    </P
></LI
><LI
><P
>                        속도문제는 코드의 단지 몇군데 지역적인 곳에서 발생한다. 이러한 문제를?                        프로그램을 완전히 만들어서 테스트하기 전에 찾아낸다는 건 매우 어려운 
                        일이다.
                    </P
></LI
></UL
>
        </P
><P
>            나는 이전에 웹기반의 전자상거래 프로젝트에 투입된 일이 있었으며, 정확하고 깔끔
            하게 작동하는데 프로젝트의 촛점을 맞추고 작업을 진행 했었다. 
            당시 같이 일하던 동료는 웹 페이지가 로딩된 후 일을 마치고 종료될때까지 무려 
            12초나 걸린다는 걸로 무척이나 고민을 하고 있었다(모든 웹페이지는 1초안에 
            필요한 작업을 마치고 결과를 출력해야 했었다). 그때 나는 속도에 신경쓰지 말고
            정확히 작동하도록 만드는데 신경쓰자고 했으며, 최적화는 가장 나중 우선순위로 
            하자고 권고하고, 그렇게 작업을 하도록 했다. 마침내 3달에 걸쳐서 완벽하게 
            작동되는 코드를 만들었고, 3일에 거쳐 병목현상이 일어나는 부분을 찾아서 속도문제를
            해결했다. 정확히 작동하도록 하는 기능구현에 촛점을 맞춤으로써, 
            정확성과 성능 모두를 만족시키는 프로젝트를 수행하게 되었다.
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN1052"
></A
>10.2. 어디를 최적화 할 것인가</H2
><P
>            최적화해야 될 부분은 많다. 그러나 시간과 능력은 한정되어 있으므로, 최적화를 
            통해서 많은 이득을 얻을 수 있는 부분을 선별해내야 한다. 
            최적화할 부분을 찾아내는 가장 좋은 방법은 <B
CLASS="EMPHASIS"
>profiler</B
>를 
            이용하는 방법이다. profiler는 각 함수별로 얼마만큼의 시간을 소비하는지 
            통계를 내는 프로그램이다. GNU/Linux 환경에서는 grpof라는 표준 profile
            프로그램을 제공한다. 프로그래머는 profiler의 결과를 보고, 어느 함수가 가장 
            많은 시간을 소비했는지를 확인해서, 함수단위로 최적화 시켜야할 부분을 결정할 
            수 있게 된다. profiler의 사용방법은 이 문서에서 논외로 하겠다. profiler에 대한
            자세한 내용은 <A
HREF="http://www.joinc.co.kr/modules/moniwiki/wiki.php/article/c_cpp_profile"
TARGET="_top"
>gprofile 사용</A
>문서를 참고하기 바란다. 
        </P
><P
>            profile결과 특정함수가 단지 1%정도의 시간만을 소비하고 있다면, 이 함수를 
            최적화할 필요는 없다. 그러나 만약 20%정도의 시간을 소비하는 함수가 있다면, 
            이 함수에 대해서는 주목할 필요가 있다. 소비하는 정도가 큰 함수일 수록 약간의 
            최적화 만으로 큰 효과를 얻을 수 있기 때문이다. 6시간의 노력으로 1%의 함수를 
            0.9%로 최적화 하는 것과 20%의 함수를 5%최적화하는 것, 어느게 효율적인지는 
            말할 필요도 없다.
        </P
><P
>            최적화에는 지역최적화와 전역최적화 두개의 커다란 영역이 있다. 
            지역최적화는 주로 하드웨어 특성과 프로그램 특성에 관련된 것들이다. 
            전역최적화는 프로그램의 구조적인 것들과 관계있다. 예를 들어 지하철 노선에서 
            각 역간 최단 거리를 확보하기 위한 노선을?찾아주는 함수가 있다면, 
            다양한 알고리즘을 코드에 적용함으로써 빠른시간안에 최단거리를 찾아주는 함수의 
            작성이 가능할 것이다. 
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN1059"
></A
>10.3. 지역 최적화 방안</H2
><P
>            여기에서는 지역 최적화를 위해서 알려진 방법중 몇 가지를 소개하도록 하겠다.
            고수준 언어를 사용할 경우에는 보통 컴파일러의 최적화 관련 옵션을 이용함으로써
            자동적으로 최적화된 코드를 만들어 낼 수 있다. 
            <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>미리계산된 값을 넘겨라</DT
><DD
><P
>						함수는 일반적으로 입력과 출력이 가능한 데이터갯수에 제한을 가지고 있다. 
						그러므로 가능한한 어떤 함수를 호출하기 전에, 필요한 계산을 모두 한다음 
						최소한의 간단한 정보만을 함수에게 넘겨줄 필요가 있다. 함수는 가능한한 
						가볍게 만들어야 한다. 쓸데없이 다량의 데이터를 넘겨서, 함수가 많은일을 
						처리하도록 하는 커다란 함수의 생성은 지양하도록 한다.
                    </P
></DD
><DT
>결과 값을 기억하라</DT
><DD
><P
>						함수를 호출해서 어떤 계산을 수행하는 데에는 많은 비용이 소비된다. 
						그러므로 가능한 함수 호출을 줄여야할 필요가 있다.
						자주 사용될 수 있는 계산된 데이터는 메모리에 저장한 후, 다른 필요한 곳에서 
						재사용하도록 하면 함수 호출을 줄일 수 있다.
						예를 들어 현재 시간을 가지고 계산을 하는 함수가 3개 정도 있다고 가정해 보자.
						이경우 매번 현재 시간을 가져오는 time()함수를 호출하는 것은 낭비다. 한번
						time()함수를 호출하고, 그 값을 메모리에 저장한다음, 필요한 함수가 사용할 수 
						있도록 하는 것이 훨씬 효율적이다. 이러한 작업은 때때로 caching 혹은 
						memoizing이라고 불리운다.
                    </P
></DD
><DT
>register의 이용</DT
><DD
><P
>						Register는 컴퓨터에서 빠르게 접근할 수 있는 메모리 영역이다. 
						당신이 메모리에 접근하려고 한다면, 프로세스는 물리적으로 떨어져 있는 메모리에
						접근하기 위해서 bus를 이용해서 메모리에 있는 데이터를 가져온다. 반면 
						register는 프로세스 그 자신이 가지고 있는 메모리 영역이다. 당연히 매우 
						빠를 수 밖에 없다. 그러므로 허용가능한 데이터를 레지스터에 올려놓고 
						사용을 할 필요가 있다. 고수준언어에서는 굳이 레지스터에 대해서 신경쓸필요 
						없이 알아서 레지스터를 쓸것인지를 결정한다. 
                    </P
></DD
><DT
>inline 함수</DT
><DD
><P
>						함수는 프로그램의 관리를 위한 가장 중요한 요수중 하나다. 함수를 이용하면 
						프로그램을 모듈화 시킬 수 있으며, 재사용 가능하도록 만들 수 있다. 또한 
						쉽게 보고 이해할 수 있도록 만들어 준다. 그러나 함수를 호출하기 위해서는 
						stack영역으로 인자를 밀어넣고, jump해야 하는 오버헤드가 발생한다. 
						이러한 문제를 해결방안으로 많은 언어들이 inline 함수 혹은 inline 메크로 함수를
						지원한다. inline함수를 사용하게 되면, 컴파일 할때 함수의 코드가 해당 영역에
						직접 삽입된다. 함수호출을 하지 않기 때문에, 빨라지는 효과를 누릴 수 있지만 
						반면 코드가 매번 삽입이 되므로, 프로그램의 덩치가 커지게 될 것이다. 또한
						재귀함수등에는 사용할 수 없는 등의 제약을 가진다.
						만약 순환문등에 inline함수를 사용한다면 특별히 많은 효과를 누릴 수 있을 것이다.
                    </P
></DD
><DT
>addressing modes</DT
><DD
><P
>						어드레싱 모드에는 몇가지 종류가 있다는 것을 알고 있을 것이다. 이들 어드레싱 
						모드는 각각 서로 다른 속도를 가지고 있다. immediate와 register 어드레싱 모드가
						가장 빠르며, Direct, indirect 모드 순으로 빠르다. pointer와 indexed indirect 
						모드가 그중 가장 느리다. 그러므로 가능한 빠른 주소모드를 사용할 필요가 있다.
                    </P
></DD
><DT
>Data Alignment</DT
><DD
><P
>						어떤 프로세서들은 데이터를 엑세스할 때 word-aligned 한다. 보통 word단위로 
						나누어서 엑세스하게 되는데, non-aligned data방식보다 빠르게 엑세스가 
						가능하다. 그래서 구조체를 만들게 될때, 구조체의 크기가 word단위로 
						만들어지는 것을 확인할 수 있다. 아래의 c코드를 컴파일 한다음 결과를 
						확인해 보도록 하자. 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>#include &#60;stdio.h&#62;

struct data
{
    int a;
    char b[1];
};

int main()
{
    struct data mydata;
    printf("%d\n", sizeof(mydata));
}</PRE
></TD
></TR
></TABLE
>
                    </P
></DD
></DL
></DIV
>
			지금까지 언급한 방법들은 여러가지 지역최적화 방법중 몇가지에 불과하다. 하지만 가장 중요한 
			요소는 읽기쉽고 관리하기 쉬운 코드를 만드는데 있다는 걸 기억해 두길 바란다.
        </P
><P
>&#13;        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN1089"
></A
>10.4. 전역 최적화 방안</H2
><P
>            전역최적화는 두가지 목표를 가진다. 첫번째는 지역 최적화가 가능하도록 코드를 작성
            하는 것이다. 예를 들어, 만들어진 코드가 복잡한 흐름을 가진 커다란 하나의 
            procedure로 구성되어 있다면, 느리게 작동할 것이다. 이것을 단순한 일을 하는 
            여러개의 코드로 쪼갠다음 계산된 값을 메모리에 저장하거나 다른 함수로 넘기는 
            식으로 해서 효율적으로 돌아가게끔 만들 수 있다.  
        </P
><P
>            stateless 함수(어떠한 글로벌함수나, 시스템콜도 사용하지 않고, 받아들인 인수를 
            가지고 단지 연산만 하는 함수)는 최적화를 위한 좋은 방법이다. 프로그래머는 
            가능하면 프로그램을 Stateless한 함수들로 모듈화 함으로써 최적화 정도를 높일 수 
            있다. 전자상거래 프로젝트를 예로 들어 보겠다. 전자상거래에서는
            특정한 제품 목록과 관련된 정보를 가지고 오는데, 이를 위해서 12번의 데이터베이스
            호출을 해야했고, 최악의 경우 20초라는 시간을 소비했다. 이 프로그램은 웹을 
            통해서 고객과 상호대화 해야 하는데, 이는 너무나 긴시간이였다. 이 문제를 해결하기 
            위해서 초기 프로그램이 시작할 때, 제품목록을 읽어와서 메모리에 적재하고, 함수에서는 
            메모리의 제품목록을 가져오도록 즉 statless한 함수를 만드는 방법을 사용했다. 
            제품의 목록은 변경이 될 수 있으므로, 일정시간 간격으로 메모리의 내용을 갱신하도록 
            하는 또다른 함수를 만들었으며 결과적으로 1초안에 작동하는 프로그램을 만들어냈다.  
        </P
><P
>            전역 최적화를 위해서 보통 아래와 같은 특성을 갖추도록 프로그램을 작성한다.
            <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>병렬화</DT
><DD
><P
>                        병렬화는 코드가 다중 프로세스에 의해서 분할되어서 
                        실행하는 것을 의미한다. 자동차를 만든다고 가정을 해보자. 이경우 
                        엔진과 인테리어를 만드는 부분은 서로 독립시켜서 동시에 작업이 
                        가능하도록 할 수 있다. 만약 여러분의 컴퓨터가 다중의 프로세스나 
                        클러스터링 되어 있고, 이들 자원을 이용할 수 있다면, 병렬화된 코드는
                        효율에서 많은 잇점을 얻을 수 있을 것이다.
                    </P
></DD
><DT
>stateless</DT
><DD
><P
>                        stateless 함수와 프로그램은 함수사이에 명확하게 정의된 데이터만을 
                        주고받는다. 물론 모든 함수가 stateless할 수는 없다. 
                        전자상거래 프로그램을 예로들어보자. 대부분의 함수가 메모리에 있는
                        상품정보를 주고 받는다고 하더라도, 최초에 하나의 함수는 DB에 접근해서
                        상품정보를 읽어오는 일을 해야할 것이다. 이 함수는 stateless할 수 없다.
                        stateless하지 않은 함수의 실행을 최소화 시킬수는 있다. 상품정보라는게 
                        변경이 자주 일어나는게 아니기 때문에, 하루에 한번만 DB에서 정보를 
                        가져오는 등의 방법으로 이러한 함수의 실행을 최소화 시킬수 있으며, 실제 
                        이러한 방법을 이용해서 프로그램을 최적화 시켰다.
                    </P
></DD
></DL
></DIV
>
        </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN1103"
></A
>10.5. 복습</H2
><P
>						<P
></P
><UL
><LI
><P
>												지역최적화와 전역최적화의 차이를 설명하라.	
										</P
></LI
><LI
><P
>												지역최적화 방안의 몇가지 방법을 설명하라.
										</P
></LI
></UL
>
		</P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="APPENDIXA"
></A
>11. Appendix A. GUI 프로그래밍</H1
><P
>		이번장의 Graphical User Interface를 작성하기 위한 방법을 가리치는게 
		목적이 아니다. 단지 다른 응용을 작성하면서, 어떻게 GUI적인 부분을 
		구현해야 할것인지, 그러한 구현을 위한 어떠한 도구와 라이브러리가 있는지 
		정도만을 소개하도록 할 것이다. 여기에서 소개한 라이브러리를 제대로 사용
		하기 위해서는 별도로 학습을 해야 할것이다.  
	</P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN1114"
></A
>11.1. GNOME 라이브러리</H2
><P
>			GNOME는 리눅스 유저에게 데스크탑환경을 제공해주기 위한 목적으로 시작된
			여러 프로젝트중 하나로, Linux 에서는 QT(:12)와 함께 데스크탑라이브러리의
			양대산맥으로 자리잡고 있다. GNOME 프로젝트는 응용을 실행시키기 위한
			launcher(실행기)와 실행된 응용을 배열할 수 있는 panel, 응용의 표준이 
			되는 파일관리,세션 관리, 설정관리등과 관련된 API를 제공한다. 
		</P
><P
>			GNOME라이브러리는 특성상 커다른 데이터 구조를 생성하고 유지하는 일련의 
			작업을 수행하지만 프로그래머로 하여금 메모리를 어떻게 관리해야 할지등의
			고민을 하지 않도록 구현되어 있다. 이러한 구현의 핵심은 모든 GUI 
			구조체 데이터를 함수호출을 통해서 처리하도록 하는데 있다. 이러한 
			라이브러리 디자인은 유지보스 측면에서 많은 도움을 준다. 예를 들어서 
			라이브러리의 버젼이 바뀌었다고 가정을 해보자. 이럴경우 데이터 구조도
			변경될 수 있는데, 데이터 구조 자체를 라이브러리에서 모두 처리하기 때문에
			라이브러리를 사용하는 응용측에서는 버젼이 바뀜에 따른 코드 수정을 
			최소화 시킬수가 있다. 그냥 컴파일한 다시 해주면 사용하는데, 문제가 
			없다. GNOME는 라이브러리와 응용간의 데이터 교환을 위해서, 실데이터를 
			전송하는 대신에, 객체를 가리키는 포인터를 주고 받게 되며, 프로그래머는 
			자료구조에 포함되어 있는 여러가지 데이터들에대해서 신경쓸 필요가 
			없더록 구성되어 있다.
		</P
><P
>			이번장에서는 GNOME의 기본적인 개념과 프로그래밍 방법에 대해서 알아보도록
			할것이다. GNOME 프로그래밍에 본격적으로 뛰어들고 싶다면 GNOME 개발자
			사이트인 http://developer.gnome.org를 방문하길 바란다. 이 사이트는 
			자습서, 메일링리스트, API 문서등 GNOME환경에서 프로그래밍을위한 다양한
			문서를 제공한다.
		</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN1119"
></A
>11.2. 다양한 언어를 이용한 간단한 GNOME 프로그램 작성</H2
><P
>			그럼 quit 버튼을 포함한 간단한 윈도우 프로그램을 만들어 보도록 하겠다.	
			이 프로그램은 버튼을 클릭하게 되면, 정말 프로그램을 종료시킬 것인지를 
			물어보는 대화창이 뜨고 yes를 클릭하면 종료하는 간단한 일을 한다.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># PURPOSE : GNOME Library를 이용한 간단한 GUI 프로그램 제작 예를 보여준다.
# INPUT   : 사용자로 부터 Quit 버튼 클릭 이벤트를 받으면 윈도우를 종료한다.
# OUTPUT  : 프로그램의 종료
#
# PROCESS : 만약 유저가 "Quit" 버튼을 클릭하면, 확인을 위한 대화창을 뛰운다. 
#           유저가 Yes를 클릭하면 종료되고, 그렇지 않으면 계속 실행된다.
#

.section .data

### Gnome 정의  
#   C언어에서의 헤더파일과 같은 일을 한다. 각종 정의된 값이 들어간다.
#

# GNOME 버튼 이름
GNOME_STOCK_BUTTON_YES:
.ascii "Button_Yes\0"
GNOME_STOCK_BUTTON_NO:
.ascii "Button_No\0"

# Gnome 메시지 박스 타입
GNOME_MESSAGE_BOX_QUESTION:
.ascii "question\0"

# NULL에대한 표준 정의
.equ NULL, 0

# GNOME 시그널 정의
signal_destroy:
.ascii "destory\0"
signal_delete_event:
.ascii "delete_event\0"
signal_clicked:
.ascii "clicked\0"


### 애플리케이션 관련 정의들

# 애플리케이션 정보
app_id:
.ascii "gnome-example\0"
app_version:
.ascii "1.000\0"
app_title:
.ascii "Gnome Example Program\0"

# 버튼및 윈도우창에 사용될 문장들 
button_quit_text:
.ascii "I Want to Quit the GNOME Example Program\0"

quit_question:
.ascii "Are you sure you want to quit?\0"


.section .bss

# 위젯관련된 변수 저장
.equ WORD_SIZE, 4
.lcomm appPtr, WORD_SIZE
.lcomm btnQuit, WORD_SIZE

.section .text

.globl main
.type main,@function

main:
	pushl %ebp
	movl %esp, %ebp

	# GNOME 라이브러리 초기화	
	pushl 12(%ebp)       # argv
	pushl 8(%ebp)        # argc
	pushl $app_version
	pushl $app_id
	call gnome_init
	addl $16, %esp       # 스택 복구

	# 새로운 애플리케이션 윈도우 생성
	pushl $app_title     # 윈도우 타이틀
	pushl $app_id        # 애플리케이션 ID
	call gnome_app_new
	addl $8, %esp        # 스택 복구
	movl %eax, appPtr    # 윈도우 포인터 저장

	# 새로운 버튼 생성
	pushl $button_quit_text        # 버튼 문자
	call gtk_button_new_with_label 
	addl $4, %esp        # 스택복구
	movl %eax, btnQuit   # 버튼포인트 저장

	# 버튼을 애플리케이션 윈도우 안에 배치 
	pushl btnQuit
	pushl appPtr
	call gnome_app_set_contents
	addl $8, %esp

	# 배치된 버튼 위젯을 보여준다. 
	pushl btnQuit
	call gtk_widget_show
	addl $4, %esp

	# 애플리케이션 윈도우를 보여준다. 
	pushl appPtr
	call gtk_widget_show
	addl $4, %esp

	# delete 이벤트 헨들러 설정
	pushl $NULL             # 함수에 넘길 NULL 값
	pushl $delete_handler     
	pushl $signal_delete_event
	pushl appPtr 
	call gtk_signal_connect
	addl $16, %esp					# 스택 복구

	# destory 이벤트 핸들러 설정	
	pushl $NULL   
	pushl $destroy_handler  #
	pushl $signal_destroy
	pushl appPtr        
	call gtk_signal_connect
	addl $16, %esp    			# 스택 복구 

	# 클릭 이벤트가 발생했을 때, 호출될 함수의 설정
	pushl $NULL
	pushl $click_handler
	pushl $signal_clicked
	pushl btnQuit
	call gtk_signal_connect
	addl $16, %esp

	#Transfer control to GNOME. Everything that
	#happens from here out is in reaction to user
	#events, which call signal handlers. This main
	#function just sets up the main window and connects
	#signal handlers, and the signal handlers take
	#care of the rest
	call gtk_main
	#After the program is finished, leave
	movl $0, %eax
	leave
	ret
	#A "destroy" event happens when the widget is being
	#removed. In this case, when the application window

	#is being removed, we simply want the event loop to
	#quit
	destroy_handler:
	pushl %ebp
	movl %esp, %ebp
	#This causes gtk to exit it’s event loop
	#as soon as it can.
	call gtk_main_quit
	movl $0, %eax
	leave
	ret
	#A "delete" event happens when the application window
	#gets clicked in the "x" that you normally use to
	#close a window
	delete_handler:
	movl $1, %eax
	ret
	#A "click" event happens when the widget gets clicked
	click_handler:
	pushl %ebp
	movl %esp, %ebp
	#Create the "Are you sure" dialog
	pushl $NULL                       #End of buttons
	pushl $GNOME_STOCK_BUTTON_NO      #Button 1
	pushl $GNOME_STOCK_BUTTON_YES     #Button 0
	pushl $GNOME_MESSAGE_BOX_QUESTION #Dialog type
	pushl $quit_question              #Dialog mesasge
	call gnome_message_box_new
	addl $16, %esp                    #recover stack

	#%eax now holds the pointer to the dialog window
	#Setting Modal to 1 prevents any other user
	#interaction while the dialog is being shown
	pushl $1
	pushl %eax
	call gtk_window_set_modal
	popl %eax
	addl $4, %esp

	#Now we show the dialog
	pushl %eax
	call gtk_widget_show
	popl %eax

	#This sets up all the necessary signal handlers
	#in order to just show the dialog, close it when
	#one of the buttons is clicked, and return the
	#number of the button that the user clicked on.
	#The button number is based on the order the buttons
	#were pushed on in the gnome_message_box_new function
	pushl %eax
	call gnome_dialog_run_and_close
	addl $4, %esp

	#Button 0 is the Yes button. If this is the
	#button they clicked on, tell GNOME to quit
	#it’s event loop. Otherwise, do nothing
	cmpl $0, %eax
	jne   click_handler_end
	call  gtk_main_quit
	click_handler_end:

	leave</PRE
></TD
></TR
></TABLE
>
		 	만들어진 코드는 다음과 같은 방법으로 빌드하면 된다.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># as gnome-example.s -o gnome-example.o
# gcc gnome-example.o `gnome-config --libs gnomeui` -o gnome-example</PRE
></TD
></TR
></TABLE
>
			이 프로그램은 Gnome에서 제공하는 함수들을 이용해서, 필요한 위젯을 생성하고 이들을 
			제어하고 있다. 이 프로그램에서 사용된 Gnome 함수들은 다음과 같다.
			<P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>gnome_init</DT
><DD
><P
>					명령행인자와 인자의 갯수, 애플리케이션 id, 버젼등의 정보를 가지고 Gnome 라이브러리를
					초기화 한다.
				</P
></DD
><DT
>gnome_app_new</DT
><DD
><P
>					새로운 애플리케이션 윈도우를 만들고 포인터를 리턴한다. 인자로 애플리케이션 id와 
					윈도우 제목을 받아들인다. 
				</P
></DD
><DT
>gtk_button_new_with_label</DT
><DD
><P
>					새로운 버튼을 만들고 포인터를 리턴한다. 인자로 버튼에 사용될 문자열을 받아들인다.
				</P
></DD
><DT
>gnome_app_set_contents</DT
><DD
><P
>					애플리케이션 윈도우에 포함시킬 위젯을 설정한다.
				</P
></DD
><DT
>gtk_widget_show</DT
><DD
><P
>					위젯을 생성시킨 후, 실제로 보이게 하려면 반드시 호출해야 한다.
				</P
></DD
><DT
>gtk_signal_connect</DT
><DD
><P
>					위젯은 버튼클릭과 같은 이벤트가 발생하게 되는데, 이러한 이벤트 시그널이 발생했을 때 
					처리해줄 callback 함수를 등록시키기 위해서 사용한다. 이 함수는 시그널을 발생시키는 
					위젯의 포인터와 callback 함수와 기타 필요한 데이터 포인터를 필요로 한다.
					이 함수를 실행시키면, 특정 이벤트가 발생될 때, 해당 이벤트를 처리할 함수가 호출된다.
					이 프로그램의 경우 기타 데이터를 필요로 하지 않기 때문에 NULL로 처리했다.
				</P
></DD
><DT
>gtk_main</DT
><DD
><P
>					GNOME의 main 루프함수다.	
				</P
></DD
><DT
>gtk_main_quit</DT
><DD
><P
>					GNOME의 main 루프를 빠져나오기 위한 함수다.
				</P
></DD
><DT
>gnome_message_box_new</DT
><DD
><P
>					응답이 가능한 대화창을 만든다. 대화창은 질의의 특징에 따라서 warning, question 등의
					타입을 정의할 수 있다.
				</P
></DD
><DT
>gtk_window_set_modal</DT
><DD
><P
>					modal 타입의 창을 만든다. modal 타입의 창은 해당 창이 닫히기 전에는 부모창을 
					선택할 수 없다.
				</P
></DD
></DL
></DIV
>
		</P
><P
>			다음은 C언어로 작성된 동일한 프로그램이다. 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>#include &#60;gnome.h&#62;

#define MY_APP_TITLE "Gnome Example Program"
#define MY_APP_ID "gnome-example"
#define MY_APP_VERSION "1.000"
#define MY_BUTTON_NEXT "I Want to Quit the Example Program"
#define MY_QUIT_QUESTION "Are you sure you want to quit?"

int destroy_handler(gpointer window, 
		GdkEventAny *e,
		gpointer data);
int delete_handler(gpointer window,
		GdkEventAny *e,
		gpointer data);
int click_handler(gpointer window,
		GdkEventAny *e,
		gpointer data);

int main(int argc, char **argv)
{
	gpointer appPtr;
	gpointer btnQuit;

	gnome_init(MY_APP_ID, MY_APP_VERSION, argc, argv);
	appPtr = gnome_app_new(MY_APP_ID, MY_APP_TITLE);

	btnQuit = gtk_button_new_with_label(MY_BUTTON_NEXT);

	gnome_app_set_contents(appPtr, btnQuit);

	gtk_widget_show(btnQuit);

	gtk_widget_show(appPtr);
	gtk_signal_connect(appPtr, "delete_event",
		GTK_SIGNAL_FUNC(delete_handler), NULL);
	gtk_signal_connect(appPtr, "destroy",
		GTK_SIGNAL_FUNC(destroy_handler), NULL);
	gtk_signal_connect(btnQuit, "clicked",
		GTK_SIGNAL_FUNC(click_handler), NULL);
	
	gtk_main();

	return 0;
}

int destroy_handler(gpointer window,
		GdkEventAny *e,
		gpointer data)
{
	gtk_main_quit();
	return 0;
}

int delete_handler(gpointer window,
		GdkEventAny *e,
		gpointer data)
{
	return 0;
}

int click_handler(gpointer window,
		GdkEventAny *e,
		gpointer data)
{
	gpointer msgbox;
	int buttonClicked;

	msgbox = gnome_message_box_new(
		MY_QUIT_QUESTION,
		GNOME_MESSAGE_BOX_QUESTION,
		GNOME_STOCK_BUTTON_YES,
		GNOME_STOCK_BUTTON_NO,
		NULL);

	gtk_window_set_modal(msgbox, 1);
	gtk_widget_show(msgbox);

	buttonClicked = gnome_dialog_run_and_close(msgbox);

	if(buttonClicked == 0)
	{
		gtk_main_quit();
	}
	return 0;
}&#13;</PRE
></TD
></TR
></TABLE
>
			다음과 같이 컴파일 하면 된다.	
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># gcc gnome-example-c.c `gnome-config --cflags \
  --libs gnomeui` -o gnome-example-c</PRE
></TD
></TR
></TABLE
>
			성공적으로 컴파일을 끝냈다면 <B
CLASS="EMPHASIS"
>./gnome-example-c</B
>로 실행하도록 한다.	
		</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN1169"
></A
>11.3. GUI Builders</H2
><P
>			여기에서 제시한 예제들은 UI를 만들기 위해서 필요한 함수를 프로그래머가 직접
			불러서 사용하는 방식이였다. 그러나 UI는 특성상 비쥬얼한 환경에서 디자인할 수 
			있는 툴을 이용해서 코드를 생성하는게, 개발시간을 아낄 수 있다. 그래서 GNOME역시
			UI를 디자인할 수 있는 <B
CLASS="EMPHASIS"
>GLADE</B
>라는 UI 디자인 툴을 제공한다. 
			이 툴을 이용하면, 개발자는 비쥬얼한 환경에서 윈도우의 각 요소들을 배치할 수 있다.  
		</P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="APPENDIXB"
></A
>12. Appendix B. Common x86 Instructions</H1
><P
>		Instructions은 테이블 형태로 설명을 하도록 할 것이다. 이 테이블은 아래와 같은 
		내용들을 담고 있다.	
		<P
></P
><UL
><LI
><P
>				Instruction 코드
			</P
></LI
><LI
><P
>				사용되는 operands
			</P
></LI
><LI
><P
>				사용되는 flags
			</P
></LI
><LI
><P
>				instruction에 대한 자세한 설명	
			</P
></LI
></UL
>
	</P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN1185"
></A
>12.1. Data Transfer Instructions</H2
><P
>	
			<DIV
CLASS="TABLE"
><A
NAME="AEN1188"
></A
><P
><B
>&#54364; 1. Data Transfer Instructions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
><I
CLASS="FOREIGNPHRASE"
>Instruction</I
></TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
><I
CLASS="FOREIGNPHRASE"
>Operands</I
></TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
><I
CLASS="FOREIGNPHRASE"
>Affected Flags</I
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>movl</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>I/R/M, I/R/M</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>O/S/Z/A/C</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
VALIGN="TOP"
>word 단위의 데이터를 다른 위치로 옮기기 위해서 사용한다. movl %eax %ebx 는 %eax의 데이터를 %ebx로 복사하라는 의미다.</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>movb</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>I/R/M, I/R/M</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>O/S/Z/A/C</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
VALIGN="TOP"
>byte단위인걸 제외하고는 movl과 동일한 일을 한다.</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>leal</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>M, I/R/M</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>O/S/Z/AC</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
VALIGN="TOP"
>메모리의 위치를 계산해서, 해당 주소를 읽어온다. 예를들어 leal 5(%ebp, %ecx, 1)일경우 5+%ebp+1*%ecx 로 계산된 주소의 값이 %eax에 저장된다.</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>popl</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>R/M</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>O/S/Z/A/C</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
VALIGN="TOP"
>스택의 가징위에 있는 위치값을 가져온다. 이것은 movl (%esp), R/M 후 addl $4 한 것과 같은 결과를 보여준다.</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>pushl</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>I/R/M</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>O/S/Z/A/C</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
VALIGN="TOP"
>스택에 값을 밀어 넣는다. movl %eax, (%esp)후 subl $4, %esp한 것과 같은 결과를 보여준다.</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>xchgl</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>R/M, R/M</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>O/S/Z/A/C</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
VALIGN="TOP"
>값을 서로 바꾼다.</TD
></TR
></TBODY
></TABLE
></DIV
>
		</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN1239"
></A
>12.2. Integer Instructions</H2
><P
>	
			부호있는 정수형과 부호없는 정수형의 계산을 위한 명령을 소개한다.
			<DIV
CLASS="TABLE"
><A
NAME="AEN1242"
></A
><P
><B
>&#54364; 2. Data Transfer Instructions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
><I
CLASS="FOREIGNPHRASE"
>Instruction</I
></TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
><I
CLASS="FOREIGNPHRASE"
>Operands</I
></TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
><I
CLASS="FOREIGNPHRASE"
>Affected Flags</I
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>adcl</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>I/R/M, R/M</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>O/S/Z/A/P/C</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
VALIGN="TOP"
>&nbsp;</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>addl</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>I/R/M, R/M</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="TOP"
>O/S/Z/A/P/C</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="LEFT"
VALIGN="TOP"
>첫번째 오퍼랜드와 두번째 오퍼랜드를 더한다. 결과는 두번째 오퍼랜드에 저장된다. 만약 더한 결과가 저장될 레지스터의 공간보다 큰다면, overflow가 발생하고 bits는 참이 된다. 이 명령은 부호형과 부호없는 정수형 모두에 사용된다.</TD
></TR
></TBODY
></TABLE
></DIV
>
		</P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="APPENDIXC"
></A
>13. Appendix C. 주요 시스템 콜들</H1
><P
>		여기에서는 리눅스에서 사용하게 되는 중요한 시스템콜들을 간단히 설명하도록 한다.
		보통은 시스템콜을 직접사용하기보다는 라이브러리 함수를 이용하는 경우가 더 많기 때문이다.
		<A
HREF="http://www.joinc.co.kr/modules/moniwiki/wiki.php/article/linux_systemcall_quick_reference"
TARGET="_top"
>리눅스 시스템콜 퀵 레퍼런스</A
>와 
		<A
HREF="http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/Assembly/Documents/article_Linux_Assembler_하우투"
TARGET="_top"
>Linux Assembler 하우투</A
>문서를 참고하기 바란다.
	</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="APPENDIXD"
></A
>14. Appendix D. ASCII 코드 표</H1
><P
>		<DIV
CLASS="FIGURE"
><A
NAME="AEN1277"
></A
><P
><B
>&#44536;&#47548; 4. ASCII 코드 표</B
></P
><P
><IMG
SRC="http://www.joinc.co.kr/albums/album01/age.gif"></P
></DIV
>
	</P
><P
>		ASCII 코드는 단순하긴 하지만, 2byte문자를 지원할 수 없다는 단점을 가진다. 
		그런 이유로 최근에는 2byte이상의 문자의 지원이 가능한 Unicode가 국제 표준으로 채택되고 
		있다. 유니코드는 몇가지 인코딩 방법이 있는데, 그중 UTF-8과 UTF-32가 가장 널리
		쓰인다. UTF-8은 ASCII와 하위 호환이 된다. UTF-32는 4바이트를 이용해서 하나의 문자를 
		만든다.
	</P
><P
>		Unicode에 대한 자세한 내용은 <A
HREF="http://www.joelonsoftware.com/articles/Unicode.html"
TARGET="_top"
>Unicode.html</A
>문서를 참고하기 바란다.
	</P
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>&#51452;&#49437;</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN150"
HREF="#AEN150"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>                유닉스와 리눅스는 윈도우와 달리 확장자(extensions)를 가질 필요가 
                없다. 윈도우즈라면 실행파일의 경우 .exe등의 확장자를 명시해야 하지만
                유닉스에서는 어떠한 확장자도 가질 필요가 없다.   
            </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN166"
HREF="#AEN166"
>[2]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>                        같은 일을 하는 프로그램이라도 매우 다양한 방법으로 
                        작성될 수 있다. 일반적인 방법이 사용될 수 있지만 여러분만의 
                        노하우를 이용해서 작성될 수 있으며, 이경우 다른 프로그래머가 
                        코드를 분석하는데 문제가 될 수 있다. 이러한 특이 사항들을 
                        명시해 두면 다른 프로그래머에게 많은 도움을 줄 수 있다.   
                    </P
></TD
></TR
></TABLE
></BODY
></HTML
>
}}}
