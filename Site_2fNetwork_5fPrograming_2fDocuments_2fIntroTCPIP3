#title TCP_IP 개요 3

=== 복습 ===
[wiki:Site/Network_Programing/Documents/IntroTCPIP TCI/IP 소개 1], [wiki:Site/Network_Programing/Documents/IntroTCPIP TCP/IP 소개 2] 2개의 문서에서 부족하게 나마 TCP/IP(:12)에 대한 대략적인 내용들과, TCP/IP의 계층 구조 그리고, 각각의 계층 구조를 이루는 TCP(:12), IP(:12), ARP(:12), UDP(:12) 와 같은 프로토콜에 대해서 간단하게 살펴보았다. 지금까지의 내용을 도표로 좀더 익목요연하게 그려보자면 아래와 같이 그려볼수 있을것이다. 아래의 그림은 그동안 의 내용을 정리한것으로, 몇개 새로운 프로토콜들이 나오는데, 거기에 대한 설명도 하도록 하겠다. 
{{{#!plain
                                                              application
+------------------------------------------------------------------------+
| +--------------+  +--------------+  +--------------+  +--------------+ |
| | User         |  | User         |  | User         |  | User         | |
| | application  |  | application  |  | application  |  | application  | |
| +--------------+  +--------------+  +--------------+  +--------------+ | 
+----------|---------------|--------|--------|---------------------------+
           |               |        |        |
           |        +------|--------|--------|------+
           |        | +---------+   |   +---------+ | transport
           |        | |   TCP   |   |   |   UDP   | |   
           |        | +---------+   |   +---------+ |
           |        +---------------|---------------+
           |                        |
     +-----|------------------------|-----------------------------+
     | +---------+             +---------+            +---------+ | network
     | |  ICMP   |<----------->|   IP    |<---------->|  IGMP   | |
     | +---------+             +---------+            +---------+ |
     +------------------------------|-----------------------------+
                                    | 
                                    | 
     +------------------------------|-----------------------------+
     | +---------+             +---------+            +---------+ | link
     | |  ARP    |<----------->| HardWare|<---------->| RARP    | |
     | +---------+             +---------+            +---------+ |
     +------------------------------------------------------------+
}}}
User application 은 telnet(:12), ftp(:12), web browser 와 같은 사용자 응용프로그램으로 각 어플리케이션 프로토콜을 사용한다. transport 계층의 TCP/UDP는 앞장에서 언급했음으로 다시 설명하진 않겠다. transport:::계층(:12) 아래로 network 계층이 존재하며, 여기에는 IP(:12), IGMP(:12), ICMP(:12) 와 같은 프로토콜이 사용된다. 그림에서 보면 IP 프로토콜은 바로 application 계층과 통신이 가능한데, raw:::socket(:12)이란 도구를 통해서 transport 계층을 거치지 않고 곧바로 IP 계층과 통신할수 있다. raw socket 는 우리말로 '''생소켓''' '''날소켓''' 이라고도 불리운다.

ICMP 는 '''I'''nternet '''C'''ontrol '''M'''essage Protocol 혹은 인터넷 제어 메시지 프로토콜 이라고 불리운다. 호스트서버와 인터넷 게이트웨이 사이에서 메시지를 제어하고 어떤 에러가 발생했는지 알려주는 프로토콜이다. 위의 그림에서 처럼 network 레이어에서 작동을 하지만 User application 에 의해서 직접처리된다. ICMP 를 이용한 가장 대표적인 응용프로그램은 ping 이라는 프로그램으로, 서버상태를 확인하기 위해서 매우 자주 사용한다. 

IGMP는 멀티캐스팅(:12)을 위해서 사용되는 프로토콜로써, 다수의 다른 컴퓨터에게 컨텐츠를 보낼수 있도록 하는 프로토콜이다. 최근들어 멀티미디어 데이타 그중 스트리밍 데이타를 전송하기 위해서 자주 응용되는 프로토콜이다. 

기존의 방식은 보통 유니케스트 방식으로 서버와 클라이언트가 1:1 로 데이타를 전송하는 방식이였는데, 이는 동일한 스트리밍 데이타를 모든 유저에 대해서 복사해서 전송해야 했음으로, CPU자원과 네트웍자원을 과도하게 소모하는 단점을 가지고 있다. 이를 해결하기 위한 방법으로 멀티캐스팅 이라는 메시지를 전달하는 다른 방법이 나오게 되었다. 멀티캐스팅을 사용하게 되면 서버측에서는 단지 하나의 스트리밍 정보만을 보내게 되고, 라우터 측에서 수신받아야될 클라이언트 에게 스트리밍 데이타를 복사해서 전달하게 된다. 그러므로 서버측 부하가 분산되어서 처리된다. 물론 일반적인 라우터가 아닌 멀티캐스트를 지원하는 라우터(:12)를 사용해야 한다. IGMP는 이러한 라우터에 메시지를 송신받을 그룹에 대한 정보를 전송시켜준다. IGMP 는 Interget Group Management Protocol 의 줄임말 이며 인터넷 그룹 관리 프로토콜이라고 불리운다. 

ARP는 이전에 논의된적이 있으니 넘어가고 RARP에 대해서만 설명하도록 하겠다. RARP 는 ARP의 반대되는 일을한다. ARP가 IP주소를 물리적인 네트워크 주소로 변환시켰다면 RARP는 물리적인 네트워크 주소를 IP 주소로 변환하는 작업을 한다. 보통의 운영체로 운영되는 시스템이라면 부팅시에 이더넷 카드에 IP 번호를 부여해 줄수 있을것이다. 그러나 하드디스크를 가지않은 전용단말기와 같은 기기의 경우 부팅시 이더넷 카드에 IP를 부여해줄수가 없을것이다. 그렇다고 메모리에 IP를 넣어 버리는 방법도 이동성이 크게 떨어지기 때문에 그리 적당하지 않다. 이럴경우 RARP 를 이용 주변의 네트웍환경을 파악하여 자신의 네트워크 주소에 IP주소를 자동적으로 할당할수 있다. 

=== Encapsulation ===
user application에서 만들어진 유저 데이타는 각각의 계층(TCP/IP 4)을 거치면서 각 계층에 필요한 정보를 유저 데이타에 덧붙이게 된다. 이러한 과정이 내용물을 캡슐에 담는것과 비슷하다고 해서, Encapsulation 이라고 불리우게 된다. 
{{{#!plain
AH     : Application Header
TCPH   : TCP Header
IPH    : IP  Header
EtherH : Ethernet Header
EtherT : Ethernet Trailer
                               +-----------+
                               | user data |
                               +-----------+
                              ↓          ↓ 
                        +------+-----------+            +-------------+
                        |  AH  | user data |            | application |
                        +------+-----------+            +-------------+
                       ↓                 ↓                  ↓
                 +------+------------------+            +-------------+
                 | TCPH | application data |            | TCP         |
                 +------+------------------+            +-------------+
                ↓                        ↓                  ↓
          +------+------+------------------+            +-------------+
          | IPH  | TCPH | application data |            | IP          |
          +------+------+------------------+            +-------------+
         ↓                               ↓                  ↓
 +--------+------+------+------------------+--------+   +-------------+
 | EtherH | IPH  | TCPH | application data | EtherT |   | Ethernet    | 
 +--------+------+------+------------------+--------+   +-------------+
}}}
위의 그림에서 처럼 최초 user data 가 만들어지면 user data 를 원하는 호스트까지 보내기 위해서 각 계층을 거치면서 필요한 정보를 데이타의 앞에 붙이게 된다. 그리고 마지막으로 Thernet Trailer 를 데이타의 뒤에 붙여줌으로써 데이타를 완전히 캡술화 하게 된다. 각 헤더에는 각 계층간 통신을 위해서 필요로하는 데이타들이 들어가게 된다.

LAN 과 인터넷 상에서의 패킷은 위와 같은 구조로 캡슐화 되어서 이동하게 된다.

=== Demultiplexing ===
인터넷 통신의 최종목적은 user data 를 전달하기 위한것이며, 여기에 TCP/IP 를 각계층별로 나누어서 데이타를 캡슐화 하는 등의 온갖 부산을 떠는것은 user data가 원하는 곳으로 전송되도록 하기위한 부가적인 작업들이다. 그러므로 일단 각종 프로토콜 헤더로 캡슐화된 데이타가 도착을 하게되면, 데이타를 받은 호스트에서는 user data 를 추출해 내는 일을 하게 되는데, 이를 Demultiplexing 라고 한다. 

캡슐화된 데이타그램이 호스트에 도착하게 되면, 각 계층은 자신의 계층에서 처리해야될 헤더를 분석해서 상위 계층으로 넘기게 되며, 이때 자신이 처리했던 헤더를 데이타 그램에서 제거하게 된다. 이런식으로 
최종적으로는 모든 헤더와 trailer 이 제거된 user data 가 전달되게 된다. 

즉 최초 데이타 그램이 Ethernet 에 도착하게 되면, 이더넷은 Ethernet header 와 Ethernet trailer 를 떼어내고 IP 계층(Network 계층) 으로 보내게 된다. 그럼 IP 계층에서는 IP header 를 떼어내고 다시 TCP 계층으로 보내게 되고, TCP 계층은 여기에서 다시 TCP header 를 떼어낸 다음 상위 계층인 어플리케이션 으로 보내게 되고, 어플리케이션에서는 다시 어플리케이션 헤더를 떼어내고, user data 를 받아보게 된다.

=== port ===
위와 같이 Demultiplexing 를 통해서 인터넷 데이타 그램은 application 까지 도착된다. 그런데 이러한 어플리케이션의 종류는 매우 다양하게 존재한다. ftp, mail, telnet, ssh, web 이처럼 다양한종류의 데이타가 하나의 서버에 도착하게 된다. 그렇다면 해당 어플리케이션은 이러한 다양한 데이타중에서 자신에게 도착하는 데이타라는걸 어떤 방식으로 구분할수 있을까 ?

이러한 문제를 해결하기 위해서 운영체제는 port 번호라는 것을 이용한다.  즉 각각의 서비스에 대해서 port 번호를 할당하여서, 특정 서비스는 특정 port 를 통해서만 통신 가능하도록 하는 것이다. 이를테면 금융서비스는 은행창구 에서, 민원 서비스는 동사무소에서, 볍률서비스는 법원에서 와 같은 원리이다. 

이러한 port 번호는 16 비트 크기의 정수로 주어지며, 자주 사용되는 표준 인터넷 서비스에 대해서는 그 번호가 미리 할당(약속)되어져 있다. 즉 ftp는 21번, ssh 는 22, telnet 는 23, smtp(mail)은 25, http 는 80 으로 약속되어져 있다. /etc/services 에 보면 이러한 약속되어진 port 번호와 해당 port 번호에 할당된 서비스에 대해 알아볼수 있다. 보통 1 - 1023 까지는 미리 할당된 서비스를 위한 port 번호이며, 그 이상은 어플리케이션 서비스를 위해 할당되거나, 혹은 그때그때 임시로 할당되는 포트번호들이다. 이건 어띠까지나 약속으로 강제로 규정된것이 아니므로 여러가지 사정에 의해서 다른 포트번호를 사용할수도 있다. 

http 를 위한 포트를 80 대신 8080 으로 사용하는게 그 예이다. 하지만 열린 인터넷 상에서 서비스를 하기 원한다면 약속된 port 를 사용하는게 좋을것이다.

[wiki:Site/Network_Programing/Documents/Poll 다중연결서버 만들기] 의 zipcode_poll.c 예제를 이용해서 실제 어떤 방식으로 포트가 할당되어지는지 알아보도록 하겠다. 우선 zipcode_poll 을 다음과 같이 실행하도록 하자. 
{{{#!plain
[root@localhost source]# ./zipcode_poll 5002
}}}
이제 Unix 의 netstate 도구를 이용해서 현재 네트웍 상황을 알아보도록 하자.
{{{#!plain
[root@localhost source]# netstate -na
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:5002            0.0.0.0:*               LISTEN      
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      
}}}

5002번 port 가 Listen(:12) 즉 연결대기 상태에 놓여있음을 알수 있다. 그다음 telnet 를 이용해서 5002 번 포트로 연결하고 
{{{#!plain
[root@localhost source]# telnet 127.0.0.1 5002 
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.

}}}
netstat 를 이용해서 네트웍 상태가 어떻게 변했는지 알아보도록 하자.
{{{#!plain
[root@localhost root]# netstat -na
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:5002            0.0.0.0:*               LISTEN      
tcp        0      0 127.0.0.1:5002          127.0.0.1:38214         ESTABLISHED 
}}}
127.0.0.1 의 38214 포트를 통해서 5002 포트로 접근했음을 알수 있다. 

다시 telnet 를 이용해서 5002 번포트로 연결을 하나 더만든 후 네트웍 상황을 보면
{{{#!plain
[root@localhost root]# netstat -na
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:5002            0.0.0.0:*               LISTEN      
tcp        0      0 127.0.0.1:5002          127.0.0.1:38214         ESTABLISHED 
tcp        0      0 127.0.0.1:5002          127.0.0.1:38215         ESTABLISHED 
}}}
이번엔 새로운 연결을 위해서 38215 번 포트를 이용하고 있음을 알수 있다. 
(이러한 클라이언트측의 포트넘버는 OS에 의해서 자동적으로 부여된다.) 
이렇듯 port 넘버를 이용해서 특정서버와의 독립적인 통신선로를 유지할수 있게 
된다. 
{{{#!plain
+-----------------+             +-----------------+    application
| Server Host     |             | Client Host     | 
| +-------------+ |             | +-------------+ |
| | telnet      |-----------------| 38214 telnet|----- telnet
| | 23          |---------+     | +-------------+ |
| +-------------+ |       |     | +-------------+ |
| +-------------+ |       +-------| 38215 telnet|----- telnet 
| | http   (23) |-------+       | +-------------+ | 
| +-------------+ |     |       | +-------------+ |
+-----------------+     +---------| 38217 http  |----- Mozilla 
                                | +-------------+ |
                                +-----------------+
}}}
서버 호스트에서는 지정된 포트번호로 써비스를 하고, 클라이언트 호스트에서는 os 에서 할당한 임의의 포트번호를 이용해서 독립적인 통신을 함을 알수 있다.  
