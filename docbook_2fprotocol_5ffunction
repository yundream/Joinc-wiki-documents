[wiki:article_protocol_function html 변환문서]

{{{#!plain
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<article lang="ko">

<!--           -->
<!-- 문서 정보 -->
<!--           -->
<articleinfo>
    <title>함수포인터를 이용한 손쉬운 프로토콜 처리</title>

    <author>
        <surname>윤상배</surname>

        <affiliation>
            <address>
                <email>yundream@join.co.kr</email>
            </address>
        </affiliation>
    </author>
    <revhistory>
        <revision>
            <revnumber>0.8</revnumber>
            <date>2004년 12월 14일 20시</date>
            <revremark>최초 문서작성</revremark>
        </revision>
    </revhistory>
</articleinfo>
<section>
	<title>소개</title>
	<para>
		이번 문서는 프로그래밍을 위한 간단한 팁정도로 생각하면 될 것같다. 
		네트워크 프로그램을 작성하다 보면 프로토콜에 따라서 클라이언트의 
		메시지를 받아서 적당한 처리를 해주는 프로그램을 작성하는 경우가 있는데, 		
		좀더 이해하기 쉬운 코드를 작성하는 방법에 대해서 알아보도록 하겠다. 
	</para>
</section>
<section>
	<title>프로토콜 처리 프로그램의 문제점</title>
	<para>
		소개에서 언급했다시피 주어진 메시지에 따라서 그에 따른 적당한 처리를 
		해야 하는 프로그램의 경우 다수의 중첩된 if else문 혹은 case문의 사용으로
		코드 자체가 복잡해지는 경우를 흔히 볼수 있다. 아래와 같은 경우가 
		대표적인 예이다.
		<screen>
클라이언트의 프로토콜 메시지를 분석한다.
if (로그인 요청 이라면)
{
  DB에 연결해서 이런 저런 작업..  
}
else if (사용자 정보 요청이라면)
{
  로그인 되었는지 여부 확인후 DB에 연결해서..
}
else if (사용자 정보 변경요청)
{
  ...
}
else if (...)
{
  ...
}
....
		</screen>
		보기에도 힘들고, 복잡하고 뭔가 일관성이 없어 보인다. 	
	</para>
	<section>
		<title>함수 포인터를 이용한 간결한 코드 생성</title>
		<para>
			아이디어는 간단하다. 어떤 문자열을 키로하는 배열을 만들고, 
			값으로는 해당 문자열을 처리하기 위한 함수의 포인터를 등록시키도록 
			하는 것이다. 예를 들자면 "Helo"라는 (프로토콜)문자열이 들어왔다면 FuncHelo 
			함수를 호출하라 하는 식이다. 
		</para>
		<para>
			그러기 위해서는 최초에 프로토콜 문자열 이름과 관련된 함수포인터를 
			등록하는 루틴과, 나중에 문자열로 검색해서 함수포인터를 돌려주는 
			루틴이 필요할 것이다. 
			필자의 경우 이러한 간단한? 자료구조와 여기에 적용시킬 검색 알고리즘
			을 만드는걸 극도로 싫어하는 관계로 STL의 맵을 사용해서 
			해결하도록 했다.
		</para>
		<para>
			파일을 다운로드 받는 간단한 프로그램을 작성하는 경우를 생각해 보자.
			이경우에 최소한 "login", "list", "down", "quit" 의 프로토콜이 필요
			할 것이다.
			<screen>
typedef map&lt;string, void *(*)(void *, class FuncArg *)> ProcessingMap; 
int ProtocolFuncRegist()
{
  // 함수포인터를 등록한다.
  ProcessingMap["login"] = ProcessLogin;
  ProcessingMap["list"] = ProcessList;
  ProcessingMap["down"]	= ProcessDown;
}

void *ProcessLogin(void *data, class FuncArg *aFuncArg)
{
  // 아이디를 이용해서 유효한 유저인지를 검사한다.	
}

void *ProcessList(void *data, class FuncArg *aFuncArg)
{
  // 파일의 리스트를 보여준다.
}

void *ProcessDown(void *data, class FuncArg *aFuncArg)
{
  // 파일을 전송한다. 
}

void *ProcessQuit(void *data, class FuncArg *aFuncArg)
{
  // 종료한다.
}
			</screen>
			함수 포인터의 경우 인자를 두개를 두고 있다. 첫번째 인자는 전달되는
			문자열이고, 두번째 인자는 확장을 위한 클래스다. 
			예를들어 데이터베이스나 파일을 열었을경우 데이터 베이스 포인터나 
			파일 포인터를 전달하기 위한 목적으로 사용할 수 있을 것이다.
			혹은 해당 클라이언트의 상태, 로그인을 끝마친 유저인지, 권한이 있는
			유저인지등에 대한 부가적인 정보를 넘기기 위해서 사용할 수 
			있을 것이다. 클래스를 어떻게 구성할건지는 프로그램의 특성에 
			따라서 달라질 것이다. 
		</para>
	</section>
</section>
<section>
	<title>적용 : 파일 전송 프로그램 만들기</title>
	<para>
		만들고자 하는 프로그램은 파일을 전송하는 간단한 프로그램이다. 
		로그인과정을 거치면, 파일리스트를 확인하고 원하는 파일을 다운로드 받는다.
	</para>
	<para>
		그러나!! 이러한 모든 코드를 실제로 구현하지 않을 것이다. 어디까지나 
		함수포인터를 사용해서 어떻게 심플하게 코드를 만들 수 있는지에 대해서만 
		다루도록 한다. 즉 실제 파일을 다운로드 받고, 리스트를 던져주는 
		실제 코드는 만들지 않도록 할것이다. 그냥 메시지만 뿌려주는 껍데기 
		코드로 대체하도록 하겠다.
	</para>
	<section>
		<title>통신 프로토콜</title>
		<para>
			초단순 프로토콜로 할 생각이다. 프로토콜은 다음과 다음과 같은 헤더+데이터 
			구조를 가지게 할 것이다.
			<screen>
struct ProtocolHeader
{
	int size;      // 데이터 사이즈 sizeof(int) + sizeof(int) + size(data) 
	char data[];   // 실제 데이터
	void H2N()
	{
		size = htonl(size);
		status = htonl(status);
	}
	void N2H()
	{
		size = ntohl(size);
		status = ntohl(status);
	}
}

  |<-------- Size ---------->|
  +----+----------------
  |SIZE| DATA ....
  +----+----------------
			</screen>	
		</para>
	</section>
	<section>
		<title>서버 프로그램 작성</title>
		<para>
			서버 프로그램은 RealTimeSignal을 이용해서 다중의 클라이언트를 처리하도록 
			작성될 것이며, 쓰레드 풀을 구성하도록 할것이다. 
		</para>
		<para>
			일단 함수포인터를 맵에 등록시키는 것 외에는 일반적인 네트워크 프로그램과 
			동일하다. 이외에 추가시켜야할게 있다면 클라이언트의 연결정보와 쓰레드풀 
			관리를 위한 자료구조정도가 될 것이다. 해당 클라이언트가 연결을 했는지, 
			연결을 했다면 로그인을 마친 상태인지 등의 정보를 유지할 필요가 있기 때문이다.
			쓰레드 풀 자료구조는, 쓰레드 풀에 등록되어 있는 쓰레드가 현재 몇개의 클라이언트를
			처리하는지의 자료를 유지해서 가장 적은 클라이언트를 처리하는 쓰레드에게 
			새로 등록된(accept)클라이언트를 할당하기 위한 목적으로 사용될 것이다. 
		</para>
		<para>
			RTS와 쓰레드풀, 함수포인터에 대한 몇개의 소개된 글을 봤다면 소스에 대한 이해는
			주석만으로 충분할 것이다. 
			제시되는 코드는 기본적인 기능만을 수행하는데 중점을 두고 만들었기 때문에, 
			버그및 비효율의 문제가 있을 수 있다. 또한 커널 2.4.x를 기준으로 작성되었기 때문에
			커널 2.6.x 에서는 분명히 제대로 작동하지 않을 것이다. 2.6.x에서 작동하게 하려면 
			약간의 수정이 필요할 것이다.
		</para>
		<para>
			<screen>
#ifndef __USE_GNU
#define __USE_GNU
#endif

#include &lt;signal.h>
#include &lt;fcntl.h>

#include &lt;sys/socket.h>
#include &lt;sys/stat.h>
#include &lt;sys/types.h>

#include &lt;netinet/in.h>
#include &lt;arpa/inet.h>

#include &lt;iostream>

#include &lt;map>
#include &lt;vector>

#include &lt;unistd.h>
#define MAXDATALENTH	512


using namespace std;

int gpid;

// 클라이언트 데이터 정보 구조체
struct clidata
{
  int sockfd;			// 처리할 소켓 번호
  int signum;			// 처리할 RTS번호이자 처리할 쓰레드의 ID
  char cbuf[512];		// 처리해야할 데이터	

  // 아래로는 쓰이지 않는다.
  // 프로그램이 해야하는 일에 따라서 다양한 변수를 선언해서
  // 사용할 수 있을 것이다.
  int status;
  int uid;
  char regdate[36];
  char serviceinfo[256];
  char ip[36];
  char port[8];
};

map&lt;int, struct clidata> ClientList;    // 처리할 클라이언트 데이타 정보 
map&lt;int, struct clidata>::iterator CLi;

// 함수포인터 호출시 넘겨줄 데이터 클래스
// 역시 프로그램이 하는일에 따라서 다양하게 선언할 수 있을 것이다. 
class FuncArg
{
	private:
		int status;
	public:
};


typedef struct _fd_sig
{
	int signum;
	int pid;
	int uid;
} FdPerSignum;

pthread_mutex_t MutexLock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  SyncCond  = PTHREAD_COND_INITIALIZER;

// 쓰레드 풀관리를 위한 map 자료구조
multimap&lt;int, FdPerSignum> PollMap;
multimap&lt;int, FdPerSignum>::iterator PollMapi;

// 프로토콜에 대해서 호출될 함수포인터를 포함할 map 
typedef map&lt;string, void *(*)(void *, class FuncArg *)> __ProcessingMap;
__ProcessingMap ProcessingMap;
__ProcessingMap::iterator ProcessingFunci;

// login 문자열을 만났을 때 호출될 함수
void *ProcessLogin(void *data, class FuncArg *aFuncArg)
{
  struct clidata lclidata;
  lclidata = *(struct clidata *)data;
  printf("Read socket(%d) : LoginProcess : %s\n", lclidata.sockfd, 
    lclidata.cbuf);
}

// list 문자열을 만났을 때 호출될 함수
void *ProcessList(void *data, class FuncArg *aFuncArg)
{
  struct clidata lclidata;
  lclidata = *(struct clidata *)data;
  printf("Read socket(%d) : ListProcess : %s\n", lclidata.sockfd,
     lclidata.cbuf);
}

// down 문자열을 만났을 때 호출될 함수
void *ProcessDown(void *data, class FuncArg *aFuncArg)
{
  struct clidata lclidata;
  lclidata = *(struct clidata *)data;
  printf("Read socket(%d) : DownProcess : %s\n", lclidata.sockfd,
    lclidata.cbuf);
}

// quit 문자열을 만났을 때 호출될 함수
// 소켓을 종료한다. 
void *ProcessQuit(void *data, class FuncArg *aFuncArg)
{
  struct clidata lclidata;
  lclidata = *(struct clidata *)data;
  printf("Read socket(%d) : QuitProcess : %s\n", lclidata.sockfd,
    lclidata.cbuf);
  close(lclidata.sockfd);
}

// 주어진 파일지정자에 대해서 리얼타임 시그널에 대응되도록 설정한다.
int setup_sigio(int fd, int sig_num, int pid)
{
  if(fcntl(fd, F_SETFL, O_RDWR|O_NONBLOCK|O_ASYNC) &lt; 0)
  {
    printf("setup nonblocking error:%d\n", fd);
  }

  if(fcntl(fd, F_SETSIG, SIGRTMIN+sig_num) &lt; 0)
  {
    printf("Couldn't set signal %d on %d\n", SIGRTMIN, fd);
    return -1;
  }

  if(fcntl(fd, F_SETOWN, pid) &lt; 0)
  {
    printf("Couldn't set owner %d on %d\n", pid, fd);
    return -1;
  }
  return 0;
}

// 클라이언트로 부터 읽어들인 데이터를 처리할 쓰레드 함수
void * CliDataProcessing(void *rts_num)
{
  int signum = *((int *)rts_num);
  socklen_t socklen;
  char buf[MAXDATALENTH];
  class FuncArg FArg;

  struct sockaddr_in sockaddr;
  struct siginfo sinfo;

  FdPerSignum fdpersignum;

  int clientnum;
  int ret;
  int readlen;
  int datalen;

  sigset_t sigset;

  gpid = getpid();
  sigemptyset(&amp;sigset);
  sigaddset(&amp;sigset, SIGRTMIN+signum);
  sigprocmask(SIG_BLOCK, &amp;sigset, NULL);

  pthread_mutex_lock(&amp;MutexLock);
  usleep(500);
  pthread_cond_signal(&amp;SyncCond);
  pthread_mutex_unlock(&amp;MutexLock);

  sigemptyset(&amp;sigset);
  sigaddset(&amp;sigset, SIGRTMIN+signum);
  sigprocmask(SIG_BLOCK, &amp;sigset, NULL);
  while(1)
  {
    struct clidata lclidata;
    socklen = sizeof(sockaddr);

    // 쓰레드가 처리하기로 지정된 소켓에서 리얼타임 시그널이 발생하는걸 기다린다.
    ret = sigwaitinfo(&amp;sigset, &amp;sinfo);
    if (ret == (SIGRTMIN + signum))
    {
      // 받을 데이터 크기를 읽어들인다. 
      if ((readlen = read(sinfo.si_fd, (void *)&amp;datalen, sizeof(int))) &lt;= 0)
      {
    // 만약 데이터를 읽는 도중 에러가 발생했다면, 
    // 해당 소켓을 닫고
    // 쓰레드풀의 값을 재조정한다.
        PollMapi = PollMap.begin();
        while(PollMapi != PollMap.end())
        {
          if(PollMapi->second.signum == signum)
          {
            fdpersignum = PollMapi->second;
            if (PollMapi->first > 0)
              clientnum = PollMapi->first - 1;
            PollMap.erase(PollMapi);
            PollMap.insert(pair&lt;int, FdPerSignum>(clientnum, fdpersignum));
          }
          PollMapi++;
        }
        close(sinfo.si_fd);
      }
      else
      {
    // 클라이언트로 부터 데이터를 읽어들인다.  
        void *(*Func)(void *, class FuncArg *);
        int readn;
        memset(buf, 0x00, MAXDATALENTH);
        readn = read(sinfo.si_fd, buf, datalen+4);
        memset(lclidata.cbuf, 0x00, sizeof(lclidata.cbuf));
        memcpy(lclidata.cbuf, buf, datalen);

        if ((CLi = ClientList.find(sinfo.si_fd)) == ClientList.end())
        {
          lclidata.sockfd = sinfo.si_fd;
          lclidata.signum = signum;
          lclidata.status = 0;
            ClientList[sinfo.si_fd] = lclidata;
        }

        // 처리해야할 메시지에 대한 함수가 존재할 때
        // 해당 함수를 호출한다.
        ProcessingFunci = ProcessingMap.find(buf);
        if (ProcessingFunci != ProcessingMap.end())
        {
          cout &lt;&lt; "Search Function data " &lt;&lt; endl; 
          Func = ProcessingFunci->second;
          Func((void *)&amp;lclidata, &amp;FArg);
        }
        else
        {
          fprintf(stderr,"Unknown msg protocol : %s\n", buf);
        }
      }
    }
  }
}

void * socket_acceptor(void *argdata)
{
  int server_sockfd, cli_sockfd;
  int clientnum;
  FdPerSignum fdpersignum;
  socklen_t socklen;

  sigset_t sigset;
  struct sockaddr_in serveraddr, clientaddr;
  struct siginfo sinfo;

  int signum = *((int *)argdata);

  if((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
  {
    perror("socket error "); 
  }
  bzero(&amp;serveraddr, sizeof(serveraddr));
  serveraddr.sin_family = AF_INET;
  serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
  serveraddr.sin_port = htons(5555);

  if (bind (server_sockfd, (struct sockaddr *)&amp;serveraddr,
    sizeof(serveraddr)) == -1)
  {
    perror("bind error");
  }

  if(listen(server_sockfd, 5) == -1)
  {
    perror("listen error");
  }

  if(setup_sigio(server_sockfd, signum, getpid()) == -1)
  {
    fprintf(stderr, "sigio setting error\n");
  }

  gpid = getpid();
  sigemptyset(&amp;sigset);
  sigaddset(&amp;sigset, SIGRTMIN+signum);
  sigprocmask(SIG_BLOCK, &amp;sigset, NULL);

  pthread_mutex_lock(&amp;MutexLock);
  usleep(500);
  pthread_cond_signal(&amp;SyncCond);
  pthread_mutex_unlock(&amp;MutexLock);

  while(1)
  {
    int ret;
    printf("Wait I/O Event (%d)\n", signum);
    ret = sigwaitinfo(&amp;sigset, &amp;sinfo);
    printf("IO Event OK\n");
    if (ret == SIGRTMIN+signum)
    {
      printf("Accept \n");
      socklen = sizeof(clientaddr);
      cli_sockfd = accept(server_sockfd,
          (struct sockaddr *)&amp;clientaddr,
          &amp;socklen);

      if (cli_sockfd &lt; 0)
      {
        fprintf(stderr, "Accept error\n");
        continue;
      }
      PollMapi = PollMap.begin();
      fdpersignum = PollMapi->second;
      clientnum = PollMapi->first+1;
      setup_sigio(cli_sockfd, PollMapi->second.signum, PollMapi->second.pid);
    cout &lt;&lt; "할당 쓰레드 번호 " &lt;&lt; PollMapi->second.signum &lt;&lt; endl; 
      PollMap.erase(PollMapi);

      PollMap.insert(pair&lt;int, FdPerSignum>(clientnum, fdpersignum));
    }
    else
    {
      // 에러처리
      cout &lt;&lt; "Unknown Error : " &lt;&lt; ret &lt;&lt;endl;
    }
  }
}

// 각 프로토콜을 처리할 함수를 등록한다.
int ProtocolFuncRegist()
{
  ProcessingMap["login"] = ProcessLogin;    
  ProcessingMap["list"] = ProcessList;
  ProcessingMap["down"] = ProcessDown;
  ProcessingMap["quit"] = ProcessQuit;
}

int main(int argc, char **argv)
{

  FdPerSignum fdpersignum;
  int status;
  int loopi, loopj;
  sigset_t sigset;
  sigaddset(&amp;sigset, SIGRTMIN);

  int thread_num = 2;              // 쓰레드 풀의 크기
  vector&lt;void *(*)(void *)> thread_list;    // 쓰레드 리스트
    vector&lt;pthread_t> threadident(thread_num);  // 쓰레드 ID 저장

  // 생성될 쓰레드의 갯수만큼 리얼타임 시그널을 등록한다. 
  for(loopi = 0; loopi &lt; thread_num +1; loopi ++)
  {
    sigaddset(&amp;sigset, SIGRTMIN+(loopi+1));
  }

  // 등록된 리얼타임 시그널이 발생할경우 블럭되도록 설정한다.
  sigprocmask(SIG_BLOCK, &amp;sigset, NULL);
  // 각 프로토콜을 처리할 함수를 등록한다. 
  ProtocolFuncRegist();

  // 클라이언트의 연결을 기다리는 쓰레드를 등록한다. 
  thread_list.push_back(socket_acceptor);

  // 클라이언트의 데이터를 처리하는 쓰레드를 등록한다.
  for (loopi = 0; loopi &lt; thread_num; loopi++)
  {
    thread_list.push_back(CliDataProcessing);
  }

  for (loopi = 0, loopj =1; loopi &lt; thread_list.size(); loopi++, loopj++)
  {
    pthread_mutex_lock(&amp;MutexLock);
    pthread_create(&amp;threadident[loopi], NULL, 
                        thread_list[loopi],
                        (void *)&amp;loopj);

    pthread_cond_wait(&amp;SyncCond, &amp;MutexLock);

    fdpersignum.signum = loopj;
    fdpersignum.pid = gpid;
    cout &lt;&lt; "PID is " &lt;&lt; gpid &lt;&lt; endl;  
    if(loopi != 0)
      PollMap.insert(pair&lt;int, FdPerSignum>(0, fdpersignum));  

    pthread_mutex_unlock(&amp;MutexLock);
  }

  for(loopi = 0; loopi &lt; thread_list.size(); loopi ++)
  {
    pthread_join(threadident[loopi], (void **)&amp;status);
  }

  return 1;
}

			</screen>
		</para>
	</section>
	<section>
		<title>클라이언트 프로그램 작성</title>
		<para>
			클라이언트 프로그램은 매우 단순하다. 굳이 설명하지 않도록 하겠다.
			<screen>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;arpa/inet.h>
#include &lt;stdio.h>
#include &lt;unistd.h>
#include &lt;stdlib.h>
#include &lt;string.h>

struct commdata
{
  int size;
  char data[256];
};

#define chop(x) x[strlen(x)-1] = '\0';

int main(int argc, char **argv)
{
  commdata senddata; 
  struct sockaddr_in serveraddr;
  int server_sockfd;
  int clilen;
  char readbuf[256];  

  if ((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
  {
    perror("error :");
    exit(0);
  }

  serveraddr.sin_family = AF_INET;
  serveraddr.sin_addr.s_addr = inet_addr(argv[1]);
  serveraddr.sin_port = htons(atoi(argv[2]));

  clilen = sizeof(serveraddr);

  if (connect(server_sockfd, (struct sockaddr *)&amp;serveraddr, clilen) &lt; 0)
  {
    perror("connect error :");
    exit(0);
  }

  memset((void *)&amp;senddata, 0x00, sizeof(senddata));
  while(1)
  {
    printf ("Insert Data : ");
    fgets(readbuf, 255, stdin);
    chop(readbuf);
    sprintf(senddata.data, "%s", readbuf);
    senddata.size = strlen(senddata.data);
    printf("Send Data Size is %d\n", senddata.size + 4);
    write(server_sockfd, (void *)&amp;senddata, senddata.size + 4);
  }
}
			</screen>
		</para>
	</section>
</section>
</article>

}}}
