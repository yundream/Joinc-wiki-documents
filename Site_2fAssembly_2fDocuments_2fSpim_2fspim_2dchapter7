#title 2진수와 16진수 표현하기

[[TableOfContents]]

== 7장 2진수와 16진수 표현하기 ==
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_1.html

기수(base)로 16을 사용해서 정수를 자주 표현한다. 기수를 16으로 사용해서 정수를 표현하는것을 16진법이라고 한다. 정수를 16진수로 표현하는것은 정수를 0과 1의 바이너리로 표현하는 명명법과 유사하다.

바이너리와 16진수로 정수를 표현하고 전환하는 것은 간단하다. 십진수를 어떤 다른 임의의 진수로 전환하고 표현하는 것은 좀더 생각할 필요가 있다. 이 장에서 바이너리와 16진수 전환하는 것을 알고리듬을 배우는 것처럼 공부해 보자. 

주제

    * 왼쪽과 오른쪽으로 이동시키기 Left and right shifts.
    * 양수와 음수를 구분하지 않는 이진수 표현 Unsigned binary representation.
    * 친숙한 이진수 숫자들 Familiar binary integers.
    * 16진수 표현법 Hexadecimal representation.
    * 16진수 표현과 그에 해당하는 비트 패턴 호칭 Equivalence of hexadecimal representation and bit pattern names.
    * 16진수를 2진수로 전환하여 표현하기 Converting representations from hexadecimal to binary.
    * 10진수를 다른 진수로 전환하여 표현하기 Converting representations from decimal to any base.

질문: 1010<2>가 십진수로 무엇입니까?

=== 1010<2> = 10<10> ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_2.html
답:

1010 <2>= 1 × 2^3  + 0 × 2^2 + 1 × 2^1 + 0 × 2^0
     = 8 + 0 + 2 + 0
     = 10 <10>

1010<2> = 10<10>

위에 것을 명심할 필요가 있다. 여러분이 1010<2>=10<10>라는 것을 안다면 1001<2>이 9<10>라는 것을 금방 알 수 있을 것이다. 큰 이진수 숫자를 십진수로 전환할 때 표를 사용해 보자. 다음과 같이 표를 만들어 볼 수 있다.

attachment:table1.JPG

역주 : power of 2 2의 거듭제곱, decimal 십진수, include 포함관계


이진수를 표현한 0과 1의 비트를 꺼짐과 켜짐 같은 표현으로 생각 해보자. 0일때는 표에 있는 십진수 값을 포함하지 않고 1일때만 십진수 값을 포함하여 더해보자. 예를 들어 1010 1010은 위의 표에서 보듯이 1일 경우에는 2의 거듭제곱수인 십진수 값을 포함하여 계산하라는 의미이다.

질문: 1010 1010<2>는 10진수로 무었일까요?

=== 자주 쓰이는 바이너리 숫자 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_3.html
답 : 128 + 32 + 8 + 2 = 170<10>    

다음의 표는 자주 쓰이는 양수를 8비트 바이너리와 10진수로 표현한 것을 보여준다. 앞으로 이러한 숫자와 패턴을 자주 접할 것이다. 현재로서는 양수만 표현하였다. 음수 표현법은 나중에 보기로 한다.

attachment:binary.JPG

유용한 패턴을 찾아볼 수 있는지 유심히 표를 관찰해 보자.

질문:

중요한 숫자가 표에서 빠져 있습니다. 0111 1111<2>를 10진수로 무었입니까?

=== 자주쓰이는 비트패턴 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_4.html
답: 0111 1111은 1000 0000 보다 하나가 적다. 1000 0000은 10진수로 128이다 그러므로 0111 1111이 10진수로 127이다.

0011 1111 같은 2진수 숫자는 오른쪽으로는 전부다 1로 그리고 왼쪽으로는 0으로만 표현 되었다. 0011 1111을 10진수로 전환하기 위해서 먼저 가장 왼쪽에 있는 1의 왼쪽에 있는 0을 1로 전환 시켜보자 그리고 나머지1은 0으로 바꿔보자. 그 숫자에 해당하는 10진수를 계산하고 그 수에 1을 빼보자.

예를들어 0011 1111을 위의 공식에 따라하면 0100 0000 -1 이다. 0100 0000에 해당하는 10진수는 64이고 64-1=63이다.

다음의 표는 10진수 양수를 비트 패턴으로 열거한 것이다. 재미있는 패턴을 찾아볼 수 있는지 관찰해 보자.

||Binary||Decimal||Notes||
||0000 0001||1|| ||         
||0000 0010||2||1 × 2||
||0000 0100||4||2 × 2||
||0000 1000||8||4 × 2||
||0000 0011||3|| ||
||0000 0110||6||3 × 2||
||0000 1100||12||6 × 2||
||0001 1000||24||12 × 2||
||0000 0111||7|| ||
||0000 1110||14||7 × 2||
||0001 1100||28||14 × 2||
||0011 1000||56||28 × 2||

질문:
0011 0010은 10진수로 50 입니다. 십진수 100은 2진수 비트패턴으로 어떻게 표현 할까요?

=== 왼쪽으로 이동시키기 left shift ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_5.html

답: 0011 0010=50<10> 그러므로 0110 0100= 100 <10>

유용한 사실: 만약 N 이라는 숫자를 비트패턴 X로 표현할 수 있다면 X0는 2N 이다.
0011 0010 비트패턴은 50<10> 이다 그러므로 0 0110 0100 은 100<10>이다. 보통 보여주는 비트 패턴의 갯수는 똑같이하고 이동된 형태로 비트패턴을 다음과 같이 보여준다.  0110 0100 = 100<10> 

이와 같은 것을 1비트 만큼 왼편으로 이동했다 또는 1 비트 레프트 쉬프트(left shit)라고 한다. 하드웨어에서 2를 곱셈할때 사용된다. 비트 패턴의 갯수를 유지하면서 레프트 쉬프트를 할때 왼쪽에 "1"로 표현된 비트가 소실되지 않도록 조심해야 한다. 

질문: 8비트로 2^8가지의 패턴이 가능하다. 2 진수 8 비트로 표현할 수 있는 가장 큰 양의 정수는 무었입니까?

===  N개의 비트에서 가능한 최대의 양수 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_6.html

답:
2^8 - 1  =  256 - 1  =  255.  256개의 패턴중에 0000 0000가 0으로 사용된다.

우리가 지금 공부하는 패턴 방식은 음수표현을 고려하지 않고 양수만 표현하고 있다. 이렇게 음수에 관계없이 비트를 표시한 이진수를 영어로 언사인드 바이너리(unsigned binary) 숫자라고 표현한다. 사람들이 일반적으로 바이너리 숫자를 지칭할때는 보통 언사인드 바이너리 숫자를 지칭한다. 언사인드 바이너리 숫자의 몇가지 특징을 열거해 보자.

1. N비트로 0,1,2,...,2^N-1의 양수를 표현할 수 있다. 예를들어 8 비트의 경우 0,1,...,2^8-1로 0....255까지의 표현이 가능하다.


2. N비트로, 0은 0....0....0(모두 0) 으로 표현된다.

3. (2^N-1)은 1...1....1(모두 1)로 표현된다.

이러한 표현법이 언사인드 바이너리에만 적용된다는 것을 명심하자. 패턴이 표현한 수가 무었인지 단정하기 전에 반드시 숫자가 언사인드 바이너리인지 확인하자.

질문: 특별하게 계산하지 않고 다음 10진수 숫자들 중에 이진수 1111 1111 1111에 해당하는 수는 무었입니까?

    * 2048
    * 4095
    * 16384
    * 18432

힌트 특성 3번을 다시 한번 생각해 보십시요.
=== 16진수 표현법 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_7.html

답:4095

여러분은 아마도 표현된 수가 2^N-1이고 홀수라는 것을 아셨을 겁니다. (2^N 이란 2x2x....x2 그러므로 짝수 입니다. 2^N-1은 홀수 입니다)
문제에서 홀수는 4095 뿐이죠.

자릿수 표현법을 다시한번 생각해 보자.
   
   1. 기수 B는 대개 양의 정수이다.
   2.  0부터 B-1까지를 표현하는 B개의 "숫자들"이 있습니다.
   3. 자릿수는 B의 거듭제곱수로 표현되고 0부터 시작해서 오른쪽에서 왼쪽으로 증가한다.
   4. 자릿수 옆에 표현된 숫자는 B의 거듭제곱수가 표현된 숫자 만큼 그 자리에 포함된 것을 보여준다.

1번 규칙에 따르면 어떤 양의 정수도 기수로 사용될 수 있다. 16을 기수로 사용해 보자. 
2번 규칙에 따르면 숫자를 표현하는 16가지의 심볼(symbol)이 필요하다. 다음 16가지의 심볼을 사용하자.

||0||1||2||3||4||5||6||7||8||9||A||B||C||D||E||F||
||영||일||이||삼||사||오||육||칠||팔||구||십||십일||십이||십삼||십사||십오||

16진수 표현법에서 10개의 0,1,2,3,4,5,6,7,8,9 아라비아 숫자와 나머지 6개의 숫자로 알파벳 문자를 16진수로 사용한다.

기수를 16을 사용하여 표현하는 것을 16진수 표현법 영어로 헥사데시멀(hexadecimal) 표현법 또는 줄여서 헥스(hex)라고 한다.

질문: 다음의 빈칸을 위의 16진수 표현법으로 채워보자.

Fill in the blanks with BASE SIXTEEN digits

31A <16>  = [         ]× 16^2 +[       ] × 16^1 +  [       ]× 16^0

=== 16진수를 10진수로 전환하기 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_8.html

답:
31A <16>   =  3 × 16^2 + 1 × 16^1 + A × 16^0

16진수를 10진수로 전환하기 위해서는 각 심볼숫자에 해당하는 자릿수 즉 16진수의 거듭제곱수에 16진수 심볼숫자를 곱하여 10진수로 전환한 후 연산을 하면된다.

31A <16> = 3 × 16^2 + 1 × 16^1 + A × 16^0

                   = 3 × 16^2 + 1 × 16^1 +  10 × 16^0

                   = 3 × 256 + 1 × 16 +  10 × 1  =  794<10>

이러한 전환을 하기 위해서 16진수의 거듭제곱수를 따로 암기할 필요는 없다. 2진수의 거듭제곱수 값만 알고 있으면 이러한 연산을 쉽게 할 수 있다.

예를들어 16^2   =   2^4 ×2^4   =   2^8   =   256.

또다른 예  16^3   =   2^4 ×2^4 ×2^4   =   2^12   =   2^2 ×2^10   =   4K

질문: 1B2<16>를 전환해 보자.

1B2 = [ ] × 십육^2 + [ ] × 십육^1 + [ ] × 십육^0

1B2 = [ ]<10> × 16^2 + [ ]<10> × 16^1 +  [ ]<10> × 16^0

1B2 = [ ]<10> × [ ]<10> + [ ]<10> × [ ]<10> +  [ ]<10> × [ ]<10>

1B2 = [ ]<10>

=== 한자릿수 이동 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_9.html

답:

1B2 =  1 × 16^2 + B × 16^1 +  2 × 16^0

1B2 =  1<10> × 16^2 + 11<10> × 16^1 + 2<10> × 16^0

1B2 =  1<10> × 256<10> + 11<10> × 16<10> + 2<10> ×1<10>

1B2 =  256<10> + 176<10> + 2<10>

1B2 =  434<10> 

여러분은 10진수에서 10을 곱하는 법을 알것이다. 끝에 0을 붙이면 된다. 83 x 10= 830 이다. 이것을 풀어서 설명하면

83       =     8 × 10^1 + 3 × 10^0

83  × 10 =  (  8 × 10^1 + 3 × 10^0 ) × 10

         =     8 × 10^2 + 3 × 10^1

         =     830

이러한 계산논리는 다른 기수(base)에도 적용된다. 만일 기수를 B로 가정할때 XYZ로 표현된 어떤 숫자를 생각 해보자. XYZ0는 XYZ에 B를 곱한것이다.

질문: 16 곱하기 8B3는 무었입니까?

=== 16진수에서 한자릿수 이동 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_10.html

답: 8B30

16진수에서 정수에 16을 곱하는 것은 16진수 끝에 0을 붙이는 것과 같습니다. 16진수 정수에서 16^N을 곱하는 것은 오른쪽에 N개의 0을 붙이는 것과 같습니다.


8B3 <16> × 16^3 = 8B3000 <16>    

16진수에서 16으로 정수를 나누는것은 가장 오른쪽에 있는 숫자를 제거하는 것입니다. 그 결과는 몫(quotient)입니다. 제거된 숫자는 나머지(remainder)입니다. 그래서 8B3<16> 나누기 16<10> =8B (그리고 나머지는 3입니다) 

질문:

A <16>   = [               ]<10>   =  [                   ]<2>

=== 16진수 10진수 2진수 표현법 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_11.html

답 : A <16>   =   10 <10>   =   1010 <2>

다음의 표는 0 부터 15 까지 정수를 16진수 10진수 2진수로 보여줍니다. 예를들어 0110<2> = 2^2 + 2^1   =   6<10>  =   6<16>  

attachment:table6.JPG

질문: 2진수 패턴 1010을 4 비트 패턴 명명법으로 부를때 비트 패턴의 명칭은 무었입니까? 

=== 16진수 표현법과 4 비트 패턴 명명법 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_12.html

답: A입니다. 4 비트 패턴 명명법의 1010 패턴을 A라고 명명합니다.

바이너리 패턴 1010의 명칭은 "A" 이다. 이진수 1010으로 표현된 숫자를 나타내는 16진수도 또한 "A"이다.
2진수 패턴이름과 16진수 숫자 "A"를 혼용 해서 사용해도 괜찮다.

하나의 4 비트 패턴은 하나의 2진수 숫자를 표현한다. 16진수에서 사용되는 숫자가 또한 비트 패턴의 이름으로 사용 되었다.

||16진수 숫자 Base Sixteen Digits:||비트 패턴 이름 When describing Bit Patterns:||2진수 숫자 Hex digits in Binary||
||0은 숫자 심볼이다. 숫자 0을 나타낸다. ||0은 0000 패턴의 이름이다. || 0 은 4비트 바이너리 표현으로 0000 이다. || 
||.||.||.||
||.||.||.||
||.||.||.||
||A는 숫자 심볼이다.숫자 10을 나타낸다. ||A는 1010 패턴의  이름이다. ||A는 4 비트 바이너리 표현으로 1010이다.||
||.||.||.||
||.||.||.||
||.||.||.||
||F는 숫자 심볼이다.숫자 15를 나타낸다.||F는 1111 패턴의 이름이다. || F는 4비트 바이너리 표현으로 1111이다.||

4 비트 패턴의 이름은 16진수 숫자 심볼과 같습니다. 16진수 숫자 심볼은 2진수 4비트 패턴으로 표현할 수 있습니다.이것은 우연이 아닙니다. 

질문: 1011<2>은 2진수로 정수를 표현한 것입니다. 이 숫자에 16을 곱하여서 2진수로 표현해 보십시요.

=== 16진수를 2 진수로 전환하기 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_13.html

답: 1011 0000 <2>  4개의 0를 붙이십시요. 2^4=16<10>

16진수를 2진수로 전환하는 것은 쉽다.
 
    * 2진수에서 왼쪽으로 4비트를 이동시키는것은 16을 곱하는 것과 같다.
    * 16진수에서 왼쪽으로 1비트를 이동시키는것은 16을 곱하는 것과 같다.

다음은 전환 과정을 자세히 설명하고 있다. 2진수와 16진수가 표현하는 정수를 주의깊게 보자.

1010 <2> = A<16>

각각의 숫자에 16을 곱합니다.

1010 0000 <2>  = A0<16>

이진수의 오른쪽에서 시작해서 비트를 4개씩 묶은것은 16의 거듭제곱수에 해당한다. 또한 4비트 그룹은 16진수 표현법의 숫자심볼로 바꾸어 쓸 수 있다. 16진수 C6D<16>을 2진수로 다시 써보자. 

C6D  =    C × 16^2 +    6 × 16^1   +    D × 16^0  

     =    C × (2^4)^2    +    6 × (2^4)^1      +    D × (2^4)^0  

     = 1100 × (2^4)^2    + 0110 × (2^4)^1      + 1101 × (2^4)^0   

     = 1100 ×  2^8      + 0110 ×  2^4        + 1101 × 1  

2진수에서 2를 곱하는 것은 오른쪽에 0을 붙이는 것이다.  다음과 같은 계산이 가능하다.

     = 1100 0000 0000  + 0110 0000         + 1101  

C6D<16>  = 1100 0110 1101<2>

16진수의 각 심볼숫자들은 4비트 바이너리 숫자로 전환되었다. 16진수 심볼숫자들의 각자릿수는 2^4의 거듭제곱수에 해당한다. 각자릿수는 4 비트씩 왼쪽으로 각기 이동한 것이다. 이와같이 각자리의 16진수 심볼숫자를 4 비트 바이너리 표현으로 전환했다. 이것은 16진수를 양수와음수 관계를 고려하지 않을때(unsigned) 2진수 표현으로 바꾼 것이다. 예를 들어보자.

   1    A    4    4    D      <16>

0001 1010 0100 0100 1101    <2>  

질문:  2진수 0001 1010 0100 0100 1101의 패턴 이름은 무었입니까?

=== 패턴이름과 숫자를 표현하기 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_14.html

답: 1A44D

만얀 비트 패턴이 표현하는 정수가 음수와 양수를 고려하지 않았을 경우(unsigned binary)에는 패턴의 이름은 16진수에서 사용하는 숫자 심볼과 동일하다.
 
attachment:NameRelations.gif

역주:  A number fifty: 숫자 50, Base sixteen representation 16진수 표현, name of the bit pattern 비트 패턴의 이름 , Base two representation of the number 2진수로 숫자를 표현한 것

16 진수를 2진수로 전환하는 것은 쉽다. 16이 2의 거듭제곱수이기 때문이다. 8진수(octal)로의 전환도 쉽게할 수 있다. 8이 2^3이기 때문이다. 8진수에서 사용하는 숫자심볼(digits)은 0,1,2,3,4,5,6,7이다. 이 숫자들을 바이너리로 표현하면 각각 000, 001, 010, 011, 100, 101, 110, 111 이다.

8진수의 각자리수는 2진수 비트 패턴 형태를 3 비트 왼쪽이동(left shift)한 위치에 해당한다.

주의할 점: Java나 C같은 컴퓨터 언어에서 0으로 시작하는 숫자는 8진수를 의미한다.  0644는 8진수이고 644는 10진수 0x644는 16진수를 의미한다.

질문: 4733<8>는 2진수로 무었입니까?

=== 전환해서 표현하기 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_15.html

답: 100 111 011 011<2>

조금만 주의를 기울인다면, 8진수를 16진수 표현으로 직접 전환할 수 있다. 하지만 2진수를 거쳐서 전환하는 것이 더쉽다.

8진수(octal)  <&#8212;&#8212;> 2진수(binary)  <&#8212;&#8212;> 16진수(hexadecimal)

비슷한 방식으로 B진수를 Y진수로 직접 전환할 수 있다. 하지만 10진수나 2진수를 거쳐서 전환하는 것이 더쉽다.

B진수  <&#8212;&#8212;> 10진수  <&#8212;&#8212;> Y진수

B진수  <&#8212;&#8212;> 2진수  <&#8212;&#8212;&#8212;> Y진수

질문: 16진수 0x1A4 8진수(octal)로 전환해 보십시요.

=== 10진수에서 B진수로 전환하기 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_16.html

답:
   
||16진수   || 2진수를 4개씩 묶은것 || 2진수 묶음없이 쓴것|| 2진수를 3개씩 묵은것  || 8진수||
||0x1A4  =||  0001 1010 0100 =||000110100100  = || 000 110 100 100   = || 0644<8>||

오른쪽에서 시작해서 비트를 묶음으로 만들었다는것을 유념하자. 만약에 왼쪽끝의 묶음이 1개 또는 2개의 비트들이 모자를때는 필요에따라 왼쪽에 0을 첨가하자.

숫자를 10진수에서 B진수로 전환하는 알고리듬(alogrithm) 의사코드(psuedo-code)
{{{#!textbox
place  = 0; //pace 자릿수

number = number to be converted; //전환 시킬 숫자

while (number > 0 )

{

  digit[place] = number mod B ; //전환 시킬 숫자를 진수 B로 모듈라(mod)값을 구해 자릿수 배열에 집어넣는다.

   number       = number div B ; //전환 시킬 숫자를 진수 B로 div(나누기)한다. 전환할 숫자는 div 결과 값이다.

   place        = place + 1 ; //자릿수를 증가 시킨다.

}

}}}
   
여러분은 이미 B진수를 10진수로 전환 시키는 방법을 알고 있다. 위에 알고리듬은 10진수를 B진수로 전환 시키는 방법을 보여주고 있다.
div라는 것은 정수를 나누기 한다는 의미이다. mod는 모듈러값(modulo)또는 나머지 값을 구한다는 의미이다.  number=number div B는 얼마 만큼의 기수 B가 number에 포함되어 있는지를 말해준다. number mod B는 나머지 값을 계산한다. 예를들어 15 div 6=2입니다 그리고 15 mod 6=3입니다.

예를 하나 들어보자: 10진수 54를 16진수로 변환하자. 기수(base)는 16이다. while loop안에서 첫번째 실행은 가장 오른쪽의 16진수 숫자를 계산해서 digit[0]에 결과 값을 저장한다. 

질문:

digit[0]=54 mod 16의 값은 무었입니까?
54 div 16의 값은 무었입니까?

=== 오른쪽에서부터 왼쪽으로 쓴  16진수 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_17.html

답: 
 54 = 16(기수) × 3(몫)+6(나머지):

digit[ 0 ] = 54 mod 16 = 6,
number = 54 div 16 = 3


숫자를 10진수에서 B진수로 전환하는 알고리듬(alogrithm) 의사코드(psuedo-code)
{{{#!textbox
place  = 0; //pace 자릿수

number = number to be converted; //전환 시킬 숫자

while (number > 0 )

{

  digit[place] = number mod B ; //전환 시킬 숫자를 진수 B로 모듈라(mod)값을 구해 자릿수 배열에 집어넣는다.

   number       = number div B ; //전환 시킬 숫자를 진수 B로 div(나누기)한다. 전환할 숫자는 div 결과 값이다.

   place        = place + 1 ; //자릿수를 증가 시킨다.

}

}}}

첫번째 loop는 가장 오른쪽에 있는 0의 자리의 숫자를 계산한다.

54<10> = 3 × 16^1 + 6 × 16^0  이와같이 6이 가장 오른쪽에 있는 숫자이다. 2번째 loop 실행에서는 3이 place가 가르키는 가장 오른쪽에 숫자이다.

다음 루프 실행에서는 number는 나눈 결과의 수이다. 3 mod 16=3 이고 3 div 16=0 이다. 3은 digit의 값이고 0이 number의 값이다.

number가 0이므로 loop는 종료되고 알고리듬의 수행은 종료된다. 결과값은 54<19>=0x36이다.

만약 여러분이 이러한 수학적 알고리듬들을 좋아한다면 귀납법(induction)을 사용하여 수학적으로 증명 할 수 도 있다. 보통 사람은 그냥 다른 예를 보는 것을 좋아한다.


질문: 247<10> to 16진수(hexadecimal)로 전환(conversion)해 보십시요


=== 다른 전환법 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_18.html

답:
number = 247
247 div 16 = 15 나머지 7    그래서  digit[ 0 ] = 7

number =  15
 15 div 16 =  0 나머지 15   그래서  digit[ 1 ] = F     
 ("15" 는 10진수이고,  "F"는 16진수 입니다)

결과: 247<10> = 0xF7

10진수 247을 16진수로 전환하기 위해서는 247을 16으로 반복해서 나누어준다. 나누어 주는 동안 16진수로 표현한 나머지 값을 수집한다. 위에 답에서 본 방식이다.
16진수를 10진수로 전환하여 결과값을 확인해 보자. 

0xF7=F x 16^1+7x16^0=15x16+7=240 + 7=247<10>

위에 설명한 알고리듬은 다음과 같다.
1. 기수(base)로 전환하려는 수를 나눈다.
2 나머지는(remainder) digit이다.
3. 몫(quotient)이 number가 된다.
4. 과정을 반복한다.

digits들의 각값들은 오른쪽부터 시작해서 과정마다 왼쪽으로 옴겨가며 계산된다.

질문: 1033<10>를 hex값으로 전환해 보자.

=== 10진수에서 5진수로 전환 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_19.html

답: 0x409

1033 div 16 = 64 나머지 9;  digit[0] = 9
64 div 16 =  4    나머지 0;  digit[1] = 0
4 div 16 =  0     나머지 4;  digit[2] = 4

전환 알고리듬은 10진수를 어느 진수로도 전환시킬 수 있다. 다음은 10진수 1033을 5진수로 전환시키는 과정이다.

{{{
    ___206___   나머지 3
5 | 1033

      
   ____41___  나머지 1
5 |  206

      
    _____8___  나머지 1
5 |   41

      
    _____1___  나머지 3
5 |    8

      
    _____0___  나머지 1
5 |    1   

}}}

그래서 1033<10> = 13113<5>  첫번째 계산한 것이 가장 오른쪽에 있는 숫자이다.
다음은 결과를 검산한 것이다.
 
13113<5>  = 1 × 5^4   + 3 × 5^3   + 1 × 5^2  + 1 × 5^1 + 3 × 5^0
        = 1 × 625 + 3 × 125 + 1 × 25  + 1 × 5   + 3
        = 625     + 375     + 25      + 5       + 3
        = 1033<10> 

질문: 100<10>을 3진수로 전환해보자.

=== 3진수를 7진수로 전환하기 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_20.html

답: 

알고리듬에따라 기수가 3이므로 number가 0 이 될 때까지 3으로 반복해서 나누어 줍니다. 


100<10> =

100 div 3 = 33   나머지 1; 
33   div 3 = 11   나머지 0;  
11   div 3 =  3    나머지 2;
3     div 3 =  1    나머지 0;  
1     div 3 =  0    나머지 1

답 100<10> = 10201<3>

검산을 해보면

10201<3> = 1 × 3^4 + 0 × 3^3 + 2 × 3^2  + 0 × 3^1 + 1 × 3^0
       = 1 × 81 + 0 × 27 + 2 × 9 + 0 × 3 + 1
       = 81 + 18 + 1 = 100

3진수를 7진수로 전환하기위해 10진수로 전환을 먼저하자. 


____3   &#8212;&#8212;&#8212;>    ____10   &#8212;&#8212;&#8212;>   ____7

질문: 

10201<3>는 7진수로 무었입니까?


=== 7장 끝 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_21.html

답:

100 div 7 = 14   나머지 2; 
14   div 7 =  2    나머지 0;  
2     div 7 =  0    나머지 2;

 10201<3> = 100<10> = 202<7>


핵심 주제들.

    * 친숙한 2진수 숫자 Familiar binary integers.
    * 2진수 패턴을 왼쪽으로 이동시키기 Shifting left a binary pattern.
    * 언사인드 2진수 표현법 Unsigned binary representation.
    * 16진수 표현법Hexadecimal representation.
    * 16진수를 왼쪽으로 이동시키기 Shifting left a hexadecimal pattern.
    * 16진수의 패턴 명명법 Equivalence of hexadecimal strings and bit pattern names
    * 16진수를 2진수로 전환시켜 표현하기 Converting representations, between base 16 and base 2.
    * 10진수를 다른 진수로 전환시켜 표현하기 Converting a decimal representation to any base.

[http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07quiz.html 퀴즈]를 꼭 풀어 봅시다.



