#title 리눅스 환경에서의 C 프로그래밍 - 12장 모듈과 라이브러리

=== Hello World 다시 보기 ===
hello world 프로그램을 다시 한번 보기로 하자.

{{{#!plain
#include <stdio.h>

int main(int argc, char **argv)
{
    printf("Hello World!!!\n");
    return 1;
}
}}}
위 프로그램을 자세히 뜯어보면, '''#include'''문이 보일 것이다. 이것이 어디에 쓰는 물건인지 자세히 알아보도록 할 것이다. 우리는 [wiki:Site/C/Documents/CprogramingForLinuxEnv/Ch7_Function 7장 함수편]에서 함수에 대해서 다루었다. 이를 통해서 우리는 함수를 사용하기 위해서는 '''함수선언'''과 '''함수원형'''이 필요하다는 것을 알게 되었다. 함수를 사용하는 이유는 중복되는 코드를 따로 묶어 둠으로써, 코드관리를 쉽게 하기 위함이라는 것도 역시 알고 있다. 하지만 '''편하겠지'''라고만 알고 있을 뿐, 실제 어떻게 편하게 사용되는지는 경험을 해보진 못했다.

자.. 우리는 함수라는 것을 알고 있다. 그렇다면 어떻게 해야 함수를 더 편하게 사용할 수 있을까. 답은 '''함수를 위한 코드를 따로 분리시킨다''' 이다. 위의 Hello World 프로그램은 이러한 전형적인 모습을 보여주고 있다. printf 함수는 거의 모든 프로그램에서 필수적으로 사용되는 함수다. 이런 코드를 사용자가 필요할때 마다 일일이 사용하는건 여간 귀찮은일이 아닐 것이다. 그렇다면 printf 함수를 별도의 코드로 만들어서, 모듈형태로 만들어 두면 될것이다. 그래서 printf 함수가 필요할 때, 가져다 쓰기만 하면 된다.

그런데, 컴파일러는 printf 함수가 어떤 모습을 가지는지 알 수가 없다. 그러니까 리턴값이 무엇이고, 인자로 무엇이 사용되는 지를 알 수가 없다는 얘기가 된다. 그러므로 컴파일러에게 printf 함수의 정보를 알려줄 수 있어야 한다. 그게 #include 문이 하는 일이다. stdio.h는 표준입출력과 관련된 함수의 정보가 들어있는 파일로 헤더파일이라고 부른다. 이 헤더파일에는 printf 함수가 선언되어 있다. stdio.h 헤더파일은 /usr/include 디렉토리 밑에 존재한다.

이제 우리는 stdio.h 만을 include 시킴으로써, 어느 코드에서든지 간단하게 printf 함수를 사용할 수 있게 된다.

=== 컴파일 과정 ===
이제 위의 hello world 프로그램이 어떻게 컴파일이 되는지 알아보도록 하자. 프로그램의 이름은 hello.c 이다.
   1. 컴파일러는 hello.c 프로그램을 읽어 들인다.
   1. hello.c 코드를 해석해서, 기계어 형태의 object 파일로 만든다. object 파일은 컴퓨터가 해석할 수 있는 단위 모듈이다.
   1. 여기에 printf 함수가 정의되어 있는 이미 만들어져 있는 object 파일과 hello object 파일을 서로 링크(연결)한다.
   1. 완전한 실행 파일이 만들어 진다.

=== 덧셈 함수를 가진 프로그램 ===
그럼 덧셈 함수를 가진 계산기 프로그램을 만들어서, 모듈별로 작성하고 이것들을 object 파일로 만들어서 link 시켜서 실행파일을 만드는 방법에 대해서 알아보도록 하겠다.

모듈별로 작성하지 않고, 하나의 파일로 이루어진 프로그램은 아래와 같이 작성할 수 있을 것이다.
{{{#!plain
#include <stdio.h>
int sum(int a, int b);
int main(int argc, char **argv)
{
    int value;
    value = sum(120, 199);
    printf("%d\n", value);
}
int sum(int a, int b)
{
    return a+b;
}
}}}
아주 간단하며 문제없이 작성될 것이다. 또한 덧셈을 위한 sum 이라는 함수를 만들었으니, 이후 덧셈계산이 필요할 때 마다, 그냥 sum 함수를 그대로 쓰기만 하면 될것이다. 그런데 이 프로그램은 통짜로 작성되어 있기 때문에, 다른 프로그램에서 sum 함수를 사용할려고 하면 copy & paste 할 수 밖에 없다. 이것은 비효율 적이다. 이제 sum 함수를 모듈형식으로 완전히 분리 시켜 보도록 하자. 이를 위해서는 다음과 같이 3개의 파일이 만들어져야 한다.
  1. sum 함수의 선언이 들어 있는 include 파일
  1. sum 함수를 사용할 main 함수가 있는 C 파일
  1. sum 함수가 정의되어 있는 C 파일

include 파일은 아주 간단하게 만들 수 있다. include 파일의 이름은 sum.h 로 하겠다.
{{{#!plain
int sum(int a, int b);
}}}

이제 sum 함수가 정의되어 있는 C 코드를 만들어보자. 역시 간단하다. 파일이름은 sum.c로 하겠다.
{{{#!plain
int sum(int a, int b)
{
    return a + b;
}
}}}

마지막으로 main 함수를 만들어 보자. 파일이름은 calc.c 로 하겠다.
{{{#!plain
#include "sum.h"
#include <stdio.h>

int main()
{
    int value;
    value = sum(130, 199);
    printf("%d\n", value);
}
}}}

include 는 

=== 헤더파일의 경로 ===
우리는 #include 키워드를 이용해서, 포함시킬 헤더파일을 지정할 수 있다. 이때 헤더파일의 완전한 경로를 포함시켜 줘야 한다. 만약 따움표를 사용했다면, 이는 현재 디렉토리에서 헤더파일을 찾겠다는 것을 의미한다. 그렇지 않고 '''<>''' 를 사용했다면, '''표준 Include 디렉토리'''와 컴파일러 옵션을 통해서 '''지정된 디렉토리'''에서 찾게된다. 유닉스(:12) 시스템의 경우 /usr/include 가 표준 Include 파일이 된다. 

헤더파일을 찾을 경로의 지정은 '''-I'''옵션을 이용하면 된다. 예를 들어 /home/yundream/include 에서 찾도록 하길 원한다면
{{{#!plain
# gcc -I/home/yundream/include -o sum sum.c
}}}
와 같이 하면 된다.

만약 /home/yundream/include 를 헤더파일 찾기 경로로 지정하고 싶다면, 다음과 같이 하면 된다.
{{{#!plain
#include "/home/yundream/include"
}}}


=== 모듈별 분할 컴파일 ===
자 이제 sum.h, sum,c, calc,c 3개의 파일이 만들어졌다. 이 3개의 파일을 컴파일해서 실행가능한 프로그램을 만들어보자.

위에서 언급되었듯이 가장 먼저 해야할일은 sum.c 와 calc.c 를 기계어가 해석가능한 object 코드로 만드는 일이다. 오브젝트 코드는 gcc에 -c 옵션을 이용해서 만들어낼 수 있다.
{{{#!plain
# gcc -c sum.c calc.c
}}}
이제 sum.o 와 calc.o 라는 파일이 만들어진걸 확인할 수 있을 것이다. 확장자 '''.o'''는 이 파일이 오브젝트 파일이라는 것을 알려준다. 이제 두개의 object 파일을 링크시켜서 실행파일을 만들면 된다. -o 옵션을 이용하면, 만들어진 오브젝트 파일들을 합쳐줄 수 있다.
{{{#!plain
# gcc -o calc sum.o calc.o
}}}
이제 실행파일인 '''calc'''가 만들어졌다.

이렇게 만들어진 object 파일은 '''기계어'''로 만들어져 있기 때문에, 이후에 사용할때는 sum.c를 다시 object 파일로 컴파일할 필요가 없다. 그냥 sum.o 프로그램에 링크시켜주기만 하면 된다. 다음과 같은 프로그램을 만들어보자. 프로그램의 이름은 mycal.c로 하자.
{{{#!plain
#include "sum.h"
#include <stdio.h>

int main(int argc, char **argv)
{
  int value;
  int a;
  int b;
  if (argc != 3)
  {
    printf("Usage : %s num1 num2\n", argv[0]);
    return 1;
  }

  a = atoi(argv[1]);
  b = atoi(argv[2]);
  value = sum(a, b);
  printf("%d + %d = %d\n", a, b, value);
  return 0;
}
}}}
이 프로그램은 첫번째 프로그램보다 더 진보된 프로그램으로, 프로그램의 명령행 인자로 받아들인 숫자를 더할 수 있도록 되어 있다. atoi(3)는 문자열을 int형 숫자로 변환해주는 함수다. sum 함수는 이미 컴파일 되어서 object 파일로 만들어져 있으므로, 별도로 컴파일할 필요가 없다. 다음과 같은방법으로 실행파일을 만들 수 있다.
{{{#!plain
# gcc -c mycal.c
# gcc -o mycal sum.o mycal.o
}}}
[[adsense]]
=== 4칙연산 프로그램 ===
위의 프로그램은 덧셈만을 지원하고 있다. 여기에 덧붙여 뺄셈, 나눗셈, 곱샘까지 지원하는 프로그램을 만들어 보도록 하자. 각각의 연산은 모두 함수로 작성되며, 각각의 함수가 헤더파일과 함수가 정의된 C 코드 파일을 가지게 될 것이다. 그렇다면, 이 프로그램은 4칙연산을 위한 4개의 함수와 4개의 헤더파일 1개의 main 함수를 포함하는 C 파일로 구성될 것이다.
  * 헤더파일 : sum.h, sub.h, mul.h, div.h
  * 함수정의된 C 파일 : sum.c, sub.c, mul.c, div.c
  * main 함수파일 : simplecal.c

먼제 헤더파일을 작성해보자.
'''sum.h'''
{{{#!plain
int sum(int a, int b);
}}}

'''sub.h'''
{{{#!plain
int sub(int a, int b);
}}}

'''mul.h'''
{{{#!plain
int mul(int a, int b);
}}}


'''div.h'''
{{{#!plain
int div(int a, int b);
}}}

이제 함수의 정의를 담고 있는 4개의 C 소스코드 파일을 만들어야 한다.

'''sum.c'''
{{{#!plain
int sum(int a, int b)
{
    return a + b;
}
}}}

'''sub.c'''
{{{#!plain
int sub(int a, int b)
{
    return a - b;
}
}}}

'''mul.c'''
{{{#!plain
int mul(int a, int b)
{
    return a * b;
}
}}}

'''div.c'''
{{{#!plain
int div(int a, int b)
{
    return a / b;
}
}}}

이제 main 함수를 가진 코드를 만들면 된다. 
{{{#!plain
#include "sum.h"
#include "sub.h"
#include "mul.h"
#include "div.h"
#include <stdio.h>

int main(int argc, char **argv)
{
   int a = 1200, b=25;

  printf("sum : %d\n", sum(a, b));
  printf("sub : %d\n", sub(a, b));
  printf("mul : %d\n", mul(a, b));
  printf("div : %d\n", div(a, b));
}
}}}

코드를 만들었다면, gcc를 이용해서 object를 만들고 이것들을 링크시켜서 실행파일로 만들면 된다.
{{{#!plain
# gcc -c sum.c sub.c mul.c div.c simplecalc.c
# gcc -o simplecalc sum.o sub.o mul.o div.o simplecalc.o
}}}

=== 라이브러리 ===
이렇게 단위 함수를 별개의 소스코드와 헤더파일로 나누어서 관리하게 되면, object 혹은 단위 소스코드 파일을 재활용할 수 있다는 장점을 가진다. 그러나 여전히 불편한 점이 있다. 함수가 많아지면, 자칫 수십개의 오브젝트 파일이 생성될 수 있을건데, 이들을 관리하는건 매우 귀찮은 일이기 때문이다.

그렇다면 4개의 object 파일을 하나로 묶을 수만 있다면, 함수들을 더 편리하게 관리할 수 있을 것이다. 이렇게 오브젝트들을 하나의 파일로 다시 묶은 것을 라이브러리(library)라고 한다.

라이브러리는 다시 '''정적 라이브러리'''와 '''공유 라이브러리'''로 나뉜다. 정적라이브러리는 실행파일에 완전히 포함되어버리는 형식의 라이브러리를 말한다. 반면 공유 라이브러리는 실행파일에 포함되지 않고, 실행될때 해당 라이브러리를 불러오는 형식의 라이브러리를 말한다.

==== 정적라이브러리 ====
'''static library'''라고 부르기도 한다. 이 라이브러리는 단순한 오브젝트의 모음일 뿐이다. 정적라이브러리는 '''ar'''이라는 프로그램을 통해서 만들 수 있다. 그럼 ar을 이용해서 위의 사칙연산을 위한 4개의 오브젝트를 모아서 '''libmycalc.a'''라는 이름의 정적라이브러리를 생성해보도록 하자. '''rc''' 옵션을 이용하면, 정적라이브러리를 만들 수 있다.

'''r'''은 정적라이브러리를 만들겠다는 옵션이고, '''c'''는 새로 생성을 하겠다는 옵션이다.
{{{#!plain
# ar rc libmycalc.a sum.o sub.o mul.o div.o
}}}
libmycalc.a 라는 파일이 생성된걸 확인할 수 있을 것이다. '''t''' 옵션을 이용하면, 해당 라이브러리가 어떤 오브젝트를 포함하고 있는지도 확인할 수 있다. '''t''' 옵션을 사용하면 된다. 참고로 정적 라이브러리의 이름은 '''lib[NAME].a'''의 형식을 따라야 한다.
{{{#!plain
# ar t libmycalc.a
div.o
mul.o
sum.o
sub.o
}}}

그럼 정적라이브러리를 이용해서 실행파일을 만들어 보도록 하자. 이전에는 4개의 오브젝트 파일을 모두 링크시켜줘야 했지만, 이제는 libmycalc.a 만 링크시켜주면 된다.

라이브러리의 링크방식은 오브젝트를 링크하는 것과는 약간 차이가 있다. library의 위치를 명확히 명시해 주어야 한다. '''-L''' 옵션을 이용해서 라이브러리가 있는 디렉토리의 위치를 명시해주고, '''-l'''옵션을 이용해서, 라이브러리 파일의 이름을 정해줘야 한다. 다음은 simplecalc.c 를 정적라이브러리를 이용해서 컴파일하는 방법을 보여준다.
{{{#!plain
# gcc -o simplecalc simplecalc.c -L./ -lmycalc
}}}
'''-L./'''은 현재 디렉토리를 라이브러리 찾기 디렉토리로 하겠다는 의미가 된다. '''-l''' 옵션뒤에 붙이는 라이브러리 파일의 이름에 주목할 필요가 있다. 라이브러리 이름은 '''lib'''와 '''.a'''를 제외한 이름을 사용한다.

==== 공유 라이브러리 ====
공유 라이브러리는 '''함께 사용하는 라이브러리'''라는 의미다. 즉 정적 라이브러리 처럼 실행파일에 붙는 것이 아니고, 시스템의 특정디렉토리에 위치하면서, 다른 모든 프로그램들이 '''공유'''해서 사용할 수 있게끔 제작된 라이브러리다. 그러므로 공유 라이브러리를 사용하도록 제작된 프로그램은 실행시에 사용할 라이브러리를 '''호출'''하는 과정을 거치게 된다.

공유 라이브러리역시 '''오브젝트'''를 이용해서 만든다는 점에서는 정적라이브러리와 비슷하지만, 호출시에 링크하기 위한 부가적인 정보를 필요로 하므로, 정적라이브러리와는 전혀 다른 형태로 만들어 진다. 정적라이브러리와 이름이 헛갈릴 수 있으니, 라이브러리 이름은 mycalcso 로 하겠다.
{{{#!plain
# gcc -fPIC -c sum.c sub.c mul.c div.c
# gcc -shared -W1,-soname,libmycalcso.so.1 -o libmycalcso.so.1.0.1 sum.o sub.o mul.o div.o
}}}

  1. 오브젝트 파일을 만들때 부터 차이가 있는데, -fPIC 옵션을 줘서 컴파일 한다.
  1. 그다음 -shared 옵션을 이용해서 공유라이브러리 파일을 생성한다.
위의 과정을 끝내고 나면, libmycalcso.so.1.0.1 이라는 파일이 생성이 된다. 이 라이브러리는 프로그램을 컴파일할때와 실행시킬때 호출이 되는데, 호출될때는 libmycalcso.so 를 찾는다. 그러므로 ln 명령을 이용해서 libmycalcso.so 링크파일을 생성하도록 하자.
{{{#!plain
# ln -s libmycalcso.so.1.0.1 libmycalcso.so
}}}
이렇게 링크를 만들게 되면, 여러가지 버전의 라이브러리 파일을 이용할 수 있으므로 관리상 잇점을 가질 수 있다. 새로운 버전의 라이브러리가 나올 경우, 오래된 버전의 라이브러리를 쓰는 프로그램은 실행시 문제가 발생할 수 있는데, 이런 문제를 해결할 수 있기 때문이다. 

이제 링크하는 과정이 남았다. 링크과정은 정적 라이브러리를 사용할때와 동일하다.
{{{#!plain
# gcc -o simplecalcso simplecalc.c -L./ -lmycalcso
}}}

이제 프로그램을 실행시켜 보도록 하자. 아마 다음과 같은 에러메시지를 만나게 될 것이다.
{{{#!plain
# ./simplecalcso
./simplecalcso: error while loading shared libraries: libmycalc.so: 
cannot open shared object file: No such file or directory
}}}

이러한 에러가 발생하는 원인에 대해서 알아보도록 하자. 정적라이브러리는 실행파일에 라이브러리가 붙여지므로, 일단 실행파일이 만들어지면, 독자적으로 실행이 가능하다. 그러나 공유라이브러리는 라이브러리가 붙여지는 방식이 아니고, 라이브러리를 호출해서 해당 함수코드를 실행하는 방식이다. 그러므로 공유라이브러리 형식으로 작성된 프로그램의 경우 '''호출할 라이브러리의 위치'''를 알고 있어야만 한다.

위의 simplecalcso 프로그램을 실행시키면, 이 프로그램은 libmycal.so 파일을 찾을 것이다. 이때 파일을 찾는 디렉토리는 '''/etc/ld.so.conf'''에 정의 되어 있다.
{{{#!plain
# cat /etc/ld.so.conf
/usr/lib
/usr/local/lib
}}}
만약 위에서 처럼되어 있다면, 프로그램은 /usr/lib 와 /usr/local/lib 밑에서 libmycal.so 를 찾게 될 것이다. 그런데 libmycal.so 가 없으니, 위에서와 같은 에러가 발생하는 것이다. 

가장 간단한 방법은 라이브러리 파일을 ld.so.conf에 등록된 디렉토리중 하나로 복사하는 방법이 될 것이다. 혹은 환경변수(:12)를 이용해서, 새로운 라이브러리 찾기 경로를 추가할 수도 있다. 이때 사용되는 환경변수는 LD_LIBRARY_PATH 다.
{{{#!plain
# export LD_LIBRARY_PATH=./:/home/myhome/lib
}}}
이제 프로그램을 실행시키면 LD_LIBRARY_PATH 에 등록된 디렉토리에서 먼저 검색하게 되고, 프로그램은 무사히 실행 될 것이다.

==== 공유라이브러리와 정적라이브러리의 장단점 ====
이들 2가지 라이브러리의 장단점에 대해서 알아보도록 하자. 장단점을 알게되면 어떤 상황에서 이들 라이브러리를 선택할 수 있을지 알 수 있을 것이다.

정적라이브러리의 장점은 간단한 배포방식에 있다. 라이브러리의 코드가 실행코드에 직접 붙어버리는 형식이기 때문에, 일단 실행파일이 만들어지면 간단하게 복사하는 정도로 다른 컴퓨터 시스템에서 실행시킬 수 있기 때문이다. 반면 동적라이브러리는 프로그램이 실행될때 호출하는 방식이므로, 라이브러리까지 함께 배포해야 한다. 라이브러리의 호출 경로등의 환경변수까지 덤으로 신경써줘야 하는 귀찮음이 따른다. 

일반적으로 정적라이브러리는 동적라이브러리에 비해서 실행속도가 빠르다. 동적라이브러리 방식의 프로그램은 라이브러리를 호출하는 부가적인 과정이 필요하기 때문이다.  

정적라이브러리는 실행파일 크기가 커진다는 단점이 있다. 해봐야 얼마나 되겠느냐 싶겠지만, 해당 라이브러리를 사용하는 프로그램이 많으면 많을 수록 '''X 프로그램수'''만큼 디스크 용량을 차지하게 된다. 반면 공유라이브러리를 사용할 경우, 라이브러리를 사용하는 프로그램이 10개건 100개건 간에, 하나의 라이브러리 복사본만 있으면 되기 때문에, 그만큼 시스템자원을 아끼게 된다. 

마지막으로 버전 관리와 관련된 장단점이 있다. 소프트웨어 개발 세계의 불문율이라면 '''버그 없는 프로그램은 없다'''이다. 어떠한 프로그램이라도 크고작은 버그가 있을 수 있으며, 라이브러리도 예외가 아니다.  

여기 산술계산을 위한 라이브러리가 있다. 그리고 정적 라이브러리 형태로 프로그램에 링크되었어서 사용되고 있다고 가정해보자. 그런데 산술계산 라이브러리에 심각한 버그가 발견되었다. 이 경우 산술계산 라이브러리를 포함한 A 프로그램을 완전히 새로 컴파일 해서 배포해야만한다. 문제는 이 라이브러리가 A 뿐만 아니라 B, C, D 등의 프로그램에 사용될 수 있다는 점이다. 결국 B, C, D 프로그램 모두를 새로 컴파일 해서 배포해야 하게 된다. 더 큰 문제는 어떤 프로그램이 버그가 있는 산술계산 라이브러리를 포함하고 있는지 알아내기가 힘들다는 점이다. 

공유라이브러리 형태로 작성하게 될경우에는 라이브러리만 새로 컴파일 한다음 바꿔주면된다. 그러면 해당 라이브러리를 사용하는 프로그램이 몇개이던간에 깔끔하게 문제가 해결된다. 

실제 이런 문제가 발생한 적이 있었다. zlib(:12) 라이브러리는 압축을 위한 라이브러리로 브라우저(:12), 웹서버(:12), 압축관리 프로그램등에 널리 사용된다. 많은 프로그램들이 이 zlib를 정적라이브러리 형태로 포함해서 배포가 되었는데, 심각한 보안문제가 발견되었다. 결국 zlib를 포함한 모든 프로그램을 새로 컴파일해서 재 설치해야 하는 번거로운 과정을 거치게 되었다. 공유라이브러리였다면 문제가 없을 것이다. 

이상 정적라이브러리와 공유라이브러리를 비교 설명했다. 그렇다면 선택의 문제가 발생할 것인데, 자신의 컴퓨터나 한정된 영역에서 사용할 프로그램을 제작하지 않는한은 공유라이브러리 형태로 프로그램을 작성하길 바란다. 특히 인터넷을 통해서 배포할 목적으로 작성할 프로그램이라면, 공유라이브러리 형태로 작성하는게 정신건강학적으로나 프로그래밍 유지차원에서나 좋을 것이다. 

=== 참고문헌 ===
  * [wiki:article/library_만들기 라이브러리 만들기]
