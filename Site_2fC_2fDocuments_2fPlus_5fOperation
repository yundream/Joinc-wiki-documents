#title 실수하기 쉬운 후위증감연산자 


'''증감연산자'''가 피연산자에 붙는 위치에 따라서 미묘한 차이가 있을 수 있다는건 알고 있는건 한데, 차이가 미묘하다 보니 실수를 할 경우가 생긴다. 이를테면 아래와 같은 경우다.
{{{#!plain
int i = 1;
int idx = 0;
while(1)
{
    idx = i++;
    //  어떤식으로든 idx를 이용한다.
}
}}}

이 경우 프로그래머가 의도하는 바는 idx에 2가 대입되는 것임이 분명하다. 그러나 idx에는 1이 대입된다. 이러한 실수는 다른 예에서도 찾아볼 수 있다.
{{{#!plain
#define MAX(A,B) ( (A) > (B) ) ? (A) : (B)
MAX(x++, 2)
}}}
위의 경우도 마찬가지다. 매크로 함수에 문제가 있는 것은 평소에는 분명히 인지하고 있겠지만, 사람이다 보니 상황에 따라 명백해 보이는 실수를 하게 된다. 평소에 '''inline templatized'''를 지원하는 [http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/C%2B%2B C++]과 같은 언어를 사용하고 있었다면, 별생각없이 위에서와 같은 버그를 가지는 매크로를 작성할 수도 있는 것이다. 

실수를 줄이는 가장 확실한 방법은 '''실수를 직접 경험해서 뼈속에 새기거나"', '''증감연산자는 조심해서 써야된다더라. 후위 증감연산자를 쓸경우 대입이 먼저 일어나게 된다더라'''라는 식으로 아는게 아닌 컴퓨터수준에서 어떻게 처리하는지를 이해하면 될것이다. 이렇다고 하더라도 이러한 류의 실수는 계속 발생하겠지만, 줄일 수는 있을 것이다.

해서, 증감연산자가 '''선위'''에 쓰이는 것과 '''후위'''에 쓰이는 차이를 어셈블리어(:12) 수준에서 고찰해보기로 했다. 테스트를 위해서 2개의 C(:12) 코드를 준비했다.
{{{#!plain
// 첫번째 테스트 코드 : 선위형 증감연산자
#include <stdio.h>

int main()
{
    int a = 0;
    int b = 1;

    a = ++b;
}

// 두번째 테스트 코드 : 후위형 증감연산자
#include <stdio.h>

int main()
{
    int a = 0;
    int b = 1;

    a = b++;
}

}}}
각각 test1.c 와 test2.c 로 저장한다음 gcc 컴파일러를 이용해서 어셈블리 코드를 생성했다. gcc는 3.2.2 버전을 사용했다.
{{{#!plain
# gcc -S test1.c
# gcc -S test2.c
}}}

다음은 만들어진 어셈블리코드다. 30라인 정도의 어셈블리 코드가 생성되었다. 그 중 중요한 부분만을 가지고 차이점에 대해서 알아보도록 했다.
{{{#!html
<pre class="code"># test1.s : 선위형 증감연산자<br />    movl    $0, -4(%ebp)                   # 값 0을 스택의 첫번째에 복사 했다. a = 0;<br />    movl    $1, -8(%ebp)                   # 값 1을 스택의 두번째에 복사 했다. b = 1;<br />    leal    -8(%ebp), %eax<br />    incl    (%eax)                         # 두번째 스택에 있는 값을 1만큼 증가 시켰다. b++;<br />    movl    -8(%ebp), %eax<br />    movl    %eax, -4(%ebp)                 # 두번재 스택에 있는 값을 스택의 첫번째에 복사했다.<br />    leave                                  # C형식으로 표현하자면 a = b 이고 결국 a에 2가 복사된다.<br /><br /># test2.s : 후위형 증감연산자<br />    movl    $0, -4(%ebp)<br />    movl    $1, -8(%ebp)<br />    movl    -8(%ebp), %eax<br />    movl    %eax, -4(%ebp)             # 두번재 스택에 있는 값을 스택의 첫번째에 저장했다. a = b<br />    leal    -8(%ebp), %eax<br />    incl    (%eax)                     # 두번째 스택에 있는 값을 1만큼 증가 시켰다. b++<br />                                       # 그러나 b의 값을 a에 복사하는 과정이 빠져있다. 결국 a는 1이다.<br /></pre>
}}}
