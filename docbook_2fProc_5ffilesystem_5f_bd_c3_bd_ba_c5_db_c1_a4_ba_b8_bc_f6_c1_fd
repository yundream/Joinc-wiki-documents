#title Proc filesystem 시스템 정보 수집
[wiki:article_Proc_filesystem_시스템정보수집 HTML 변환문서]

{{{#!plain
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<article lang="ko">

<!--           -->
<!-- 문서 정보 -->
<!--           -->
<articleinfo>
	<title>Proc filesystem - 자세히 버젼</title>

	<author>
		<surname>윤 상배</surname>

		<affiliation>
			<address>
				<email>dreamyun@yahoo.co.kr</email>
			</address>
		</affiliation>
	</author>
</articleinfo>


<!--                                                                 -->
<!-- 섹션 시작                                                       -->
<!--                                                                 -->
<section>
	<title>소개</title>
	<para>
		이미 몇번에 걸쳐서 간단하게 proc 파일시스템에 대해서 
		알아보긴 했으나, 지금까지의 문서는 거의 입문수준의 이벤트성 
		문서였었다. 	  
	</para>
	<para>
		그래서 이번에는 좀더 자세히 다루고자 마음먹고 문서를 작성한다. 
		이문서는 리눅스 커널 2.4.x 를 기준으로 작성될것이나, 대부분의 
		경우 2.2.x 에도 동일하게 적용될 것이다. 가끔은 솔라리스와 
		비교 설명을 하게 될것이다.  
	</para>
</section>

<section>
	<title>시스템 정보수집</title>
	<para>
		이번장에서는 pseudo 파일 시스템인 /proc 에 대한 개략적인 설명과 함께, 
		LInux 시스템상의 어떠한 정보를 제공하고 있는지 알아볼것이다. 
		이해를 돕기 위해서 실례를 들어가면서 설명을 하게 될것이다. 
	</para>
	<para>
		기본적으로 proc 파일 시스템은 커널이 가지고 있는 여러가지 데이타 
		구조체를 시스템 사용자(프로그래머 혹은 시스템 관리자)에게 쉽게 
		전달하기 위해서 사용하는 목적으로 만들어져 있다. 이 /proc 파일시스템 
		을 이용하게 됨으로써 좀더 쉽게 각종 시스템 정보를 얻어올수 있으며, 
		여러가지 커널옵션을 특별한 프로그래밍 과정없이 단지 파일의 정보변경
		만을 통해서 쉽게 변경할수 있도록 도와준다.  
	</para>
	<para>
		실제 proc 파일시스템을 이용하지 않고 커널 데이타 구조체에서 직접 
		원하는 시스템 정보를 가져올수 있기는 하지만, 별도의 프로그래밍 
		과정을 거쳐야 할뿐더라 꽤 귀찮은 여러가지 요건을 만족시켜주어야 한다. 
		특별히 성능을 중요시 여기지 않는 대부분의 경우 proc 파일시스템을 
		이용해서 정보를 가져오는 것으로도 충분히 기본적인 목적을 
		달성할수 있을것이다.   
	</para>
	<para>
		수집된 정보는 특히 시스템관리를 위한 시스템 모니터링 시스템(SMS) 
		과 시스템 최적화를 위한 시스템성능분석등에 유용하게 사용될수 있다. 
	</para>
	<section>
		<title>프로세스 정보 디렉토리</title>
		<para>
			/proc 디렉토리에는 프로세스 정보를 가지는 디렉토리가 존재한다. 
			이들 프로세스정보 디렉토리는 각 프로세스의 PID를 이름으로 가지며 
			이 디렉토리 안에는 다음과 같은 다양한 정보들을 제공한다.  
			<table>
				<title>/proc/PID 에서 제공하는 프로세스 정보들</title>
				<tgroup cols=2>
				<tbody>
					<row>
						<entry>파일명</entry>
						<entry>제공 정보</entry>
					</row>
					<row>
						<entry>cmdline</entry>
						<entry>명령행 옵션</entry>
					</row>
					<row>
						<entry>cpu</entry>
						<entry>SMP 시스템일경우 어떤 cpu 에서 실행되었는지</entry>
					</row>
					<row>
						<entry>cwd</entry>
						<entry>작업디렉토리 링크</entry>
					</row>
					<row>
						<entry>exe</entry>
						<entry>프로세스를 실행시킨 명령어의 링크</entry>
					</row>
					<row>
						<entry>fd</entry>
						<entry>디렉토리로 모든 파일지정자를 가진다.</entry>
					</row>
					<row>
						<entry>maps</entry>
						<entry>실행어와 라이브러리파일의 메모리 맵</entry>
					</row>
					<row>
						<entry>mem</entry>
						<entry>이 프로세스에 의해서 사용되는 메모리</entry>
					</row>
					<row>
						<entry>root</entry>
						<entry>이 프로세스의 루트 디렉토리</entry>
					</row>
					<row>
						<entry>stat</entry>
						<entry>프로세스 상태</entry>
					</row>
					<row>
						<entry>statm</entry>
						<entry>프로세스 메모리 상태</entry>
					</row>
					<row>
						<entry>status</entry>
						<entry>프로세스 상태(인간이 알아보기 쉬운 포맷)</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
			예를 들어서 PID가 1264 인 프로세스의 정보를 알아보고 싶다면 
			/proc/1264/status 정보를 확인하면 된다.
			<screen> 		 
[root@localhost 1264]# cat /proc/1264/status 
Name:   bx
State:  S (sleeping)
Tgid:   1264
Pid:    1264
PPid:   1225
TracerPid:      0
Uid:    500     500     500     500
Gid:    500     500     500     500
FDSize: 256
Groups: 500 
VmSize:     3620 kB
VmLck:         0 kB
VmRSS:      1900 kB
VmData:      636 kB
VmStk:       140 kB
VmExe:       896 kB
VmLib:      1756 kB
SigPnd: 0000000000000000
SigBlk: 0000000080000000
SigIgn: 8000000000001004
SigCgt: 0000000000036203
CapInh: 0000000000000000
CapPrm: 0000000000000000
CapEff: 0000000000000000
			</screen> 		 
			내용을 보면 ps 명령어가 보여주는 대부분의 정보를 보여주고 있음을 
			알수 있으며, 실질적으로도 ps 프로그램은 proc 파일시스템의 정보를 
			이용해서 시스템 정보를 출력시켜준다. 실제 프로세스 정보 분석프로그램을 
			만들일이 있다면 status 보다는 stat 파일을 사용하는게 편할것이다. 
			status 는 인간이 보기에는 편하지만 프로그래밍 작업을 통해서 
			원하는 데이타를 가져오기에는 적당하지 않은 포맷으로 되어 있다. 
		</para>
		<para>
			또한 ststm 파일을 확인하면 프로세스 메모리 사용에 대한 더욱 상세한 
			내용을 확인해 볼수 있다. 
			여기에는 다음과 같은 상세 메모리 정보가 포함되어 있다. 
			<table>
				<title>statm 파일이 가지는 정보들</title>
				<tgroup cols=2>
				<tbody>
					<row>
						<entry>필드</entry>
						<entry>값</entry>
					</row>
					<row>
						<entry>size</entry>
						<entry>프로그램의 총 크기</entry>
					</row>
					<row>
						<entry>resident</entry>
						<entry>할당된 메모리의 크기</entry>
					</row>
					<row>
						<entry>shared</entry>
						<entry>공유영역으로 할당된 페이지의 수</entry>
					</row>
					<row>
						<entry>trs</entry>
						<entry>code 를 위해 할당된 페이지의 수</entry>
					</row>
					<row>
						<entry>drs</entry>
						<entry>data및 stack 로 할당된 페이지의 수</entry>
					</row>
					<row>
						<entry>lrs</entry>
						<entry>라이브러리 로 할당된 페이지의 수</entry>
					</row>
					<row>
						<entry>dt</entry>
						<entry>dirty 페이지의 수</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
		</para>
	</section>
	<section>
		<title>커널 정보들</title>
		<para>
			리눅스의 proc 파일시스템은 프로세스의 정보뿐만 아니라 커널이 실행되면서 
			작성된 각종 정보들을 역시 파일로 관리하고 있다. (솔라리스의 경우에는 
			단지 프로세스 정보만을 제공한다.) 제공하는 정보는 다음의 테이블에서 
			확인하기 바란다.     
			<table>
				<title>/proc 의 파일정보들</title>
				<tgroup cols=2>
				<tbody>
					<row>
						<entry>파일</entry>
						<entry>내용</entry>
					</row>
					<row>
						<entry>apm</entry>
						<entry>Advanced power management 정보</entry>
					</row>
					<row>
						<entry>bus</entry>
						<entry>bus 관련정보</entry>
					</row>
					<row>
						<entry>cmdline</entry>
						<entry>커널 실행옵션</entry>
					</row>
					<row>
						<entry>cpuinfo</entry>
						<entry>사용cpu 정보</entry>
					</row>
					<row>
						<entry>device</entry>
						<entry>사용가능한 디바이스(블럭/문자 장치)</entry>
					</row>
					<row>
						<entry>dma</entry>
						<entry>사용하고 있는 DMS 채널</entry>
					</row>
					<row>
						<entry>filesystems</entry>
						<entry>지원되는 파일시스템</entry>
					</row>
					<row>
						<entry>driver/rtc</entry>
						<entry>드라이버 정보</entry>
					</row>
					<row>
						<entry>execdomains</entry>
						<entry>execdomains, 보안과 관련</entry>
					</row>
					<row>
						<entry>fb</entry>
						<entry>프레임버퍼 디바이스</entry>
					</row>
					<row>
						<entry>ide</entry>
						<entry>IDE 장치에 대한 정보 디렉토리</entry>
					</row>
					<row>
						<entry>interrupts</entry>
						<entry>인터럽트 사용율</entry>
					</row>
					<row>
						<entry>iomem</entry>
						<entry>메모리지도</entry>
					</row>
					<row>
						<entry>ioports</entry>
						<entry>사용중인 입출력포트</entry>
					</row>
					<row>
						<entry>isapnp</entry>
						<entry>pnp 정보</entry>
					</row>
					<row>
						<entry>kcore</entry>
						<entry>커널 core 이미지</entry>
					</row>
					<row>
						<entry>kmsg</entry>
						<entry>커널메시지</entry>
					</row>
					<row>
						<entry>ksyms</entry>
						<entry>커널 심볼 테이블</entry>
					</row>
					<row>
						<entry>loadavg</entry>
						<entry>최근 1,5,15 분의 평균 load</entry>
					</row>
					<row>
						<entry>locks</entry>
						<entry>kernel locks 정보</entry>
					</row>
					<row>
						<entry>meminfo</entry>
						<entry>메모리 정보</entry>
					</row>
					<row>
						<entry>misc</entry>
						<entry>기타등등</entry>
					</row>
					<row>
						<entry>modules</entry>
						<entry>실행중인(load) 모듈 목록, lsmod로 나오는 정보다</entry>
					</row>
					<row>
						<entry>mounts</entry>
						<entry>마운트된 파일시스템 정보</entry>
					</row>
					<row>
						<entry>net</entry>
						<entry>네트워킹 정보</entry>
					</row>
					<row>
						<entry>partitions</entry>
						<entry>파티션 정보</entry>
					</row>
					<row>
						<entry>pci</entry>
						<entry>PCI 버스 정보</entry>
					</row>
					<row>
						<entry>scsi</entry>
						<entry>SCSI 정보</entry>
					</row>
					<row>
						<entry>slabinfo</entry>
						<entry>Slab pool 정보</entry>
					</row>
					<row>
						<entry>swaps</entry>
						<entry>swap 파일시스템 사용정보</entry>
					</row>
					<row>
						<entry>sysvipc</entry>
						<entry>SysVIPC 자원정보(메시지큐, 세마포어, 공유메모리등)</entry>
					</row>
					<row>
						<entry>tty</entry>
						<entry>tty 드라이버 정보</entry>
					</row>
					<row>
						<entry>uptime</entry>
						<entry>시스템 가도시간</entry>
					</row>
					<row>
						<entry>version</entry>
						<entry>커널버젼</entry>
					</row>
				</tbody>
			</table>
		</para>
		<para>
			예를들어서 시스템 인터럽트를 확인해 보고 싶다면 interrupts 
			화일을 확인하면 된다. 
			<screen>
[root@localhost /proc]# cat /proc/interrupts
           CPU0       
  0:   55607808          XT-PIC  timer
  1:     479783          XT-PIC  keyboard
  2:          0          XT-PIC  cascade
  8:          1          XT-PIC  rtc
  9:    2217067          XT-PIC  eth0
 10:      88957          XT-PIC  usb-uhci, usb-uhci, Crystal CS4281
 12:    2121308          XT-PIC  PS/2 Mouse
 14:     487260          XT-PIC  ide0
 15:      80045          XT-PIC  ide1
NMI:          0 
ERR:          0
			</screen>
			CPU0 이란 헤더명에서 볼수 있듯이 복수의 CPU 인터럽트정보를 
			표시해 줄수 있다.
		</para>
		<para>
			커널 2.4 부터는 irq 라는 흥미로운 정보를 담고 있는 새로운 
			시스템정보를 알려주기 위한 디렉토리가 만들어져 있다. 여기에 
			있는 정보들을 변경하면 IRQ와 CPU의 관계를 조정할수 있다. 
			이 이야기는 여러분이 단지 하나의 CPU 에서 IRQ 를 "hook" 할수 있도록
			할수 있음을 의미한다. - 물론 테스트를 위해서는 2개 이상의 CPU 를 
			사용하는 시스템이 필요로 하지만 - 
			irq 디렉토리를 보면 각각의 IRQ 번호를 이름으로 갖는 서브 디렉토리를 
			가지며 이 디렉토리에는 prof_cpu_mask 라는 파일을 가진다. 
			(이 파일은 CPU 가 2개 이상일때만 존재한다) 
			<screen>
[root@localhost /proc]# ls irq/
0  1  10  11  12  13  14  15  2  3  4  5  6  7  8  9  prof_cpu_mask
[root@localhost /proc]# ls irq/0/
smp_affinity
			</screen>
			smp_affinity 를 보면 다음과 같은 값이 세팅되어 있을것이다. 
			<screen>
[root@localhost /proc]# cat irq/0/smp_affinity 
ffffffff
			</screen>
			이 값은 bitmask 로써, 당신이 이 IRQ(0번)를 제어하기 위해서 어떤 
			CPU를 할당할것인지를 지정할수 있다. 
			예를들어서 단지 첫번째 CPU 만이 IRQ 를 제어하도록 하려면 아래와 
			같이하면된다.  
			<screen>  
[root@localhost /proc]# echo 1 > irq/0/smp_affinity 
			</screen> 
		</para>
	</section>
	<section>
		<title>IDE 장치 정보 /proc/ide</title>
		<para>
			/proc/ide 디렉토리는 커널에서 등록중인 모든 IDE 장치에 대한 
			정보를 가지고 있다. 이 디렉토리에는 각각의 IDE 컨트롤러 정보를 
			가지는 써브디렉토리를 가진다. 그리고 각각의 IDE 컨트롤러를 가리키는 
			심볼릭 링크 파일과 각 장치 버젼을 담고 있는 drivers 파일을 
			제공한다.  
			다음은 IDE 장치의 버젼정보를 담고 있는 drivers 파일의 출력 내용
			이다. 
			<screen>
[root@coco ide]# cat drivers 
ide-cdrom version 4.59
ide-floppy version 0.97
ide-disk version 1.10
			</screen>
			위의 drivers 에는 가장 일반적인 정보인 어떤 ide 장치인지(
			하드디스크, cdrom, 플로프)와 그 버젼만을 가지고 있는데, 
			좀더 자세한 내용을 알기를 원한다면 ide0, ide1 과 같은 
			디렉토리의 내용을 확인해야 한다. 다음 테이블을 
			참고하기 바란다.  
			<table>
				<title>IDE 컨트롤러 정보 /proc/ide/ide?</title>
				<tgroup cols=2>
				<tbody>
					<row>
						<entry>파일명</entry>
						<entry>제공 정보</entry>
					</row>
					<row>
						<entry>channel</entry>
						<entry>IDE 체널 (0 또는 1)</entry>
					</row>
					<row>
						<entry>config</entry>
						<entry>PCI/IDE bridge 를 위한 설정</entry>
					</row>
					<row>
						<entry>mate</entry>
						<entry>Mate name</entry>
					</row>
					<row>
						<entry>model</entry>
						<entry>IDE 컨트롤러의 칩셋/타입</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
		</para>
		<para>
			IDE 컨트롤러 정보 /proc/ide? 디렉토리 아래에는 IDE 장치 
			정보를 가지는 파일들이 제공된다. 다음 테이블을 참고하라. 
			<table>
				<title>IDE 컨트롤러 정보 /proc/ide/ide?/</title>
				<tgroup cols=2>
				<tbody>
					<row>
						<entry>파일명</entry>
						<entry>제공 정보</entry>
					</row>
					<row>
						<entry>cache</entry>
						<entry>cache 정보</entry>
					</row>
					<row>
						<entry>capacity</entry>
						<entry>저장공간블럭(1블럭 == 512byte)</entry>
					</row>
					<row>
						<entry>driver</entry>
						<entry>드라이버 버젼</entry>
					</row>
					<row>
						<entry>geometry</entry>
						<entry>물리적/논리적 geometry</entry>
					</row>
					<row>
						<entry>identify</entry>
						<entry>devide identify block</entry>
					</row>
					<row>
						<entry>media</entry>
						<entry>매체의 종류</entry>
					</row>
					<row>
						<entry>settings</entry>
						<entry>디바이스 셋업 정보</entry>
					</row>
					<row>
						<entry>smart_thresholds</entry>
						<entry>IDE disk management thresholds</entry>
					</row>
					<row>
						<entry>smart_value</entry>
						<entry>IDE disk management values</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
		</para>
		<para>
			필자의 PC 에는 하나의 HDD 와 하나의 CDROM (둘다 IDE) 가 
			달려있자. CDROM 은 hdc 와 연결되어 있는데, /proc/ide/hdc/media
			의 내용을 출력하자 cdrom 이라고 나왔다. 미더어 타입을 
			쉽게 알수 있다. 또한 capacity 사이즈가 1108760 블럭 으로 
			나왔는데, 1block 은 512byte 임으로 계산하면 567685120 으로 
			cdrom 미디어의 용량을 계산할수 있다. HDD 역시 마찬가지의 
			방법을 이용해서 미디어와 용량을 계산할수 있을것이다.  
		</para>
		<para>
			그러나 가장 중요한 정보를 주는 것은 settings 파일일것이다.  
			<screen>
[root@localhost hda]# cat settings 
name                    value           min             max             mode
----                    -----           ---             ---             ----
bios_cyl                1861            0               65535           rw
bios_head               255             0               255             rw
bios_sect               63              0               63              rw
breada_readahead        4               0               127             rw
bswap                   0               0               1               r
current_speed           66              0               69              rw
file_readahead          0               0               2097151         rw
ide_scsi                0               0               1               rw
init_speed              12              0               69              rw
io_32bit                1               0               3               rw
keepsettings            0               0               1               rw
lun                     0               0               7               rw
max_kb_per_request      64              1               127             rw
multcount               8               0               8               rw
nice1                   1               0               1               rw
nowerr                  0               0               1               rw
number                  0               0               3               rw
pio_mode                write-only      0               255             w
slow                    0               0               1               rw
unmaskirq               1               0               1               rw
using_dma               1               0               1               rw
			</screen>
			언뜻봐도 실린더, 헤더, 섹터 등에 대한 정보가 눈에 들어올 것이다. 
		</para>
	</section>
	<section>
		<title>네트워킹 정보 /proc/net</title>
		<para>
			/proc/net 디렉토리에는 네트웍과 관련된 다양한 정보를 가지고 
			있는 파일들이 있다. 당신의 시스템이 ipv6 를 지금지원하고 
			있다면 ipv6 와 정보와 관련된 다음의 추가 파일들이 가지고 있을 
			것이다. 당신이 kernel 2.4.x 를 사용하고 ipv6 모듈을 가지고 
			있다면 지금 modprobe 를 이용해서 ipv6 모듈을 적재하기 바란다. 
			그럼 아래의 파일들이 생성될 것이다.  
			<table>
				<title>/proc/net 에서 제공하는 IPv6 정보</title>
				<tgroup cols=2>
				<tbody>
					<row>
						<entry>파일명</entry>
						<entry>제공 정보</entry>
					</row>
					<row>
						<entry>udp6</entry>
						<entry>열린 UDP 소켓리스트</entry>
					</row>
					<row>
						<entry>tcp6</entry>
						<entry>열린 TCP 소켓리스트</entry>
					</row>
					<row>
						<entry>raw6</entry>
						<entry>RAW 디바이스 상태</entry>
					</row>
					<row>
						<entry>igmp6</entry>
						<entry>IP 멀티캐스트 주소</entry>
					</row>
					<row>
						<entry>if_inet6</entry>
						<entry>IPv6 인터페이스 주소목록</entry>
					</row>
					<row>
						<entry>ipv6_route</entry>
						<entry>IPv6 를 위한 커널 라우팅 테이블</entry>
					</row>
					<row>
						<entry>ipv6_stats</entry>
						<entry>Global IPv6 라우팅 테이블</entry>
					</row>
					<row>
						<entry>sockstat6</entry>
						<entry>IPv6 소켓 상태</entry>
					</row>
					<row>
						<entry>snmp6</entry>
						<entry>IPv6 snmp 데이타</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
		</para>
		<para>
			다음은 일반적인 데이타이다. IPv4 관련 네트웍 정보파일과 
			다른 것들을 포함하고 있다. 
			<table>
				<title>/proc/net 에서 제공하는 네트웍 정보</title>
				<tgroup cols=2>
				<tbody>
					<row>
						<entry>파일명</entry>
						<entry>제공 정보</entry>
					</row>
					<row>
						<entry>arp</entry>
						<entry>커널 ARP 테이블</entry>
					</row>
					<row>
						<entry>dev</entry>
						<entry>네트웍 디바이스 상태</entry>
					</row>
					<row>
						<entry>ip_fwchains</entry>
						<entry>방화벽 </entry>
					</row>
				</tbody>
				</tgroup>
			</table>
		</para>
	</section>
</section>
</article>
}}}
