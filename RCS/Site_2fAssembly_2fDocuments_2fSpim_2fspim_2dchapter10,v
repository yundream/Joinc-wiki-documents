head	1.1;
access;
symbols;
locks
	root:1.1; strict;
comment	@# @;


1.1
date	2014.10.13.12.04.15;	author root;	state Exp;
branches;
next	;


desc
@./data/text/Site_2fAssembly_2fDocuments_2fSpim_2fspim_2dchapter10
@


1.1
log
@223.194.107.102;;Anonymous;;
@
text
@#title MIPS 프로그래밍 모델

[[TableOfContents]]

 '''번역 : 강웅빈'''
 '''감수 : 프갤ㅤㅎㅛㅇ들'''

== 10장 MIPS 프로그래밍 모델 ==
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_1.html

이 장에서는 MIPS 프로세서를 위한 프로그래밍 모델을 제시한다. 프로그래밍 모델은 프로그래밍을 위한, 그러나 작업을 위해 필요하지 않은 상세한 설명을 빼고서 프로세서를 추상화하여 보는 것 이다. 또한 프로그래밍 모델은 프로그래머가 프로그래밍 할 때 프로그래머가 사용하는 기계를 이해하는 관점이다.


 이 장에서는...
 *'''기본 MIPS 프로그래밍 모델(Basic MIPS Programming model)'''
 *'''메모리(Memory)'''
 *'''레지스터(Registers)'''
 *'''머신 사이클(Machine cycle)'''
 *'''흐름제어(Control flow)'''

를 다룰 것이다.

질문: 여러분이 고속도로에서 차를 운전할때 점화코일에 대해 신경쓰면서 운전합니까?

=== 메모리 모델 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_2.html

답: 아니오. 여러분은 차를 운전할때 '운전자의 관점' 에서만 보고 불필요한 것들에 대해서는 생각하지 않을 것이다. 물론 항상 그런식으로만 생각하지는 않을 것이다. 만약 비가 오는 가운데 차가 퍽퍽 소리를 낸다면 코일에 대해 생각하는 것이 좋을 것이다.


거의 모든 현대의 컴퓨터 시스템은 캐쉬 메모리(cache memory)와 가상 메모리(virtual memory)를 사용한다. 하지만 여기서 우리가 메모리를 보는 추상적 관점에서는 가상메모리에대해 생각하지 않을 것이다(역자 주:마치 운전사가 점화 플러그를 생각하지 않는 것 처럼). 가상 메모리를 사용하는 이유는 프로그램이 완전한 주소 공간(full address space)을 사용할 수 있는것 처럼 보이기 위한 것이다. 그래서 우리의 프로그래밍 모델에서는 프로그램이 모든 주소 공간(full address space)을 사용할 수 있다. 캐쉬(cache)를 가지는 목적은 메모리 액세스(memory access)의 속도를 높이기 위해서이다. 이 또한 우리가 보는 추상적 관점에는 포함되지 않을 것이다. 우리 프로그래밍 모델에서 메모리 모델은 다음과 같다.

[[Image(memory01.gif,0,0,right,)]]

 '''데이터(Data):'''

 MIPS 메모리는 2^32바이트로 이루어진 배열이다. 각각의 바이트는 32비트의 주소를 가지고 있다. 각각의 바이트는 1개의 8비트 패턴을 담고 있다. 담겨진 비트 패턴은 8비트로 표현될 수 있는 256개의 패턴중에 하나이다. MIPS 메인 메모리의 범위는 0x00000000 부터 0xFFFFFFFF까지이다.

하지만 사용자의 프로그램과 데이터는 첫 2^31 바이트에만 저장될수 있도록 제한되어 있다. 나머지 반은 운영체제와 특수 목적에 쓰인다.

 '''동작(Operations):''' 

 프로세서 칩은 비트패턴을 저장할 수 있는 전자부품인 레지스터들을 담고있다. 프로세서는 비트패턴을 레지스터 메모리사이에서 옮기며 메모리와 상호작용한다.

  *'''불러오기(load):''' 

  메모리의 지정된 주소에서 시작하는 비트 패턴이 프로세서 안의 레지스터로 복사 된다.

  *'''저장하기(store):''' 

  프로세서 레지스터의 비트패턴이 메모리의 지정된 주소로 복사 된다.

비트패턴은 메모리와 레지스터사이를 1, 2, 4, 혹은 8개의 연속된 바이트 형태로 무리지어 복사된다. 여러 바이트가 동작(operation)에 쓰일때는 제일 첫번째 바이트의 주소만이 지정된다.

질문:

 메모리에서 불러오는 동작을 하면 메모리의 비트패턴에 변화를 줍니까?
 메모리에 저장하는 동작이 메모리의 비트패턴에 변화를 줍니까?

=== 메모리 레이아웃 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_3.html
[[Image(memoryLayout.gif,0,0,right,)]]
답 : 
 1. 불러오기(load) 동작이 메모리에 변화를 줍니까? 아니오, 메모리의 복사본이 레지스터에 기록됩니다.
 2. 저장하기(store) 동작이 메모리에 변화를 줍니까? 예, 레지스터에 있는 비트 패턴이 지정된 주소에 있는 것을 덮어 씌웁니다.

불러오기(load)및 저장하기(store) 동작은 비트 패턴을 소스(source)로부터 목적지(destination)로 복사한다. (레지스터이거나 메모리이거나) 소스(source)는 변하지 않는다.  물론 목적지에 있는 비트 패턴은 소스(source)의 비트패턴으로 교체된다.

메모리는 비트패턴을 저장하기 위해 만들어졌다. 기계명령이나 데이터는 모두 비트패턴 형태로 표현되었다. 비트 패턴은 기계명령이거나 데이터이거나 상관없이 메모리 어느 장소에나 (최소한 하드웨어적으로는) 저장될 수 있다. 하지만 기계명령과 데이터를 분리해서 저장하는 것이 프로그래머와 시스템 소프트웨어 모두에게 편리하다. 그림은 MIPS OS가 메모리를 배치한 것(memory layout)을 보여준다.

 
주소 길이가 32비트 일지라도 사용자 프로그램은 윗쪽 주소 0x8000000 부터 0xFFFFFFFF는 사용할 수 없다.  운영체제와 롬(ROM)이 그 제한된 주소들을 사용한다. MIPS칩이 엠베디드 컨트롤러에 쓰일 때 제어프로그램은 이와같이 제한된 메모리 상위 반의 주소에 ROM으로써 상주한다.

나머지 사용자 프로그램이 사용 할 수 있는 부분은 다음과 같이 나뉘어 진다.

 *텍스트 세그먼트(Text Segment): 사용자 프로그램의 기계어를 담는다("the text")

 *데이터 세그먼트(Data Segment): 프로그램이 사용하는 데이터를 담는다. 데이터의 일부분은 정적(static)이다. 정적인 데이터는 어셈블러에 의해 할당(allocation)되고 프로그램 실행중에 그 크기는 변하지 않는다. 할당된 메모리안에 있는 값은 변할 수 있다. "정적" 이란 말은 실행중에 데이터의 크기가 변하지 않는다는 것이다. 정적 데이터이외에도 동적(dynamic)데이터라는 것이 있다. 동적(dynamic) 데이터는 프로그램 실행중에 할당되거나 할당을 해제 할 수 있다. C언어 에서는 할당과 할당해제는  malloc() 과 free()를 사용한다.
 
 *스택 세그먼트(Stack Segment): 사용자 주소 공간의 최상부에는 스택이 있다. 고급언어에서는 프로시져(procedure)가 수행될때 프로시져의 지역변수(local variable)와 파라미터(parameter)들이 스택에 들어가고(push) 프로시져가 끝났을 때 빠져나온다(pop).

질문: (생각이 필요한 질문) 프로그램이 실행되면서 데이터 세그먼트는 (동적 변수가 할당되면서)위쪽으로 자랍니다. 그리고 스택은 아래쪽으로 증가됩니다. 이렇게 하는게 현명한 방법일까요?  (힌트: 두 세그먼트가 만날 때 메모리가 얼마나 남습니까?)


=== 레지스터 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_4.html

답: 그렇다. 고정된 메모리의 양을 각 영역별로 정해 주는것보다는 각각의 영역이 필요에 따라 사용가능한 메모리를 이용함으로써 증가할 수 있게하는 것이 현명하다. 스택과 데이터 두 영역이 만날 때는 더이상 사용가능한 메모리는 없다.

 보통, 데이터들은 몇개의 연속적인 바이트로 저장된다. 컴퓨터 제조사들마다 바이트보다 큰 데이터를 보관할 경우 부르는 단위가 다르다. MIPS칩의 경우 다음과 같은 단위를 사용한다.

 *바이트(byte) - 8비트
 *워드(word)- 4바이트, 32비트
 *더블워드(double word) - 8바이트, 64비트

 한단위의 연속적인 메모리공간을 가르킬 때에는 첫 바이트의 주소(가장 낮은 주소를 가진 바이트)를 사용한다. 거의 모든 MIPS명령들이 고정된 수의 바이트로 이루어져있다.
 종종 byte나 word나 double word와 같은 표준단위 이외의 비트가 필요한 경우를 볼 수 있다. 그럴 경우 표준 단위 다음으로 가장 큰 단위를 사용하자. 그럴경우 주의를 기울여야 한다. 
 비트의 수를 최소한으로 절약하여 사용하려는 시도는 노력에 비해 복잡하고 가치가 없다. 또한 어셈블러 프로그래밍에서의 많은 에러를 발생시키는 원인 중에 하나가 될 수 있다.

 레지스터는 비트패턴을 담을 수 있는 프로세서의 한부분이다. MIPS 에서는 하나의 레지스터는 32비트를 담을 수 있다. 프로세서에 많은 레지스터가 있지만 어셈블러는 그 중에 일부분의 레지스터만 사용할 수 있다. 나머지 레지스터는 프로세서가 동작을 수행하는데 사용한다.

 *불러오기(load) 동작은 메모리로부터 비트패턴을 불러들여 레지스터에 복사한다. 
 *저장하기(store) 동작은 레지스터에서부터 비트패턴을 불러들여 메모리에 복사한다.

어셈블러가 사용할 수 있는 레지스터들에는 일반레지스터(general purpose registers)와 부동소수점레지스터(floating point registers)가 있다.
{{{#!plain 
일반 레지스터는 32개가 있는데 각각의 레지스터가 32비트 패턴을 담을 수 있다. 어셈블러에서 이러한 일반레지스터들은 $0, $1 ... $31로  이름 지어져 있다.
}}}
부동소수점레지스터도 32개가 있는데 그것들은 나중에 다룰 것이다.

일반레지스터중 하나는 항상 0x00000000(모두 0) 을 담고 있다.

{{{#!plain
질문: $0...$31 중에 어떤것이 0x00000000의 값을 가지고 있습니까?
 }}}

=== 레지스터와 산술논리장치(Arithmetic Logic Unit-ALU) ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_5.html
{{{#!plain 
답 : $0번 레지스터  : 기계어에서 비트패턴 0x00000000은 매우 자주 나타나기 때문에 레지스터0번이 항상 그 값을 가지고 있습니다. 
}}}
이 비트패턴은 아주 흔한 정수인 "0"(영) 을 의미 합니다. 또한 이 0으로 표현된 비트패턴은 문자열과 몇몇 자료구조들의 끝을 나타낼 때 사용하는 null을 표현 합니다.

[[Image(ALURegisters.gif,0,0,right,)]]
산술논리장치(앞으로 ALU) 는 정수의 산술연산과 논리 연산을 수행하는 프로세서이다.  예를 들자면 32비트정수 두개를 더하는 동작이 ALU가 하는 일중 하나이다. 
ALU의 동작을 위해 입력된 정수를 연산대상 또는 피연산자 영어로 오퍼랜드(operand)라고 한다.  ALU의 작동시 최소한 하나의 연산대상(operand)은 항상 레지스터에 들어있다. 나머지 한쪽은 레지스터에 있을 수도 있고 기계명령 자체의 일부분일 수도 있다. 
연산결과는 일반레지스터에 넣어진다.

ALU를 사용하는 기계명령은 4가지를 정의한다 :

 *수행할 연산
 *첫 연산대상 (보통 레지스터 안에 있다)
 *두번째 연산대상 (보통 레지스터 안에 있다)
 *결과를 저장할 레지스터

이 그림은 32비트 덧셈연산을 보여준다. 연산대상은 레지스터 $8와 $9에서 온다. 결과는 $10에 저장된다. 다음은 이 명령을 어셈블러로 쓴것이다:
{{{#!plain 
 addu $10, $8,$9
}}}


질문 : 아래는 ALU를 사용하는 어셈블러로 쓰여진 명령이다.
{{{#!plain 
subu    $25,$16,$17 
}}}
다음을 써보아라:

동작 : ________________
첫 연산대상의 위치 : ________________
다른 연산대상의 위치 : ________________
결과를 집어넣는곳 : ________________

=== 기계어 ===

http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_6.html

답:
{{{#!plain 
1. 동작(operation) : 두 32비트 정수의 빼기
2. 첫 연산대상(operand)의 위치 : $16 레지스터
3. 다른 연산대상(operand)의 위치 : $17 레지스터
4. 결과를 집어넣는곳 : $25 레지스터
( 실행시간에는 : $25 <== ($16) - ($17) )
}}}

VAX를 포함함 몇몇의 프로세서들에서는 ALU가 메인메모리가 담고있는 데이터를 직접 처리 할 수 있다. 그러나 이런 동작은 추가적인 데이터 패스(data path)와 제어 논리가 필요하고 실행속도를 감소시킨다. MIPS에서는 ALU의 연산대상(operand)과 결과물이 저장되는 목적지는 항상 칩 안에(보통은 레지스터 안에) 있다.

다음과 같은 덧셈 명령 어셈블리어가 있다.
{{{#!plain 
addu $10,$8,$9
}}}
이와 같은 어셈블리 명령은 다음과 같은 기계어로 번역된다.
{{{#!plain 
0x01095021
}}}
그리고 이것은 위 기계어의 비트 패턴이다.
{{{#!plain 
0000 0001 0000 1001 0101 0000 0010 0001
}}}

아래에 여러 그룹으로 묶어서 비트 패턴을 써 놓았다. 각각의 그룹 제일 밑에는 이 패턴들이 기계명령으로 무엇을 의미하는지 적혀 있다. (큰 비트 패턴을 구성하는 작은 비트 패턴의 그룹을 필드(field)라 부른다).  기계명령의 각 필드(field)는 특정한 기능을 가지고 있다.
{{{#!plain

  0    1    0    9    5    0    2    1     -- 16진수

0000 0001 0000 1001 0101 0000 0010 0001    -- 비트패턴으로 표현된 기계명령

000000 01000 01001 01010 00000 100001      -- 명령을 필드로 해석해서 보는 경우

OP코드(opcode) |  연산대상(oprnd)  | 연산대상(oprnd)  | 목적지(dest) | ----- | 2차 OP코드(2ndary opcode)      -- 필드의 의미

ALUop   $8    $9   $10           addu

}}}

어떻게 각 그룹이 다음 4가지를 지정하는 지 자세히 살펴보자 : (1) 동작(operation), (2) 연산대상1(operand 1), (3) 연산대상2(operand 2), (4) 결과물이 저장되는 장소(result destination)

기계명령은 기계동작과 데이터를 지정하는 필드들로 구성 되어있다. addu동작을 알려주는 12비트는 2가지 그룹으로 나뉜다. 첫번째 그룹은 OP코드(opcode), 두번째 그룹은 2차 OP코드(secondary opcode)이다.

레지스터 번호들은 2진수 정수로 읽을 수 있다. 몇몇 비트들은 0으로 남겨져 있는데 자세한 사항은 MIPS 문서를 찾아봐야 알 수 있다.
{{{#!plain
질문: 다음은 기계명령이다. 목적지가 빈칸이다. 목적지가 $11이 되도록 채워보자.
}}}
|| 000000 || 01000 || 01001 || _____ || 00000 || 100001 ||
|| addu || $8 || $9 || $11 || || addu ||
|| || 연산대상 || 연산대상 || 저장대상 || || ||


=== 레지스터 사용 관례 === 

http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_7.html

답:
|| 000000 || 01000 || 01001 || 01011 || 00000 || 100001 ||
|| addu || $8 || $9 || $11 || || addu ||
|| || 연산대상 || 연산대상 || 저장대상 || || ||
축하합니다! (만약 답이 맞았으면) 여러분은 기계여 프로그래밍을 한 것 입니다. 해묵은 어셈블러는 이제 필요가 없죠?

어셈블러 프로그램은 (부동소수점레지스터와 함께) 일반레지스터를 사용한다. 일반레지스터는 0번 레지스터부터 31번 레지스터까지 번호가 있다. 그러나 관습적으로(또는 하드웨어에따라) 각각의 레지스터들은 저마다 다른 용도로 쓰인다.

숫자 $0 - $31 외에도 레지스터는 기억하기 쉬운 이름(mnemonic name) 을 가지고 있다. 예를들어 $0은 'zero' 라는 이름을 가지고있다.  다음의 표는 32개의 레지스터와 이것의 일반적인 용도를 보여준다.

|| 레지스터 번호 || 기억하기 쉬운 이름 || 일반적 용도 ||
|| $0 || zero || 항상 0 ||
|| $1 || $at || 어셈블러 템포러리(지정되어 있음) ||
|| $2, $3 || $v0, $v1 || 서브루틴에서 리턴되는 값 ||
|| $4-$7 || $a0-$a3 || 서브루틴에 입력되는 값 ||
|| $8-$15 || $t0-$t7 || 임시 - 함수호출중에 변할 수 있다 ||
|| $16-$23 || $s0-$s7 || 저장되는 레지스터 - 함수호출중에도 불변 ||
|| $24,$25 || $t8,$t9 || 임시 ||
|| $26,$27 || $k0,$k1 ||커널(OS가 사용함)||
|| $28 || $gp || 전역포인터 ||
|| $29 || $sp || 스택포인터 ||
|| $30 || $fp || 프레임포인터 ||
|| $31 || $ra || 리턴주소(몇몇 명령에서 자동으로 사용됨) ||

레지스터 $0과 $31은 유일하게 다른것들과 다르게 작동하는 레지스터다. $0은 항상 0을 가지고있고, $31은 리턴주소를 보관하기위해 몇몇의 서브루틴연결명령에서 사용된다.

완전히 암호같아도 걱정하지말고 외울 필요는 없다. 프로그램 몇개 짜면 익숙해 질 것이다.

질문 : 프로그램이 $8에 있는 중요한 값을 계산하고 $0에 결과를 넣었다. 잘 한 일인가?

=== 머신 사이클(기계 주기) 모델 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_8.html
[[Image(machinecycle.gif,0,0,right,)]]

답 : 아니오. $0은 항상 0을 담고 있기 때문이다. 값이 $0레지스터에 복사 된것 처럼 보일 수 도 있고 실행도 제대로 된 것 처럼 보이겠지만 $에 0이라는 값은 안바뀐다.


MIPS 어셈블러는 머신 사이클(챕터1의 복습)을 포함한다. MIPS는 3가지 기본 스텝을 따라 끊임없이 반복된다. 각각의 사이클은 1개의 기계명령을 실행한다. 프로세서가 하는 모든 일이 일련의 기계동작이다. 결과적으로, 프로그램이 하는일은 수백만의 머신사이클을 수행한 결과이다.


프로그램이 실행 됨에 따라 특별한 레지스터인 '''프로그램 카운터 program counter(PC)''', 는 실행할 다음 명령을 가리킨다.


 1., '''다음명령을 읽는다.(Fetch the next Instruction. )''' PC는 다음 명령의 주소를 가리킨다. 메모리에서 명령을 읽어들인다.
 2., '''PC를 증가시킨다.(Increment the PC. )''' PC는 4만큼 증가된다.
 3., '''명령 수행.(Execute the Instruction. )''' 명령에 의해 정해진 동작이 수행된다.


질문 : 왜 PC가 4만큼 증가합니까?

=== 순차적 실행 ===

http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_9.html

답 : MIPS명령 하나의 길이는 32비트(4바이트) 이다. PC는 다음 명령을 가리키기 위해 증가된다.

모든 MIPS명령은 32비트(4바이트) 길이이다. 보통, 프로그램 명령들은 프로그램의 첫번째 명령부터 시작해서 순차적으로 실행된다. 순차적 실행은 메모리를 따라 윗쪽 방향으로 진행된다. 순차적 실행의 흐름은 분기명령(branch)나 점프명령(jump)을 통해 바뀔 수 있다.

예를들어 이전 챕터의 프로그램을 그려놓았다. 3개의 명령들은 각각 0x00400000, 0x00400004와 0x00400008에 있고 그 순서대로 실행된다.

attachment:addProg.gif

이 작은 프로그램을 실행하기 위해선 3번의 머신사이클이 요구된다.
 
질문 : 0x00400008에 있는 명령이 실행된 후 무슨일이 일어납니까?

=== 제어 ===

http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_10.html

답 : 주소 0x0040000C에있는 그 주소에 담겨 있는 비트 패턴이 무엇이건 간에32비트 패턴을 불러와서 명령을 실행시키려고 할 것 입니다.

머신사이클에 의해 읽혀진 모든 비트패턴은 명령으로 해석된다. 비트패턴의 필드들이 무슨 동작을 하는지 그리고 데이터는 무엇인지를 말해준다. 만약 비트패턴이 말이 안돼면 머신사이클은 중단된다. 그리고 프로그램은 깨진다 영어로 크래쉬 (crash) 되었다고 표현한다. 그러나 패턴이 명령으로써 해석될 수 있다면, 그 패턴이 무엇이든 실행될 것 이다.

실행되는 프로그램의 제어점(control point)은 현재 실행되고 있는 명령의 주소다. 명령이 실행될때(머신사이클의 3번째 단계) PC는 제어점 다음의 명령을 담는다.

보통 제어점은 기계명령을 따라 순차적으로 움직인다. MIPS의 경우에는 보통 제어점은 스텝당 4바이트(32 비트) 단위로 움직인다. 일반적으로 제어점(control point)은 줄여서 제어(control)라고 표현한다. 제어의 흐름이(flow of control)란 제어점(control point)이 메모리에서 어떻게 움직이는 가를 의미한다.

만약 제어의 흐름에 따라 어떤 메모리의 주소가 지정 되었다면, 그 지정된 메모리부터 시작해서 4바이트가 하나의 기계명령으로써 읽혀진다(fetched). 프로세서는 명령과 데이터를 구분할 능력이 없다. 메모리로부터 무슨 비트패턴이 명령으로 읽혔든 간에 명령으로써 실행될 것이다. 버그가 많은프로그램의 경우 이 제어점이 데이터 영역으로 들어가서 문제가 발생하는 경우를 흔히 볼 수 있다. 그리고 아주 '신비한 결과'를 만들어낸다.

소프트웨어 관례에 따라 데이터와 명령은 메모리의 다른 구간에 저장 되어있다(이것은 잘못된 결과를 방지하는데 도움이 된다). 그렇지만 이것이 구조적으로 제한되어 있는 것은 아니다.

질문: 거의 모든 컴퓨터 시스템은 전원이 켜졌을때 운영체제를 동작시킵니다. 응용프로그램이 시작될 때 운영체제는 제어를 응용프로그램으로 넘깁니다.

응용프로그램이 끝나면 응용프로그램이 할 일은 무엇입니까?

=== 멀티태스킹 ===

http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_11.html

답 : 운영체제에 제어를 넘깁니다.

마이크로 소프트사의 DOS에서는 응용프로그램이 제어를 넘겨받아 프로그램의 완료시까지 실행되고 그 다음에 DOS로 제어를 넘겼다. 결과적으로 한번엔 한 응용프로그램만 돌아간다. 더욱이 내부에 문제가 발생한 프로그램은 DOS로 제어를 넘기지 못하므로 전체 시스템이 정지 하게된다.

현대의 컴퓨터시스템은 실행되는 프로그램의 제어흐름을 중단할수 있는 기능을 가지고 있다. 제어의 흐름이 중단(interrupt)되었을때, 운영체제는 제어권을 다른 프로그램에 넘길 수 있다. 초당 여러번 이런 것을 반복한다면 여러 프로그램이 한번에 돌아가는 것 처럼 보인다. 이 기술을 '''여러가지 일하기 또는 영어로 멀티태스킹(multitasking)'''이라 부른다. 이 기술은 1960년대부터 메인프레임 컴퓨터에서쓰였고, 1978년부터 많은 소형컴퓨터에서 쓰였다. 그리고 1995년쯤부터 윈도우즈를 사용하는 PC에서 사용되었다.

MIPS칩은 멀티태스킹을 아주 잘 지원한다. 하지만 멀타태스킹은 여기서 다루는 기초적 프로그래밍 모델에는 포함되지 않았다. 공부를 더한 후 고급과목에서 멀티태스킹을 공부해 보자.

질문 : 인간의 뇌는 멀티태스킹을 합니까?

=== 모델 요약 ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_12.html

답 : 사람의 두뇌는 거의 항상 병렬로 작동합니다. 멀티태스킹은 병렬처리를 하는것처럼 보여줍니다. 사람의 두뇌와 몇몇 컴퓨터들은 정말로 병렬처리를 할 수 있습니다.
[[Image(machinecycle.gif,0,0,right,)]]
다음은 우리가 다룬 기초MIPS프로그래밍 모델의 요약이다.

 *기계명령 : 기계명령은 32비트 길이이다. 비트패턴들은 동작, 연산대상, 그리고 결과를 저장할 곳을 지정한다. 기본적 동작으로는 산술, 논리, 메모리접근 그리고 흐름제어가 있다.

 *머신사이클 : 머신사이클 그림을 주목해서 보자. 실행은 순차적으로 한번에 한명령씩 실행된다. 제어점(control point)은 실행될 명령을 가리킨다. ALU 동작은 절대 메모리를 직접 접근하지 않는다.

 *레지스터 :관례에 따라 다양한 용도로 쓰이는 32개의 32비트길이의 일반레지스터가  있다. $0은 32비트의 0을 항상 가지고 있다.

 *메모리 : 32비트의 메모리공간이지만 아랫쪽 반만이 사용자 프로그램이 사용할수 있는 영역이다. (소프트웨어 관례에 따라) 유저 메모리 공간은 더세부적으로 텍스트 영역,데이터 영역 그리고 스택 영역으로 나눌 수 있다.

[http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10quiz.html 10장퀴즈]를 꼭 풀어보자. 


=== 프갤러들의 수다 ===
1. "자바하는넘" 수고 수고. 난 휴가가도 되겠네.
2. "자바하는놈" 근데 정말 휴가가요? XD  나 파서 소스 날려서 기분이 이상해 아주 ㄲㄲㄲ 이제부턴 내문서 백업 하룻밤에 하나씩 해야겠어 백업셋 2개에.
3. "자바하는놈" 어디 state? 지금 한참 더울땐에 몸조심하세요. 나 오늘 아빠친구 만나서 intel어셈좀 약간. 윈도우에 보니깐 매크로 어셈블러가 있더라고. cmd-debug
4. "자바하는놈" 그분은 그 막 비디오램 주소를 다 기억하고 계셨어 - - f b000:0000 0100 42 07  이런식으로하면 화면에 A로 가득차더라고 ㄲㄲ
5. "자바하는놈" &#54973; 짤방있지 real programmers program in binary. 그거를 정말 하셨다더군 - - 여튼 재밌는장난감 . 그럼 내일 계속하겠습니다 jul 1 06
6. "자바하는놈" 형 요즘 바뻐요? jul 9 06
7. "자바하는넘" 음 요새 좀 바쁘네. 이 장은 혼자 번역해봐 남는게 많을 거야. 궁금한 거 있으면 책읽자ㅤㅎㅛㅇ이나,스미골행ㅤㅎㅛㅇ이나,샤ㅤㅎㅛㅇ,푼내기ㅤㅎㅛㅇ한테 물어봐.
8. "자바하는놈" 저기 위에 기계어부분 완전노가다네 -- 한글로하니깐 안맞아용
9. "자바하는넘" 수고 수고 :)
@
