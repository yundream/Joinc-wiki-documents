Describe Site/Assembly/Documents/docbook_ProgrammingGroundUp/trans/Appendix_B here
2006.7.10 시작~~

----

= Appendix B. x86 명령어 =

== 테이블 읽는 방법 ==

이번 장에 나온 명령어 테이블은 다음과 같이 구성된다.

 * 명령어 코드
 * 사용하는 오퍼랜드
 * 사용하는 플래그
 * 명령어가 하는 일에 대한 설명

오퍼랜드에는 명령어에 사용되야할 오퍼랜드 종류를 나열한다. 여러개의 오퍼랜드를 사용할 때는 쉼표를 사용해서 각각의 오퍼랜드를 구분한다.
오퍼랜드를 표시할 때 어떤 오퍼랜드가 사용될 수 있는지 표시하기 위한 약자를 사용한다. 
오퍼랜드 설명에 I가 표시되면 상수값을, R은 레지스터를, M은 메모리 주소를 오퍼랜드로 사용한다는 뜻이다.
예를 들어 movl 명령어에는 I/R/M, R/M으로 표시되었는데 첫번째 오퍼랜드에는 모든 값이 사용될 수 있다는 것이고
두번째 오퍼랜드에는 레지스터나 메모리가 사용되어야 한다는 것이다. 
x86 어셈블리에서는 두 오퍼랜드를 모두 메모리 주소로 사용할 수 없다는 것을 주의하자.

플래그 칸에는 명령어의 실행 결과에 따라 변할 수 있는 플래그를 보여준다. 다음의 플래그들을 표시한다.

'''O'''
오버플로우 플래그. 목적 오퍼랜드가 명령의 실행 결과를 저장할 수 있는 정도로 크기가 충분하지 못할 때 참이 된다.

'''S'''
부호 플래그. 최종 결과의 부호를 나타낸다.

'''Z'''
제로 플래그. 연산 결과가 0이 되면 참이 된다.

'''A'''
추가 캐리 플래그. 3번째 비트와 4번째 비트 사이에 캐리나 버로우가 생겼을 때 참이 된다. 자주 사용되지는 않는다.

'''P'''
패리티 플래그. 연산 결과에서 1인 비트가 짝수개일 때 참이 된다.

'''C'''
캐리 플래그. 여러개의 바이트를 이용해서 덧셈을 하는 등의 경우에 특정 바이트의 연산 결과에서 다음 바이트로 캐리가 발생했을 때
사용될 수 있다. 보통 목적 레지스터가 연산 결과를 저장하기에 충분히 크지 못한 경우에 캐리 플래그가 발생한다. 
캐리가 발생한 경우의 처리는 프로그래머가 직접 해주어야 한다. (무시할 수도 있고 다른 바이트의 연산에 전달할 수도 있다.)

다른 플래그들도 있지만 크게 중요하지는 않다.

== 데이터 전송 명령어 ==

이 명령어들은 보통 계산에 사용되지 않고 데이터를 옮길 때 주로 사용된다.

'''Table B-1. 데이터 전송 명령어'''

|| 명령어  |||| 오퍼랜드                 ||||             영향받는 플래그 ||
|| movl    |||| I/R/M, I/R/M          ||||       O/S/Z/A/C              ||
|| 워드 크기의 데이터를 복사한다. movl %eax, %ebx 는 %ebx의 값을 %eax로 복사한다. ||
|| movb   |||| I/R/M, I/R/M          ||||             O/S/Z/A/C        ||
|| movl와 같지만 오퍼랜드가 바이트 크기인 것만 다르다. ||
|| leal       ||||  M, I/R/M              ||||       O/S/Z/A/C              ||
|| 다른 명령어들 처럼 특정 메모리 위치에 있는 값을 읽는 것이 아니라 메모리 주소를 읽어들이게 된다. 예를 들어 leal 5(%ebp, %ecx, 1), %eax는 5+%ebp+1*%ecx로 계산한 주소 값의 메모리를 읽어서 %eax에 저장한다. ||
|| popl      ||||       R/M                |||| O/S/Z/A/C                    ||
|| 스택의 꼭대기에서 값을 꺼내서 지정된 위치에 저장한다. movl (%sp), R/M과 addl $4, %esp 명령으로 스택의 값을 읽고 스택 포인터를 증가시킨 것과 같은 일을 한다. popfl은 popl와 같은 종류의 명령어이고 스택에서 %eflags 레지스터의 내용까지 읽어들이는 일까지 한다. ||
|| pushl     ||||  I/R/M                   ||||  O/S/Z/A/C                   ||
|| 주어진 값을 스택에 저장한다. subl %4, %esp와 movl I/R/M, %(esp) 명령을 실행한 것과 같다. pushfl은 pushl과 같은 일을 하는데 %eflag 레지스터를 스택에 저장하는 일까지 하는 명령어이다. ||
|| xchgl     |||| R/M, R/M               ||||  O/S/Z/A/C                    ||
|| 오퍼랜드로 주어진 값을 서로 바꾼다. ||

== 정수 연산 명령어 ==

부호가 있는 정수나 없는 정수를 가지고 계산을 하는데 사용되는 명령어들이다.

'''Table B-2. 정수 연산 명령어'''

|| 명령어  |||| 오퍼랜드                 ||||             영향받는 플래그 ||
|| adcl    |||| I/R/M, R/M               |||| O/S/Z/A/P/C                 ||
|| 캐리까지 포함해서 덧셈을 한다. 두개의 오퍼랜드와 캐리 비트까지 더해서 오버플로우가 발생하면 캐리와 오버플로우를 셋팅한다. 보통 프로세서의 워드 크기보다 큰 값을 연산할 때 사용한다. 제일 낮은 자리의 덧셈만 addl을 쓰고 다른 자리들은 adcl을 쓰게 된다. 그러면 낮은 자리의 덧셈에서 자리 올림이 전달된다. 보통은 addl만 사용해도 충분하다. ||
|| addl     |||| I/R/M, R/M              |||| O/S/Z/A/P/C                 ||
|| 덧셈 연산을 한다. 첫번째 오퍼랜드와 두번째 오퍼랜드를 더해서 두번째 오퍼랜드에 저장한다. 계산 결과가 레지스터보다 크면 오버플로우나 캐리 비트가 설정된다. 이 연산자는 부호 있는 정수나 없는 정수 모두 계산할 수 있다. ||
|| cdq      ||||                          |||| O/S/Z/A/P/C            ||
|| %eax에 저장된 워드 값을 %edx:%eax 에 저장되는 더블 워드 값으로 확장시켜준다. q라고 써진 것은 quad-word 즉 4개의 워드를 의미하는 것인데 16비트를 한 워드로 생각했을 때 정해진 이름이므로 64비트를 말하는 것이다. 보통 idivl 명령어 바로 직전에 사용한다. ||
|| cmpl  |||| I/R/M, R/M |||| O/S/Z/A/P/C ||
|| 두 정수를 비교한다. 두번째 오퍼랜드에 첫번째 오퍼랜드를 뺀 결과를 이용해서 크기를 비교한다. 보통 조건부 점프를 위해 사용한다. ||
|| decl |||| R/M |||| O/S/Z/A/P ||
|| 레지스터나 메모리에 있는 값을 1씩 감소시킨다. 바이트 크기의 값을 감소시킬 때는 decb를 사용한다. ||
|| divl ||||  R/M  |||| O/S/Z/A/P ||
|| 부호 없는 정수의 나눗셈을 한다. %edx:%eax 두개의 레지스터에 저장된 더블 워드 값을 레지스터나 메모리에 저장된 값으로 나눈다. %eax에는 몫이 저장되고 %edx에는 나머지가 저장된다. 몫이 너무 커서 %eax에 저장할 수 없으면 0번 인터럽를 발생시킨다. ||
|| idivl |||| R/M  |||| O/S/Z/A/P ||
|| 부호 있는 정수의 나눗셈을 한다. 그 외에는 divl과 같다. ||
|| imull |||| R/M/I, R |||| O/S/Z/A/P/C ||
|| 부호 있는 정수의 곱셈을 하고 결과 값을 두번째 오퍼랜드에 저장한다. 두번째 오퍼랜드를 지정하지 않으면 %eax가 두번째 오퍼랜드라고 인식하고 계산하며 결과 값을 %edx:%eax에 더블 워드 크기로 저장한다. ||
|| incl |||| R/M |||| O/S/Z/A/P ||
|| 지정된 레지스터나 메모리 위치에 있는 값을 증가시킨다. incb는 바이트 크기의 값을 증가시킨다. ||
|| mull |||| R/M/I, R |||| O/S/Z/A/P/C ||
|| 부호 없는 정수의 곱셈을 한다. 그 외에는 imull와 같다. ||
|| negl |||| R/M |||| O/S/Z/A/P/C ||
|| 지정된 레지스터나 메모리의 값의 부호를 바꾼다. 결과적으로 2의 보수 값을 계산하는 일을 한다. ||
|| sbbl |||| I/R/M, R/M |||| O/S/Z/A/P/C ||
|| 자리 내림 (버로우)까지 이용하여 뺄셈을 한다. adc와 단지 뺄셈을 한다는 것뿐 같은 방식으로 사용하면 된다. 보통 subl이 사용된다. ||
|| subl |||| I/R/M, R/M |||| O/S/Z/A/P/C ||
|| 두번재 오퍼랜드에 첫번째 오퍼랜드의 값을 빼서 두번째 오퍼랜드에 저장한다. 부호가 있거나 없는 정수 모두 사용될 수 있다. ||

== 논리 연산자 ==

이 명령어들은 워드 단위의 값이 아니라 비트 단위의 값을 처리하는데 사용된다.

'''Table B-2. 정수 연산 명령어'''

|| 명령어  |||| 오퍼랜드                 ||||             영향받는 플래그 ||
|| andl |||| I/R/M, R/M |||| O/S/Z/P/C ||
|| 논리 연산 AND를 한다. 결과 값은 두번째 오퍼랜드에 저장된다. 오버플로우와 캐리 플래그를 클리어한다. ||
|| notl |||| R/M ||||  ||
|| 논리 연산 not을 한다. 오퍼랜드로 지정된 값에서 각 비트를 반전시킨다. 1의 보수 값이 된다. ||
|| orl |||| I/R/M, R/M  |||| O/S/Z/A/P/C ||
|| 두 오퍼랜드를 가지고 OR 연산을 하고 결과 값을 두번째 오퍼랜드에 저장한다. 오버플로우와 캐리 플래그를 클리어한다. ||
|| rcll |||| I/%cl, R/M  ||||  O/C ||
|| 두번째 오퍼랜드의 각 비트를 왼쪽으로 회전시킨다. %CL 레지스터의 값이나 상수 값만큼 회전을 시킬 수 있다. 캐리 플래그도 함께 회전되므로 32비트가 아니라 33비트가 회전하게 된다. 오버플래그에 영향을 준다. ||
|| rcrl |||| I/%cl, R/M  |||| O/C ||
|| 위의 rcll과 같은데 회전 방향이 오른쪽이다. ||
|| roll |||| I/%cl, R/M ||||  O/C ||
|| 왼쪽으로 비트를 회전시키는데 rcll처럼 캐리 플래그까지 회전시키지는 않는다. 얼마나 회전할 지는 %CL 레지스터나 상수 값으로 지정할 수 있다. ||
|| rorl |||| I/%cl, R/M  ||||  O/C ||
|| roll과 같고 오른족으로 회전한다. ||
|| sall |||| I/%cl, R/M  |||| C  ||
|| Arithmetic shift left이다. 비트를 왼쪽으로 이동한다. Arithmetic shift left라는 말은 수학적인 특성을 유지하는 쉬프트 연산이라는 의미이다. 따라서 부호 비트는 계속 유지된다는 말이다. 부호 비트로 사용된 최상위 비트는 캐리 플래그 값으로 이동하고, 최하위 비트에는 0이 들어온다. 그 외의 비트들은 왼쪽으로 이동하기만 한다. 얼마나 이동할지는 %CL 레지스터나 상수값으로 지정한다. ||
|| sarl |||| I/%cl, R/M |||| C ||
|| sall과는 반대로 최하위 비트가 캐리 플래그로 넘어가고 기타 비트들은 오른쪽으로 이동한다. 부호 비트도 오른쪽으로 이동하고 빈 자리에는 같은 비트 값이 채워진다. %CL 레지스터나 상수 값으로 몇 비트 이동할지를 지정한다. ||
|| shll  |||| I/%cl, R/M  |||| C ||
|| 가장 왼쪽에 있는 비트는 캐리 플래그로 넘겨지고 모든 비트가 왼쪽으로 이동한다. 부호 비트는 무시되고 빈 자리에는 0이 채워진다. %CL 레지스터나 상수 값으로 얼마나 이동할지를 지정한다. ||
|| shrl  |||| I/%cl, R/M  |||| C ||
|| 모든 비트를 오른쪽으로 옮기고 빈 자리는 0을 채운다. 부호 비트는 상관하지 않는다. 가장 오른쪽에 있던 비트는 캐리 플래그로 넘겨지고 %CL 레지스터나 상수 값으로 지정된 만큼 이동한다. ||
|| testl |||| I/R/M, R/M  |||| O/S/Z/A/P/C ||
|| AND 논리 연산을 수행하지만 결과 값을 저장하지는 않는다. 단시 결과 값에 따라 플래그를 설정하기만 한다. ||
|| xorl |||| I/R/M, R/M  ||||  O/S/Z/A/P/C ||
|| 두 오퍼랜드를 가지고 XOR 연산을 하고 결과 값을 두번째 오퍼랜드에 저장한다. 오버플로우와 캐리 플래그를 클리어한다. ||

== 흐름 제어 명령어 ==

이 명령어들은 프로그램의 흐름을 바꿀 때 사용된다.

'''Table B-4. 흐름 제어 명령어'''

|| 명령어  |||| 오퍼랜드                 ||||             영향받는 플래그 ||
|| call |||| destination address |||| O/S/Z/A/C ||
|| 스택에 이 명령어 다음에 있는 명령어의 주소를 저장하고 타겟 주소로 점프한다. 이 명령어는 함수를 호출하는데 사용되는 명령어이다. *%eax와 같이 *을 앞에 붙이면 간접 주소 참조를 한다. 즉 call *%eax와 같이 사용하면 레지스터에 저장된 주소를 읽고 그 주소에 있는 함수로 점프하게 된다. ||
|| int  |||| I ||||  O/S/Z/A/C ||
|| 정해진 번호의 인터럽트를 실행하게 된다. 시스템 콜이나 커널 인터페이스를 호출하는데 주로 사용된다. ||
|| Jcc    ||||  destination address  ||||  O/S/Z/A/C ||
|| 조건부 점프를 한다. cc는 condition code라는 말인데 특정 조건이 만족해야만 정해진 주소로 점프한다는 뜻이다. 물론 이 명령어 이전에 비교를 하거나 해서 어떤 조건을 검사해야 한다. 조건이 맞지 않으면 그냥 다음 명령어를 실행한다. 사용되는 조건들은 다음과 같다. ||
|| * [n]a[e] - 부호없이 크기가 클 때. n은 not을 의미해서 이 조건이 만족하지 않을 때를 말하고 e는 크거나 같을 때를 말한다. ||
|| * [n]b[e] - 부호없이 크기가 작을 때 ||
|| * [n]e - 같을 때 ||
|| * [n]z - 0일 때 ||
|| * [n]g[e] - 부호까지 고려해서 크기가 클 때 ||
|| * [n]l[e] - 부호를 고려해서 크기가 작을 때 ||
|| * [n]c - 캐리가 발생했을 때 ||
|| * [n]o - 오버플로우가 발생했을 때 ||
|| * [p]p - 패리티 조건이 참일 때 ||
|| * [n]s - 부호가 양수 일때 ||
|| * ecxz - %ecx 레지스터가 0일 때 ||
|| jmp |||| destination address |||| O/S/Z/A/C ||
|| 무조건 점프한다. 단순히 %eip 레지스터를 지정된 주소로 바꾸기만 한다. *를 쓰면 간접 주소 지정을 하게 된다. 예를 들어 jmp *%eax라고 하면 %eax의 값을 주소로 읽어서 해당 주소에 저장된 값으로 점프한다. ||
|| ret ||||    |||| O/S/Z/A/C ||
|| 스택에서 값을 꺼내서 %eip에 저장한다. 함수 호출이 끝난 후 되돌아오는 일을 한다. ||

== 어셈블러 지시어 ==

지시어는 명령어들처럼 프로세서에게 명령하는 것이 아니라 어셈블러와 링커에게 명령하는 것이다. 어셈블러가 코드를 정확하게 어셈블하도록 돕거나 어셈블러를 사용하기 쉽게 해주는 일을 한다.

'''Table B-5. 어셈블러 지시어'''

|| 명령어  |||| 오퍼랜드                 ||||             
|| .ascii  |||| QUOTED STRING ||
|| 따옴표 안에 써진 문자열을 바이트 단위로 저장한다. ||
|| .byte ||||  VALUES ||
|| 콤마로 여러개의 값들을 쓰면 바이트 크기의 데이터로 저장한다. ||
|| .endr  ||
|| .rept 로 반복하도록 지정된 구역의 끝을 나타낸다. ||
|| .equ |||| LABEL, VALUE ||
|| LABEL을 VALUE로 지정된 값으로 정의한다. 이 값은 문자나 숫자가 될 수도 있고 문자나 숫자를 이용한 표현식이 될 수도 있다. 레이블이 지정된 값으로 바뀐다고 생각하면 된다. ||
|| .globl  ||||  LABEL ||
|| 지정된 레이블을 전역적으로 선언한다. 따라서 다른 파일에서도 사용할 수 있게 된다.
|| .include  ||||  FILE  ||
|| 지정된 파일을 코드에 포함시킨다. 마치 지정된 파일이 선언된 위치에 합쳐진 것같이 된다. ||
|| .lcomm  ||||  SYMBOL, SIZE ||
|| .bss 섹션 안에서 프로그램이 실행될 때 할당되는 메모리 영역을 지정한다. 특정 메모리 주소에 할당하도록 선언하면 지정된 크기만큼 할당되는 것을 확인할 수도 있다. ||
|| .long  ||||  VALUES ||
|| 콤마로 여러개의 수를 지정하면 4바이트 단위 워드 크기로 저장한다. 프로그램 안에서 숫자들이 선언된 그 위치에 데이터를 저장하게 된다. ||
|| .rept  ||||  COUNT ||
|| .rept와 .endr 지시어 사이에 있는 어떤 것이든지 지정된 수만큼 반복한다. ||
|| .section   ||||  SECTION NAME  ||
|| 섹션을 지정한다. 보통 섹션이란 .text (코드 섹션), .data (프로그램 파일 안에 저장된 데이터), .bss (초기화되지 않은 전역 데이터) 를 말한다. ||
|| .type  ||||  SYMBOL, @function  ||
|| 링커에게 지정된 SYMBOL이 함수라는 것을 알려준다. ||


==  이 책 외의 다른 문법들과 사용되는 용어들 ==

이 책에서 사용되는 어셈블리 언어는 AT&T 문법이라고 불린다. GNU 툴들이 지원하고 있어서 거의 모든 리눅스의 표준같이 되었다. 그러나 x86 어셈블리 언어의 공식 문법은 Intel 문법이라고 알려져있는 문법이다. 같은 플랫폼에서 사용되는 같은 어셈블리 언어지만 보기에는 달라보인다. 그 차이점은 다음과 같다.

 * 인털 문법에는 명령어의 오퍼랜드가 반대로 되어있다. 목적 오퍼랜드가 소스 오퍼랜드보가 앞에 온다.
 * 인텔 문법에는 레지스터 이름 앞에 %를 붙이지 않는다.
 * 인텔 문법에는 상수 앞에 $를 붙이지 않는다. 대신에 상수가 아닌 주소 값은 [] 앞에 쓴다.
 * 인텔 문법에는 명령어에 옮겨야 할 데이터의 크기를 쓰지 않는다. 그래서 좀 애매한 경우가 있으므로 명령어 다음에 BYTE, WORD, DWORD같이 데이터의 크기를 표시해준다.
 * 메모리 주소를 표현하는 방법이 완전히 다르다.
 * x86 프로세서들은 16비트에서 시작했기 때문에 16비트 값을 한 워드라고 부르고 32비트를 더블 워드라고 부란다. 그러나 워드라는 말은 프로세서가 가진 레지스터의 크기를 가르키는 말이므로 x86 프로세서에서는 32비트가 되야 한다. 따라서 인텔 문법에서는 더블 워드를 나타내는 DWORD가 우리가 워드라고 부르는 32비트 크기를 말하는 것이다.
 * 인텔 어셈블리 언어는 세그먼트/오프셋으로 메모리 주소를 지정할 수 있다. 하지만 리눅스에서는 세그먼트를 사용하지 않고 일반적인 리눅스 프로그래밍에서 사용되지 않으므로 이 책에서는 이런 메모리 주소 지정에 대해 설명하지 않았다. 

다른 차이점들이 있지만 큰 것은 아니다. 다음 명령을 보면 차이점을 알 수 있을 것이다.

mobl %eax, 8(%ebx, %edi, 4)

이것을 인텔 문법으로 쓰면 다음과 같다.

mov [8+ebx+1*edi], eax

주소 계산이 직관적으로 표현되므로 메모리 표현이 조금 더 쉬워진다. 그러나 인텔 문법에서는 오퍼랜드가 순서가 혼란스러울 수 있다.

