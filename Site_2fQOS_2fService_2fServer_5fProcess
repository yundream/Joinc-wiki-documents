#title QOS - HTTP Submit Process

다음과 같은 2가지 사항에 대해서 체크한다면, 웹서비스에 대한 기본적인 품질 체크는 가능할 것이다.
  1. 페이지 응답체크
  1. 페이지 응답시간
=== Submit Process ===
여기에 덧붙여서 Submit Process까지 체크한다면, 더 나은 품질 모니터링 환경을 만들 수 있을 것이다.

어떤 웹서비스가 제대로 작동하는지 확인하고 싶을 경우, POST(:12) 혹은 GET(:12)으로 연결된 몇개의 페이지를 연결해서 검사해야할 필요가 있다. 예를 들어서 로그인을 위해서 OpenID(:12)를 사용한다고 가정해보자. 

기존의 로그인 방식이라면, 로그인관련 데이터가 로컬에 있으니, 로그인데이터를 관리하는 DB시스템이 제대로 살아있는지만 확인할 수 있으면 되었다. 그러나 OpenID와 같은 경우에는 로컬 DB를 이용하는게 아닌, '''로그인 서비스'''를 이용하는 방식이기 때문에 실제 Submit을 해서 다음 페이지로 넘어가는지를 확인해 주어야 한다.

Submit 프로세스를 체크하기 위해서는 HTTP(:12)와 POST(:12), GET(:12)을 이용한 데이터 전달방식 그리고 cookie(:12)에 대해서 알고 있어야 할것이다. 여기에서는 그냥 wget(1)을 이용해서 간단하게 처리하는 방법에 대해서 알아보도록 하겠다.

{{{#!plain
# wget --load-cookies=cookies.txt --save-cookies=cookies.txt \
--post-data 'uname=myid&pass=mypass&op=login' \
'http://www.domain.com/auth.php'  -O /dev/null
}}}
아주 간단하다. --post-data 옵션을 이용하면, 해당 페이지에 POST 데이터를 넘길 수 있다. POST 데이터를 받은 웹서버는 인증과정을 거친 후, 그 결과를 Cookie로 클라이언트에 전달하고, 이후의 인증 세션유지는 cookie 값의 교환으로 이루어지게 된다. --save-cookies 옵션을 이용하면, 서버로 부터 넘어온 cookie 값을 파일에 저장할 수가 있다. 이제 --load-cookies 옵션을 이용해서 해당 웹페이지를 호출할 때, 쿠키도 같이 보내면 된다.

위의 명령을 쉘스크립트(:12) 형태로 만들어서 주기적으로 실행하고, 그 결과를 분석하는 걸로, 간단하게 Submit Process에 대한 체크를 할 수 있다. C(:12) 언어가 마음에 든다면, fork(:12) & exec(:12)를 이용한 실행코드를 만들어 낼 수도 있을 것이다. 위의 경우는 요청한 페이지정보를 /dev/null 로 보내고 있는데, 로그인 결과까지를 확인하고 싶다면, 입력받은 페이지를 스트링매칭 시키는 방법으로 분석해야 할 것이다.

=== 응답시간 ===
응답시간 역시 wget을 이용해서 간단하게 해결할 수 있다. 더불어 '''-p'''옵션을 사용한다면, 해당 페이지에 링크되어 있는 '''이미지, 사운드, CSS(:12)''' 데이터들의 로딩시간까지 함께 체크할 수 있다. 
{{{#!plain
# wget -p http://www.domain.com/index.php > /dev/null
}}}
