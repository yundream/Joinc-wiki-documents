head	1.5;
access;
symbols;
locks
	root:1.5; strict;
comment	@# @;


1.5
date	2012.11.14.01.20.19;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2012.11.13.15.15.09;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.13.15.12.53;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2012.11.13.13.29.14;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2012.11.13.13.25.51;	author root;	state Exp;
branches;
next	;


desc
@./data/text/man_2f12_2fTDD
@


1.5
log
@183.98.30.10;;yundream;;
@
text
@#title TDD - Test Driven Development

[[TableOfContents]]
== TDD ==
Test-driven development는 소프트웨어 개발 공정으로 매우 빠른 개발 사이클을 반복적으로 진행하는 것을 특징으로 한다.

개발자는 새로운 코드를 만들거나 혹은 (기능 향상을 위한)코드 수정이 있을 때, 먼저 테스트 케이스를 작성한다. 이 테스트 케이스는 자동화된 테스트 도구에 의해서 매 개발 사이클 마다 수행한다. 모든 케이스에 대한 테스트가 끝났다면, 그때 이 코드를 적용하고 하나의 주기를 끝낸다.

따라서 하나의 제품은 여러 단계의 개발 주기를 가지게 된다. 

TDD는 '''Test-driven'''이름에서 알 수 있듯이, 테스트가 주도가 된다. 테스트 자체가 TDD가 아니다. 예를 들어 코드를 다 만든 다음에 테스트 케이스를 만들어서 테스트 하는 것은 TDD가 아니다. 일상적인 단위 테스트일 뿐이다. TDD는 테스트 코드를 먼저 만들고, 그 다음 코드를 만든다. 이렇게 하면 예컨데, 개발을 하는 방법이 바뀐다. 

개발자는 코드를 만들기 전에 테스트를 먼저 작성해야 하는데, 테스트를 하기 위해서는 작동을 해야 한다. 따라서 개발자는 개발 사이클을 작게 가져갈 수 밖에 없다. 개발 사이클을 길게 가져가면 확인안된 테스트 코드의 복잡도가 너무 커져서 제어할 수 없는 상황에 이르게 된다. TDD를 적용하면 개발자는 제어가능한 적당한 복잡도의 테스트 및 실행 가능한 코드를 만들수 밖에 없게 된다. 

또한 TDD는 테스트 자동화를 포함한다. 개발주기를 끝낸 코드는 다음 개발주기에도 여전히 테스트가 된다. 싫든 좋든 개발자는 각 개발단계마다 전체 개발 코드를 리펙토링하게 된다. 이렇게 개발 방법 자체가 바뀌기 때문에 TDD는 개발 방법론 관점에서 접근해야 한다.

=== 왜 풀어줬나 ===
영화 올드보이의 핵심 질문은 "왜 가뒀나"가 아니라 "왜 풀어줬나 ?" 이다. 문제 해결능력보다 문제를 인지하고 문제를 정의하는 능력이 중요하다. TDD를 따르면 자연스럽게  문제를 인지하고 정의하는 능력을 훈련할 수 있다. 

=== 개발 사이클 ===
TDD의 개발 사이클은 다음과 같습니다.

http://upload.wikimedia.org/wikipedia/en/9/9c/Test-driven_development.PNG
==== 테스트 추가 ====
새로운 기능이 추가되면 기능을 테스트하기 위한 코드를 먼저 만든다. 기능이 구현되기 전에 테스트 코드가 먼저 만들어지기 때문에, 테스트는 반드시 실패하게 돼 있습니다. 당연하게도 제대로된 테스트 케이스를 만들려면, 개발자는 추가하려는 기능의 사양과 요구사항을 정확히 이해하고 있어야 합니다.  

==== 테스트를 테스트한다 ====
테스트가 올바로 작동하는지를 테스트 한다. 혹은 빼먹은 테스트가 없는지 검사한다. 테스트는 실패하는 경우와 예외 즉, 부정적인 테스트까지 포함해야 한다.

==== 코드를 만든다 ====
이제 코드를 만든다. 이 코드는 기능 구현 뿐만 아니라 이전에 작성한 모든 테스트 케이스를 통과해야 한다. 이 단계에서는 테스트를 통과하는게 중요할 수 있다. 예컨데, 때때로 단지 테스트만 겨우 통과할 정도의 그다지 우아하지 않은 코드가 만들어질 수도 있음을 의미한다. 다음 단계에서 이 코드를 개선할 것이기 때문에 허용된다. 처음부터 완벽한 코드를 만들지는 않을 것이다. 

==== 테스트 수행. 모든 테스트를 통과할 때까지.. ====
모든 테스트 케이스를 통과했다면, 프로그래머는 테스트 요구사항을 모두 충족했다는 것을 확신할 수 있다. 이제 프로그래머는 다음 단계로 넘어간다. 

테스트는 자동으로 수행돼야 한다. 모든 개발 언어는 테스트 자동화를 위한 툴을 제공한다.

==== 코드 리팩토링 ====
이제 코드를 깔끔하게 정리할 차례다. 개발자는 magic number, 중복 코드등을 제거하고 비효율적인 알고리즘을 개선하는 작업을 한다. 이제 코드는 테스트만을 통과하기 위한 수준이 아니라 기능적으로 효율적으로 혹은 구조적으로 좀 더 우아한 모습을 가지게 될 것이다. 

==== 반복 ====
새로운 테스트를 만들고 앞의 단계들을 반복한다. 

=== 개발 방법 ===
TDD는 개발지침이므로 개발자의 성향이나 수준에 따라서 다양한 방법들이 있을 수 있습니다만, 다음의 원칙들을 바탕에 두어야 한다. 

'''먼저 테스트 코드를 만들어라'''
  어떤 기능을 추가해야 한다면, 반드시 테스트 코드를 먼저 만들어서 테스트를 합니다. 이때 코드는 생각할 수 있는 모든 테스트를 통과할 수 있도록 짜야 합니다. 


'''실패할 수 있는 모든 경우에 대해서 테스트하라'''
  TDD에서 중요한 것은 가능한 실패할 수 있는 경우에 대해서 테스트 하는 겁니다. 성공하는 경우는 뭐 그리 중요할게 없지요. 잘 작동할 테니까요. TDD는 프로그램의 완성도를 높이는 것이지, 정상적인 데이터 입력에 대해서 정상적으로 작동하는 걸 확인하기 위한 게 아니니까요.
   * '''NULL 일때''',
   * 문자열의 끝을 '''만나지 못했을 때''',
   * 문자를 '''찾지 못했을 때''', 찾았을 때
   * 버퍼크기를 초과했을 때
   * 음수일때, '''0일 때''', 양수일 때
   * '''예상 최대 크기를 초과했을 때''', 예상 최소 크기 미만의 값이 들어올 때
   * '''실패했을 때''', 성공했을 때

'''각 주기는 짧아야 한다'''
  테스트 코드는 짧고 간단하게 작성돼야 한다. 테스트 코드가 길어진다는 것은 테스트 범위가 늘어난다는 것을 의미한다. 범위가 늘어나면 복잡도가 증가하게 되고, 테스트 케이스를 빼먹을 수 있다.    

=== 어려움들 ===
모든 function을 테스트하기가 어려울 수 있다. 예를 들어 개발 코드가 socket과 같은 시스템 함수를 호출한다면, 테스트 케이스에 socket 함수가 실패할 경우도 들어가야 한다. 테스트 코드는 실제 socket으로 테스트 할 수 없기 때문에 socket 함수를 시뮬레이션 해야 한다. 데이터 베이스를 사용하는 코드도 마찬가지의 어려움이 있다. 물론 이런 문제를 해결하기 위한 TDD 툴들이 있다. 하지만 익숙해 지려면 노력이 필요하다.

조직의 지원이 필요하다. 조직이 TDD 방식을 도입함으로써 소프트웨어의 품질이 높아질 거란 것에 대해서 동의하지 않는다면, 테스트를 위해서 쓸데없이 시간을 낭비한다고 생각할 것이다.

테스트 코드도 개발자가 개발한다. 따라서 일반 코드 개발에서 찾아볼 수 있는 오류를 가질 수 있다. 예를 들어 개발자는 매개변수를 테스트 하때, 개발자의 관점에서 테스트 케이스를 만들 수 있다. 예를 들어 사람의 나이를 매개 변수로 받는데, 0보다 작은 경우 혹은 255보다 큰 경우의 테스트 케이스를 놓칠 수 있다. 특히 개발자가 요구사항 분석과 개발을 모두 할 경우 이런 문제가 발생할 확률이 높다.

테스트 코드를 만들고 유지하는데 추가적인 비용이 든다. 깨지기 쉬운 테스트 코드가 있다면, 정기적인 테스트에서 잘못된 테스트 오류 메시지가 감지될 수도 있다. 깨지기 쉬운 테스트 코드는 리팩토링 단계에서 가능한 제거해야 한다.

== 참고 문서들 ==
  * [wiki:Site/SoftWare_engineering/TDD C++에 TDD적용] 
  * [wiki:Site/Ruby/Unittest 루비 Unittest]
  * [http://code.google.com/p/tddbook/downloads/detail?name=TDD_PT.pdf 테스트 주도 개발 TDD 실천법과 도구 PDF 문서]

== 히스토리 ==
  * 수정
     * [[Date(2012-11-13T13:29:14)]] : 내부 링크 수정, TDD PDF 문서 링크 수정
     * [[Date(2012-11-13T15:15:09)]] : TDD 사이클을 좀더 자세히. 어려움들 세션 추가 
@


1.4
log
@14.52.44.49;;yundream;;
@
text
@d17 3
@


1.3
log
@14.52.44.49;;yundream;;
@
text
@d78 1
@


1.2
log
@14.52.44.49;;yundream;;
@
text
@d5 1
a5 1
Test-driven development는 소프트웨어 개발 공정으로 매우 빠른 개발 사이클을 반복적으로 진행하는 것을 특징으로 합니다.
d7 1
a7 1
개발자는 새로운 코드를 만들거나 혹은 (기능 향상을 위한)코드 수정이 있을 때, 먼저 테스트 케이스를 작성한다. 이 테스트 케이스는 자동화된 테스트 도구에 의해서 매 개발 사이클 마다 수행합니다. 모든 케이스에 대한 테스트가 끝났다면, 그때 이 코드를 적용하고 사이클을 끝내게 되는 거죠.
d9 1
a9 1
TDD는 '''Test-driven'''이름에서 알 수 있듯이, 테스트가 주도가 됩니다. 테스트 자체가 TDD를 의미하는게 아닙니다. 예를 들어 코드를 다 만든 다음에 테스트 케이스를 만들어서 테스트 하는 것은 TDD가 아닙니다. 그냥 테스트일 뿐이죠. TDD는 테스트 코드를 먼저 만들고, 완전히 테스트를 끝낸 후 이것을 적용합니다.  
d11 1
a11 1
TDD를 생소하게 받아들이는 개발자도 있겠지만, '''기존에 이미 그렇게 해왔는데. 별거 있나 ?'''생각하는 개발자도 있을 것 같은데요. 많은  개발자이 기능을 구현하기 전에, 테스트 코드를 먼저 만들어서 돌려본 다음 문제 없이 돌아가면 그때 코드에 적용하는 방법을 사용하기 때문입니다. 저도 그래왔구요.
d13 1
a13 6
TDD를 적용하기 전의 방식, 그러니까 먼저 테스트 코드를 만들어서 테스트하고 실제 프로그램에 적용하는 방식을 생각해 보죠. 분명 테스트가 주도하긴 하지만 다음과 같은 한계가 있습니다.
  1. 보통 처음 한번 테스트하고 끝냅니다. 
     구현하고자 하는 기능의 컨셉을 테스트하는 수준에서 진행되죠. 지속적으로 테스트가 이루어지지는 않죠. 테스트 케이스를 자동화 하는 경우가 거의 없기 때문인데요. 그래서 다른 기능이 추가될 수록, 점점 더 불안한 코드가 될 수 밖에 없습니다. 모듈이 상호작용하면서 새로운 문제를 만들기 때문이죠. 코딩중에 실수를 할 수 도 있고요.
  1. 프로그램의 흐름을 테스트하지는 않습니다. 
     함수단위로 테스트를 진행하는게 대부분이죠. 프로그램은 여러 개의 함수들이 상호작용하는데, 일반적으로 그 것 까지 테스트하지는 않습니다. 좀 꼼꼼한 개발자는 흐름도 테스트하긴 하지만 제한적이죠. 툴을 가지고 있지 않기 때문입니다.
  1. 테스트 범위가 명확하지 않습니다.
d15 1
a15 1
TDD는 이것을 체계적인 과정으로 정립한거죠. 그래서 개발 방법을 정의하고, 툴들을 제공해서 이 개발 방법을 잘 따를 수 있도록 체계화 했습니다. 
d18 5
a22 3
TDD의 원칙은 다음과 같습니다.
  1. 모든 코드는 테스트 돼야 한다. 
  1. 모든 코드는 모든 사이클에서 테스트 돼야 한다. 
d24 2
a25 1
중요한 것은 두번째 원칙입니다. 첫번째 원칙은 앞서 언급했듯이, TDD 전에도 개발자 나름대로 테스크 코드를 만드는 식으로 적용 해 왔습니다. 두번째 원칙을 지키기가 어려웠는데요. 모든 개발 사이클에서 테스트가 돼지 않으면 아무래도 테스트의 신뢰성이 떨어질 수 밖에 없습니다. 코드가 커질 수록 코드들이 서로 영향을 주기 때문입니다.   
d27 2
a28 1
TDD는 개발 사이클을 짧게 하는 것으로 이 문제를 해결하고 있습니다. 물론 각 개발 사이클마다 테스트가 진행이 되야 합니다. 새로 추가된 테스트 케이스 뿐만 아니라, 이전에 진행됐던 테스트 케이스에 대한 테스트도 중복 진행됩니다. 코드가 증가함에 따라 문제가 확산되거나, 기존 코드에서 새로운 문제가 발생하거나 하는 등의 문제를 막을 수가 있죠. 
d30 4
a33 1
TDD의 개발 사이클은 다음과 같습니다.
d35 2
a36 7
http://upload.wikimedia.org/wikipedia/en/9/9c/Test-driven_development.PNG
  1. 테스트 케이스 별로, 테스트 코드 작성
  1. 모든 테스트 케이스를 통과할 때까지 계속 테스트
  1. 테스트가 끝나면 코드를 제품에 추가한다.
  1. 다시 테스트를 진행. 언제까지 ? 모두 성공할 때까지.
  1. 테스트를 통과 했다면, 코드를 다듬어서 빌드에 적용하는 것으로 사이클 종료
위 단계를 계속 반복합니다.
d38 2
a39 1
위 과정을 반복하면서, 코드는 각 사이클 마다 리펙토링 되기 때문에 품질 역시 따라서 높아집니다. 
d42 1
a42 1
TDD는 개발지침이므로 개발자의 성향이나 수준에 따라서 다양한 방법들이 있을 수 있습니다만, 다음의 원칙들을 바탕으로 방법을 짜야 합니다. 
d45 1
a45 1
어떤 기능을 추가해야 한다면, 반드시 테스트 코드를 먼저 만들어서 테스트를 합니다. 이때 코드는 생각할 수 있는 모든 테스트를 통과할 수 있도록 짜야 합니다. 
d49 1
a49 1
TDD에서 중요한 것은 가능한 실패할 수 있는 경우에 대해서 테스트 하는 겁니다. 성공하는 경우는 뭐 그리 중요할게 없지요. 잘 작동할 테니까요. TDD는 프로그램의 완성도를 높이는 것이지, 정상적인 데이터 입력에 대해서 정상적으로 작동하는 걸 확인하기 위한 게 아니니까요.
d58 12
@


1.1
log
@14.52.44.49;;yundream;;
@
text
@d3 1
d63 1
a63 1
  * [http://www.facebook.com/l.php?u=http%3A%2F%2Fcode.google.com%2Fp%2Ftddbook%2Fdownloads%2Fdetail%3Fname%3DTDD_PT.pdf&h=14d8f 테스트 주도 개발 TDD 실천법과 도구]
d65 3
a67 4
{{{#!comment
글쓴 날 : 2011년 6월 16일 
글쓴 사람 : 윤 상배
}}}
@
