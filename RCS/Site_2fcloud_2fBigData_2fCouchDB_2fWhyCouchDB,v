head	1.6;
access;
symbols;
locks
	root:1.6; strict;
comment	@# @;


1.6
date	2014.07.27.14.49.58;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2014.07.27.14.47.18;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2014.07.27.12.52.26;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2014.07.27.04.04.41;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2014.07.27.03.27.56;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2014.07.26.05.50.44;	author root;	state Exp;
branches;
next	;


desc
@./data/text/Site_2fcloud_2fBigData_2fCouchDB_2fWhyCouchDB
@


1.6
log
@119.64.102.68;;yundream;;
@
text
@#title Why CouchDB

[[TableOfcontents]]
== Why CouchDB ==
아파치 카우치디비(apache couchdb)는 새로운 방식의 데이터베이스 관리 시스템 중 하나다. 이번 장에서는 새로운 데이터베이스 시스템의 필요성과 카우치디비가 만들어진 동기를 함께 살펴보려 한다. 

카우치디비 개발자로서, 나는 카우치디비를 이용하는 것을 기쁘게 생각한다. 이 장에서 나는 왜 내가 카우치디비에 열광하는지를 공유할 것이다. 또한 카우치디비의 schema-free 문서 관리 모델이 다른 일반적인 애플리케이션에 비해서 어떤 장점을 가지는지, 내장된 질의어 엔진이 데이터를 처리하는데 어떤 강점을 보이는지 살펴볼 것이다. 마지막으로 카우치디비의 디자인이 가지는 모듈화와 확장성을 알아보도록 하겠다.  

== 느긋하게 ==
요즘 같은 세상에 느긋하게라고?  개발자의 생산성은 지난 5년 동안 두 배이상 향상됐다. 가장 주요한 이유는 사용하기 쉬운 강력한 툴들의 등장에 있다. 루비 온 레일즈(ROR)가 단적인 예다. ROR은 매우 복잡한 프레임워크지만 아주 쉽게 사용할 수 있다. ROR이 처음 나왔을 때, "5분만에 블로그 만들기"등의 동영상이 유행이었다. ROR의 복잡한 다른 면이 있다는 걸 감안하더라도, 쉽게 시작하기에 좋은 툴임은 분명하다. ROR이 성공한 것은 '''쉬운 사용'''에 촛점을 맞췄기 때문이다. 

카우치디비에 대해서도 마찬가지의 이유로 느긋해도 된다. 웹 개발 경허이 있는 개발자라면, 카우치디비의 개념은 쉽게 이해할 수 있다. 개발자가 아니라도 쉽게 이해할 수 있을 정도다. 
그러니 좀 느긋해도 된다.--난 이 도구들을 이용해서 생산성을 세 배로 늘릴거야 라고 마음먹었다면, 느긋할 수 없겠지만--.  

다른 한편 카우치디비 유저들은 제품을 만드는데 편안함을 느낄 것이다. 만약 이미 운영중인 애플리케이션이 있다면, 카우치디비를 이용해서 여러가지 운영상의 문제를 쉽게 해결할 수 있다. 카우치디비는 fault-tolerant 하도록 설계 됐으며, 실패가 발생하더라도 자연스럽게 처리가 가능하다. 하나의 문제가 다른 문제로 확산되지 않음은 물론이다. 

카우치디비의 개념은 간단하고 쉽게 이해할 수 있다. 운영팀 혹은 개인은 추적할 수 없는 에러들에 때문에 전전긍긍할 필요가 없다. 어느 시스템이나 문제가 있고, 카우치디비 역시 문제가 있을 수 있다. 하지만 문제는 매우 드물게 발생할 것이고, 발생했다고 하더라도 쉽게 문제를 찾아서 해결할 수 있을 것이다.

카우치디비는 트래픽을 쉽게 제어할 수 있다. 예를들어, 웹 사이트에서 급격한 트래픽이 발생하더라도 카우치디비는 (물론 각 요청처리에 대해서 약간의 시간이 더 걸리겠지만) 요청을 무리없이 처리할 테고, 관리자가 원인을 파악해서 대처할 수 있는 시간을 확보해줄 것이다. 많은 경우 관리자가 개입하지 않아도 잘 해결될 것이다.  

앉고 싶으면, 눕고 싶은법. 개발자를 느긋하게 만드는 세번째 영역은 scaling과 관련된 영역이다. 이것은 '''Part 4 Deploying CouchDB'''에서 다룰 것이다.  

== 데이터를 다루기 위한 새로운 모델 ==
당신은 카우치디비를 사용하면서, 문서기반 애플리케이션을 개발하는 전혀 다른 방식을 경험하게 될 것이다. 카우치디비는 직관적인 문서 저장 모델과 강력한 질의 엔진을 사용하다 보면 "왜 카우치디비 전에는 이런식의 접근 모델을 사용하지 않았지 ?"라는 의문을 가지게 될 거다. 

카우치디비는 웹 아키텍처로 부터 자원에 대한 개념, 접근 방법(method), 표현(representation)에 대한 많은 아이디어를 빌려와서 디자인을 했다. 웹에 있는 자원을 접근하는 것과 비슷한 방법으로 데이터를 질의하고 맵합수를 적용하고 조합하고 필터링 할 수 있다. Fault tolerance, 뛰어난 확장성 증분 리플리케이션(incremental replication), 문서형상관리는 덤이다. 

== A Better Fit for common Applications ==
우리는 우리의 사람과 다른 이들의 삶을 개선하기 위해서 소프트웨어를 개발한다. 이러한 일들을 하기 위해서는 연락처, 청구서, 영수증등의 정보를 컴퓨터 애플리케이션을 이용해서 조작해야만 한다. 카우치디비는 우리의 일상생활을 직접 개선해줄 만한 애플리케이션의 개발에 최적화된 도구다. 왜냐하면, 우리가 일상생활에서 사용하는 거의 모든 정보들은 문서기반으로 카우치디비가 특히 잘 처리할 수 있는 정보들이다.    

=== Self Contained Data ===
송장은 그 자체가 하나의 트랜잭션으로 트랜잭션을 완료하기 위한 판매자, 구매자, 날짜, 판매 상품, 서비스 목록 등 모든 정보가 들어있다. 예컨데, 트랜잭션을 완료하기 위해서 다른 데이터를 참조할 필요가 없다. 이런 종류의 데이터를 '''Self contained Data'''라고 한다. 

아래 그림은 self contained 데이터를 묘사하고 있다. 여기에서 각 문서간에 포함된 이름, 주소등은 다른 문서들을 참조할 필요 없이 그 자체로 완성된 정보다. 지금의 송장을 처리하기 위해서 과거의 송장이 필요하진 않으니 말이다. 회계사 입장에서는 개별 문서만 처리하면 되니, 업무 계획도 단순화 할 수 있을 거다.

{{{#!html
<img src="https://docs.google.com/drawings/d/1qO6D_nOY4R9KvIs1DFMhYamYDqqItn5mz244OrAgYMg/pub?w=515&amp;h=230">
}}}

물론 관계형 데이터베이스 처럼 참조를 해서 데이터를 조작하는 방법도 있다. 송장에 들어가는 정보들을 가지는 테이블을 만들어서, 각 송장을 하나의 row에 저장한다. 마찬가지로 연락처정보는 별도의 테이블에 만들어서 동일한 방식으로 저장한다. 연락처정보의 경우 하나의 row에는 "전화번호, 이메일, 이름"을 포함할 것이다. 이렇게 구성을 해도 정보를 처리하는데 전혀 문제가 없다. 

이는 정보처리를 위한 다양한 모델들을 적용할 수 있음을 의미한다. NoSQL은 관계형데이터베이스의 대체재가 아니다. 데이처 처리 모델 중에 하나일 뿐이다. 어떤 정보는 관계형 데이터베이스로 처리하기에 적합하고, 어떤 경우에는 NoSQL 모델(NoSQL내에서도 여러가지 모델이 있다)로 처리하기에 적합하다. 

=== Syntax and Semantics ===
모든 명함은 거의 같은 정보를 포함하고 있다. 명함을 가진 사람의 고유한 이름, 제휴정보, 연락처 등이다. 이 정보의 정확한 형태는 명함에 따라 다를 수 있지만, 전달되는 일반적인 정보는 동일한 형식을 유지한다. 따라서 우리는 서로다른 회사의 명함이라고 하더라도 쉽게 인식할 수 있다. 동일한 패턴을 가지고 있다는 건데, 따라서 우리는 명함을 정형화된 문서로 묘사할 수 있다.   

Jan's의 명함은 전화번호는 포함하고 있지만 팩스번호는 빠져있다. J.chris의 비지니스 카드는 전화번호와 팩스번호를 모두 포함하고 있다. Jan's의 경우 팩스번호가 없긴 하지만 "Fax: None"등으로 표시할 수 있으니, 없는 걸 위해서 무언가를 할 필요는 없다. 예를 들어 "Have Fax: Y/N"필드를 만들 필요는 없다. 

우리는 명함과 같은 실제 문서들이 상당히 많은 문법을 가지고 있다면, 비슷한 구문을 가지고 있다는 걸 알고 있다. 자연은 혹은 사회는 비슷한 구문을 공유하기 때문에, 인간은 이런 류의 정보를 편하게 다룰 수 있다. 

관계형 데이터베이스의 경우 정보를 저장하기 전에 정보의 관계를 모델링해야 하지만 카우치디비는(다른 많은 NoSQL 도구들도 마찬가지) schema-free하게 정보를 모델링할 수 있다. 카우치디비는 나중에 저오를 꺼내는 시점에서 정보를 처리하기 위한 강력한 방법을 제시한다.  

== Building Blocks for Lager System ==
카우치디비는 그 자체를 저장 시스템으로 사용할 수 있다. 당신이 원한다면 개별 애플리케이션에서 저장용도로 카우치디비를 사용할 수도 있을 거다. 그렇지만 기본적으로 카우치디비는 좀 더 큰 데이이터를 처리하기 위한 목적으로 디자인됐다. 카우치디비의 컴포넌트들은 다른 애플리케이션들과는 다른 방법으로 복잡하고 큰 시스템을 구축할 수 있도록 만들어졌다. 

미친듯한 속도로 하지만 안정성도 보장하는 시스템(로깅 시스템 같은)을 구축해야 한다고 가정해 보자. 염두에둬야 할 것은 속도와 안정성을 동시에 보장하는 시스템을 만드는 건 어려운 일이라는 점이다. 안정성을 위해서는 물리적으로 분리된 두 개의 스토리지를 구성해야 하는데, 이렇게 구성하면 성능희생이 따르기 마련이다. 카우치디비를 이용하면 이런 시스템을 구성할 수 있다.

성능과 안정성을 결정하는 몇 개의 요소가 있는데, 이들 요소는 상호 영향을 미친다. 한쪽 영역이 더 잘 작동하도록 설정하면, 다른 영역에 (보통 나쁜 방향으로)영향을 미친다. 닫힌계에서 한쪽의 엔트로피를 낮출려면, 다른 쪽의 엔트로피를 증가시키는 수 밖에 없는 거다. 요약하자면 '''공짜 점심은 없다.'''. 데이터베이스와 관련된 이들 요소의 상관관계가 성능과 안정성에 미치는 영향은 '''CAP 이론'''으로 정리된게 있다. CAP 이론과 관련된 건 [wiki:Site/cloud/BigData/CouchDB/EventualConsistency Eventual Consistency] 문서를 읽어보기 바란다. 

아래 그림은 지연(latency)을 줄이기 위해서 참고 할만 하다. 지연에 영향을 미치는 요소는 '''Throughput(처리 량)과 Concurrency(동시요청)다. 처리량을 늘릴려면 동시요청을 늘리면된다. 대신 응답 지연이 발생할 것이달 이야기다. 결국 처리량을 늘리겠다고 마음을 먹었다면, 응답 지연을 관리하기 위한 장치도 함께 마련해야 한다.

http://guide.couchdb.org/draft/why/02.png

아래 그림은 Scale-out을 위해 참고 할만 하다. 

http://guide.couchdb.org/draft/why/03.png

카우치디비는 시스템에서 발생하는 스케일링 문제를 해결하기 위한 다양하고 간단한 방법들을 제공한다.  

=== 카우치디비 리플리케이션 ===
스케일링을 위해서 가장 쉽게 선택할 수 있는 방법은 데이터를 복제(replication)하는 거다. 카우치디비 역시 복제 기능을 지원한다. 복제는 카우치디비 데이터베이스를 두 개 이상의 동일한 셋으로 구성하는 기능이다. 별 것 아닌 기능인 것 같지만, 단순 복제만으로도 많은 문제를 해결할 수 있다. 데이터를 물리적으로 분리된 여러개의 컴퓨터에 안정적으로 중복 저장할 수 있다. 유저 요청을 분산하길 원한다면 카우치디비 클러스터를 구성하면 된다. 클러스터를 구성하면, 유저 요청은 클러스터를 구성하는 각각의 카우치디비 노드로 분산된다. 물리적으로 멀리 떨어진 지역에 서비스 하려고 할 때, 리플리케이션은 큰 도움을 준다. 뉴욕과 도쿄에 데이터를 서비스해야 한다고 가정해보자. 복제된 데이터를 각각의 지역에 둔다면 원할한 서비스가 가능할 것이다.   

카우치디비 리플리케이션은 [wiki:man/12/rest REST API]를 이용해서 구성할 수 있다. 카우치디비에 있어서 [wiki:Site/Network_Programing/AdvancedComm/HTTP HTTP]는 일종의 유비쿼터스 툴이라고 할 수 있겠다. 리플리케이션은 incrementally하게 작업한다. 이것이 의미하는 바는 다음과 같다. 만약 네트워크 연결 문제등으로 리플리케이션에 문제가 생겼다면, 네트워크가 연결된 나중 시점에 동기화를 위해서 필요한 데이터를 전송한다. 

카우치디비는 (네트워크 연결을 비롯해서) 모든 것이 잘못 될 수 있다는 걸 가정하고 디자인을 했다. 그리고 에러가 발생했을 때, 원만히 해결할 수 있는 방안들을 개발했다. 리플리케이션 시스템을 incremental 하게 디자인한 것은 최고의 선택이다. 이유는 모든 것은 실패하는 방향으로 움직이기 때문이다. 이러한 생각은 분산 컴퓨팅에 대한 착오(Fallacies of distributed Computing)에 잘 나타난다.    
  1. 네트워크는 안전하다. 
  1. 지연은 0이다.
  1. 무한한 대역폭을 가지고 있다.
  1. 네트워크는 안전하다.
  1. 토폴로지는 변하지 않는다. 
  1. 하나의 관리자만 있다.
  1. 전송비용은 0이다.
  1. 네트워크는 단일(homogeneous)하다. 
현실은 위의 가정이 완전히 착오라는 걸 알려준다. 종종 위의 사실들 중 몇개 혹은 전부가 없는 것 처럼 혹은 해결 가능한 것으로 가정하고 만든 툴들이 있다. 결과적으로 이러한 현실부정은 심각한 문제를 발생하게 한다. 반면 카우치디비는 위의 가정들이 모두 착오라는 걸 받아들인다. 그냥 오류로 받아들인다는 이야기다. 중요한 것은 오류를 정상적으로 처리 할 수 있다는 것, 그리고 정상적으로 처리됐다는 걸 알 수 있다는 것이다. 

== 로컬 데이터가 왕이다 ==
카우치디비는 웹으로 부터 몇 가지 중요한 교훈을 얻어서 개발했다. 하지만 웹으로 부터 개선한 것도 있는데 '''지연(latency)'''가 바로 그것이다.

애플리케이션이 웹 서버로의 연결을 기다리고 응답을 기다릴 때, 웹 사이트 랜더링을 기다릴 때, 우리는 항상 더 빨리 이 모든 것이 끝났으면 하는 바램을 가진다. 몇 초를 기다리는 대신 밀리세컨드를 기다리게 하는 것은 유저 경험과 만족도에 큰 영향을 미친다.

오프라인일 때는 어떤 일이 벌어질까 ? 여러가지 이유로 오프라인이 될 수 있다. 케이블 사업자에 문제가 생기거나 아이폰, 안드로이드에 문제가 생길 수 있다. 오프라인까지는 아니지만 불안정한 네트워크 환경 때문에 사실상 오프라인에서 작업해야 하는 경우도 있다. 이 경우 우리가 할 수 있는 일은 아무 것도 없다.    

카우치디비는 이러한 문제들을 잘 해결하고 있으며, 문제해결 방법이 스케일링에 중요한 영향을 미친다. 

아이폰에 카우치디비가 설치돼 있다고 가정해보자. 아이폰이 네트워크에 연결되면, 중앙 데이터 저장소와 데이터 동기화를 시작할 것이다. 데이터 동기화는 몇 초가 걸릴 수도 있지만, 백그라운드 작업이기 때문에 대부분의 경우 사용자 경험에 영향을 미치지 않는다. 모바일 애플리케이션은 로컬 카우치디비로 데이터를 가져와서 작업을 하기 때문에, 원격 네트워크 환경을 필요로 하지 않는다. 로컬인 만큼 낮은 네트워크 지연을 유지할 수 있다. 
@


1.5
log
@119.64.102.68;;yundream;;
@
text
@d73 1
a73 1
카우치디비 리플리케이션은 '''REST API'''를 이용해서 구성할 수 있다. 카우치디비에 있어서 HTTP는 일종의 유비쿼터스 툴이라고 할 수 있겠다. 리플리케이션은 incrementally하게 작업한다. 이것이 의미하는 바는 다음과 같다. 만약 네트워크 연결 문제등으로 리플리케이션에 문제가 생겼다면, 네트워크가 연결된 나중 시점에 동기화를 위해서 필요한 데이터를 전송한다. 
@


1.4
log
@119.64.102.68;;yundream;;
@
text
@d75 10
a84 1
카우치디비는 (네트워크 연결을 비롯해서) 모든 것이 잘못 될 수 있다는 걸 가정하고 디자인을 했다. 그리고 에러가 발생했을 때, 원만히 해결할 수 있는 방안들을 개발했다. 리플리케이션 시스템을 incremental 하게 디자인한 것은 최고의 선택이다. 
d87 1
d89 7
a95 1
== 정리 ==
@


1.3
log
@119.64.102.68;;yundream;;
@
text
@d68 1
d71 5
@


1.2
log
@119.64.102.68;;yundream;;
@
text
@d60 9
@


1.1
log
@119.64.102.68;;yundream;;
@
text
@d3 1
d34 31
a64 1
아래 그림은 self contained 데이터를 묘사하고 있다. 
@
