#title Interface

== Interface n. ==
(!) inter- 와 face가 결합된 단어로 표면이라는 뜻을 가진 face와 각 물체를 연결할 때 두 물체 사이(間)를 의미하는 inter- 접두사의 합성어.

== 소프트웨어 인터페이스 ==
소프트웨어영역에서는 '''자기 내부에서 외부의 데이터를 받아들일 수 있도록 이어주는 추상화된 수용객체'''로 해석할 수 있다. 사전적 의미로는 경계면, 공유 영역, 이종간의 의사 소통, 조화시키다, 조정하다 등의 의미가 있다. 일반적으로 환경에 능동적으로 반응하는 생물은 외부의 데이터를 받아들이기 위한 인터페이스를 가진다. 예컨데, 주변의 모습을 재현하기 위해서, 인간은 '''눈'''이라는 인터페이스를 이용해서 '''광선'''을 받아들인다. 광선은 데이터가 되며, 눈으로 받은 광선정보는 두뇌에서 구체적인 형태로 재현된다. 정보를 수용한다는 의미에서 때때로 '''수용기'''라고 부르기도 한다.

컴퓨터에서는 서로 다른 명령체계를 가진 명령처리기 사이에서 명령을 전달하는 역할을 한다. 가장 흔히 볼 수 있는 인터페이스로 User Interface를 들 수 있다. 사용자와 OS 사이에서 명령과 결과를 전달하는 UI는 키보드의 키 눌림과 마우스의 움직임을 이용해 사용자의 의사를 OS에 전달하고 OS가 처리한 결과를 사용자에게 되돌려주는 역할을 한다. 그 외에도 Device Driver와 Application 사이에서 Application의 명령을 전달하고 Driver에서 처리된 결과를 되돌려 준다던지 하는 역할도 모두 인터페이스라고 볼 수 있다. 전자공학에서는 칩과 칩 사이의 배선, 배선에 연결된 끝단의 소자들을 추상적으로 말할 때 인터페이스라고 한다.

시스템 프로그램을 작성할 경우, 프로그래머는 운영체제(:12)와 대화를 할 필요가 있다. 이러한 대화는 system_call(:12)을 통해서 이루어지며, 이때 system call이 운영체제와 프로그래머(:12) 간의 인터페이스 역할을 한다. 넓은 의미로 프로그래밍시에 사용되는 모든 system call과 응용 라이브러리(:12)를 프로그래밍(인터페이스)라고 할 수 있다.
{{{#!plain
                  Interface/데이터 입출력
 +----------+       +-------------+       +------------+
 | 운영체제 |<----->| System Call |<----->| 프로그래머 |
 +----------+       +-------------+       +------------+
}}}

== 객체지향에서의 인터페이스 ==
객체지향에서의 인터페이스는 약간 다른관점에서 바라보는게 이해에 도움이 될 것 같다. 객체지향(:12)에서 인터페이스는 실세계에서의 methaphors(은유)와 비슷하다. 은유는 내부의 의미를 숨긴상태로 '''외연'''만을 제공한다. 사람에게 보여지는 것은 '''외연'''이며, 이를 보고 내부의 의미를 파악하게 된다. 은유의 잇점은 다양한 사람에게 다양한 의미를 전달할 수 있다는데 있다. 외연을 보고 의미를 파악하는 과정 즉 해석과 재현은 인간의 두뇌에서 일어나는 일인데, 해석과 재현의 방법은 사람마다 다르기 때문이다. 

객체지향에서의 인터페이스는 은유의 다른 이름이다. 인터페이스는는 단지 메서드의 외형적인 모습만을 가지고 있을 뿐이다. 실구현은 인터페이스를 상속(:12)받아서 이루어진다. 얻을 수 있는 잇점은 필요에 따라서 다양한 구현을 할 수 있다는 점이 될 것이다.

환타지 세계의 군인을 예로 들어보자. solider interface는 군인의 외연만을 제공한다. 즉 attack, defense, cure가 될 것이다. 실제 구현은 이 인터페이스를 상속받아서 이루어진다. 만약 '''전사'''를 만들기로 했다면, attack은 '''칼공격''', defense는 '''방패막기'''를 하도록 구현될 것이다. 반면 '''마법사'''를 만들기로 했다면 attack는 '''화염구'''나 '''냉기돌풍'''이 될 것이고, 방어는 '''얼음방패 소환'''등이 이루어지도록 구현할 수 있을 것이다.

Interface는 체계적인 설계가 가능하도록 하며, 인터페이스가 만들어진 이유를 알고 있다면, 각 개발자들간의 원할한 커뮤니케이션이 가능하게 한다. 전사 개발자와 마법사 개발자가 다른 것에 신경스지 않고, 독립적으로 개발하능한 환경을 만들어준다. 

=== C++ 에서의 Interface ===
C++은 메서드를 virtual로 선언해서 구현할 수 있다.
{{{#!plain
class soldier
{
	public:
		virtual void attack()=0;
		virtual void defense()=0;
		virtual void cure()=0;
};

class fighter:public soldier
{
	public:
		fighter(){cout << "I'm Fighter" << endl;}
		void attack(){ cout << "칼 공격" << endl; }
		void defense(){ cout << "방패 막기" << endl;}
		void cure(){ cout << "붕대질" << endl;}
};

class magician:public soldier 
{
	public:
		magician(){cout << "I'm magician" << endl;}
		void attack(){ cout << "마법 공격" << endl; }
		void defense(){ cout << "얼음방패 시전" << endl;}
		void cure(){ cout << "힐링 마법 시전" << endl;}
};
}}}

=== Java ===
자바에서는 '''interface'''를 이용해서, 인터페이스 객체를 생성할 수 있다. C++ 예제의 Java(:12) 버전이다.
{{{#!plain
interface solider {
	public void attack();
	public void defense();
	public void cure();
}
class fighter implements solider
{

	@Override
	public void attack() {
	}

	@Override
	public void cure() {
		
	}

	@Override
	public void defense() {
		
	}
	
}
}}}
