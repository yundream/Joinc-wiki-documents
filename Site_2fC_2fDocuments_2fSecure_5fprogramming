#title Secure Programming for Linux and Unix HOWTO

  * [wiki:Site/Ebook/Books/Secure_Programming_for_Linux_and_Unix_HowTO Ebook 문서 다운로드]

{{{#!html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Secure Programming for Linux and Unix HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><META
NAME="KEYWORD"
CONTENT="secure programming"><META
NAME="KEYWORD"
CONTENT="secure programs"><META
NAME="KEYWORD"
CONTENT="secure applications"><META
NAME="KEYWORD"
CONTENT="secure"><META
NAME="KEYWORD"
CONTENT="programming"><META
NAME="KEYWORD"
CONTENT="security"><META
NAME="KEYWORD"
CONTENT="Linux"><META
NAME="KEYWORD"
CONTENT="Unix"><META
NAME="KEYWORD"
CONTENT="hack"><META
NAME="KEYWORD"
CONTENT="crack"><META
NAME="KEYWORD"
CONTENT="vulnerability"><META
NAME="KEYWORD"
CONTENT="buffer overflow"><META
NAME="KEYWORD"
CONTENT="design"><META
NAME="KEYWORD"
CONTENT="implementation"><META
NAME="KEYWORD"
CONTENT="web application"><META
NAME="KEYWORD"
CONTENT="web applications"><META
NAME="KEYWORD"
CONTENT="CGI"><META
NAME="KEYWORD"
CONTENT="setuid"><META
NAME="KEYWORD"
CONTENT="setgid"><META
NAME="KEYWORD"
CONTENT="C"><META
NAME="KEYWORD"
CONTENT="C++"><META
NAME="KEYWORD"
CONTENT="Java"><META
NAME="KEYWORD"
CONTENT="Perl"><META
NAME="KEYWORD"
CONTENT="PHP"><META
NAME="KEYWORD"
CONTENT="Python"><META
NAME="KEYWORD"
CONTENT="TCL"><META
NAME="KEYWORD"
CONTENT="Ada"><META
NAME="KEYWORD"
CONTENT="Ada95"><META
http-equiv="Content-Type"
content="text/html; charset=euc-kr"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Secure Programming for Linux and Unix HOWTO</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN4"
></A
>David A. Wheeler</H3
><H3
CLASS="OTHERCREDIT"
>서정룡</H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
><CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:s_ryong@hotmail.com"
>s_ryong@hotmail.com</A
>&#62;</CODE
></P
></DIV
></DIV
><H3
CLASS="OTHERCREDIT"
>송재숙</H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
><CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:affinity@orgio.net"
>affinity@orgio.net</A
>&#62;</CODE
></P
></DIV
></DIV
><P
CLASS="PUBDATE"
>v2.92, 8 January 2002<BR></P
><P
CLASS="COPYRIGHT"
>Copyright &copy; 1999, 2000, 2001, 2002 by David A. Wheeler</P
><DIV
><DIV
CLASS="ABSTRACT"
><P
></P
><A
NAME="AEN39"
></A
><P
>&#13;이 책은 리눅스와 유닉스 시스템에서 보안적인 프로그램을 작성하기 위한
일련의 설계 및 구현 지침들을 제공한다. 보안적인 프로그램들은 원격 데이타
뷰어로 사용되는 애플리케이션 프로그램, CGI 스크립트를 포함한 웹
애플리케이션, 네트워크 서버와 setuid/setgid 프로그램들을 포함한다. C,
C++, 자바, 펄, PHP, 파이썬, TCL 과 Ada95 에 대한 명확한 지침도 포함된다.&#13;</P
><P
></P
></DIV
></DIV
><DIV
CLASS="LEGALNOTICE"
><P
></P
><A
NAME="AEN37"
></A
><P
>This book is Copyright (C) 1999-2002 David A. Wheeler.
Permission is granted to copy, distribute and/or modify
this book under the terms of the GNU Free Documentation License (GFDL),
Version 1.1 or any later version published by the Free Software Foundation;
with the invariant sections being ``About the Author'',
with no Front-Cover Texts, and no Back-Cover texts.
A copy of the license is included in the section entitled
"GNU Free Documentation License".
This book is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</P
><P
></P
></DIV
><DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>&#44256;&#52828; &#44284;&#51221;</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>&#44256;&#52840; v2.92</TD
><TD
ALIGN="LEFT"
>수정일 2002-1-22</TD
><TD
ALIGN="LEFT"
>&#44256;&#52828;&#51060; JRSoh</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>2.86 에서 2.92 버전으로 갱신하였습니다.</TD
></TR
></TABLE
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>&#52264;&#47168;</B
></DT
><DT
>1. <A
HREF="#INTRODUCTION"
>소개</A
></DT
><DT
>2. <A
HREF="#BACKGROUND"
>배경</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#HISTORY"
>유닉스, 리눅스, 오픈 소스/자유 소프트웨어의 역사</A
></DT
><DD
><DL
><DT
>2.1.1. <A
HREF="#UNIX-HISTORY"
>유닉스</A
></DT
><DT
>2.1.2. <A
HREF="#FSF-HISTORY"
>자유 소프트웨어 재단</A
></DT
><DT
>2.1.3. <A
HREF="#LINUX-HISTORY"
>리눅스</A
></DT
><DT
>2.1.4. <A
HREF="#OSS-HISTORY"
>오픈 소스/자유 소프트웨어</A
></DT
><DT
>2.1.5. <A
HREF="#LINUX-VS-UNIX"
>리눅스와 유닉스 비교</A
></DT
></DL
></DD
><DT
>2.2. <A
HREF="#SECURITY-PRINCIPLES"
>보안 원리</A
></DT
><DT
>2.3. <A
HREF="#WHY-WRITE-INSECURE"
>프로그래머들은 왜 비보안적인 코드를 작성하는가</A
></DT
><DT
>2.4. <A
HREF="#OPEN-SOURCE-SECURITY"
>오픈 소스가 보안에 유리한가?</A
></DT
><DT
>2.5. <A
HREF="#TYPES-OF-PROGRAMS"
>보안적인 프로그램 타입</A
></DT
><DT
>2.6. <A
HREF="#PARANOIA"
>편집증은 미덕이다</A
></DT
><DT
>2.7. <A
HREF="#WHY-WRITE"
>이 문서를 작성한 이유는?</A
></DT
><DT
>2.8. <A
HREF="#SOURCES-OF-GUIDELINES"
>설계와 구현 지침의 출처</A
></DT
><DT
>2.9. <A
HREF="#OTHER-SOURCES"
>보안 정보의 다른 출처들</A
></DT
><DT
>2.10. <A
HREF="#CONVENTIONS"
>문서 관행</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#FEATURES"
>리눅스 및 유닉스 보안 특징들의 요약</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#PROCESSES"
>프로세스</A
></DT
><DD
><DL
><DT
>3.1.1. <A
HREF="#PROCESS-ATTRIBUTES"
>프로세스 속성</A
></DT
><DT
>3.1.2. <A
HREF="#POSIX-CAPABILITIES"
>POSIX Capabilities</A
></DT
><DT
>3.1.3. <A
HREF="#PROCESS-CREATION"
>프로세스 생성과 조작</A
></DT
></DL
></DD
><DT
>3.2. <A
HREF="#FILES"
>파일</A
></DT
><DD
><DL
><DT
>3.2.1. <A
HREF="#FSO-ATTRIBUTES"
>파일시스템 객체 속성</A
></DT
><DT
>3.2.2. <A
HREF="#FSO-INITIAL-VALUES"
>생성시 초기값</A
></DT
><DT
>3.2.3. <A
HREF="#CHANGING-ACLS"
>접근 제어 속성 변경</A
></DT
><DT
>3.2.4. <A
HREF="#USING-ACLS"
>접근 제어 속성 사용</A
></DT
><DT
>3.2.5. <A
HREF="#FILESYSTEM-HIERARCHY"
>파일시스템 계층구조</A
></DT
></DL
></DD
><DT
>3.3. <A
HREF="#SYSV-IPC"
>System V 프로세스간 통신</A
></DT
><DT
>3.4. <A
HREF="#SOCKETS"
>소켓과 네트워크 연결</A
></DT
><DT
>3.5. <A
HREF="#SIGNALS"
>시그널</A
></DT
><DT
>3.6. <A
HREF="#QUOTAS"
>쿼터와 한도</A
></DT
><DT
>3.7. <A
HREF="#DLLS"
>동적 링크 라이브러리</A
></DT
><DT
>3.8. <A
HREF="#AUDIT"
>감사</A
></DT
><DT
>3.9. <A
HREF="#PAM"
>PAM</A
></DT
><DT
>3.10. <A
HREF="#UNIX-EXTENSIONS"
>유닉스 계열 시스템을 위한 전문적인 보안 확장</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#INPUT"
>모든 입력을 확인해라</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#COMMAND-LINE"
>명령 행</A
></DT
><DT
>4.2. <A
HREF="#ENVIRONMENT-VARIABLES"
>환경 변수</A
></DT
><DD
><DL
><DT
>4.2.1. <A
HREF="#ENV-VARS-DANGEROUS"
>몇몇 환경 변수는 위험하다</A
></DT
><DT
>4.2.2. <A
HREF="#ENV-STORAGE-DANGEROUS"
>환경 변수 저장 포맷은 위험하다</A
></DT
><DT
>4.2.3. <A
HREF="#ENV-VAR-SOLUTION"
>해결방안 - 추출 및 제거</A
></DT
></DL
></DD
><DT
>4.3. <A
HREF="#FILE-DESCRIPTORS"
>파일 기술자</A
></DT
><DT
>4.4. <A
HREF="#FILE-CONTENTS"
>파일 컨텐츠</A
></DT
><DT
>4.5. <A
HREF="#WEB-APPS"
>웹 기반 애플리케이션 입력 (특히 CGI 스크립트)</A
></DT
><DT
>4.6. <A
HREF="#OTHER-INPUTS"
>다른 입력</A
></DT
><DT
>4.7. <A
HREF="#LOCALE"
>인간 언어 (로케일) 선택</A
></DT
><DD
><DL
><DT
>4.7.1. <A
HREF="#HOW-LOCALES-SELECTED"
>로케일 선택 방법</A
></DT
><DT
>4.7.2. <A
HREF="#LOCALE-SUPPORT-MECHANISMS"
>로케일 지원 메카니즘</A
></DT
><DT
>4.7.3. <A
HREF="#LOCALE-LEGAL-VALUES"
>합법적인 값</A
></DT
><DT
>4.7.4. <A
HREF="#LOCALE-BOTTOM-LINE"
>최종 결과</A
></DT
></DL
></DD
><DT
>4.8. <A
HREF="#CHARACTER-ENCODING"
>문자 인코딩</A
></DT
><DD
><DL
><DT
>4.8.1. <A
HREF="#CHARACTER-ENCODING-INTRO"
>문자 인코딩 소개</A
></DT
><DT
>4.8.2. <A
HREF="#CHARACTER-ENCODING-UTF8"
>UTF-8 소개</A
></DT
><DT
>4.8.3. <A
HREF="#UTF8-SECURITY-ISSUES"
>UTF-8 보안 쟁점</A
></DT
><DT
>4.8.4. <A
HREF="#UTF8-LEGAL-VALUES"
>UTF-8 합법적인 값</A
></DT
><DT
>4.8.5. <A
HREF="#UTF8-RELATED-ISSUES"
>UTF-8 관련 쟁점</A
></DT
></DL
></DD
><DT
>4.9. <A
HREF="#INPUT-PROTECTION-CROSS-SITE"
>입력에서 교차 사이트의 악의있는 컨텐트를 예방해라</A
></DT
><DT
>4.10. <A
HREF="#FILTER-HTML"
>다시 보내질 수도 있는 HTML/URIs 를 필터링해라</A
></DT
><DD
><DL
><DT
>4.10.1. <A
HREF="#REMOVE-HTML-TAGS"
>몇몇 HTML 데이타를 제거 및 금지해라</A
></DT
><DT
>4.10.2. <A
HREF="#ENCODING-HTML-TAGS"
>HTML 데이타 인코딩</A
></DT
><DT
>4.10.3. <A
HREF="#VALIDATING-HTML-TAGS"
>HTML 데이타 확인</A
></DT
><DT
>4.10.4. <A
HREF="#VALIDATING-URIS"
>하이퍼텍스트 링크 (URIs/URLs) 확인</A
></DT
><DT
>4.10.5. <A
HREF="#OTHER-HTML-TAGS"
>다른 HTML 태그</A
></DT
><DT
>4.10.6. <A
HREF="#RELATED-ISSUES"
>관련 쟁점</A
></DT
></DL
></DD
><DT
>4.11. <A
HREF="#AVOID-GET-NON-QUERIES"
>비질의를 수행하는 HTTP GET 을 금지해라</A
></DT
><DT
>4.12. <A
HREF="#LIMIT-TIME"
>합당한 입력 시간 및 로드 레벨을 제한해라</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#BUFFER-OVERFLOW"
>버퍼오버플로우 피하기</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#DANGERS-C"
>C/C++ 에서의 위험</A
></DT
><DT
>5.2. <A
HREF="#LIBRARY-C"
>C/C++ 에서의 라이브러리 솔루션</A
></DT
><DD
><DL
><DT
>5.2.1. <A
HREF="#BUFFER-STANDARD-SOLUTION"
>표준 C 라이브러리 솔루션</A
></DT
><DT
>5.2.2. <A
HREF="#STATIC-VS-DYNAMIC-BUFFERS"
>정적 및 동적 할당 버퍼</A
></DT
><DT
>5.2.3. <A
HREF="#STRLCPY"
>strlcpy and strlcat</A
></DT
><DT
>5.2.4. <A
HREF="#LIBMIB"
>libmib</A
></DT
><DT
>5.2.5. <A
HREF="#STD-STRING"
>C++ std::string class</A
></DT
><DT
>5.2.6. <A
HREF="#LIBSAFE"
>Libsafe</A
></DT
><DT
>5.2.7. <A
HREF="#OTHER-BUFFER-LIBRARIES"
>다른 라이브러리</A
></DT
></DL
></DD
><DT
>5.3. <A
HREF="#COMPILATION-C"
>C/C++ 에서의 컴파일 솔루션</A
></DT
><DT
>5.4. <A
HREF="#OTHER-LANGUAGES"
>다른 언어</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#INTERNALS"
>프로그램 내부 구조화 및 접근 방법</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#FOLLOW-GOOD-PRINCIPLES"
>보안적인 프로그램에 대해 훌륭한 소프트웨어 엔지니어링 원리를 
따르라</A
></DT
><DT
>6.2. <A
HREF="#SECURE-INTERFACE"
>인터페이스를 안전하게 해라</A
></DT
><DT
>6.3. <A
HREF="#MINIMIZE-PRIVILEGES"
>권한을 최소화해라</A
></DT
><DD
><DL
><DT
>6.3.1. <A
HREF="#MIMIMIZE-PRIVILEGES-GRANTED"
>허가되는 권한을 최소화해라</A
></DT
><DT
>6.3.2. <A
HREF="#MINIMIZE-TIME-PRIVILEGE-USABLE"
>권한이 사용될 수 있는 시간을 최소화해라</A
></DT
><DT
>6.3.3. <A
HREF="#MINIMIZE-TIME-PRIVILEGE-ACTIVE"
>권한이 필요한 시간을 최소화해라</A
></DT
><DT
>6.3.4. <A
HREF="#MINIMIZE-PRIVILEGED-MODULES"
>권한이 허가된 모듈을 최소화해라</A
></DT
><DT
>6.3.5. <A
HREF="#CONSIDER-FSUID"
>권한을 제한하기 위해 FSUID 사용을 고려해라</A
></DT
><DT
>6.3.6. <A
HREF="#CONSIDER-CHROOT"
>사용할 수 있는 파일을 최소화하기 위해 Chroot 사용을 고려해라</A
></DT
><DT
>6.3.7. <A
HREF="#MINIMIZE-ACCESSIBLE-DATA"
>접근할 수 있는 데이타의 최소화를 고려해라</A
></DT
><DT
>6.3.8. <A
HREF="#MINIMIZE-RESOURCES"
>사용가능한 자원의 최소화를 고려해라</A
></DT
></DL
></DD
><DT
>6.4. <A
HREF="#AVOID-SETUID"
>Setuid/Setgid 스크립트 생성을 피해라</A
></DT
><DT
>6.5. <A
HREF="#SAFE-CONFIGURE"
>안전하게 설정하고 안전한 디폴트를 사용해라</A
></DT
><DT
>6.6. <A
HREF="#INIT-SAFE"
>안전하게 초기화값을 적재해라</A
></DT
><DT
>6.7. <A
HREF="#FAIL-SAFE"
>고장 안전</A
></DT
><DT
>6.8. <A
HREF="#AVOID-RACE"
>경쟁 상태를 피해라</A
></DT
><DD
><DL
><DT
>6.8.1. <A
HREF="#NON-ATOMIC"
>시퀀싱 (비원자적) 문제</A
></DT
><DD
><DL
><DT
>6.8.1.1. <A
HREF="#ATOMIC-FILESYSTEM"
>파일시스템에서의 원자적 동작</A
></DT
><DT
>6.8.1.2. <A
HREF="#TEMPORARY-FILES"
>임시 파일</A
></DT
></DL
></DD
><DT
>6.8.2. <A
HREF="#LOCKING"
>로킹</A
></DT
><DD
><DL
><DT
>6.8.2.1. <A
HREF="#LOCKING-USING-FILES"
>로크로서 파일 사용</A
></DT
><DT
>6.8.2.2. <A
HREF="#OTHER-LOCKING"
>로킹에 대한 다른 접근 방법</A
></DT
></DL
></DD
></DL
></DD
><DT
>6.9. <A
HREF="#TRUSTWORTHY-CHANNELS"
>단지 신뢰할 수 있는 체널만 신뢰해라</A
></DT
><DT
>6.10. <A
HREF="#TRUSTED-PATH"
>신뢰된 경로를 설정해라</A
></DT
><DT
>6.11. <A
HREF="#INTERNAL-CHECK"
>내부의 일관성을 검사하는 코드를 사용해라</A
></DT
><DT
>6.12. <A
HREF="#SELF-LIMIT-RESOURCES"
>스스로 자원을 제한해라</A
></DT
><DT
>6.13. <A
HREF="#CROSS-SITE-MALICIOUS-CONTENT"
>교차 사이트의 악의있는 컨텐트를 예방해라</A
></DT
><DD
><DL
><DT
>6.13.1. <A
HREF="#EXPLAIN-CROSS-SITE"
>문제 설명</A
></DT
><DT
>6.13.2. <A
HREF="#SOLUTIONS-CROSS-SITE"
>교차 사이트의 악의있는 컨텐트에 대한 해결방안</A
></DT
><DD
><DL
><DT
>6.13.2.1. <A
HREF="#AEN1234"
>특별 문자 식별</A
></DT
><DT
>6.13.2.2. <A
HREF="#AEN1274"
>필터링</A
></DT
><DT
>6.13.2.3. <A
HREF="#AEN1281"
>인코딩</A
></DT
></DL
></DD
></DL
></DD
><DT
>6.14. <A
HREF="#CAREFUL-TYPING"
>데이타 타입에 주의해라</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#CALL-OUT"
>다른 자원을 주의깊게 호출해라</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#CALL-ONLY-SAFE"
>안전한 라이브러리 루틴만 호출해라</A
></DT
><DT
>7.2. <A
HREF="#LIMIT-CALL-OUTS"
>호출을 합당한 값으로 제한해라</A
></DT
><DT
>7.3. <A
HREF="#CALL-INTENTIONAL-APIS"
>프로그래머가 사용하도록 의도된 인터페이스만 호출해라</A
></DT
><DT
>7.4. <A
HREF="#CHECK-RETURNS"
>모슨 시스템 호출 반환을 검사해라</A
></DT
><DT
>7.5. <A
HREF="#AVOID-VFORK"
>vfork(2) 사용을 피해라</A
></DT
><DT
>7.6. <A
HREF="#EMBEDDED-CONTENT-BUGS"
>내장된 컨텐트를 검색할 때 웹버그에 대처해라</A
></DT
><DT
>7.7. <A
HREF="#HIDE-SENSITIVE-INFORMATION"
>기밀을 다루는 정보를 숨겨라</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#OUTPUT"
>정보를 신중하게 되돌려줘라</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#MINIMIZE-FEEDBACK"
>피드백을 최소화해라</A
></DT
><DT
>8.2. <A
HREF="#NO-COMMENTS"
>주석을 포함하지 마라</A
></DT
><DT
>8.3. <A
HREF="#HANDLE-FULL-OUTPUT"
>완전한/무반응의 출력을 다뤄라</A
></DT
><DT
>8.4. <A
HREF="#CONTROL-FORMATTING"
>데이타 포맷팅을 제어해라 (문자열 포맷)</A
></DT
><DT
>8.5. <A
HREF="#OUTPUT-CHARACTER-ENCODING"
>출력에서 문자 인코딩을 제어해라</A
></DT
><DT
>8.6. <A
HREF="#PREVENT-INCLUDE-ACCESS"
>포함/설정 파일 접근을 예방해라</A
></DT
></DL
></DD
><DT
>9. <A
HREF="#LANGUAGE-SPECIFIC"
>언어에 특정적인 쟁점</A
></DT
><DD
><DL
><DT
>9.1. <A
HREF="#C-CPP"
>C/C++</A
></DT
><DT
>9.2. <A
HREF="#PERL"
>펄</A
></DT
><DT
>9.3. <A
HREF="#PYTHON"
>파이썬</A
></DT
><DT
>9.4. <A
HREF="#SHELL"
>쉘 스크립팅 언어 (sh 과 csh Deritivatives)</A
></DT
><DT
>9.5. <A
HREF="#ADA"
>Ada</A
></DT
><DT
>9.6. <A
HREF="#JAVA"
>자바</A
></DT
><DT
>9.7. <A
HREF="#TCL"
>TCL</A
></DT
><DT
>9.8. <A
HREF="#PHP"
>PHP</A
></DT
></DL
></DD
><DT
>10. <A
HREF="#SPECIAL"
>특별 주제</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#PASSWORDS"
>패스워드</A
></DT
><DT
>10.2. <A
HREF="#WEB-AUTHENTICATION"
>웹에서 인증</A
></DT
><DD
><DL
><DT
>10.2.1. <A
HREF="#WEB-AUTHENTICATION-LOGIN"
>웹에서 인증: 로그인</A
></DT
><DT
>10.2.2. <A
HREF="#WEB-AUTHENTICATION-SUBSEQUENT"
>웹에서 인증: 일련의 행동</A
></DT
><DT
>10.2.3. <A
HREF="#WEB-AUTHENTICATION-LOGOUT"
>웹에서 인증: 로그아웃</A
></DT
></DL
></DD
><DT
>10.3. <A
HREF="#RANDOM-NUMBERS"
>난수</A
></DT
><DT
>10.4. <A
HREF="#PROTECT-SECRETS"
>사용자가 기억하는 비밀 (패스워드 및 키) 을 특히 보호해라</A
></DT
><DT
>10.5. <A
HREF="#CRYPTO"
>암호화 알고리듬 및 프로토콜</A
></DT
><DD
><DL
><DT
>10.5.1. <A
HREF="#CRYPTO-PROTOCOLS"
>암호학적 프로토콜</A
></DT
><DT
>10.5.2. <A
HREF="#SYMMETRIC-ENCRYPTION"
>대칭키 암호화 알고리듬</A
></DT
><DT
>10.5.3. <A
HREF="#PUBLIC-KEY-ENCRYPTION"
>공개키 알고리듬</A
></DT
><DT
>10.5.4. <A
HREF="#HASH"
>암호학적 해시 알고리듬</A
></DT
><DT
>10.5.5. <A
HREF="#ITNEGRITY-CHECK"
>무결성 검사</A
></DT
><DT
>10.5.6. <A
HREF="#CRYPTO-OTHER"
>다른 암호학적 쟁점</A
></DT
></DL
></DD
><DT
>10.6. <A
HREF="#USE-PAM"
>PAM 사용</A
></DT
><DT
>10.7. <A
HREF="#TOOLS"
>도구</A
></DT
><DT
>10.8. <A
HREF="#WINDOWS-CE"
>Windows CE</A
></DT
><DT
>10.9. <A
HREF="#WRITE-AUDIT-RECORDS"
>감사 레코드 작성</A
></DT
><DT
>10.10. <A
HREF="#MISCELLANEOUS"
>기타</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#CONCLUSION"
>결론</A
></DT
><DT
>12. <A
HREF="#BIBLIOGRAPHY"
>문헌 목록</A
></DT
><DT
>A. <A
HREF="#DOCUMENT-HISTORY"
>책 발표 기록</A
></DT
><DT
>B. <A
HREF="#ACKNOWLEDGEMENTS"
>감사의 글</A
></DT
><DT
>C. <A
HREF="#ABOUT-LICENSE"
>문서의 라이센스</A
></DT
><DT
>D. <A
HREF="#FDL"
>GNU Free Documentation License</A
></DT
><DT
>E. <A
HREF="#ENDORSEMENTS"
>승인</A
></DT
><DT
>F. <A
HREF="#ABOUT-AUTHOR"
>저자</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>&#54364; &#47785;&#47197;</B
></DT
><DT
>4-1. <A
HREF="#AEN726"
>합법적인 UTF-8 시퀀스</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>&#44536;&#47548; &#47785;&#47197;</B
></DT
><DT
>1-1. <A
HREF="#ABSTRACT-PROGRAM"
>Abstract View of a Program</A
></DT
></DL
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="INTRODUCTION"
>1&#51109;. 소개</A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>A wise man attacks the city of the mighty
and pulls down the stronghold in which they trust.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Proverbs 21:22 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><P
>&#13;이 책은 리눅스와 유닉스 시스템에서 보안적인 프로그램을 작성하기 위한
일련의 설계 및 구현 지침들을 기술한다. 이 책의 목적을 위해 보안적인
(secure) 프로그램을 보안 경계에 존재하여 프로그램과 동일한 권한을 갖지
않는 출처로부터 입력을 받아들이는 프로그램으로 정의할 수 있는데 이들로는
원격 뷰어로 사용되는 애플리케이션 프로그램, CGI 스크립트를 포함한 웹
애플리케이션, 네트워크 서버와 setuid/setgid 프로그램들이 있다. 이 책에서
논의되는 원리들중 다수가 적용됨에도 불구하고 운영 체제의 커널 자체를
수정하는 것을 다루지는 않는다. 이 지침들은 저자가 추가한 의견과 함께
보안적인 프로그램들을 만드는 방법에 대한 다양한 출처들로부터 배운
교훈들을 조사함으로써 개발되었으며 일련의 더욱 커다란 원리들로
재구성되었다. 이 책은 C, C++, 자바, 펄, PHP, 파이썬, TCL 과 Ada95 를 포함한
많은 언어들에 대한 구체적인 안내를 포함한다.&#13;</P
><P
>&#13;이 책은 보증 조치, 소프트웨어 엔지니어링 프로세스와 품질 보증 방법을
다루지는 않는데 이는 중요하지만 다른 곳에 광범위하게 논의되어 있기
때문이다. 그러한 조치들로는 검사, 자세한 검토 (peer review), 설정 관리와
학문적인 (formal) 방법들이 있는데 보안 문제에 대한 일련의 발전하고 있는
보증 조치들을 명확하게 분간하는 문서들로는 Common Criteria [CC 1999] 와
System Security Engineering Capability Maturity Model [SSE-CMM 1999]
들이 있다. 일련의 더욱 일반적인 소프트웨어 엔지니어링 방법 또는
프로세스들은 Software Engineering Institute's Capability Maturity Model
for Software (SE-CMM) [Paulk 1993a, 1993b] 과 ISO 12207 [ISO 12207] 과 
같은 문서들내에 정의되어 있다. 품질 시스템에 대한 일반적인 국제적 표준은  
ISO 9000 과 ISO 9001 [ISO 9000, 9001] 내에 정의되어 있다.&#13;</P
><P
>&#13;이 책은 주어진 환경에서 시스템 또는 네트워크를 보안적으로 설정하는
방법을 논의하지는 않는다. 이것이 주어진 프로그램을 보안적으로 사용하기
위해서는 분명히 필요하지만 매우 많은 다른 문서들이 보안적인 설정을
논의하고 있다. 유닉스 계열 시스템을 보안적으로 설정하는 방법에 대한
우수한 일반 책으로는 Garfinkel [1996] 이 있으며 유닉스 계열 시스템을
안전하게 하기 위한 다른 책으로는 Anonymous [1998] 가 있다. 또한 <A
HREF="http://www.unixtools.com/security.html"
TARGET="_top"
>http://www.unixtools.com/security.html</A
>
와 같은 웹 사이트에서 유닉스 계열 시스템 설정에 관한 정보를 찾을 수
있다. 리눅스 시스템의 보안적 설정에 대한 정보는 Fenzi [1996], Seifried
[1999], Wreski [1998], Swan [2001] 과 Anonymous [1999] 를 포함한
광범위한 문서들에서 얻을 수 있다. Geodsoft [2001] 은 OpenBSD 를 강화하는 방법을 
기술하고 있는데 많은 제안들은 모든 유닉스 계열 시스템에 대해 유용하다. 
리눅스 시스템 (결국 다른 유닉스 계열
시스템) 의 경우 리눅스 운영체제를 강화 또는 단련시키려고 하는 Bastille
강화 시스템의 검토를 원할 수도 있는데 이에 관해서는 <A
HREF="http://www.bastille-linux.org"
TARGET="_top"
>http://www.bastille-linux.org</A
>
에서 더욱 많은 것을 배울 수 있다. 이는 GPL (General Public License)
라이센스로 무료로 얻을 수 있다. 윈도우 2000 의 경우는 Cox [2000] 을 살펴볼 수 있다. &#13;</P
><P
>&#13;컴퓨터를 설정하는 것은 바이러스에 어떻게 대처하는가, 어떤 종류의 조직상의 
보안 정책이 필요한가, 사업의 연속성 계획 등을 포함하는 더욱 큰 영역인 보안 
관리의 단지 일부분이다. 
보안 관리를 위해 국제적 표준 및 길잡이 들이 있다. ISO 13335 는 보안 관리에 
대한 길잡이 역할을 하는 다섯 부분으로 구성된 기술적 보고서이다 [ISO 13335]. 
또한 ISO/IEC 17799:2000 은 실제 관례를 정의하고 있다 [ISO 17799]; 그 공표된 
목적은 ``조직내에서 보안 발의, 구현 또는 유지하는 책임을 지는 사람들이 
사용하도록 정보 보안 관리를 위한 권고를 주는 것이다" (대략적인 의미에서 
이는 기술 문서는 아니다). ISO/IEC 17799:2000 이 매우 논의의 여지가 있음을 
언급하는 것은 가치가 있다; 벨기에, 캐나다, 프랑스, 독일, 이탈리아, 일본과 
미국은 이의 채택에 <B
CLASS="EMPHASIS"
>반대</B
> 투표를 했다. 
이 논쟁에 대한 더욱 자세한 정보는 NIST 의 <A
HREF="http://csrc.nist.gov/publications/secpubs/otherpubs/reviso-faq.pdf"
TARGET="_top"
>ISO/IEC 17799:2000 FAQ</A
> 를 보라. 
<A
HREF="http://www.caspr.org"
TARGET="_top"
>http://www.caspr.org</A
> 의 
Commonly Accepted Security Practices &#38; Recommendations (CASPR) 프로젝트는 
정보 보안 지식에서 모든 사람이 사용할 수 있는 일련의 논문을 만들려고 하고 있다 
(GNU FDL 라이센스하에서 함으로써 추후 파생 문서도 모든 사람이 계속 사용할 
수 있을 것이다).&#13;</P
><P
>&#13;이 책은 독자가 일반적인 컴퓨터 보안 문제, 유닉스 계열 시스템의 일반적인
보안 모델, 네트워킹 (특히 TCP/IP 기반 네트워크) 과 C 프로그래밍 언어를 
이해하고 있다고 가정하며 보안 목적의 리눅스와 유닉스 프로그래밍 모델에 
대해 상당한 정보를 포함하고 있다. 
TCP/IP 기반 네트워크 및 프로토콜이 어떻게 작동하는지에 대한 더욱 자세한 
(보안 프로토콜을 포함해) 정보가 필요하다면 [Murhammer 1998] 과 같은 
TCP/IP 에 대한 일반적인 연구를 참고해라.&#13;</P
><P
>&#13;이 책은 리눅스 및 유닉스의 다양한 변형들을 포함한 모든 유닉스 계열
시스템들을 다루지만 특히 리눅스에 중점을 두어 명확하게 이에 대한 세부
사항들을 제공한다. 윈도우 CE 에 대해 명확하게 설명하는 약간의 자료들도 
있지만 사실 이들중 많은 것들은 특정 운영 체제에 한정되어 있지 않다. 
이 책에 포함되어 있지 않은 관련 정보를 알고 있다면 저자에게 알려주기 바란다. &#13;</P
><P
>&#13;이 책의 원본은 <A
HREF="http://www.dwheeler.com/secure-programs"
TARGET="_top"
>http://www.dwheeler.com/secure-programs</A
>
에서 찾을 수 있으며 <A
HREF="http://www.linuxdoc.org"
TARGET="_top"
>http://www.linuxdoc.org</A
> 의 리눅스
문서화 프로젝트 (Linux Documentation Project, LDP) 의 한 부분으로 몇몇의
다른 사이트에서도 또한 미러링되고 있다. LDP 복사본 및/또는 각 배포
복사본을 포함한 이러한 복사본들이 원본보다 오래된 것일 수도 있음을
주목하기 바란다. 저자는 이 책에 대한 의견을 듣고 싶지만 반드시 여러분의
의견이 최신 버전에 대해 타당한지 검사한 후 의견을 보내주기 바란다.&#13;</P
><P
>&#13;이 책의 저작권은 1999-2001 David A. Wheeler 에 있으며 그 라이센스는 GNU
Free Documentation License (GFDL) 이다; 더욱 자세한 정보는 <A
HREF="#ABOUT-LICENSE"
>&#48512;&#47197; C</A
> 와 <A
HREF="#FDL"
>&#48512;&#47197; D</A
> 를 보라.&#13;</P
><P
>&#13;<A
HREF="#BACKGROUND"
>2&#51109;</A
> 은 유닉스, 리눅스 및 보안에 대한 배경을
논의하며 <A
HREF="#FEATURES"
>3&#51109;</A
> 은 프로세스, 파일시스템 객체 등의
보안 속성과 연산을 개괄적으로 설명하는데 일반적인 유닉스 및 리눅스 보안
모델을 기술한다. 다음 장에서는 이 책의 골자인 리눅스와 유닉스 시스템에서
애플리케이션을 개발하기 위한 일련의 설계 및 구현 지침들을 논의한다. 이
책은 <A
HREF="#CONCLUSION"
>11&#51109;</A
>에서 결론으로 매듭지으며 다음에 이
책에서 인용한 도서 목록과 부록이 나온다.&#13;</P
><P
>&#13;설계 및 구현 지침들은 저자가 믿기에 프로그래머의 관점에 중점을 둔 범주로
나누어진다. <A
HREF="#ABSTRACT-PROGRAM"
>&#44536;&#47548; 1-1</A
> 에 보이는 것과 같이
프로그램은 입력을 받고, 데이타를 처리하고, 다른 자원들을 호출하고 출력을
산출한다; 개념적으로 모든 보안 지침들은 이러한 범주들중 하나와
일치하는데 저자는 ``데이타 처리" 를 프로그램 내부 구조화하기와 접근 방법, 버퍼
오버플로우 피하기 (어떤 경우 입력 문제로 고려될 수 있다), 언어에
특정적인 정보와 특별 주제로 세분화하였다. 각 장들은 쉽게 따라갈 수
있도록 정리되었는데 따라서 지침들을 제공하는 각 장들은 모든 입력
유효화하기 (<A
HREF="#INPUT"
>4&#51109;</A
>), 버퍼 오버플로우 피하기 (<A
HREF="#BUFFER-OVERFLOW"
>5&#51109;</A
>), 프로그램 내부 구조화하기 및 접근 방법
(<A
HREF="#INTERNALS"
>6&#51109;</A
>), 주의깊게 다른 자원들 호출하기 (<A
HREF="#CALL-OUT"
>7&#51109;</A
>), 신중히 정보를 되돌려주기 (<A
HREF="#OUTPUT"
>8&#51109;</A
>), 언어에 특정적인 정보 (<A
HREF="#LANGUAGE-SPECIFIC"
>9&#51109;</A
>) 그리고 난수 (random number) 를 얻는 방법과
같은 특별 주제에 대한 정보 (<A
HREF="#SPECIAL"
>10&#51109;</A
>) 들을 논의한다.&#13;</P
><DIV
CLASS="FIGURE"
><A
NAME="ABSTRACT-PROGRAM"
></A
><P
><B
>&#44536;&#47548; 1-1. Abstract View of a Program</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="program.png"></P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="BACKGROUND"
>2&#51109;. 배경</A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>I issued an order and a search was made, and it was found that this
city has a long history of revolt against kings and has been
a place of rebellion and sedition.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Ezra 4:19 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HISTORY"
>2.1. 유닉스, 리눅스, 오픈 소스/자유 소프트웨어의 역사</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="UNIX-HISTORY"
>2.1.1. 유닉스</A
></H3
><P
>&#13;1969-1970년 사이에 AT&#38;T 벨 실험실의 Kenneth Thompson, Dennis Ritchie
와 동료들은 약간 사용되고 있던 PDP-7 상에서 작은 운영 체제를 개발하기
시작했는데 이는 곧 MULTICS 라 불리는 초기의 운영체제 프로젝트를 빗대어
유닉스 (UNIX) 로 명명되었다. 1972-1973년 사이에 시스템은 실현불가능했던
드문 방법인 C 프로그래밍 언어로 재작성되었는데 이 결정때문에 유닉스는 그
원래의 하드웨어로부터 바꿀 수 있고 그 원래의 하드웨어를 극복할 수 있는
최초의 널리 사용되는 운영체제가 되었다. 다른 혁신적인 것들도 또한
유닉스에 추가되었는데 이는 특히 벨 실험실과 대학 공동체의 상호 협동에
기인했다. 1979년 유닉스 7번째 버전 V7 이 발표되었으며 이는 모든 현존하는
유닉스 시스템의 대부격이다.&#13;</P
><P
>&#13;이 시점 이후 유닉스의 역사는 다소 복잡하게 되었는데 Berkeley 가 주도한
대학 공동체가 Berkeley Software Fistribution (BSD) 라 불리는 변종을
개발한 반면 AT&#38;T 는 System III 와 나중에는 System IV 라는 이름으로
계속해서 유닉스를 개발했다. 1980년대 후반에서 1990년대 초반에 이러한 두
가지 중요한 변형들간의 전쟁은 최고조에 달했지만 여러 해가 지난 후에는 각
변형이 다른 변형의 중요 특징들중 많은 부분을 채택하였다. 상업적으로
System V 는 인터페이스의 대부분이 정식 표준에 채택됨으로써 표준 전쟁에서
이겼으며 대부분의 하드웨어 벤더들은 AT&#38;T 의 System V 로 전환하였다.
그러나 System V 도 결국 많은 BSD 혁신들을 받아들이게 되었으며 그래서
결과적으로 시스템은 두 시스템의 합병 이상이었다. BSD 시스템도 사라지지
않았으며 대신 연구, PC 하드웨어와 단일 목적 서버 (예, 많은 웹 서버들은
BSD 에서 파생된 시스템을 사용하고 있다) 용으로 널리사용되게 되었다.&#13;</P
><P
>&#13;결과적으로 원래 7번째 판에 기초한 많은 여러가지 유닉스 버전들이 존재하게
되었다. 유닉스의 대부분 버전들은 재산권이 있으며 각각의 하드웨어 벤더에
의해 관리되었는데 예를 들어 썬 솔라리는 System V 의 변형이다. BSD 줄기의
세가지 버전들은 결국 오프 소스가 되었으며 이들은 각각 PC 타입의
하드웨어에 손쉬운 설치에 중점을 둔 FreeBSD, 많은 여러가지 CPU 아키텍쳐에
중점을 둔 NetBSD 와 보안에 중점을 둔 OpenBSD 이다. 유닉스 역사에 대한
더욱 일반적인 정보는 <A
HREF="http://www.datametrics.com/tech/unix/uxhistry/brf-hist.htm"
TARGET="_top"
>http://www.datametrics.com/tech/unix/uxhistry/brf-hist.htm</A
> 
와 <A
HREF="http://perso.wanadoo.fr/levenez/unix"
TARGET="_top"
>http://perso.wanadoo.fr/levenez/unix</A
>
에서 찾을 수 있다. BSD 역사에 대한 더욱 많은 정보는 [McKusick 1999] 와
<A
HREF="ftp://ftp.freebsd.org/pub/FreeBSD/FreeBSD-current/src/share/misc/bsd-family-tree"
TARGET="_top"
>ftp://ftp.freebsd.org/pub/FreeBSD/FreeBSD-current/src/share/misc/bsd-family-tree</A
>
에서 찾을 수 있다.&#13;</P
><P
>&#13;유닉스 계열 시스템 사용에 대한 찬성론을 설명하고 있는 지지 기사를 읽고
싶은 사람들은 <A
HREF="http://www.unix-vs-nt.org"
TARGET="_top"
>http://www.unix-vs-nt.org</A
> 를
보아야 한다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FSF-HISTORY"
>2.1.2. 자유 소프트웨어 재단</A
></H3
><P
>&#13;1984년 Richard Stallman 의 자유 소프트웨어 재단 (Free Software
Foundation, FSF) 은 유닉스 운영체제의 무료 버전을 만들기 위해 GNU
프로젝트를 시작했는데 Stallman 은 자유로이 사용될 수 있고, 읽혀질 수
있고, 수정될 수 있고, 재배포될 수 있는 소프트웨어의 의미로 free 를
사용했다. FSF 는 C 컴파일러 (gcc), 텍스트 에디터 (emacs) 와 많은
기본적인 도구를 포함해 엄청나게 많은 유용한 컴포넌트들 성공적으로
구축하였다. 그러나 1990년대 FSF 는 운영체제 커널을 개발하는데 어려움을
겪었으며 커널이 없다면 그들의 나머지 소프트웨어들은 소용없었을 것이다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LINUX-HISTORY"
>2.1.3. 리눅스</A
></H3
><P
>&#13;1991년 Linus Torvalds 는 ``리눅스"라고 이름지은 운영체제 커널을 개발하기
시작했다 [Torvalds 1999]. 이 커널은 자유로이 수정될 수 있고 매우 유용한
운영체제를 만들기 위해 FSF 산물과 다른 컴포넌트들 (특히 BSD 컴포넌트들의
일부와 MIT 의 X 윈도우 소프트웨어) 과 병합될 수 있었는데 이 책에서 커널
자체는 ``리눅스 커널"로 전체 결합은 ``리눅스"로 지칭할 것이다. 많은
사람들은 대신 ``GNU/Linux" 라는 용어를 사용함을 주목해라.&#13;</P
><P
>&#13;리눅스 공동체에서 여러 조직들은 사용할 수 있는 컴포넌트들을 다르게
조합하였는데 각 조합은 ``배포판"으로 부르며 배포판들을 개발한 조직들은
``배포업자"라고 부른다. 일반적으로 널리 알려진 배포판으로는 레드햇
(Red Hat), 맨드레이크 (Mandrake), 수제 (SuSE), 칼데라 (Caldera), 코렐
(Corel) 및 데비안 (Debian) 이 있다. 다양한 배포판들간에는 차이점들이
있지만 모든 배포판들은 동일한 기반인 리눅스 커널 및 GNU glibc
라이브러리들에 기초하고 있다. 두가지 모두는 ``copyleft" 스타일의
라이센스로 다뤄지기 때문에 이러한 기반에 대한 변경은 일반적으로 모든
사람이 사용할 수 있어야 한다. 이는 BSD 와 AT&#38;T 에서 파생된 유닉스
시스템간에는 존재하지 않는 리눅스만의 기반에서 리눅스 배포판들을
통합시키는 힘이 원천이다. 이 책은 특정 리눅스 배포판에 고유한 것은
아니며 리눅스를 논의할 때 이 책은 본질적으로 모든 현재 주요 리눅스
배포판들에 대해 유효한 가정인 리눅스 커널 버전 2.2 이상과 C 라이브러리
glibc 2.1 이상을 가정한다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="OSS-HISTORY"
>2.1.4. 오픈 소스/자유 소프트웨어</A
></H3
><P
>&#13;자유로이 공유되는 소프트웨어에 대한 관심이 증가함에 따라 이에 대한 정의
및 설명이 더욱 더 필요하게 되었다. 널리 사용되는 용어는 ``오픈 소스
소프트웨어"로 [OSI 1999] 내에 더욱 자세하게 정의되어 있다. Eric Raymond
[1997, 1998] 은 다양한 개발 과정들을 고찰한 몇몇의 독창성있는 기사들을
작성했다. 다른 널리 사용되는 용어는 ``자유 소프트웨어 (free software)"
로 ``free" 는 ``freedom" 을 나타내는데 보통 설명은 ``free beer 가 아닌
free speech" 이다. 그러나 두 표현 모두 완벽한 것은 아니다. ``자유
소프트웨어"라는 용어는 대개 실행파일은 무료로 제공되지만 소스 코드를 볼
수 없고, 수정할 수 없고 또는 재배포할 수 없는 프로그램들과 혼동된다.
반대로 ``오픈 소스"라는 용어는 때때로 소스 코드를 볼 수는 있지만 사용,
수정 또는 재배포에 제한이 있는 소프트웨어를 의미하는데 사용 (악용) 되고
있다. 이 책은 보통의 즉, 소스 코드의 사용, 보기, 수정 및 재배포를
자유로이 할 수 있는 소프트웨어에 대해 ``오픈 소스"라는 용어를 사용한다;
더욱 세부적인 정의는 <A
HREF="http://www.opensource.org/osd.html"
TARGET="_top"
>Open Source Definition</A
>
에 포함되어 있다. 어떤 경우 목적의 차이가 제안되고 있는데 ``자유
소프트웨어"라는 용어를 선호하는 사람들은 자유의 필요성을 강력히 강조하길
바라는 반면 다른 사람들은 다른 목적 (예, 높은 신뢰성) 를 가지거나 단순히
덜 불쾌하게 보이고 싶을 수도 있다. 자유 소프트웨어 정의와 그 이면에
숨겨져 있는 목적에 대한 정보는 <A
HREF="http://www.fsf.org"
TARGET="_top"
>http://www.fsf.org</A
> 에서 찾을 수 있다.&#13;</P
><P
>&#13;
오픈 소스 소프트웨어와 자유 소프트웨어에 대한 지지 기사들을 읽고 싶은
사람들은 <A
HREF="http://www.opensource.org"
TARGET="_top"
>http://www.opensource.org</A
> 와
<A
HREF="http://www.fsf.org"
TARGET="_top"
>http://www.fsf.org</A
> 를 보아야
한다. 그러한 소프트웨어를 고찰한 다른 문서들도 있는데 예를 들어 Miller
[1995] 는 오픈 소스 소프트웨어가 지적 재산권이 있는 소프트웨어보다
더욱 현저하게 신뢰할 수 있음을 발견했다 (임의의 입력때문에 생기는 파손에
대해 얼마나 저항하는지를 측정하는 수단을 사용하였다).&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LINUX-VS-UNIX"
>2.1.5. 리눅스와 유닉스 비교</A
></H3
><P
>&#13;이 책은 의도적으로 유닉스와 같은 시스템을 기술하기 위해 ``유닉스 계열
(Unix-like)" 이라는 용어를 사용한다. 특히 유닉스 계열은 모든 주요 유닉스
변형들과 리눅스 배포판들을 포함한다. 많은 사람들이 이러한 시스템들을
기술하기 위해 단순히 ``유닉스"라는 용어를 사용함을 주목해라. 
원래 ``유닉스" 라는 용어는 AT&#38;T 에 의해 개발된 특정 제품을 의미했다. 
오늘날 오픈 그룹이 유닉스 상표권을 소유하고 있으며 유닉스를 
``worldwide Single UNIX Specification" 으로 정의하고 있다.&#13;</P
><P
>&#13;리눅스가 유닉스 소스 코드에서 파생되지 않았지만 그 인터페이스는
의도적으로 유닉스와 같다. 따라서 유닉스에서 배운 교훈이 보안에 대한
정보를 포함해 일반적으로 둘 모두에 적용된다. 이 책에서 정보의 대부분은
모든 유닉스 계열 시스템에 적용되는데 리눅스에 특정적인 정보가 리눅스를
사용하는 사람들이 리눅스의 능력을 사용할 수 있게 하려고 의도적으로
추가되었다.&#13;</P
><P
>&#13;유닉스 계열 시스템들은 많은 보안 메카니즘들을 공유한다. 물론 이
메카니즘들은 미묘한 차이가 있고 모든 시스템들에서 모든 메카니즘을 사용할
수는 없다. 모든 시스템들은 각 프로세스에 대한 사용자 및 그룹 ids (uids
및 gids) 와 user, group 와 other 에 대한 읽기, 쓰기와 실행하기 허가를
갖는 파일시스템을 포함하고 있다. 기본 보안 메카니즘을 포함해 유닉스
시스템에 대한 일반적인 정보는 Thompson [1974] 와 Bach [1986] 을 보라.
<A
HREF="#FEATURES"
>3&#51109;</A
>은 유닉스와 리눅스의 주요 보안 특징을
요약한다.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECURITY-PRINCIPLES"
>2.2. 보안 원리</A
></H2
><P
>&#13;잘 알고 있어야 하는 많은 일반적인 보안 원리들이 있다; 정보 보안에 대한
일반적인 정보를 얻을 수 있는 한 곳은 Information Assurance Technical
Framework (IATF) [NSA 2000] 이다. NIST 는 높은 수준의 ``일반적으로
인정된 원리와 실제 (generally accepted principles and practices)" 을
식별하였다 [Swanson 1996]. [Pfleeger 1997] 같은 컴퓨터 보안에 대한
일반적인 교재도 또한 볼 수 있다. 약간의 보안 원리들은 다음과 같이
요약된다:&#13;</P
><P
>&#13;대개 컴퓨터 보안의 목적은 다음 세가지 전반적인 목적에 의해 기술된다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;<B
CLASS="EMPHASIS"
>기밀성 (confidentiality, 또한 secrecy)</B
>.
컴퓨팅 시스템 자산은 단지 인가된 사람들에 의해서만 접근된다.&#13;</P
></LI
><LI
><P
>&#13;<B
CLASS="EMPHASIS"
>무결성 (integrity)</B
>. 시스템 자산은 단지
인가된 사람들에 의해 인가된 방식으로만 변경될 수 있다.&#13;</P
></LI
><LI
><P
>&#13;<B
CLASS="EMPHASIS"
>가용성 (availability)</B
>. 인가된 사람들은
(시스템 사양에 의해 결정되는) 빠른 속도로 자산에 접근할 수 있다. 이
목적을 충족시키지 못하는 것을 서비스 부인이라 부른다.&#13;</P
></LI
></UL
><P
>&#13;어떤 사람들은 추가적인 보안 목적을 정의하는 반면 다른 사람들은 이러한
추가적인 목적을 위 세가지 목적의 특별한 경우로 일률적으로 취급한다. 예를
들어 어떤 사람은 부인 방지 (non-repudiation) 를 별도의 목적으로
분류하는데 이는 송신자와 수신자가 나중에 부인할 수 있음에도 불구하고
각각 메시지를 전송 및 수신했음을 ``입증"하는 능력이다. 프라이버시는
때때로 기밀성과 별도로 다뤄지는데 어떤 사람은 이를 데이타 대신
<B
CLASS="EMPHASIS"
>사용자</B
>  (예, 그들의 신원) 의 기밀성 보호로
정의한다. 대부분의 목적들은 식별 (identification) 과 인증을 필요로
하는데 이는 때때로 별개의 목적으로 열거된다. 종종 감사 (auditing, 또한
회계 책임 accountability 이라고도 부른다) 도 합당한 보안 목적으로
분간된다. 때때로 접근 제어 (access control) 및 신뢰성 (authenticity) 도
또한 별도로 열거된다. 모든 경우에 있어 이러한 목적들을 어떻게
종합하느냐에 상관없이 이들을 언제 충족시켜야 하는지 알 수있도록
프로그램의 전반적인 목적을 확인하는 것이 중요하다.&#13;</P
><P
>&#13;
때때로 이러한 목적들은 알려진 일련의 위협에 대한 반응으로 때때로 이러한
목적들중 일부는 법에 의해 요구된다. 예를 들어 미국의 은행들 및 다른 금융
기관들에 대해서는 ``Gramm-Leach-Bliley (GLB)''  법령이라 불리는 새로운
프라이버시 법이 있다. 이 법은 공유되는 개인 정보의 발표와 그 데이타를
안전하게 하는 방법을 명하고 제삼자에 의해 공유될 개인 정보의 발표를
요구하며 기관들이 고객들에게 공유되는 데이타를 선택할 기회를 주도록
정하고 있다 [Jones 2000].&#13;</P
><P
>&#13;때때로 보안과 어떤 다른 일반적인 시스템/소프트웨어 엔지니어링
원리들간에는 불일치가 있다. 보안은 때때로 ``손쉬운 사용"을 방해할 수
있는데 예를 들어 보안적인 설정을 설치하는 것은 작동하지만 비보안적인
``평범한" 설정보다 더욱 많은 노력이 들 수도 있다. 종종 이 명백한
불일치는 해결될 수 있는데 예를 들어 문제를 다시 생각함으로써 보안적인
시스템을 또한 사용하기 쉽게 만드는 것은 대개 가능하다. 또한 보안과
추상화 (정보 숨기기) 간에도 불일치가 있는데 예를 들어 어떤 고수준
라이브러리 루틴들이 보안적으로 또는 비보안적으로 구현될 수도 있지만
그들의 설계 스펙은 무엇이라고 말해주지 못할 것이다. 결국
애플이케이션이 보안적이여야 한다면 그렇다고 확신할 수 없는 경우 반드시
스스로 이를 보안적으로 만들어야 한다 - 물론 맞다. 라이브러리는
수정되어야 하며 라이브러리 루틴을 잘못 선택함으로써 손해를 입을 사람들은
바로 사용자들이다.&#13;</P
><P
>&#13;훌륭한 일반적인 보안 원리는 ``철저한 방어 (defense in depth)"이다; 적소에 매우 많은 보호
메카니즘들 (``계층, layers") 들을 가져야 하며 따라서 공격자가 성공적인
공격을 수행하기 위해 다수의 메카니즘을 무너뜨려야 하도록 설계되어야 한다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="WHY-WRITE-INSECURE"
>2.3. 프로그래머들은 왜 비보안적인 코드를 작성하는가</A
></H2
><P
>&#13;많은 프로그래머들이 비보안적인 코드를 작성하려고 하지는 않는다 - 그러나 
어쨌든 작성한다. 다음은 이에 대한 많은 이유들이다. 이들중 대부분은 
1998년 12월 17일 Bugtraq 에 게시한 Aleph One 에 의해 수집 및 요약된 
것이다. &#13;</P
><P
></P
><UL
><LI
><P
>&#13;대부분의 학교에서 컴퓨터 보안에 대해 말하는 교과 과정은 없다. <B
CLASS="EMPHASIS"
>있다</B
> 하더라도 컴퓨터 보안 교과 과정은 대개 전체적으로 보안적인 
프로그램을 작성하는 방법을 논의하고 있지 않다. 많은 교과 과정은 단지 
암호학 또는 프로토콜과 같은 특정 영역만을 다루고 있다. 이들도 중요하지만 
버퍼 오버플로우, 문자열 포맷팅 및 입력 검사와 같은 공통적인 실세계의 문제를 
대개 논의하지 못하고 있다. 
저자는 이것이 가장 중요한 문제들중 하나라고 믿는다; 대학교를 마친 
프로그래머들이라도 보안적인 프로그램 작성 방법을 배울 것 같지는 않으며 
더구나 우리는 보안적인 프로그램을 작성하는데 있어 이러한 사람들에게 
의존하고 있다. &#13;</P
></LI
><LI
><P
>&#13;프로그래밍 책/클래스가 보안적인/안전한 프로그래밍 기법을 가르치지 않고 있다. 
정말로 최근까지 보안적인 프로그램 작성 방법에 대한 책은 전혀 없었다.&#13;</P
></LI
><LI
><P
>&#13;어느 누구도 학문적인 입증 방법을 사용하지 않는다.&#13;</P
></LI
><LI
><P
>&#13;C 는 불안전한 언어이며 표준 C 라이브러리 문자열 함수도 불안전하다.&#13;</P
></LI
><LI
><P
>&#13;이는 C 가 널리 사용되고 있기때문에 특히 중요하다 - C 를 사용하는 간단한 
방식은 위험한 악용을 허용한다.&#13;</P
></LI
><LI
><P
>&#13;프로그래머가 ``다수의 사용자"를 생각하지 않는다.&#13;</P
></LI
><LI
><P
>&#13;프로그래머는 인간이며 인간은 게으르다. 따라서 프로그래머는 보안적인 
방법 대신 ``쉬운" 방법을 대개 사용할 것이다 - 일단 작동한다면 대개 이를 
추후에 수정하지 않는다.&#13;</P
></LI
><LI
><P
>&#13;대부분의 프로그래머들은 결코 훌륭한 프로그래머가 아니다.&#13;</P
></LI
><LI
><P
>&#13;대부분의 프로그래머들은 보안 인력이 아니다; 이들은 졀코 공격자만큼 
생각을 하지 않는다.&#13;</P
></LI
><LI
><P
>&#13;대부분의 보안 인력은 프로그래머가 아니다. 이는 몇몇 Bugtraq 기여자들의 
진술이지만 이 주장이 실제 옳은 지는 명확하지 않다.&#13;</P
></LI
><LI
><P
>&#13;대부분의 컴퓨터 보안 모델은 엄하다.&#13;</P
></LI
><LI
><P
>&#13;많은 ``파괴된" 레거시 소프트웨어들이 있다. (보안 결함을 제거하거나 더욱 
제한적인 보안 정책과 함께 사용하기 위해) 이 소프트웨어를 수정하는 것은 
어렵다 &#13;</P
></LI
><LI
><P
>&#13;소비자들은 보안에 관심이 없다. 저자는 소비자들이 보안에 관심을 갖기를 
희망한다; 지속적으로 악용되고 있는 컴퓨터 시스템은 도움이 되지 않거나 
사용하기 쉽지 않다.&#13;</P
></LI
><LI
><P
>&#13;보안 비용과 여분의 개발 시간.&#13;</P
></LI
><LI
><P
>&#13;추가적인 테스트 관점에서 보안 비용.&#13;</P
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="OPEN-SOURCE-SECURITY"
>2.4. 오픈 소스가 보안에 유리한가?</A
></H2
><P
>&#13;보안에 대한 오픈 소스 방법의 영향에 관해서는 보안 전문가들에 의해 많은
논의가 있어왔다. 주요 쟁점들중의 하나는 오픈 소스가 공격자와 방어자를
포함해 모든 사람이 검토할 수 있게끔 소스 코드를 드러낸다는 것으로
분별있는 사람들은 이 상황의 궁극적인 영향에 관해 이의를 갖고 있다.&#13;</P
><P
>&#13;다음은 이 주제를 고찰해왔던 사람들로부터 약간 인용한 것이다. Bruce
Schneier 은 현명한 엔지니어들은 ``보안과 관련된 모든 것을 위해 오픈 소스
코드를 요구"해야 한다고 주장하며 [Schneier 1999] 또한 오픈 소스
소프트웨어를 보안적으로 만들기 위해 충족되어야 하는 필수 조건들의 일부를
논의하고 있다. Advanced Encryption Standard (AES) 암호화 알고리듬 개발자인
Vincent Rijmen 은 리눅스의 오픈 소스 본질이 더욱 많은 사람들이 보안
취약성 (vulnerability) 을 조사할 수 있을뿐만 아니라 더욱 중요하게
모델이 사람들에게 더욱 분명한 코드의 작성과 표준을 고수하게끔 하기
때문에 이들의 발견 및 수정을 더욱 쉽게 만드는 우수한 방법을 제공한다고
믿고 있다. 따라서 이는 보안 검토를 손쉽게 한다 [Rijmen 2000]. Elias Levy
(Aleph1) 은 기사 <A
HREF="http://www.securityfocus.com/commentary/19"
TARGET="_top"
>Is Open Source Really
More Secure that Closed?</A
> 에서 오픈 소스 소프트웨어를 보안적으로
만드는데 있어 문제점들의 일부를 논의하고 있는데 그의 요약은 다음과
같다:&#13;</P
><A
NAME="AEN211"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;그래서 모든 이것이 오픈 소스 소프트웨어가 보안에 취약하게 될 때 비공개
소스 소프트웨어보다 좋지 않다는 것을 의미하는가? 그렇지 않다. 오픈 소스
소프트웨어는 틀림없이 이에 대응되는 비공개 소스 소프트웨어보다 더욱
보안적으로 될 가능성을 갖고 있다. 그러나 오해하지 마라 단순히 오픈
소스라고해서 보안을 보증하지는 않는다.&#13;</P
></BLOCKQUOTE
><P
>&#13;John Viega 의 기사 <A
HREF="http://dev-opensourceit.earthweb.com/news/000526_security.html"
TARGET="_top"
>The
Myth of Open Source Security</A
> 도 또한 이 쟁점을 논의하고 있는데
다음 방식으로 요약된다:&#13;</P
><A
NAME="AEN215"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;오픈 소스 소프트웨어 프로젝트는 비공개 소스 프로젝트보다 더욱 보안적으로
될 수 있다. 그러나 오픈 소스 프로그램을 보안적으로 만드는 바로 그것, 즉
소스 코드의 가용성과 많은 수의 사용자들이 보안 구멍을 찾아 수정할 수
있다는 사실이 사람들로 하여금 보안에 대해 잘못된 인식을 갖게 할 수
있다.&#13;</P
></BLOCKQUOTE
><P
>&#13;<A
HREF="http://www.linuxworld.com/linuxworld/lw-1998-11/lw-11-ramparts.html"
TARGET="_top"
>Michael
H. Warfield 의 Musings on open source security</A
> 는 보안에 대한
오픈 소스 소프트웨어의 영향에 대해 더욱 더 긍정적이다. Fred Schneider 는
오픈 소스 코드를 검사하는 많은 사람들이 시스템 보안을 손상시킬 수 있는
버그들을 식별하는데 성공할 것이라고 믿을 이유가 없다고 말하며 ``코드내의
버그들이 지배적인 공격 방법은 아니다"라고 주장하면서 오픈 소스가 보안에
도움이 되지 않는다고 믿고 있다 [Schneider 2000]. 그는 또한 오픈 소스는
구축 과정의 제어를 배제한다고 주장하고 있는데 그러나 모든 주요 오픈 소스
프로그램들이 명성있는 ``소유자" 의 하나 또는 약간의 공식 버전을 갖고
있듯이 오픈 소스의 실제 구축 과정에는 제어가 있다 . Peter G. Neumann 은
``오픈 박스 소프트웨어 (아마도 단지 어떤 조건하에서만 소스 코드를 얻을
수 있는) 가 실제로 시스템 보안을 향상시킬 것인가? 나의 답은 가능성이
고려될 수 있음에도 불구하고 바로 그것에 의한 것은 아니다"라고 말하면서
이를 논의하고 있다 [Neumann 2000]. 
TruSecure Corporation 은 오픈 소스 회사인 레드햇의 후원하에 왜 그들이 
오픈 소스가 보안에 더욱 효과적이라고 믿는지에 대한 논문을 작성하였다. 
<A
HREF="http://www-106.ibm.com/developerworks/linux/library/l-oss.html?open&#38;I=252,t=gr,p=SeclmpOS"
TARGET="_top"
>Natalie Walker Whitlock's IBM DeveloperWorks article</A
> 
는 또한 찬반 양론을 논의하고 있다. Brian Witten, Carl Landwehr 과 Caloyannides 
[Witten 2001] 은 소스 코드를 사용가능하게 하는 것은 시스템 보안에 유리하게 
작동한다고 잠정적으로 결론지은 기사를 IEEE 소프트웨어에 발표하였다; 
그들은 다음과 같이 언급한다:&#13;</P
><A
NAME="AEN220"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;우리는 이 논의로 부터 네 가지 추가적인 결론을 이끌어 낼 수 있다. 
첫번째 소스 코드에 대한 접근은 사용자들로 하여금 시스템 보안을 
향상시키도록 한다 -- 사용자들이 향상시킬 능력과 자원을 갖고 있다면. 
두번째 어떤 경우에 있어 오픈 소스 생명 주기가 악의적이지 않은 결함에 
대해 덜 취약한 시스템을 만들어냄을 제한된 테스트가 나타내고 있다. 
세번째 세가지 운영 체제에 대한 조사는 한가지 오픈 소스 운영 체제가 
12개월에 걸쳐 알려졌지만 패치되지 않은 취약성의 형태에 
두가지 소유권이 있는 운영 체제가 경험한 것보다 더욱 적은 노출을 경험하였다. 
마지막으로 비공개 소유권이 있는 시스템 개발 모델은 덜 보안적인 시스템이 
더욱 이익이 되지 않는 한 더욱 보안적인 시스템을 배치하고 지원하는 것에 
대해 방해에 직면해 있다. 
이러한 결론에도 불구하고 이 중요한 문제에 대한 논의는 발달 단계에 있으며 
고객에게 넘겨지는 보안을 반영할 수 있는 metrics (측정 기준) 를 절실히 
필요로 하고 있다.&#13;</P
></BLOCKQUOTE
><P
>&#13;때때로 존재하지만 알려지지 않은 취약성은 악용될 수 없으며 그래서
시스템은 실제로 보안적임이 특히 언급되고 있다. 이론상 이는 옳지만 문제는
일단 누군가가 취약성을 발견한다면 발견자가 이의 수정을 돕는 대신 단지
취약성을 악용할 수도 있다는 것이다. 따라서 취약성이 알려지지 않았다고
해서 실제로 취약성이 없어지는 것은 아니다; 이는 단순히 취약성이 언제든
악용될 수 있는 시한 폭탄임을 의미한다. 근본적으로 누군가 자신이 
발견한 취약성을 악용하는 문제는 오픈 및 비공개 소스 시스템 모두에 대한
문제이다. 소스 코드가 없는 시스템이 이러한 의미에서 더욱 보안적이다고
논의되어 왔는데 이는 공격자가 얻을 수 있는 정보가 적기 때문에 공격자가
취약성을 발견하는 것은 더욱 어려울 것이다. 이에 대응되는 논의는 공격자는
일반적으로 소스 코드를 필요로 하지 않으며 그들이 소스 코드를 사용하길
원한다면 소프트웨어의 소스를 재생성하기 위해 디셈블러를 사용할 수 있다는
것이다. 비공개 코드가 보안 취약성에 대해 어떻게 조사될 수 있는가에 대한 
한가지 논의에 대해서는 Flake [2001] 을 보라. 반대로 방어자는 소스 코드가 
없다면 보통 문제를 찾지 못할 것이며 따라서 소스 코드가 없다는 것은 
공격자와 비교해 방어자를 불리한 처지에 놓이게 한다.&#13;</P
><P
>&#13;때때로 요구되는 한가지는 사람들이 취약성에 대한 경고를 공표하여 이를 논의하지 
않아야 한다는 것이다. 이는 이론상 좋게 보이지만 문제는 공격자가 이미 
많은 채널을 통해 취약성에 대한 정보를 유포한다는 것이다. 
요약하면 이러한 접근 방법은 방어자를 공격당하기 쉽게 만드는 반면 공격자를 
저지하기 위해 할 수 있는 일은 없다. 과거에 회사들은 취약성 발표를 적극적으로 
방해하려고 했지만 일반적으로 취약성이 (취약성이 수정되어야 한다고 
강력하게 주장할 수 있는) 사용자에게 널리 알려지고 나서야 
회사들이 취약성을 수정했음을 경험을 통해 알 수 있다. 
이것이 ``완전한 발표" 찬성론의 모든 중요한 요소이다. 
Gartner 그룹은 ``Commentary: Hype is the real issue - Tech News" 라는 CNET.com 
기사에 솔직한 주석을 달았는데 다음과 같이 말하였다:&#13;</P
><A
NAME="AEN224"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;마이크로소프트사의 컴퓨터 보안 대응 센터 관리자 Scott Culp 의 의견은 
정보에 대해 오래된, 진행중인 전쟁에서의 흔한 후렴구를 되풀이하고 있다. 
정보의 배포에 관한 도덕성의 논의는 과거로 거슬로 올라가서 매우 잘 알려져 
있다. 몇 세기전에 예를 들어 교회는 태양이 태양계의 중심이라는 코페르니쿠스와 
갈릴레오의 이론을 억누르려고 하였다...

마이크로소프트 제품내의 최근의 수많은 취약성을 ``정보 보안 전문가"의 탓으로 
돌리려는 Culp 의 시도는 아무래도 솔직하지 않다. 아마도 이는 그러한 제품을 
구축했던 회사에 대한 비난을 빗나가게 하려는 시도를 나타내고 있다...

모든 관계자의 노력이 계속적으로 개선이 진행되는데 도움이 된다. 취약성이 
더욱 널리 알려지면 질수록 더욱 빠르게 수정될 것이다.&#13;</P
></BLOCKQUOTE
><P
>&#13;오픈 소스 프로그램에는 하나의 회사에 의해 적용된 제어가 없기 때문에 
사람들이 트로이 목마 (Trojan Horses) 및 다른 악의있는 코드를 삽입할 
수 있도록 한다고 때때로 논의되어 왔다. 
트로이 목마는 오픈 소스 코드에 삽입될 수 있으며 이는 사실이다. 그러나 
이는 소유권이 있는 코드내에도 삽입될 수 있다. 불만을 품거나 매수된 
고용인이 악의있는 코드를 삽입할 수 있으며 많은 회사에서 오픈 소스 프로그램에서 
보다 덜 발견될 것같다. 결국 조직 외부의 누구도 코드를 검토할 수 
없고 코드를 내부적으로 검토하는 회사는 거의 없다 (또는 검토한다 하더라도 
검토된 코드가 실제로 사용되고 있는 코드임을 확신할 수 있는 사람은 거의 없다). 
비공개 소스 회사가 나중에 고소당할 것이라는 생각은 거의 증명되지 않았다 ; 
거의 모든 라이센스는 모든 보증을 부인하며 법원은 일반적으로
소프트웨어 개발 회사가 법적 의무가 있다고 판결하지 않는다.&#13;</P
><P
>&#13;볼랜드사 (Borland) 의 Interbase 서버가 이에 해당하는 재미있는 경우인데
1992년과 1994년 사이에 볼랜드사는 그들의 데이타베이스 서버인
``Interbase" 에 의도적으로 ``백도어 (back door)" 를 삽입했는데 이
백도어는 모든 로컬 또는 원격 사용자에게 모든 데이타베이스 객체의 조작 및
임의의 프로그램들을 설치할 수 있도록 했으며 어떤 경우는 ``루트"
권한으로서 머신을 제어할 수 있게까지 하였다. 이 취약성은 적어도 6년간
제품에 그대로 있었는데 어느 누구도 이 제품을 검토할 수 없었으며
볼랜드사는 이 취약성을 제거할 동기가 없었다. 그리고 나서 볼랜드사는
2000년 7월에 소스 코드를 공개했으며 ``Firebird" 프로젝트가 이 소스
코드를 갖고 작업을 하기 시작해 2000년 12월 Interbase 와 관련된 심각한 이
보안 문제를 폭로하였다. 20001년 1월 CERT 는 <A
HREF="http://www.cert.org/advisories/CA-2001-01.html"
TARGET="_top"
>CERT advisory
CA-2001-01</A
> 로 이 백도어의 존재를 공표하였다. 맥빠지는 것은 바로
백도어가 단순히 프로그램의 아스키 덤프 (ASCII dump, 일반적인 크래커의
수법) 를 검사함으로써 쉽게 발견될 수 있다는 것이다. 이 문제가 오픈 소스
개발자가 코드를 검토하는 동안 발견되었다면 빠르게 패치되었을 것이다.
물론 패스워드를 알려지지 않게 보관함으로써 프로그램은 안전한 상태로
있었고 소스 오픈이 프로그램을 덜 보안적으로 만들었다고 주장할 수도 있다.
저자는 이를 터무니 없는 주장이라고 생각한다. 왜냐하면 아스키 덤프는
대수롭지 않은 일이고 표준 공격 기법으로 잘 알려진 것이기 때문에 모든
공격자가 취약성을 공표할만큼 갑작스런 충동을 가지지는 않았을 것이다 -
사실 이 취약성이 많이 악용되지 않았음을 확신할 어떠한 방법도 없다.
소스가 오픈된 후 소스 코드는 여러번 검토되었으며 취약성이 발견되어
수정되었음은 명백하다. 이를 특징짓는 한가지 방식은 원래 코드는 취약했고
처음 소스가 오픈될 때 이 취약성을 악용하는 것은 더욱 쉬웠지만 결국
이러한 취약성은 수정되었다고 말하는 것이다.&#13;</P
><P
>&#13;소스 코드를 오픈했을 때의 장점은 공격되어지는 소프트웨어 뿐만아니라 취약성 
평가 스캐너에도 확장된다. 취약성 평가 스캐너는 설정된 시스템에서 
의도적으로 취약성을 찾아낸다. 최근의 Network Computing 의 평가는 
가장 우수한 스캐너 (다른 무엇보다 가장 규칙에 맞는 취약성을 발견했다) 는 
오픈 소스 스캐너 인 Nessus 임을 알아냈다 [Forristal 2001].&#13;</P
><P
>&#13;그래서 최종 결과는 무엇인가? 저자는 개인적으로 프로그램의 소스가 처음
오픈될 때 종종 취약성이 노출되어 모든 사용자에 대해 덜 보안적으로
시작하지만 시간이 지난후 (가령 몇년후) 에는 비공개 프로그램보다 더욱
보안적으로 될 가능성을 갖는다고 믿고 있다. 단지 프로그램의 소스를
오픈하는 것이 갑자기 프로그램을 보안적으로 만드는 것은 아니며 오픈 소스
프로그램을 보안적으로 만든는 것은 보증되지 않는다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;첫번째 사람들은 정말로 코드를 검토해야 한다. 이는 논의되는 주요 요점중
하나이다 - 사람들이 정말로 오픈 소스 프로젝트에서 코드를 검토할 것인가?
모든 종류의 요인들이 검토량을 줄일 수 있다: 특수한 용도에 맞는 제품인가
(niche) 또는 거의 사용되지 않는 제품인가 (물론 이 제품이 검토될 가능성은
거의 없다), 개발자가 적은가, 그리고 거의 사용되지 않는 컴퓨터 언어를
사용하는가. 
분명히 한사람이 개발하며 다른 어떤 기여자도 없는 프로그램은 이러한 종류의 
검토를 받지 못한다. 한편 주요 저자와 가끔 코드를 조사하고 기여하는 많은 
다른 사람이 있는 프로그램은 코드를 검토하는 (최소한 기여를 하는) 다른 
사람들이 있다고 넌지시 말한다. 
일반적으로 더욱 많은 검토자가 있는 경우 누군가 결함을 식별할 가능성이 
일반적으로 더욱 높다 - 이것이 ``many eyeballs" (많은 검토자) 이론의 기초이다. &#13;</P
><P
>&#13;특히 검토 가능성을 줄일 수 있는 한가지 요인은 실제로 오픈 소스로 하지
않는 것이다. 어떤 벤더들은 발표한 소스 (disclosed source, 또한 소스를
얻을 수 있는 source available) 프로그램들을 오픈 소스라고 티를 내고
싶어하지만 프로그램 소유자가 상당히 독점적인 권한을 갖기 때문에 다른
사람들이 코드 소유자를 위해 무료로 작업할 마음을 더욱 갖지는 않을
것이다. 별나게 MPL 과 같은 비대칭 권한을 갖는 오픈 소스 라이센스도 이
문제를 갖고 있다. 결국 사람들은 다른 어떤 사람이 자신들의 결과에 대해
자신은 갖고 있지 않은 권한을 갖는다면 자발적으로 참여할 것 같지는 않다
(Bruce Perens 는 ``누가 다른 누군가의 무보수 고용인이 되길 원하는가?"
라고 말하고 있다). 특히 동기를 갖고 있는 대부분의 검토자들은 프로그램을
수정하려고 하는 사람인 경우가 많기 때문에 이러한 참여하려는 의욕을
방해하는 것은 검토자들의 수를 저하시킨다. Elias Levy 는 오픈 소스 보안에
대한 그의 기사에서 이 오해를 하였다; 그가 예를 들었던 파괴된 소프트웨어
(예, TIS 의 Gauntlet) 는 그 당시 오픈 소스가 아니었다.&#13;</P
></LI
><LI
><P
>&#13;두번째 코드를 개발 및 검토하려는 사람들은 보안적인 프로그램의 작성
방법을 알아야 한다. 바라건대 이 책이 도움이 될 것이다. 분명히 많은
검토자가 있더라도 아무도 찾지 못한다면 검토자의 수는 중요하지 않다. 
사람들이 코드 변경의 조사 방법을 안다면 모든 사람이 보안적인 프로그램의 
작성 방법을 알 필요는 없음을 주목해라.&#13;</P
></LI
><LI
><P
>&#13;세번째 일단 발견된다면 이러한 문제점들은 빠르게 수정되어 배포될 필요가
있다. 오픈 소스 시스템은 문제점들을 빠르게 수정하는 경향이 있지만 배포가
늘 순조로운 것은 아니다. 예를 들어 OpenBSD 개발자들은 보안 결함에 대해
매우 우수한 검토를 하지만 확인된 문제점들을 원래 개발자에게 늘
알려주지는 않는다. 따라서 한 시스템에는 수정 버전이 있지만 다른
시스템에는 결함이 남아있는 것도 가능하다.&#13;</P
></LI
></UL
><P
>&#13;오픈 소스의 다른 장점은 문제점을 발견하는 경우 즉시 이를 수정할 수
있다는 것이다.&#13;</P
><P
>&#13;
요약하면 오픈 소스 소프트웨어가 보안에 미치는 영향은 많은 탁월한
전문가들이 더욱 보안적이 될 가능성이 있다고 믿고 있음에도 불구하고 보안
공동체에서 아직도 주된 논의 대상이라는 것이다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="TYPES-OF-PROGRAMS"
>2.5. 보안적인 프로그램 타입</A
></H2
><P
>&#13;많은 여러가지 타입의 프로그램들이 보안적인 프로그램 (이 책에 정의된 바와
같이) 일 필요가 있을 수 있는데 약간의 공통된 타입은 다음과 같다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;원격 데이타 뷰어로 사용되는 애플리케이션 프로그램. 워드 프로세서 또는
파일 포맷 뷰어와 같은 뷰어로 사용되는 프로그램들은 대개 신뢰되지 않은 
사용자가 원격적으로 보내온 데이타를 보기 위해 요청된다 (이 요청은 웹
브라우저에 의해 자동적으로 호출될 수도 있다). 분명히 신뢰되지 않은 
사용자의 입력은 애플리케이션에게 임의의 프로그램을 실행시키도록
허용해서는 안된다. 보통 초기화 매크로를 지원하는 것은 어리석은데
(매크로는 데이타가 표시될 때 실행된다) 이를 지원해야 한다면 보안적인
sandbox 를 만들어야 한다 (복잡하고 에러를 일으키기 쉬운 태스크). <A
HREF="#BUFFER-OVERFLOW"
>5&#51109;</A
> 에서 논의되는 버퍼 오버 플로우와 같은
문제들을 조심해라 이는 신뢰되지 않은 사용자에게 뷰어로 임의의
프로그램을 실행시키도록 허용할 수도 있다.&#13;</P
></LI
><LI
><P
>&#13;관리자 (루트) 가 사용하는 애플리케이션 프로그램. 그러한 프로그램들은
관리자가 아닌 사람에 의해 제어될 수 있는 정보를 신뢰하지 않아야 한다.&#13;</P
></LI
><LI
><P
>&#13;로컬 서버 (또한 데몬이라고도 부른다).&#13;</P
></LI
><LI
><P
>&#13;네트워크에 접근할 수 있는 서버 (때때로 네트워크 데몬이라고도 부른다).&#13;</P
></LI
><LI
><P
>&#13;CGI 스크립트를 포함한 웹 기반 애플리케이션. 이들은 네트워크에 접근할 수
있는 서버의 특별한 경우지만 그들만의 범주를 가질만할만큼 보편적이다.
그러한 프로그램들은 웹 서버를 통해 간접적으로 호출되는데 많은 공격을
걸러내어 제거하지만 그럼에도 불구하고 견뎌야 하는 많은 공격들을
남긴다.&#13;</P
></LI
><LI
><P
>&#13;애플릿 (클라이언트로 다운로드되어 자동적으로 실행되는 프로그램). 이는
파이썬과 같은 다른 언어들도 또한 모바일 코드를 지원하지만 특히 자바가
유명하다. 몇몇 보안 관점이 있는데 클라이언트측에서 애플릿 인프라
(infrastructure) 를 구현하는 사람은 반드시 단지 허용된 기능들만을
``보안적인" 것으로 해야하며 애플릿 작성자는 적의있는 호스트들의 문제를
다뤄야 한다 (다른 말로 보통 클라이언트를 믿을 수 없다). 적의있는
호스트에서 애플릿을 실행시키는 것을 다루려는 약간의 연구가 있지만 솔직히
저자는 이들 연구 방법의 가치에 대해 회의적이며 이 주제는 저자가 이
책에서 더욱 깊게 다루지 않을 만큼 이색적이다.&#13;</P
></LI
><LI
><P
>&#13;setuid/setgid 프로그램. 이 프로그램은 로컬 사용자에 의해 호출되어 실행될
때 즉시 프로그램 소유자 및/또는 소유자 그룹의 권한이 주어진다. 많은
방식에 있어 이들은 안전하게 하기 가장 어려운 프로그램으로 이는 그들의
입력 중 많은 부분이 신뢰되지 않은 사용자의 제어하에 있고 또한 그러한
입력 중 일부는 명백하지 않기 때문이다.&#13;</P
></LI
></UL
><P
>&#13;이 책은 이러한 여러가지 타입의 프로그램들의 문제들을 하나의 집합으로
병합한다. 이 방법의 단점은 여기서 확인된 문제들중 일부가 모든 프로그램
타입에 적용되지 않는다는 것인데 특히, setuid/setgid 프로그램은 많은
예기치 않은 입력들을 갖으며 이 책의 지침들중 몇몇만이 이에 적용된다.
그러나 각각의 프로그램이 이러한 경계들을 가로지를 수도 있고 (예, CGI
스크립트가 setuid/setgid 일 수도 있으며 또한 동일한 효과를 갖는 방식으로
설정될 수도 있다) 어떤 프로그램들은 다른 타입의 프로그램으로 고려될 수
있는 몇몇 실행 파일로 나누어질 수도 있기 때문에 분명한 것은 아니다.
이러한 프로그램 타입 모두를 한꺼번에 고려하는데 있어 장점은 프로그램에
부적절한 범주를 적용하려 하지 않고 모든 문제를 고려할 수 있다는 것이다.
추후 볼 것이지만 원리들의 많은 부분이 안전하게 될 필요가 있는 모든
프로그램에 적용된다.&#13;</P
><P
>&#13;
이 책은 C++, 펄, PHP, 파이썬, Ada95 와 자바와 같은 다른 언어들에 대해 약간
언급하며 주로 C 로 작성된 프로그램에 대해 다룬다. 이는 C 가 유닉스 계열
시스템 (CGI 스크립트이외에 펄, PHP, 파이썬을 을 사용하는 경향이 있다) 에서 보안적인
프로그램을 구현하는 가장 보편적인 언어이고 대부분의 다른 언어들의 구현이
C 라이브러리를 호출하기 때문이다. 그러나 C 가 보안 목적에 맞는 가장
최선의 언어라는 것을 의미하지는 않으며 이 책에 기술된 원리들중 대부분은
사용된 프로그래밍 언어에 상관없이 적용된다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PARANOIA"
>2.6. 편집증은 미덕이다</A
></H2
><P
>&#13;보안적인 프로그램을 작성하는데 있어 기본적인 어려움은 그들을 작성하기
위해서는 다른 마음 자세 요약하면 편집광적인 마음 자세를 가져야 한다는
것이다. 이는 에러 (또한 결함 또는 버그라고도 부른다) 의 영향이 완전히
다를 수 있기 때문이다.&#13;</P
><P
>&#13;보통 보안적이지 못한 프로그램들은 많은 에러들을 갖고 있다. 이러한
에러들은 바람직하지 않지만 보통 드문 또는 있을 법하지 않은 상황을
포함하고 있는데 사용자가 우연히 이를 발견한다면 추후에는 그러한 방식으로
도구를 사용하지 않으려고 할 것이다.&#13;</P
><P
>&#13;보안적인 프로그램에서 상황은 역전된다. 어떤 사용자들은 자신들이 부당한
권한을 얻을 것이라는 희망아래 의도적으로 드문 또는 있을 법 하지 않은
상황을 찾거나 일으킬 것이다. 따라서 보안적인 프로그램을 작성할 때
편집증은 미덕이다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="WHY-WRITE"
>2.7. 이 문서를 작성한 이유는?</A
></H2
><P
>&#13;저자가 받아온 질문은 "왜 이 책을 썼는가? 하는 것인데 다음이 저자의
답이다: 지난 몇년간에 걸쳐 저자는 리눅스와 유닉스 개발자들이 되풀이해서
계속적으로 동일한 보안 위험에 빠져드는 것 같음을 알아차렸다. 감사자들은
문제점들을 느리게 발견하고 있었지만 문제점들이 우선 코드내에 놓이지
않았다면 더욱 좋았을 것이다. 저자는 문제의 일부가 개발자들이 가서 알려진
위험들을 피하는 방법에 대한 정보를 얻을 수 있는 공통의 명백한 공간이
없었다라고 믿고 있다. 정보를 공개적으로 얻을 수 있었지만 대개 시대에
뒤쳐져 있고 불완전하며 다른 문제들을 갖고 있음을 발견하는 것은 어려웠다.
대부분의 그러한 정보는 리눅스가 널리 사용되게 되었음에도 불구하고 특별히
리눅스만을 논의하지 않았다. 이러한 것이 저자의 답에 대한 실마리가
되었다: 저자는 장래의 소프트웨어 개발자들이 과거의 잘못을 되풀이하지
않을 것이며 결과적으로는 더욱 보안적인 시스템을 개발할 것이라는 희망을
갖고 이 책을 작성했다. <A
HREF="http://www.linuxsecurity.com/feature_stories/feature_story-6.html"
TARGET="_top"
>http://www.linuxsecurity.com/feature_stories/feature_story-6.html</A
>
에서 이에 대한 많은 논의를 볼 수 있다.&#13;</P
><P
>&#13;대답할 수 있는 관련 질문으로는 ``단지 다른 문서를 참조하는 대신 왜 당신
스스로 책을 썼는가?" 하는 것인데 이에 대한 몇가지 답변은 다음과 같다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;이 정보의 많은 부분은 산재되어 있었는데 중대한 정보를 하나의 조직화된
문서에 놓음으로써 이의 사용은 더욱 용이하다.&#13;</P
></LI
><LI
><P
>&#13;이 정보중 일부분은 프로그래머를 위해 작성된 것이 아니라 관리자 또는
사용자를 위해 작성된 것이다.&#13;</P
></LI
><LI
><P
>&#13;사용할 수 있는 정보의 많은 부분은 이식성있는 구축 (모든 유닉스 계열
시스템에서 작동하는 구축) 을 강조하고 있으며 결코 리눅스만을 논의하지는
않았다. 이식성을 위해서는 대개 리눅스 고유의 능력을 피하는 것이
최선이지만 때때로 리눅스 고유의 능력이 실제로 보안에 도움이 될 수 있다.
리눅스에 이식되길 바라지 않더라도 리눅스에서 작동할 때 리눅스 고유의
능력을 지원하길 원할 수도 있다. 그리고 리눅스를 강조함으로써 저자는 다른
사람들에게 필수적으로 들어맞지는 않지만 리눅스를 목표로 하는
사람들에게는 유용한 정보에 대한 참조를 포함시킬 수 있다.&#13;</P
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SOURCES-OF-GUIDELINES"
>2.8. 설계와 구현 지침의 출처</A
></H2
><P
>&#13;몇몇 문서들은 보안적인 프로그램 작성 방법 (또는 대안으로 기존
프로그램에서 보안 문제들을 찾는 방법) 을 기술하는데 도움이 되는데 이들이
이 책의 나머지부분에서 강조된 지침들에 기초가 되었다.&#13;</P
><P
>&#13;범용 서버와 setuid/setgid 프로그램의 경우는 많은 가치있는 문서들이 있다.
물론 이들에 대한 참조없이는 찾기 어려운 문서들이다.&#13;</P
><P
>&#13;Matt Bishop [1996, 1997] 은 이 주제에 대해 몇몇의 지극히 가치있는
논문들과 발표들을 발표해왔으며 사실 이 주제를 위한 웹 페이지 <A
HREF="http://olympus.cs.ucdavis.edu/~bishop/secprog.html"
TARGET="_top"
>http://olympus.cs.ucdavis.edu/~bishop/secprog.html</A
>
를 갖고 있다. AUSCERT 는 보안적인 SUID 및 네트워크 프로그램 작성 방법을
논의한 Garfinkel 과 Spafford 의 책 <A
HREF="http://www.oreilly.com/catalog/puis"
TARGET="_top"
>[Garfinkel 1996]</A
> 의 23
장의 부분적으로 기초한 프로그래밍 체크리스트 <A
HREF="ftp://ftp.auscert.org.au/pub/auscert/papers/secure_programming_checklist"
TARGET="_top"
>[AUSCERT
1996]</A
> 를 공개하였다. <A
HREF="http://www.sunworld.com/swol-04-1998/swol-04-security.html"
TARGET="_top"
>Galvin
[1998a]</A
> 은 보안적인 프로그램 개발을 위한 간단한 프로세스와
체크리스트를 기술했는데 나중에 <A
HREF="http://www.sunworld.com/sunworldonline/swol-08-1998/swol-08-security.html"
TARGET="_top"
>Galvin
[1998b]</A
> 에서 체크리스트를 갱신했다. <A
HREF="http://www.pobox.com/~kragen/security-holes.html"
TARGET="_top"
>Sitaker
[1999]</A
> 는 ``리눅스 보안 감사팀"이 찾아야 할 문제점들의 목록을
제출하고 있다. <A
HREF="http://www.homeport.org/~adam/review.html"
TARGET="_top"
>Shostack [1999]</A
>
는 보안에 민감한 코드 검토를 위한 다른 체크리스트를 정의하고 있다. NCSA
<A
HREF="http://www.ncsa.uiuc.edu/General/Grid/ACES/security/programming"
TARGET="_top"
>[NCSA]</A
>
는 일련의 간결하지만 유용한 보안적인 프로그래밍 지침들을 제공하고 있다.
다른 유용한 정보의 출처들은 <B
CLASS="EMPHASIS"
>Secure Unix Programming
FAQ</B
> <A
HREF="http://www.whitefang.com/sup/"
TARGET="_top"
>[Al-Herbish
1999]</A
>, <B
CLASS="EMPHASIS"
>Security-Audit's Frequently Asked
Questions</B
> <A
HREF="http://lsap.org/faq.txt"
TARGET="_top"
>[Graham
1999]</A
>와 <A
HREF="http://www.clark.net/pub/mjr/pubs/pdf/"
TARGET="_top"
>Ranum [1998]</A
> 들이
있다. 약간의 권고안들은 주의를 갖고 받아들여야 하는데 예를 들어 BSD 의
setuid(7) 맨페이지 <A
HREF="http://www.homeport.org/~adam/setuid.7.html"
TARGET="_top"
>[Unknown]</A
> 는
보통 수반되는 경쟁 상태 (race conditions) 를 언급하지 않고서 access(3)
의 사용을 추천하고 있다. Wood [1985] 는 ``Security for Programmers"
장에서 약간 유용하지만 오래된 충고를 하고 있다. <A
HREF="http://www.research.att.com/~smb/talks"
TARGET="_top"
>[Bellovin 1994]</A
> 는
ftpd 구현을 어떻게 더욱 간단하고 보안적으로 재구축하는 가와 같은 유용한
지침들과 약간의 특정 예를 포함하고 있다. FreeBSD 는 약간의 지침들을
제공하고 있다 <A
HREF="http://www.freebsd.org/security/security.html"
TARGET="_top"
>FreeBSD
[1999]</A
>. <A
HREF="http://developer.gnome.org/doc/guides/programming-guidelines/book1.html"
TARGET="_top"
>[Quintero
1999]</A
> 는 기본적으로 GNOME 프로그래밍 지침에 관심이 있지만 보안
고려에 대한 절을 포함하고 있다. <A
HREF="http://www.fish.com/security/murphy.html"
TARGET="_top"
>[Venema 1996]</A
> 는
보안적인 프로그램을 작성할 때 약간의 공통적인 에러들에 대한 세부적인
논의를 예와 함께 제공하고 있다 (널리 알려진 또는 예측가능한 패스워드,
악의있는 데이타에 속아넘어가기, 사용자가 접근가능한 데이타에서의 비밀과
다른 프로그램에 의존하기). <A
HREF="http://www.fish.com/security/maldata.html"
TARGET="_top"
>[Sibert 1996]</A
> 는
악의있는 데이타로부터 생기는 위협들을 기술하고 있다.&#13;</P
><P
>&#13;
웹을 방해하는 CGI (Common Gateway Interface) 를 사용한 프로그램들에 대한
보안 지침들을 제공하는 많은 문서들이 있다. 이들은 <A
HREF="http://www.csclub.uwaterloo.ca/u/mlvanbie/cgisec"
TARGET="_top"
>Van Biesbrouck
[1996]</A
>, <A
HREF="http://language.perl.com/CPAN/doc/FAQs/cgi/perl-cgi-faq.html"
TARGET="_top"
>Gundavaram
[unknown]</A
>, <A
HREF="http://webreview.com/wr/pub/97/08/08/bookshelf"
TARGET="_top"
>[Garfinkel
1997]</A
>, <A
HREF="http://www.eekim.com/pubs/cgibook"
TARGET="_top"
>Kim
[1996]</A
>, <A
HREF="http://www.go2net.com/people/paulp/cgi-security/safe-cgi.txt"
TARGET="_top"
>Phillips
[1995]</A
> <A
HREF="http://www.w3.org/Security/Faq/www-security-faq.html"
TARGET="_top"
>Stein
[1999]</A
>, <A
HREF="http://members.home.net/razvan.peteanu"
TARGET="_top"
>[Peteanu 2000]</A
> 와
<A
HREF="http://advosys.ca/tips/web-security.html"
TARGET="_top"
>[Advosys
2000]</A
> 들을 포함한다.&#13;</P
><P
>&#13;언어에 고유한 많은 문서들도 있는데 이는 이 책의 언어에 특정적인 절에서
더욱 논의된다. 예를 들어 펄 배포판은 <A
HREF="http://www.perl.com/pub/doc/manual/html/pod/perlsec.html"
TARGET="_top"
>perlsec(1)</A
>
을 포함하는데 이는 펄을 더욱 보안적으로 사용하는 방법을 기술하고 있다.
Secure Internet Programming 사이트인 <A
HREF="http://www.cs.princeton.edu/sip"
TARGET="_top"
>http://www.cs.princeton.edu/sip</A
>
는 일반적인 보안 컴퓨터 보안 문제에 관계되어 있지만 자바, 액티브X
(ActiveX) 와 자바스크립트와 같은 모바일 코드 시스템에도 중점을 두고
있다; Ed Felten 은 <A
HREF="#JAVA"
>9.6&#51208;</A
> 에서 논의되는 자바를 안전하게
하기 (<A
HREF="http://www.linuxdoc.org/HOWTO/Secure-Programs-HOWTO/www.securingjava.com"
TARGET="_top"
>[McGraw
1999]</A
>) 에 대한 책을 공동 작성했다. 썬사의 보안 코드 지침들은
본질적으로 자바와 C 에 대한 약간의 지침들을 제공하고 있는데 이는 <A
HREF="http://java.sun.com/security/seccodeguide.html"
TARGET="_top"
>http://java.sun.com/security/seccodeguide.html</A
>
에서 얻을 수 있다.&#13;</P
><P
>&#13;Yoder [1998] 은 애플리케이션 보안을 다룰 때 사용되는 패턴들의 집합을
포함하고 있는데 이는 실제 일련의 특별한 지침이라기 보다는 프로그래밍을
위해 유용하다고 생각될 수 있는 공통적으로 사용되는 일련의 패턴들이다.
Schmoo 그룹은 <A
HREF="http://www.shmoo.com/securecode"
TARGET="_top"
>http://www.shmoo.com/securecode</A
>
에 보안적인 코드 작성 방법에 대한 정보를 링크하고 있는 웹 페이지를
관리하고 있다.&#13;</P
><P
>&#13;다른 관점 (예 시스템을 크랙하는 방법) 에서 문제점들을 기술하고 있는 많은
문서들이 있다. 한 예는 McClure [1999] 로 인터넷에는 이 입장으로 바라 본
셀 수 없을 만큼 많은 자료들이 있다. 
컴퓨터 아키텍쳐를 악용하기 위해 어떤 공격을 해야하는 가에 대해 컴퓨터 아키텍처에 
관한 더욱 일반적인 문서도 있다 (예, [LSD 2001]). 
Honeynet 프로젝트는 공격자가 실제 어떤 공격을 수행하는 가에 대한 정보를 
수집해 왔다; 더욱 자세한 정보는 웹 사이트 <A
HREF="http://project.honeynet.org"
TARGET="_top"
>http://project.honeynet.org</A
> 를 보라.&#13;</P
><P
>&#13;또한 기존 프로그램에서 이미 확인된 취약성에 대한 많은 정보들도 있다.
이는 많은 특정 예들로부터 더욱 일반적인 지침들을 추출하는데 많은 노력이
들어감에도 불구하고 ``하지 말아야 할 것"에 대한 일련의 유용한 예들일 수
있다. 보안 쟁점들을 논의하는 메일링 리스트들도 있다; 가장 널리 알려진 것
중의 하나는 <A
HREF="http://securityfocus.com/forums/bugtraq/faq.html"
TARGET="_top"
>Bugtraq</A
>
으로 무엇보다도 취약성 목록을 발전시키고 있다. CERT Coordination Center
(CERT/CC) 는 인터넷 보안 문제들에 대해 취약성을 보고하는 주요 보고
센터로 가끔 패치 또는 착수한 작업의 세부사항들을 얻는 방법에 대한 지시와
함께 심각한 보안 문제와 이의 영향을 설명하는 권고안을 내놓고 있다; 더욱
자세한 정보는 <A
HREF="http://www.cert.org/"
TARGET="_top"
>http://www.cert.org/</A
> 를 보라. 원래
CERT 는 소규모 컴퓨터 응급 대책팀이었지만 공식적으로 CERT 는 현재 이를
의미하지 않음을 주목해라. 노동부 (Department of Energy, 에너지부) 의
<A
HREF="http://ciac.llnl.gov/ciac"
TARGET="_top"
>Computer Incident Advisory
Capability (CIAC)</A
> 도 또한 취약성을 보고하고 있다. 이러한 여러
그룹들은 동일한 취약성을 식별할 수도 있지만 다른 이름을 사용할 수도
있다. 이 문제를 해결하기 위해 MITRE 는 모든 공개적으로 알려진 취약성과
다른 사람에 의해 확인된 보안 적발 (exposure) 에 대해 유일한 고유 식별자
(``이름") 를 만드는 CVE (Common Vulnerabilities and Exposures) 목록을
지지하고 있다; <A
HREF="http://www.cve.mitre.org/"
TARGET="_top"
>http://www.cve.mitre.org/</A
> 를
보라. NIST 의 ICAT 는 검색가능한 컴퓨터 취약성들의 목록으로 각 CVE
취약성을 갖고 이들에 대한 목록을 작성함으로써 나중에 검색 및 비교될 수
있도록 한다; <A
HREF="http://csrc.nist.gov/icat"
TARGET="_top"
>http://csrc.nist.gov/icat</A
> 를
보라.&#13;</P
><P
>&#13;이 책은 저자가 믿기에 가장 유용하고 중요한 지침들의 요악이다; 저자의
목적은 훌륭한 프로그래머가 그저 이 책을 읽은 후 보안적인 프로그램을
구현하는데 잘 준비가 되어 있도록 하는데 있다. 어떠한 하나의 문서도 실제
이 목적을 충족시킬 수는 없지만 저자는 시도할 만한다고 믿는다. 저자의
목적은 ``자주 되풀이되고 이해하기 어려운 모든 가능한 지침들의 완벽한
목록"과 ``훌륭하고 짧지만 많은 중대한 문제들을 생략한 온라인상에서 얻을
수 있는 많은 짧은 목록"사이의 균형에 도달하는 것이다. 불확실할 때는
본보기를 포함한다; 저자는 그런 경우 이 ``one stop shop" 문서내에서 모든
사람에게 도움이 되는 정보를 만드는 것이 가장 좋다고 믿고 있다. 이 책은
저자 스스로 구성한 것으로 (모든 리스트는 자신만의 다른 구조를 갖는다)
지침들의 일부 (능력들과 fsuid 값에 대한 것들과 같은 특히 리눅스 고유의
것들) 도 스스로 만든 것이다. 위에 열거된 모든 참조된 문서들을 읽는 것
또한 강력히 추천한다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="OTHER-SOURCES"
>2.9. 보안 정보의 다른 출처들</A
></H2
><P
>&#13;보안 쟁점들만을 위한 매우 많은 웹 사이트들과 메일링 리스트들이 있는데
다음은 보안 정보의 약간의 다른 출처들이다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;
<A
HREF="http://www.securityfocus.com/"
TARGET="_top"
>Securityfocus.com</A
> 는
많은 일반적인 보안관련 뉴스와 정보를 갖고 있으며 많은 보안 관련 메일링
리스트를 호스팅하고 있다. 구독 및 그들의 기록들 (archives) 을 보는
방법에 대한 정보는 웹 사이트를 보라. SecurityFocus 에 있는 대부분의 관련
메일링 리스트들중 일부는 다음과 같다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;``bugtraq" 메일링 리스트는 컴퓨터 보안 취약성의 세부적인 논의 및 공표를
위한 완전한 폭로에 알맞는 메일링 리스트이다: 취약성들은 무엇이며 그들을
어떻게 악용하며 그리고 그들을 어떻게 수정하는가.&#13;</P
></LI
><LI
><P
>&#13;``secprog" 메일링 리스트는 보안적인 소프트웨어 개발 방법론과 기법의
논의에 알맞는 메일링 리스트이다. 저자는 특히 이 리스트를 조사하며
SECPROG (저자가 그들에 일치하면) 에 도달한 해결 방안이 이 문서에
병합되었는지를 보증하기 위해 중재자와 협의한다.&#13;</P
></LI
><LI
><P
>&#13;``vuln-dev" 메일링 리스크는 잠재적인 또는 미개발된 보안 구멍들을
논의한다.&#13;</P
></LI
></UL
></LI
><LI
><P
>&#13;IBM 의 ``developerWorks: Security" 는 많은 재미있는 기사들을 갖고 있는데
<A
HREF="http://www.ibm.com/developer/security"
TARGET="_top"
>http://www.ibm.com/developer/security</A
>
에서 더욱 많은 것을 배울 수 있다.&#13;</P
></LI
><LI
><P
>&#13;리눅스 고유의 보안 정보의 경우 훌륭한 출처는 <A
HREF="http://www.linuxsecurity.com/"
TARGET="_top"
>LinuxSecurity.com</A
> 이다.
리눅스 코드 감사에 관심이 있다면 살펴 볼 곳으로는 <A
HREF="http://www.linuxhelp.org/lsap.shtml"
TARGET="_top"
>Linux Security-Audit Project
FAQ</A
> 이며 <A
HREF="http://www.lkap.org/"
TARGET="_top"
>Linux Kernel Auditing
Project</A
> 는 보안 쟁점들에 대해 리눅스 코드를 감사하는데 전념하고
있다.&#13;</P
></LI
></UL
><P
>&#13;물론 특정 시스템을 안전하게 하려면 그들의 보안 메일링 리스트에 서명
(마이크로소프트, 레드햇 등) 해야 하며 그 후 모든 보안 갱신들을 통지받을
수 있다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CONVENTIONS"
>2.10. 문서 관행</A
></H2
><P
>&#13;시스템 메뉴얼 페이지들은 <B
CLASS="EMPHASIS"
>name(number)</B
> 로
참조되는데 <B
CLASS="EMPHASIS"
>number</B
> 는 메뉴얼의 절
숫자이다. ``다른 어느 곳도 가리키지 않음"을 의미하는 포인터 값은 NULL 로
부른다; C 컴파일러들은 정수 0 을 포인터가 필요한 대부분의 경우 NULL
값으로 변환할 것이다. 그러나 C 표준의 어떤 것도 NULL 이 일련의 모두가 0
인 비트에 의해 구현되어야 함을 요구하지 않음을 주목해라. C 와 C++ 은
'\0' (아스키 0) 을 특별히 취급하는데 이 책에서 이 값은 NIL (보통 ``NUL"
로 부르지만 ``NUL" 과 ``NULL" 은 동일해 보인다) 로 간주된다. 함수와
메쏘드 이름들은 늘 정확하게 대소문자를 구별해야 하는데 이것이 어떤
문장들이 소문자로 시작해야 함을 의미해도 마찬가지이다. 저자는 유닉스,
리눅스 또는 기본 모델들이 유닉스와 매우 유사한 다른 시스템들을 의미하기
위해 ``유닉스 계열 (Unix-like)" 이라는 용어를 사용한다; 저자는 POSIX 의
일부분을 구현하고 있지만 매우 다른 보안 모델을 갖는 윈도우 2000 과 같은
시스템들이 있기 때문에 POSIX 를 말할 수는 없다.&#13;</P
><P
>&#13;공격자는 ``attacker", ``cracker" 또는 ``adversary" 로 부른다. 어떤
저널리스트들은 ``attacker" 대신 ``해커 (hacker)" 를 사용하는데 많은
리눅스와 유닉스 개발자들이 전통적으로 악하지 않은 의미로 그들 자신을
``해커"라고 하기 때문에 이 책에서는 이러한 (오)사용을 피한다. 즉, 많은
리눅스와 유닉스 개발자들에게 ``해커"라는 용어는 특히 컴퓨터와 관련하여
계속해서 단순히 전문가 또는 열광팬을 의미한다.&#13;</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="FEATURES"
>3&#51109;. 리눅스 및 유닉스 보안 특징들의 요약</A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>Discretion will protect you, and understanding will guard you.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Proverbs 2:11 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><P
>&#13;리눅스 또는 유닉스 보안 특징들의 사용 방법에 대한 지침을 논의하기 전에
프로그래머의 관점에서 보았을 때 그러한 특징들이 무엇인가를 아는 것은
유용하다. 이 절에서는 거의 모든 유닉스 계열 시스템에서 널리 사용할 수 
있는 이러한 특징들을 간략히 기술한다. 그러나 유닉스 계열 시스템의 여러
버전간에는 상당한 변동이 있으며 모든 시스템이 여기서 기술한 능력을 갖지
않음을 주목해라. 이 장은 또한 리눅스에 대한 약간의 확장들 또는 리눅스
고유의 특징들을 특히 언급한다; 리눅스 배포판들은 모두 본질적으로 동일한
커널 및 C 라이브러리 (GPL 에 기초한 라이센스들은 새롭게 변경된 어떠한
사항들도 빠르게 보급될 수 있도록 장려한다) 를 사용하기 때문에 보안에
대해 프로그래밍 관점에서 보았을 때 각각은 상당히 유사한 경향이 있다. 
또한 여러가지 유닉스 구현사이에는 보안과 관련해서 약간의 차이를 언급하지만 
이것이 완전한 목록이 아님을 주목하기 바란다. 
이 장에서는 많은 유닉스 계열 시스템들이 구현하지 않은 MAC 
(Mandatory Access Control) 같은 쟁점들은 논의하지 않는다. 이러한 
특징들이 무엇인지 알고 있다면 이 절을 건너뛰어 읽어도 무방하다.&#13;</P
><P
>&#13;많은 프로그래밍 지침들은 리눅스 또는 유닉스의 보안 관련 부분을 간략하게
대충 다루며 중요한 정보를 건너뛰는데 특히 이러한 지침들은 대개 일반적인
말투로 ``사용 방법"을 논의하며 사용에 영향을 미치는 보안 속성에 관해서는
얼버무린다. 이와는 반대로 메뉴얼 페이지에는 개별적인 기능에 대한 상당한
양의 세부 정보가 있지만 각각의 개별적 기능의 사용 방법에 관한 세부
논의로 인해 때때로 주요한 보안 쟁점들을 이해하기 어렵게 한다. 이 절은
프로그래머가 사용할 것같은 리눅스 보안 메카니즘을 개략적으로 그러나 보안
관련 문제에 특히 중점을 두어 기술함으로써 이러한 간격을 좁히고자 한다.
이 절은 명확하게 보안 관련 문제에 중점을 둠으로써 일반적인 프로그래밍
지침보다 보다 깊이를 갖으며 더욱 세부적인 것을 얻을 수 있는 참고문헌들을
지적한다.&#13;</P
><P
>&#13;우선 기본. 리눅스와 유닉스는 근본적으로 커널과 ``사용자 공간 (user
space)" 두 부분으로 나누어 지는데 대부분의 프로그램들은 커널 윗 부분의
사용자 공간에서 실행된다. 리눅스는 ``커널 모듈"의 개념을 지원하는데 이는
단순히 커널에 동적으로 코드를 적재할 수 있는 능력으로 리눅스가 아직도 이
근본적인 분리를 지님을 주목해라. HURD 와 같은 다른 시스템들은 ``마이크로
커널"에 기초하는데 이들은 더욱 제한된 기능성을 갖는 작은 커널과 커널에
의해 전통적으로 하위 수준 기능들을 구현하는 일련의 사용자 프로그램으로
이루어진다.&#13;</P
><P
>&#13;어떤 유닉스 계열 시스템들은 강력한 보안, 특히 Mandatory Acces Control 
(B1 수준 또는 그 이상) 에 대한 미국의 국방성 요건을 지원하기 위해
광범위하게 널리 수정되어 왔다. 이 책의 현재 버전은 이러한 시스템 또는
쟁점들을 다루지는 않는다. 물론 향후 버전에서는 이를 다룰 수 있을 것이다.
이들중 일부에 대한 보다 세부적인 정보는 다른 곳에서 얻을 수 있는데 예를
들어 SGI 의 "Trusted IRIX/B" 에 대한 항목들은 NSA 의 <A
HREF="http://www.radium.ncsc.mil/tpep/library/fers/index.html"
TARGET="_top"
>Final
Evaluation Reports (FERs)</A
> 에서 얻을 수 있다. &#13;</P
><P
>&#13;사용자가 로그인할 때 사용자 이름은 사용자 아이디 ``UID" 와 그룹
(사용자가 멤버) 아이디 ``GID" 를 나타내는 정수로 사상되는데 UID 가 0 인
사용자는 특별한 권한을 갖는 사용자로 일반적으로 ``루트" 라고 불린다;
대부분의 유닉스 계열 시스템에서 루트는 대부분의 보안 검사를 좌우할 수
있고 시스템을 관리하는데 사용된다. 몇몇 유닉스 시스템에 GID 0 은 특별하며 
그룹 수준에서 자원에 대해 제한되지 않은 접근을 허용한다 [Gay 2000, 228]; 
이는 리눅스와 같은 다른 시스템에서는 들어맞지 않으며 그러나 이러한 
시스템에서 group 0 은 많은 특별한 시스템 파일을 소유하기 때문에 만능이다. 
보안 관점에서는 프로세스만이 ``주체"인데 즉 단지 프로세스만이 활성 객체이다. 
프로세스는 다양한 데이타 객체, 특히 파일시스템 객체 (FileSystem Object, FSO), System V
프로세스간 통신 (Interprocess Communication, IPC) 객체 및 네트워크
포트에 접근할 수 있다. 또한 프로세스는 시그널을 설정할 수 있다. 다른
보안 관련 주제는 쿼터 (quota) 및 한도 (limits), 라이브러리, 감사와 PAM
을 포함하는데 이는 다음 몇개의 하부 절에서 세부적으로 논의된다.&#13;</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PROCESSES"
>3.1. 프로세스</A
></H2
><P
>&#13;유닉스 계열 시스템에서 사용자는 프로세스를 실행시킴으로써 작업을 한다.
대부분의 유닉스 시스템은 별개의 개념으로서 ``쓰레드"를 지원하는데
쓰레드는 프로세스내에서 메모리를 공유하며 시스템 스케쥴러가 실제로 이를
스케쥴한다. 리눅스에서는 이를 다르게 다루는데 (필자 의견으로는 더욱 나은
접근 방법을 사용한다) 쓰레드와 프로세스사이에 본질적인 차이는 없다.
리눅스에서는 대신 프로세스가 다른 프로세스를 생성할 때 어떠 자원 (예를
들면 메모리) 이 공유될 지를 선택할 수 있다. 곧이어 커널은 쓰레드 수준의
속도를 얻기 위해 최적화를 수행하는데 더욱 자세한 정보는 clone(2) 를
보라. 리눅스 커널 개발자들은 ``쓰레드" 또는 ``프로세스"라기 보다는
``태스크"를 사용하는 반면 형식적인 문서에서는 프로세스를 사용하는 경향이
있음을 언급하는 것은 가치가 있다 (따라서 저자는 ``프로세스"란 용어를
사용할 것이다). 다중 쓰레드 애플리케이션을 프로그래밍할때는 보통 이러한
차이점을 드러내지 않는 표준 쓰레드 라이브러리중 하나를 사용하는 것이
더욱 좋다. 이는 대개 쓰레드의 이식성을 더욱 높이지만 단독 운영 체제
쓰레드로 한 애플리케이션 수준 이상의 쓰레드를 구현함으로써 어떤
라이브러리는 추가적인 간접 (indirection) 수준을 제공한다; 이는 어떤
애플리케이션에 대해 몇몇 시스템에서 상당히 향상된 성능을 제공할 수
있다.&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROCESS-ATTRIBUTES"
>3.1.1. 프로세스 속성</A
></H3
><P
>&#13;유닉스 계열 시스템에서 각 프로세스와 관련된 대표적인 속성은 다음과 같다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;RUID, RGID - 프로세스를 실행시키는 사용자의 실제 UID 와 GID&#13;</P
></LI
><LI
><P
>&#13;EUID, EGID - 특권 검사에 사용되는 유효 UID 와 GID (파일시스템 제외)&#13;</P
></LI
><LI
><P
>&#13;SUID, SGID - 허가 전환 ``on 과 off "을 지원하기 위해 사용되는 유보된
(saved) UID 와 GID (밑부분에서 논의). 모든 유닉스 계열 시스템이 이를
지원하지는 않지만 리눅스 및 쏠라리스를 포함한 대다수는 이를 지원한다; 
주어진 시스템이 POSIX 표준에서 이 옵션을 구현하는지 검사하려면 
_POSIX_SAVED_IDS 가 유효한지 결정하기 위해 sysconf(2) 를 사용할 수 있다.&#13;</P
></LI
><LI
><P
>&#13;보충 그룹들 (supplemental groups) - 이 사용자가 멤버로 소속되는 그룹들의
목록. 원래 버전인 유닉스 7 에서는 존재하지 않는다 - 프로세스는 단지 한번에 
한 그룹의 멤버였고 그룹을 변경시키기 위해서 특별한 명령을 실행시켜야 했다. 
BSD 는 더욱 유연하게 각 프로세스내에 그룹 리스트에 대한 지원을 추가했으며 
이는 현재 리눅스 및 쏠라리스를 포함해 널리 구현되고 있다. &#13;</P
></LI
><LI
><P
>&#13;umask - 새로운 파일시스템 객체가 생성될 때 디폴트 접근 제어 설정을
결정하는 일련의 비트들; umask(2) 를 보라.&#13;</P
></LI
><LI
><P
>&#13;스케쥴링 매개변수 (scheduling parameters) - 각 프로세스는 스케쥴링
정책을 갖는데 디폴트 정책 SCHED_OTHER 을 갖는 프로세스들은
부가적인 매개변수인 nice, priority 및 counter 를 갖는다. 더욱 자세한
정보는 sched_setscheduler(2) 를 보라.&#13;</P
></LI
><LI
><P
>&#13;한도 (limits) - 프로세스당 자원 한도 (밑부분 참조)&#13;</P
></LI
><LI
><P
>&#13;파일시스템 루트 (filesystem root) - 루트 파일시스템 ("/") 이 어디서
시작하는 가에 대한 프로세스의 인식 (idea); chroot(2) 를 보라.&#13;</P
></LI
></UL
><P
>&#13;다음은 프로세스와 관련해 덜 공통된 속성들이다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;FSUID, FSGID - 파일시스템 접근 검사를 위해 사용되는 UID 와 GID 로 각각
EUID 와 EGID 와 동일하다. 이는 리눅스 고유의 속성이다.&#13;</P
></LI
><LI
><P
>&#13;능력 (capabilities) - POSIX 능력 정보; 프로세스는 유효한, 상속가능한 및
허가된 세가지 능력을 갖는데 POSIX 능력에 대해 더욱 자세한 정보는
밑부분을 보라. 리눅스 커널 2.2 와 그 이상 버전에서는 이를 지원한다; 다른
유닉스 계열 시스템도 이를 지원하는데 리눅스만큼 널리 사용되지는 않는다.&#13;</P
></LI
></UL
><P
>&#13;리눅스에서 실제로 각 프로세스에 어떤 속성들이 관련되었는 지를 정확히 알
필요가 있다면 리눅스 소스 코드가 가장 명확한 소스이다. 특히
<TT
CLASS="FILENAME"
>/usr/include/linux/sched.h</TT
> 파일에서 task_struct 의
정의를 참조해라.&#13;</P
><P
>&#13;새로운 프로세스를 생성하는 이식성있는 방식으로 리눅스는 fork(2) 호출을
사용한다. BSD 는 최적화 기법으로 변형된 vfork(2) 를 도입하였다. vfork 과
관련된 최종 결과는 간단한데 이를 피할 수 있다면 <B
CLASS="EMPHASIS"
>사용하지 마라</B
>. 더욱 자세한 정보는  <A
HREF="#AVOID-VFORK"
>7.5&#51208;</A
> 를 참조해라.&#13;</P
><P
>&#13;리눅스는 고유의 clone(2) 호출을 지원하는데 fork(2) 호출과 유사하게
작동하지만 공유되어야 하는 자원 (예, 메모리, 파일기술자 등) 을 지정할 수
있다. 여러 가지 BSD 시스템들은 원래 Plan9 에서 개발된 rfork() 시스템
호출을 구현하는데 동일한 일반적 개념을 갖고 있지만 상이한 의미 체계
(semantics) 를 갖고 있다 (이는 공유되는 것에 대해 보다 엄격한 제어를
갖는 프로세스를 생성한다). 이식성있는 프로그램이라면 가능한 이러한
호출을 직접적으로 사용하지 않아야 한다; 앞에서 언급했듯이 프로그램들은
쓰레드를 구현하기 위해 이러한 호출을 사용하는 쓰레딩 라이브러리에
의존해야 한다.&#13;</P
><P
>&#13;이 책은 프로그램 작성에 대한 완전한 지침서가 아니며 따라서 프로세스를
다루는 널리 얻을 수 있는 정보를 건너뛸 것이다. 더욱 자세한 정보는
wait(2), exit(2) 등에 대한 문서를 봐야 한다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="POSIX-CAPABILITIES"
>3.1.2. POSIX Capabilities</A
></H3
><P
>&#13;POSIX 능력 (capability) 은 일반적으로 루트가 소유하는 권한을 보다 구체적인 권한들의
커다란 셋으로 분할할 수 있도록 하는 비트들의 셋이다. 이는 IEEE 표준
초안에 의해 정의되는데 리눅스 고유의 것은 아니며 또한 일반적으로 다른 
유닉스 계열 시스템에 의해 지원되지도 않는다. 리눅스 커널 2.0 은 POSIX 능력을
지원하지 않는 반면 2.2 버전은 프로세스에 대한 이 지원을 추가하였다. 이
문서를 포함하여 리눅스 문서들이 ``루트 권한을 필요로 한다" 라고 할 때
거의 모든 경우에 있어 이는 능력 문서에 인용된 바와 같이 ``능력을 필요로
한다"를 의미한다. 필요한 특정 능력을 알고 싶다면 능력 문서에서 이를
조사해라.&#13;</P
><P
>&#13;리눅스에서 궁극적인 목적은 파일시스템내의 파일에 능력이 결부될 수 있도록
하려는 것인데 그러나 이 글을 쓰는 시점에서 이는 아직까지 지원되지
않고 있다. 능력 양도에 대한 지원도 있지만 디폴트로 이러한 기능은 금지되어
있다. 리눅스 2.2.11 버전은 ``능력 제한 셋 (capability bounding set)"
라는 능력을 보다 직접적으로 사용할 수 있게 하는 특징을 추가하였다. 능력
제한 셋은 시스템내의 모든 프로세스가 보유할 수 있는 능력 목록이다 (물론
그렇지않으면 특별한 init 프로세스 만이 이를 보유할 수 있다). 능력이 제한
셋에 없다면 어떤 프로세스라도 지닌 권한에 상관없이 이를 사용하지 못할
것이다. 이 특징은 예를 들어 커널 모듈 적재를 금지하는데 사용될 수 있는데
이를 이용한 예제 도구는 <A
HREF="http://pweb.netcom.com/~spoon/lcap/"
TARGET="_top"
>http://pweb.netcom.com/~spoon/lcap/</A
>
의 LCAP 이다.&#13;</P
><P
>&#13;POSIX 능력에 대한 더욱 자세한 정보는 <A
HREF="ftp://linux.kernel.org/pub/linux/libs/security/linux-privs"
TARGET="_top"
>ftp://linux.kernel.org/pub/linux/libs/security/linux-privs</A
>
에서 얻을 수 있다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROCESS-CREATION"
>3.1.3. 프로세스 생성과 조작</A
></H3
><P
>&#13;프로세스는 fork(2), vfork(2) (추천하지 않는다) 또는 리눅스 고유의
clone(2) 를 사용하여 생성될 수 있는데 이러한 시스템 호출 모두는 기존
프로세스로부터 두 프로세스를 생성함으로써 기존 프로세스를 복제한다.
프로세스는 execve(2) 또는 이에 대한 다양한 전위 (front-end) (예를 들어
exec(3), system(3) 및 popen(3) 를 보라) 를 호출함으로써 다른 프로그램을
실행시킬 수 있다.&#13;</P
><P
>&#13;프로그램이 실행되어 그 파일의 setuid 또는 setgid 비트 셋이 설정될 때
프로세스의 EUID 또는 EGID 각각은 대개 파일의 값들로 설정된다. 이
기능성은 경쟁 상태 (race condition) 때문에 setuid 또는 setgid 스크립트를
지원하기 위해 사용될 때 초기 유닉스의 보안 결함의 원인이였다. 커널이
어떤 인터프리터를 실행시켜야 하는지 알기 위해 파일을 여는 시간과 방금 id
가 설정된 인터프리터가 실행되어 파일을 해석하기 위해 이를 다시 여는
시간사이에 해커가 직접적으로 또는 심볼릭 링크를 통해 파일을 변경할 수
있다.&#13;</P
><P
>&#13;여러가지 유닉스 계열 시스템들은 다른 방식으로 setuid 스크립트에 대한
보안 쟁점을 다룬다. 리눅스와 같은 시스템들은 스크립트를 실행할 때 setuid
와 setgid 비트를 완전히 무시하는데 이는 명백히 안전한 접근 방법이다.
대부분의 SysVr4 와 BSD 4.4 현재 버전은 커널 경쟁 상태를 피하기 위해 다른
접근 방법을 사용하는데, 커널이 열려고 하는 set-id 스크립트의 이름을
인터프리터에 전달할 때 경쟁 상태를 허용할 수 있는 경로이름보다는 대신
파일이름 /dev/fd/3 을 전달한다. 이는 스크립트상에 이미 열려진 특별
파일로 따라서 공격자가 악용할 수 있는 경쟁 상태는 없다. 이러한
파일시스템에서도 저자는 밑부분에 논의될 것이지만 보안적인 프로그램
작성에 setuid/setgid 쉘 스크립트 언어를 사용하지 말라고 추천한다.&#13;</P
><P
>&#13;어떤 경우에 있어 프로세스는 여러 가지 UID 와 GID 값들에 영향을 미칠 수
있는데 setuid(2), seteuid(2), setreuid(2) 와 리눅스 고유의 setfsuid(2)
를 보라. 특히, 유보된 사용자 id (SUID) 속성은 신뢰된 프로그램이
일시적으로 UID 들을 변경할 수 있도록 하는 것이다. SUID 를 지원하는
유닉스 계열 시스템들은 다음 규칙을 사용한다: RUID 가 변경되거나 또는
EUID 가 RUID 와 동일하게 설정되지 않으면 SUID 가 새로운 EUID 로
설정된다. 권한이 없는 사용자들은 그들의 SUID 로부터 EUID 를 설정할 수
있으며 RUID 를 EUID 로 EUID 를 RUID 로 설정할 수 있다.&#13;</P
><P
>&#13;리눅스 고유의 FSUID 프로세스 속성은 NFS 서버와 같은 프로그램들에게
시그널을 프로세스에 보내기 위한 UID 허가권을 주지 않고서 이들이 자신들을
어떤 주어진 UID 권한을 갖는 파일시스템으로 제한할 수 있도록 하는
속성이다. EUID 가 변경될 때마다 FSUID 는 새로운 EUID 값으로 변경된다;
FSUID 값은 리눅스 고유 호출인 setfsuid(2) 를 사용하여 별도로 설정될 수
있다. 루트이외의 호출자들은 FSUID 를 단지 현재 RUID, EUID, SEUID 또는
현재 FSUID 값으로만 설정할 수 있음을 주목해라.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FILES"
>3.2. 파일</A
></H2
><P
>&#13;모든 유닉스 계열 시스템에서 정보들은 기본적으로 "/" 루트 파일 트리에
저장된다. 파일 트리는 디렉토리들의 계층적 집합으로 디렉토리 각자가
파일시스템 객체 (FSO) 를 포함할 수도  있다.&#13;</P
><P
>&#13;리눅스에서 파일시스템 객체는 보통의 파일, 디렉토리, 심볼릭 링크, 네임드
파이프 (선입 선처리, FIFO, first-in first-out 이라고도 부른다) , 소켓
(밑부분을 보라), 문자 디바이스 파일 또는 블록 디바이스 파일일 수 있다
(이 목록은 find(1) 명령으로 볼 수 있다). 다른 유닉스 계열 시스템도
동일한 또는 유사한 FSO 타입 목록을 갖는다.&#13;</P
><P
>&#13;파일시스템 객체는 파일 트리에 디렉토리로 마운트 및 언마운트될 수 있는
파일시스템에 모아진다. 파일시스템 타입 (예, ext2 와 FAT) 은 속도, 신뢰성
등을 최적하기 위해 디스크상에 데이터를 배열하기 위한 특정한 일련의
합의이다; ``파일시스템"은 ``파일시스템 유형" 과 동의어로 사용된다.&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FSO-ATTRIBUTES"
>3.2.1. 파일시스템 객체 속성</A
></H3
><P
>&#13;여러가지 유닉스 계열 시스템은 다양한 파일시스템 타입을 지원한다.
파일시스템은 약간 다른 일련의 접근 제어 속성들을 가질 수 있으며 접근
제어는 마운트시 선택한 옵션에 의해 영향을 받을 수 있다. 리눅스에서는
ext2 파일시스템이 현재 가장 널리 사용되고 있으며 리눅스는 방대한 양의
파일시스템을 지원하는데 대부분의 유닉스 계열 시스템도 다중 파일시스템을
또한 지원한다.&#13;</P
><P
>&#13;유닉스 계열 시스템에서 대부분의 파일시스템은 적어도 다음을 저장한다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;소유 UID 와 GID - 파일시스템 객체의 ``소유자"를 식별한다. 달리 언급되지
않는다면 소유자 또는 루트만이 접근 제어 속성을 변경할 수 있다.&#13;</P
></LI
><LI
><P
>&#13;허가권 비트 (permission bits) - 각 사용자 (소유자), 그룹 및 other 에 대한
읽기, 쓰기 및 실행하기 비트. 일반 파일에 대해서는 읽기, 쓰기와
실행하기는 일반적인 의미를 갖는다. 디렉토리에서 ``읽기" 허가권은 
디렉토리의 내용들을 표시하기 위해 필요하며 반면 ``실행하기" 허가권은 
때로는 ``검색 (search)" 허가권이라고도 하는데 그 내용들를 사용하기 위해 실제
디렉토리내로 들어가기 위해 필요하다. 디렉토리에서 ``쓰기" 허가권은 그
디렉토리내에 파일 추가하기, 제거하기 및 재명명하기를 허용한다; 단지
추가하기만을 허용하려면 밑부분에 언급되는 sticky 비트를 설정해라. 심볼릭
링크에 대해서는 허가권 값이 전혀 사용되지 않음을 주목해라; 중요한 것은
단지 이들이 포함하는 디렉토리와 링크된 파일의 값이다.&#13;</P
></LI
><LI
><P
>&#13;``sticky" 비트 - 이 비트가 디렉토리에 설정되어 있을 때 그 디렉토리내에서
파일의 언링크 (제거) 및 재명명은 파일 소유자, 디렉토리 소유자 또는
루트만이 할 수 있다. 이는 매우 공통된 유닉스의 확장으로 오픈 그룹의
Single Unix Specification 버전 2 에 명시되어 있다. 초기 유닉스 버전들은
이를 ``save program text" 비트라고 불렀으며 이를 메모리에 상주해야 하는
실행가능한 파일을 가리킬 때 사용하였다. 루트만이 이 비트를 설정할 수
있도록 시스템은 보증했는데 그렇지 않다면 사용자들이 억지로 ``모든 것"을
메모리에 올림으로써 시스템을 파손시킬 수 있을 것이다. 리눅스에서 이
비트는 일반 파일에 아무런 영향을 미치지 않으며 일반 사용자는 자신이
소유한 파일에 대해 이 비트를 변경할 수 있다: 리눅스의 가상 메모리 관리
기법은 이러한 비트를 사용해도 아무런 문제가 되지 않게 한다.&#13;</P
></LI
><LI
><P
>&#13;setuid, setgid - 실행가능한 파일에 설정되어 있을 때 이 파일을
실행시킴으로써 프로세스의 유효 UID 또는 유효 GID 는 각각 파일 소유 UID
또는 GID 로 설정될 것이다. 모든 유닉스 계열 시스템은 이를 지원한다.
리눅스와 System V 에서 실행 권한이 없는 파일에 setgid 가 설정되어 있을
때 이는 접근 도중 강제 로킹 (mandatory locking) 되는 파일을 가리킨다 
(파일시스템이 강제 로킹을 지원하도록 마운트된 경우); 이렇듯
많은 의미는 많은 사람을 놀라게 하는데 유닉스 계열 시스템에서 보편적인
것은 아니다. 사실 chmod(3) 에 대한 오픈 그룹의 Single Unix Specification
버전 2 는 이러한 설정이 의미가 없는 경우 실행불가능한 파일에 대해 setgid
을 설정하는 요청을 시스템이 무시할 수 있도록 한다. 리눅스와 솔라리스에서
디렉토리에 setgid 가 설정되어 있을 때 이 디렉토리내에서 생성된 파일의
GID 는 디렉토리의 GID 로 자동 설정된다. 이러한 접근방법의 목적은
``프로젝트 디렉토리"를 지원하기 위한 것으로 사용자들은 파일을 이렇게
특별히 설정된 디렉토리에 저장할 수 있으며 그룹 소유자는 자동적으로
변경된다. 그러나 디렉토리에 setgid 를 설정하는 것은 SiIngle Unix
Specification [Open Group 1997] 과 같은 표준에는 명시되어 있지 않다.&#13;</P
></LI
><LI
><P
>&#13;타임스탬프 - 각 파일시스템 객체에 대해 접근 및 변경 시간이 저장된다.
그러나 소유자는 이 값을 임의로 설정할 수 있기 때문에 (touch(1) 을 보라)
이러한 정보의 신뢰성에 유의해라. 모든 유닉스 계열 시스템은 이를
지원한다.&#13;</P
></LI
></UL
><P
>&#13;다음 속성은 ext2 파일시스템에서 리눅스 고유의 확장이다. 물론 많은 다른
파일시스템도 유사한 기능성을 갖는다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;immutable (불변) 비트 - 파일시스템 객체에 대한 어떠한 변경도 허용되지
않는데 단지 루트만이 이 비트를 설정 또는 제거할 수 있다. 이는 단지 ext2
만 지원하며 모든 유닉스 시스템 (또는 모든 리눅스 파일시스템) 에 대해
이식가능한 것은 아니다.&#13;</P
></LI
><LI
><P
>&#13;append-only 비트 - 파일시스템 객체에 덧붙이기만 허용되는데 단지 루트만이
이 비트를 설정 또는 제거할 수 있다. 이는 단지 ext2 만 지원하며 모든
유닉스 시스템 (또는 모든 리눅스 파일시스템) 에 대해 이식가능한 것은
아니다.&#13;</P
></LI
></UL
><P
>&#13;다른 공통된 확장은 ``이 파일을 삭제할 수 없다" 를 가리키는 어떤 종류의
비트들을 포함한다.&#13;</P
><P
>&#13;이러한 값들중 많은 것들은 마운트시 영향을 받을 수 있으며 따라서 예를
들면 어떤 비트는 일정한 값 (미디어상에서 그들의 값에 상관없이) 을 갖고
있는 것처럼 처리될 수 있다. 이에 대해 더욱 자세한 정보는 mount(1) 을
보라. 이러한 비트들은 유용하지만 이들중 일부는 손쉬운 사용을 간단히 하기
위한 것으로 실제로 어떤 행동을 예방할 만큼 충분하지 않음을 알고 있어라.
예를 들어 리눅스에서 ``noexec" 옵션을 갖고 마운팅을 하는 것은 그
파일시스템에서 프로그램의 실행을 금지할 것이다; 메뉴얼에 언급된
것과 같아 이는 호환되지 않는 시스템에 대해 바이너리를 포함하고 있는
파일시스템을 마운팅하기 위한 것이다. 리눅스에서 이 옵션이 파일 실행을
완전히 막지는 못할 것이다; 파일을 실행시킬 수 있는 다른 어딘가에 이를
복사할 수 있으며 또한 이 파일을 직접적으로 실행시키기 위해
``/lib/ld-linux.so.2" 명령을 실행시킬 수도 있다.&#13;</P
><P
>&#13;어떤 파일시스템들은 이러한 접근 제어 값들중 일부를 지원하지 않는다;
이러한 파일시스템이 어떻게 다뤄지는 가에 대해서는 mount(1) 을 보라. 특히
많은 유닉스 계열 시스템은 MS-DOS 디스크를 지원하는데 MS-DOS 디스크는
이러한 속성들을 거의 지원하지 않는다 (이러한 속성을 정의하는 표준 방식은
없다). 이런 경우 유닉스 계열 시스템은 표준 속성을 에뮬레이트하며 (특별한
디스크상의 파일을 통해 될 수 있는한 이들을 구현함으로써) 이러한 속성은
일반적으로 mount(1) 명령에 의해 영향을 받는다.&#13;</P
><P
>&#13;유닉스 계열 시스템이 보다 복잡한 체계 (POSIX ACL) 을 지원하지 않는다면
파일 추가 및 제거를 위해서는 파일의 <B
CLASS="EMPHASIS"
>디렉토리</B
> 허가권 
비트와 소유자만이 중요하다는 것을 언급하는 것은 중요하다. 시스템이 다른
확장을 갖고 있지 않다면, 리눅스 2.2 는 이를 지원하지 않는데, 허가권 비트가
설정되지 않은 파일은 파일을 포함하는 디렉토리가 제거를 허용한다면 제거될
수 있다. 또는 조상 디렉토리가 자손에게 어떤 사용자 또는 그룹에 의해
변경되도록 허용한다면 그 디렉토리의 모든 자손은 그 사용자 또는 그룹으로
대체될 것이다.&#13;</P
><P
>&#13;보안에 대한 IEEE POSIX 표준 초안은 허가권을 갖는 사용자와 그룹 목록을
지원하는 표준에 일치하는 ACL 에 대한 기법을 정의하고 있다. 불행히 이는
널리 지원되지 않으며 유닉스 계열 시스템에 동일한 방식으로 지원되지
않는다. 예를 들어 리눅스 2.2 는 파일시스템내에 ACL 또는 POSIX 능력 값을
갖고 있지 않다.&#13;</P
><P
>&#13;리눅스 ext2 파일시스템이 루트 사용자를 위해 소량의 공간을 남겨두고
있음을 언급하는 것은 가치가 있다. 이는 서비스 부인 공격에 대한 부분적인
방어로 사용자가 루트 사용자와 공유하는 디스크를 가득 채운다고 할지라도
루트 사용자는 중대한 기능을 위해 소량의 공간을 갖는다. 디폴트는
파일시스템의 5% 로 mke2fs(8) 특히 "-m" 옵션을 보라.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FSO-INITIAL-VALUES"
>3.2.2. 생성시 초기값</A
></H3
><P
>&#13;생성시 다음 규칙이 적용된다. 대부분의 유닉스 시스템에서 create(2) 또는
open(2) 에 의해 새로운 파일시스템 객체가 생성될 때 FSO 의 UID 와 GID 는
각각 프로세스의 UID 와 GID 로 설정된다. 리눅스는 FSUID 확장때문에 약간
다르게 작동하는데 FSO 의 UID 와 GID 가 각각 프로세스의 FSUID 와 FSGUID
로 설정된다; 파일을 포함하는 디렉토리의 setgid 비트 또는 파일시스템의
``GRPID" 플래그가 설정되어 있다면 FSO GID 는 실제적으로 그 디렉토리의
GID 로 설정된다. 썬 솔라리스와 리눅스를 포함한 많은 시스템들은 또한
setgid 디렉토리 확장을 지원하는데 앞에 언급했듯이 이 특별한 경우는
``프로젝트" 디렉토리를 지원한다; ``프로젝트" 디렉토리를 만들기 위해서는
그 프로젝트에 대한 특별 그룹을 생성하고 그룹 소유의 프로젝트를 위한
디렉토리를 생성한 후 디렉토리에 setgid 비트를 설정해라: 이 디렉토리에
놓인 파일은 자동적으로 프로젝트에 의해 소유된다. 비슷하게 새로운
디렉토리가 setgid 비트가 설정된 (파일시스템 GRPID 는 설정되어 있지 않다)
디렉토리내에서 생성된다면 새로운 하부 디렉토리도 setgid 비트가 설정되어
있을 것이다. 따라서 프로젝트 하부 디렉토리도 비슷하게 사용할 수 있다:
모든 다른 경우에 있어서 setgid 비트는 새로운 파일에 대해 제거된다. 이는
``사용자-개인 그룹 (user-private group)" 체계에 대한 논리적 근거로
레드햇 및 다른 배포업자가 사용하고 있는데 모든 사용자는 단지 자신을
멤버로 갖는 "개인" 그룹의 멤버이며 따라서 디폴트로 그룹에게 파일 읽기와
쓰기 권한을 허용할 수 있다 (자신의 그룹의 멤버이기 때문에). 따라서
파일의 그룹 멤버십 이런 방식으로 전달될 때 읽기와 쓰기 권한도 또한
전달된다. FSO 기본 접근 제어 값 (읽기, 쓰기, 실행하기) 은 요청값과
프로세스의 umask 논리곱으로부터 계산된다. 새로운 파일은 늘 sticky 및
setuid 비트가 없이 시작된다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CHANGING-ACLS"
>3.2.3. 접근 제어 속성 변경</A
></H3
><P
>&#13;chmod(2), fcmod(2)  또는 chmod(1) 을 이용하여 이러한 속성값의 대부분을
설정할 수 있는데 또한 chown(1) 과 chgrp(1) 을 보라. 리눅스 고유의 속성중
일부는 chattr(1) 을 이용하여 조작된다.&#13;</P
><P
>&#13;리눅스에서는 단지 루트만이 주어진 파일의 소유자를 변경할 수 있음을
주목해라. 어떤 유닉스 계열 시스템은 일반 사용자가 그들의 파일 소유권을
다른 사용자에게 전달할 수 있도록 하는데 이는 문제를 복잡하게 하며
리눅스에서는 금지되어 있다. 예를 들어, 디스크 사용을 제한하려고 하는
경우 파일 소유권 변경을 허용한다면 사용자들은 임의의 커다란 파일은
실제로 다른 사용자의 것이다라고 항의를 할 것이다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="USING-ACLS"
>3.2.4. 접근 제어 속성 사용</A
></H3
><P
>&#13;리눅스와 대부분의 유닉스 계열 시스템하에서 읽기와 쓰기 속성값은 파일이
열려질 때만 검사된다; 물론 모든 읽기 또는 쓰기에 대해 재검사되지는
않는다. 파일시스템은 유닉스 계열 시스템의 중심이기 때문에 아직도 많은
수의 호출이 이러한 속성을 검사하는데 이러한 호출로는 open(2),
create(2), link(2), unlink(2), rename(2), mknod(2), symlink(2) 및
socket(2) 들이 있다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FILESYSTEM-HIERARCHY"
>3.2.5. 파일시스템 계층구조</A
></H3
><P
>&#13;다년간에 걸쳐 어떤 파일은 어느 곳에 놓아햐 한다는 합의가 확립되어 왔다.
가능한 계층구조에 정보를 놓을 때 합의된 사용을 따르기 바란다. 예를 들어,
전체적인 설정 정보는 /etc 디렉토리밑에 놓아라. 파일시스템 계층구조 표준
(Filesystem Hierarchy Standard, FHS) 는 논리적 방식으로 이 합의를
정의하려고 하며 리눅스 시스템에 널리 사용되고 있다. FHS 는 리눅스, BSD와
시스템 V로부터 얻어진 교훈과 접근방법을 병합한 이전 리눅스 파일시스템
구조 표준 (Filesystem Structure Standard, FSSTND)의 갱신이다. FHS 에
대한 더욱 자세한 정보는 <A
HREF="http://www.pathname.com/fhs"
TARGET="_top"
>http://www.pathname.com/fhs</A
> 를
보라. 이러한 합의의 요약은 리눅스와 솔라리스에 대해 각각 hier(5) 와
hier(7) 에 있다. 때때로 서로 다른 합의가 일치하지 않는데 가능한 이러한
상황은 컴파일 또는 설치시에 설정할 수 있도록 해라.&#13;</P
><P
>&#13;저자는 FHS 가 리눅스 배포판들간의 호환성 증대 및 소프트웨어
애플리케이션이 호환되는 리눅스 시스템에서 작동할 수 있도록 일련의 표준을
개발 및 촉진하는 <A
HREF="http://www.linuxbase.org"
TARGET="_top"
>Linux Standard
Base</A
>에 의해 채택되었음을 특히 언급한다.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SYSV-IPC"
>3.3. System V 프로세스간 통신</A
></H2
><P
>&#13;리눅스와 System V 를 포함한 많은 유닉스 계열 시스템은 System V IPC
(Interprocess communication, 프로세스간 통신) 객체를 지원하는데 이는
오픈 그룹의 Single UNIX Specification 버전 2 [Open Group 1997] 에 의해
요구된다. System V IPC 객체는 System V 메시지 큐, 세마포어 집합 및 공유
메모리 세그먼트 중 하나로 이러한 각 객체는 다음 속성을 갖는다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;각 생성자, 생성자 그룹 및 others 에 대해 읽기와 쓰기 허가.&#13;</P
></LI
><LI
><P
>&#13;생성자 UID 와 GID - 객체 생성자의 UID 와 GID&#13;</P
></LI
><LI
><P
>&#13;소유 UID 와 GID - 객체 소유자의 UID 와 GID (처음에는 생성자 UID 와 동일)&#13;</P
></LI
></UL
><P
>&#13;이러한 객체에 접근할 때 다음 규칙들이 적용된다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;루트 권한을 갖는 프로세스라면 접근이 허가된다.&#13;</P
></LI
><LI
><P
>&#13;프로세스 EUID 가 객체의 소유자 또는 생성자의 UID 라면 접근이
허가되는지를 보기 위해 적합한 생성자 허가권 비트가 검사된다.&#13;</P
></LI
><LI
><P
>&#13;프로세스 EGID 가 객체의 소유자 또는 생성자의 GID 이거나 프로세스
그룹들중 한 그룹의 EGID 가 객체의 소유 또는 생성 GID 라면 접근을 위해
적합한  생성자 그룹 허가권 비트가 검사된다.&#13;</P
></LI
><LI
><P
>&#13;다른 경우에는 접근을 위해 적합한 ``other" 허가권 비트가 검사된다.&#13;</P
></LI
></UL
><P
>&#13;루트 또는 소유자이거나 생성자의 EUID 를 갖는 프로세스는 소유 UID 및 GID
를 설정할 수 있고/있거나 객체를 제거할 수 있다. 더욱 자세한 정보는
ipc(5) 에서 얻을 수 있다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SOCKETS"
>3.4. 소켓과 네트워크 연결</A
></H2
><P
>&#13;소켓은 특히 네트워크를 통한 통신에 사용된다. 소켓은 본래 유닉스 시스템의
BSD 계열에서 개발되었지만 일반적으로 다른 유닉스 계열 시스템으로
이식가능하다: 리눅스와 System V 변형들도 또한 소켓을 지원하는데 오픈
그룹의 Single Unix Specification [Open Group 1997] 은 소켓 지원을
요구하고 있다. System V 는 전통적으로 호환되지 않는 다른 네트워크 통신
인터페이스를 사용했지만 솔라리스같은 시스템이 소켓 지원을 포함한다는
것을 언급하는 것은 가치가 있다. Socket(2) 은 통신을 위한 끝점
(endpoint) 를 생성하여 파일에 대한 open(2) 과 유사한 방식으로 기술자
(descriptor) 를 반환한다. 소켓 매개변수는 인터넷 도메인 (TCP/IP 버전 4),
Novell 의 IPX 또는 ``유닉스 도메인" 과 같은 프로토콜 계열과 타입을
지정한다. 서버는 곧이어 일반적으로 bind(2), listen(2) 과 accept(2) 또는
select(2) 를 호출하며 클라이언트는 일반적으로 bind(2) (생략될 수도 있다)
와 connect(2) 를 호출한다. 더욱 자세한 정보는 이러한 루틴 각각의 맨
페이지를 보라. 맨 페이지에서 소켓 사용방법을 이해하는 것은 어려울 수
있는데 이러한 호출을 함께 어떻게 사용하는지를 배우려면 Hall "Beej"
[1999] 와 같은 다른 논문을 참조할 수 있다.&#13;</P
><P
>&#13;``유닉스 도메인 소켓"은 실제 네트워크 프로토콜을 나타내지는 않는데 다만
동일 머신상의 소켓에 접속할 수 있다 (표준 리눅스 커널에 대한 이 글을
작성하는 시점에는). 스트림으로 사용될 때 이는 네임드 파이프와 아주
유사하지만 상당한 장점을 갖고 있다. 특히 유닉스 도메인 소켓은 접속
지향으로 소켓으로의 새로운 각 접속은 네임드 파이프와는 매우 다르게
새로운 통신 채널을 생성한다. 이 특성때문에 유닉스 도메인 소켓은 대개
많은 중요한 서비스에 대해 IPC 를 구현하기 위해 네임드 파이프 대신
사용된다. 언네임드 파이프를 가질 수 있듯이 socketpair(2) 를 사용하여
언네임드 유닉스 도메인 소켓을 가질 수 있는데 이는 언네임드 파이프와
유사한 방식으로 IPC 에 대해 유용하다.&#13;</P
><P
>&#13;유닉스 도메인 소켓은 보안과 관련해서 몇가지 재미있는 함축된 의미를 갖고
있다. 첫째 유닉스 도메인 소켓이 파일시스템에 나타나며 이에 적용되는
stat(2) 를 가질 수 있음에도 불구하고 open(2) 을 사용해서 이를 열 수는
없다 (socket(2) 와 friends 인터페이스를 사용해야 한다). 두번째 유닉스
도메인 소켓은 프로세스간 파일 기술자를 전달하는데 사용될 수 있다 (그저
파일 내용이 아닌). 다른 모든 IPC 메카니즘에서 사용할 수 없는 이러한
색다른 능력은 모든 타입의 체계 (scheme) 를 해킹하는데 사용되어 왔다
(기술자는 컴퓨터 과학 분야에서 기본적으로 ``능력"의 제한된 버전으로
사용될 수 있다). 파일 기술자는 sendmsg(2) 를 사용하여 보내지는데 msg
(메시지) 의 msg_control 필드는 제어 메시지 헤더의 배열을 가리킨다
(msg_controllen 필드가 배열에 포함된 바이트수를 지정해야 한다).
각 제어 메시지는 데이타 다음에 오는 cmsghdr 구조체로 이 목적을 위해
cmsg_type 을 SCM_RIGHTS 로 설정해야 한다. 파일기술자는 recvmsg(2)
를 통해 검색되며 이때부터 유사한 방식으로 추적된다. 솔직히 이 특징은
매우 색다르지만 알만한 가치가 있다.&#13;</P
><P
>&#13;리눅스 2.2 는 유닉스 도메인 소켓에서 부가적인 특징을 지원하는데 peer 의
"credentials" (pid, uid 와 gid) 을 얻을 수 있다. 다음은 예제 코드이다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> /* fd= 식별하기를 원하는 클라이언트에 접속된 유닉스 도메인 소켓의 파일 기술자 */

 struct ucred cr;
 int cl=sizeof(cr);

 if (getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &#38;cr, &#38;cl)==0) {
   printf("Peer's pid=%d, uid=%d, gid=%d\n",
           cr.pid, cr.uid, cr.gid);</PRE
></TD
></TR
></TABLE
><P
>&#13;표준 유닉스에서는 1024 미만의 TCP 와 UDP 지역 포트 넘버로의 바인딩은
루트 권한을 가져야 하며 모든 프로세스는 1024 또는 그 이상의 unbound 포트
넘버에 바인드할 수 있는 것이 관례이다. 리눅스는 이 관례를 더욱 명확하게
따르는데, 리눅스는 1024 미만의 포트 넘버로 바인딩하기 위해서는
CAP_NET_BIND_SERVICE 능력을 갖는 프로세스를
필요로한다.; 이 능력은 보통 euid 가 0 인 프로세스만이 갖는다. 관심이
있다면 리눅스 소스를 살펴봄으로써 이를 확인할 수 있는데 리눅스 2.2.12 의
<TT
CLASS="FILENAME"
>/usr/src/linux/net/ipv4/af_inet.c</TT
> 파일에서
inet_bind() 함수를 보라.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SIGNALS"
>3.5. 시그널</A
></H2
><P
>&#13;시그널은 유닉스 계열 OS 세계에서 ``인터럽션 (interruption, 중단)"의
간단한 형태로 유닉스의 아주 오래된 부분이다. 프로세스는 다른 프로세스에
``시그널"을 설정할 수 있으며 (kill(1) 또는 kill(2) 를 사용하여) 다른
프로세스는 비동기적으로 시그널을 받아 처리할 수 있다. 프로세스가 어떤
다른 프로세스에 시그널을 보내는 것이 허용되기 위해서는 그 프로세스가
루트 권한을 갖거나 실제 또는 유효 사용자 ID 가 시그널을 받는 프로세스의
실제 또는 유보된 (saved) set-user-ID 와 동일해야 한다. 
그러나 몇몇 시그널은 다른 방법으로 보내질 수 있다. 특히 SIGURG 는 TCP/IP 
의 out of band (OOB) 메시지를 통한 네트워크를 통해 전달될 수 있다.&#13;</P
><P
>&#13;시그널이 유닉스의 아주 오래된 부분임에도 불구하고 시그널은 여러가지
구현에서 다른 의미 체계를 갖는다. 기본적으로 "다른 시그널을 처리하는
동안 시그널이 발생하면 어떤 일이 생길까?" 하는 질문이 한 예가 될 수
있는데 새로운 GNU libc 라이브러리보다 오래된 리눅스 libc 5 는 어떤
시그널 연산에 대해 일련의 다른 의미 체계를 사용했다. 시그널 핸들러내에서
C 라이브러리 함수를 호출하는 것이 필수적으로 안전하지는 않은데 각 호출에
대해 문서를 조사할 필요가 있다. 더욱 자세한 정보는 glibc FAQ 를 보라
(어떤 시스템에서는 /usr/doc/glibc-*/FAQ 에서 얻을 수 있다).&#13;</P
><P
>&#13;새로운 프로그램에 대해서는 단지 POSIX 시그널 시스템 (BSD 에 기초한) 을
사용해라; 이는 널리 지원되고 있으며 오래된 시그널 시스템이 갖고 있던 문제가
없다. POSIX 시그널 시스템은 sigset_t 데이타 타입 사용에
기초하는데 sigemptyset(), sigillset(), sigaddset(), sigdelset() 과
sigismember() 들의 일련의 연산을 통해 조작될 수 있다. sigsetops(3) 에서
이에 대해 읽을 수 있는데 manipulate 시그널 핸들링을 설정하기 위해서는
sigaction(2), sigprocmask(2) 와 sigsuspend(2) 를 사용해라 (더욱 자세한
정보는 맨 페이지를 보라).&#13;</P
><P
>&#13;일반적으로 모든 시그널 핸들러는 매우 짧고 간단하게 만들고 경쟁 상태를
주의해서 찾아라. 시그널은 본질적으로 비동기적이기 때문에 쉽게 경쟁
상태를 야기할 수 있다.&#13;</P
><P
>&#13;서버에 대해 공통된 관례가 존재한다: SIGHUP 시그널을 받으면 모든 로그
파일을 닫고 설정파일을 다시 열어 다시 읽은 후 로그 파일을 다시 열어야
한다. 이를 통해 서버를 중지하지 않고 재설정할 수 있으며 데이타 손실없이
로그 순환 (rotation) 을 할 수 있다. 이러한 관례를 따라야 하는 서버를
작성하고 있다면 이를 지원하기 바란다.&#13;</P
><P
>&#13;Michal Zalewski [2001] 은 시그널 핸들러가 어떻게 악용되는가에 대한 
훌륭한 지도서를 작성하였고 시그널 경쟁 문제를 제거하는 방법에 대한 
권고를 하였다. 저자는 더욱 자세한 정보를 위해 요약을 보기를 권한다; 
다음은 저자의 권고안으로 Michal 의 것과 유사한 것이다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;가능한 시그널 핸들러를 무조건적으로 특정 플래그로 설정하고 그 밖의 다른 
것은 하지 마라.&#13;</P
></LI
><LI
><P
>&#13;더욱 복잡한 시그널 핸들러가 필요하다면 시그널 핸들러에서 사용하기에 
안전하다고 명확하게 지적된 호출들만 사용해라. 대부분의 시스템에서 
시그널에 대해 보호되지 않는 C 의 malloc() 또는 free() 또는 
이들에 의존하는 (printf() 계열 및 syslog()) 함수들을 사용하지 마라. 
재진입 (re-entry) 을 피하기 위해 전역 플래그에 대한 검사를 이용해 비보안적인 
라이브러리 호출에 대한 호출을 ``wrap" 할 수도 있지만 이를 추천하지는 않는다.&#13;</P
></LI
><LI
><P
>&#13;프로그램내의 모든 비원자적 연산동안과 시그널 핸들러내에서의 시그널 전달을 
블록해라.&#13;</P
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="QUOTAS"
>3.6. 쿼터와 한도</A
></H2
><P
>&#13;많은 유닉스 계열 시스템은 파일시스템 쿼터 (할당) 와 프로세스 자원 한도를
지원하는 메카니즘을 갖고 있으녀며 리눅스도 틀림없이 이를 지원한다. 이
메카니즘은 서비스 부인 공격을 예방하는데 특히 유용한데 각 사용자가
사용할 수 있는 자원에 한도를 설정함으로써 한 명의 사용자가 모든 시스템
자원을 소비하는 것을 어렵게 할 수 있다. 파일시스템 쿼터와 프로세스 자원
한도 모두 ``hard" 와 ``soft" 한도를 갖는데 여기서 사용된 전문 용어에
주의해라. 용어가 약간 다른 의미를 갖는다.&#13;</P
><P
>&#13;사용될 수 있는 스토리지 블록 수와/또는 고유 파일 수 (아이노드) 에 대해
각 마운트포인트에 스토리지 (파일시스템) 쿼터 한도를 정의할 수 있으며
사용자 또는 그룹에 대해 이러한 한도를 설정할 수도 있다. ``hard" 쿼터
한도는 절대로 초과해서는 안되는 한도이며 반면 ``soft" 쿼터 한도는
일시적으로 초과될 수 있다. quota(1), quotactl(2) 과 quotaon(8) 을 보라.&#13;</P
><P
>&#13;rlimit 메카니즘은 파일 크기, 자식 프로세스 수, 오픈 파일 수 등과 같이
많은 프로세스 쿼터를 지원한다. ``soft" 한도 (현재 한도) 와 "hard" 한도
(상위 한도) 가 있으며 soft 한도는 언제나 초과될 수 없지만 호출을 통해
hard 한도 값으로 상향 설정될 수 있다. getrlimit(), setrlimit() 과
getrusage() 를 보라. PAM 모듈 pam_limits 를 포함하여 이러한
한도를 설정하기 위한 여러가지 방식이 있음을 주목해라.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DLLS"
>3.7. 동적 링크 라이브러리</A
></H2
><P
>&#13;실제적으로 모든 프로그램은 실행되는 라이브러리에 의존하는데 리눅스를
포함한 현재 대부분의 유닉스 계열 시스템에서 프로그램은 <B
CLASS="EMPHASIS"
>동적 링크 라이브러리 (Dynamically linked libraries,
DLLs)</B
> 를 사용하도록 컴파일된다. 이러한 방식에 의해
라이브러리를 갱신할 수 있으며 그 라이브러리를 사용하는 프로그램은 가능한
경우 새로운 버전 (아마도 향상된) 을 사용할 것이다.&#13;</P
><P
>&#13;동적 링크 라이브러리는 일반적으로 몇개의 특정 디렉토리들에 놓이는데 보통
<TT
CLASS="FILENAME"
>/lib</TT
>, <TT
CLASS="FILENAME"
>/usr/lib</TT
>, PAM 의 경우
<TT
CLASS="FILENAME"
>/lib/security</TT
>, X 윈도우의 경우
<TT
CLASS="FILENAME"
>/usr/X11R6/lib</TT
> 과
<TT
CLASS="FILENAME"
>/usr/local/lib</TT
> 디렉토리들이 있다. 프로그램에서
이러한 표준 관례를 사용해야 하는데, 디버깅중이 아니라면 현재
디렉토리로부터 계산된 값을 동적 링크 라이브러리에 대한 소스로 사용하지
않아야 한다 (공격자가 자신이 선택한 ``라이브러리" 값을 추가할 수도 있을
것이다).&#13;</P
><P
>&#13;라이브러리 네이밍과 이들에 대한 심볼릭 생성에 있어 특별한 관례가 있다.
특히 심볼릭 생성을 통해 라이브러리를 갱신할 수 있으며 오래되고 역
호환성이 없는 라이브러리 사용을 원하는 프로그램을 지원할 수도 있다.
특별한 프로그램을 실행시킬 때 특정 라이브러리 또는 라이브러리내의 특정
함수만을 재정의할 수 있는 방법들도 있다. 이는 윈도우 계열 시스템에 대한
유닉스 계열 시스템의 장점이다; 저자는 유닉스 계열 시스템이 라이브러리
갱신에 대해 더욱 훌륭한 시스템이라고 믿고 있는데 이것이 유닉스와 리눅스
시스템이 윈도우 기반 시스템보다 더욱 안정하다고 평가되는 한가지
이유이다.&#13;</P
><P
>&#13;모든 리눅스 시스템을 포함하여 GNU glibc 에 기초한 시스템에서 프로그램
시동중에 자동적으로 검색되는 디렉토리 목록은 /etc/ld.so.conf 파일에
저장되어 있다. 많은 레드햇에서 파생된 배포판들은 일반적으로
<TT
CLASS="FILENAME"
>/etc/ld.so.conf</TT
> 파일에
<TT
CLASS="FILENAME"
>/usr/local/lib</TT
> 이 포함되어 있지 않다. 저자는 이를
버그라고 생각하는데 이러한 배포판에서 많은 프로그램들을 작동시키기
위해서는 <TT
CLASS="FILENAME"
>/usr/local/lib 를 /etc/ld.so.conf</TT
> 에
추가하는 수정 작업이 필요하다. 라이브러리에서 단지 몇개의 함수를
재정의하고 나머지를 그대로 이용하려면
<TT
CLASS="FILENAME"
>/etc/ld.so.preload</TT
> 에 재정의 라이브러리 (.o 파일)
이름을 넣어줄 수 있다; 이런 ``선적재" 라이브러리는 표준 라이브러리에
우선된다. 이 선적재 파일은 일반적으로 응급 패치를 위해 사용되는데
배포판은 출시될 때 일반적으로 이러한 파일을 포함하지 않을 것이다.
프로그램 시동시에 이런 모든 디렉토리를 검색하는 것은 매우 많은 시간이
걸리는데 실제로는 캐싱 방법이 사용된다. ldconfig(8) 프로그램은 디폴트로
/etc/ld.so.conf 파일을 읽어들여 동적 링크 디렉토리 (표준 관례를 따른다)
에 적절한 심볼릭 링크를 설정한 후 나중에 다른 프로그램이 사용할 캐시를
/etc/ld.so.cache 에 작성한다. 따라서 ldconfig 가 DLL 이 추가될때마다,
DLL 이 제거될때 또는 DLL 디렉토리들이 변경될 때 실행되어야 한다;
ldconfig 를 실행시키는 것은 라이브러리를 설치할 때 패키지 관리자가 자주
수행하는 조치중의 하나이다. 시동시 프로그램은 동적 로더를 사용해
/etc/ld.so.cache 파일을 읽어 들인 후 필요로 하는 라이브러리를 적재하는
것이다.&#13;</P
><P
>&#13;다양한 환경 변수가 이 프로세스를 제어할 수 있으며 사실 이 프로세스를
재정의할 수 있는 환경 변수가 있다 (따라서 특별한 프로그램을 실행하는
경우 잠정적으로 다른 라이브러리로 대체할 수 있다). 리눅스에서
LD_LIBRARY_PATH 는 표준 디렉토리 집합에 앞서 우선적으로
라이브러리가 검색되는 콜론으로 분리된 디렉토리 집합이다; 이는 새로운
라이브러리 디버깅 또는 특별한 목적을 위한 비표준 라이브러리 사용할 때
유용하지만 이러한 디렉토리를 제어할 수 있는 해당 사용자가 이들을
신뢰해야 함을 명심해라. LD_RELOAD 변수는 /etc/ld.so.preload
파일이 하는 것처럼 표준 집합을 재정의하는 함수들을 갖는 객체 파일을
열거한다. LD_DEBUG 변수는 디버깅 정보를 보여준다; ``all" 로
설정된다면 디버깅시에 동적 링크 프로세스에 대한 방대한 정보를 보여준다.&#13;</P
><P
>&#13;사용자가 동적 링크 라이브러리를 제어할 수 있게 허용하는 것은 특별한
조치를 취하지 않는다면 setuid/setgid 프로그램의 경우 매우 위험할 것이다.
따라서 GNU glibc 구현에서 setuid 또는 setgid 프로그램의 경우 이러한 변수
(또는 다른 유사한 변수) 는 무시되거나 그들이 할 수 있는 것이 제한된다.
GNU glibc 라이브러리는 프로그램의 credentials 을 검사함으로써 setuid
또는 setgid 프로그램인지를 결정한다; uid 와 euid 또는 gid 와 egid 가
다른 경우 라이브러리는 setuid/setgid 프로그램 (또는 이러한 프로그램의
자손) 이라고 간주해서 링크를 제어할 수 있는 능력을 매우 제한한다. GNU
glibc 라이브러리를 적재한다면 이러한 현상을 볼 수 있다; 특히 elf/rtld.c
와 sysdeps/generic/dl-sysdep.c 파일을 보라. 이는 uid 와 gid 를 euid 와
egid 와 같게 만들어서 프로그램을 호출하는 경우 이러한 변수들이 최대한
영향을 미칠 것임을 의미한다. 다른 유닉스 계열 시스템은 이 상황을
다르지만 동일한 이유로 다룬다: setuid/setgid 프로그램은 환경 변수 셋에
의해 부당하게 영향을 받지 않아야 한다.&#13;</P
><P
>&#13;리눅스 시스템에 대해서 저자가 작성한 문서인 <A
HREF="http://www.dwheeler.com/program-library"
TARGET="_top"
><B
CLASS="EMPHASIS"
>Program Library
HOWTO</B
></A
> 에서 더욱 자세한 정보를 얻을 수 있다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AUDIT"
>3.8. 감사</A
></H2
><P
>&#13;여러가지 유닉스 계열 시스템은 감사를 다르게 다루는데 리눅스에서 대부분의
공통된 ``감사" 메카니즘은 syslogd(8) 로 보통 klogd(8) 과 함께 작동한다.
또한 wtmp(5), utmp(5), lastlog(8) 과 acct(2) 를 살펴볼 수도 있다. 아파치
웹서버와 같은 어떤 서버 프로그램들은 자신들만의 감사 추적 (trail)
프로그램을 갖고 있다. FHS 에 따라 감사 로그는 /var/log 또는 그 하부
디렉토리에 저장되어야 한다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PAM"
>3.9. PAM</A
></H2
><P
>&#13;썬 솔라리스와 거의 모든 리눅스 시스템은 인증을 위해 PAM (Pluggable
Authenticatoin Module, 장착식 인증 모듈) 을 사용한다. PAM 은 인증 방법의
런타임 설정을 허용한다 (예, 패스워드, 스마트 카드 등의 사용). PAM 사용에
대해 더욱 자세한 정보는  <A
HREF="#USE-PAM"
>10.6&#51208;</A
> 를 보라.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="UNIX-EXTENSIONS"
>3.10. 유닉스 계열 시스템을 위한 전문적인 보안 확장</A
></H2
><P
>&#13;방대한 양의 연구과 개발이 다양한 커뮤니티의 보안 요구를 지원하기 위해
유닉스 계열 시스템을 확장해왔다. 예를 들어, 몇가지 유닉스 계열 시스템은
미국의 다중 수준의 군용 보안을 지원하기 확장되어졌다. 소프트웨어를
개발하려면 이러한 확장과 함께 작동될 수 있도록 소프트웨어 설계를 하려고
노력해야 한다.&#13;</P
><P
>&#13;FreeBSD 는 <A
HREF="http://docs.freebsd.org/44doc/papers/jail/jail.html"
TARGET="_top"
>jail(2)</A
>
라는 새로운 시스템 호출을 갖고 있다. jail 시스템 호출은 환경을 많은 가상
머신으로 하부-파티셔닝할 수 있게 지원한다 (``super-chroot" 의미); 이는 인터넷
서비스 공급업자 (ISP) 가 가상 머신 서비스를 제공할 수 있는 환경을
구축하는데 있어 매우 널리 사용되고 있다. jail 내에서 모든 프로세스 (루트
소유의 프로세스일지라도) 는 jail 로 제한된 요청 범위를 갖는다. FreeBSD
가 처음 설치되어 부팅될 때 어떠한 프로세스도 jail 내에는 존재하지 않을
것이다. 프로세스가 jail 내에 놓일 때 그 프로세스 및 모든 자손 프로세스는
그 jail 내에 존재할 것이다. 일단 jail 내에 있다면 파일 네임-공간은
chroot(2) (일반적인 chroot 이스케이프 루트 (route) 는 블럭되어 있다) 를 통해서만
접근할  수 있으며 네트워크 자원은 특정 IP 주소의 경우만 바인딩할 수
있다. 또한 시스템 자원 조작 및 특권을 갖는 연산을 수행할 수 있는 능력은
갑자기 축소되며 다른 프로세스와 상호작용할 수 있는 능력도 동일 jail 내의
프로세스로만 제한된다. 각 jail 은 하나의 IP 주소에 바운드되어 있음을
주목해라; jail 내의 프로세스는 나가거나 들어오는 접속에 대해 다른 모든
IP 주소를 사용할 수 없을 것이다.&#13;</P
><P
>&#13;POSIX 능력과 특별한 마운트-time 옵션과 같이 리눅스에서 사용할 수 있는
약간의 확장은 이미 논의되었으며 리눅스 시스템에 대해 제한된 실행 환경을
생성하기 위해 약간의 노력이 있어 왔다; 많은 다른 접근 방법이 있다. 
미국의 National Security Agency
(NSA) 는 전문화된 언어로 보안 정책의 정의를 지원하고 이 정책을 적용하는
<A
HREF="http://www.nsa.gov/selinux"
TARGET="_top"
>Security-Enhanced Linux
(Flask)</A
> 를 개발했다. <A
HREF="http://medusa.fornax.sk"
TARGET="_top"
>Medusa
DS9</A
> 은 커널 수준에서 사용자 공간 인가 서버를 지원함으로써
리눅스를 확장한다. <A
HREF="http://www.lids.org"
TARGET="_top"
>LIDS</A
> 는
관리자로 하여금 시스템을 로크 다운 (lock down) 할 수 있게 함으로써
파일과 프로세스를 보호한다. ``Rule Set Based Access Control" 시스템
<A
HREF="http://www.rsbac.de"
TARGET="_top"
>RSBAC</A
> 는 Abrams 와 Lapadula 에
의한 Generalized Framework for Access Control (GFAC) 에 기초하는데 몇몇
커널 모듈에 기초해 접근 제어를 할 수 있는 유연한 시스템을 제공한다.
<A
HREF="http://subterfugue.org"
TARGET="_top"
>Subterfugue</A
> 는 ``observing
and playing with the reality of software" 의 뼈대로 시스템 호출을 가로채
그 매개변수와/또는 반환값을 변경해 sandbox, 추적기 등을 구현할 수 있다;
이는 변경없이 (어떠한 커널 수정도 필요하지 않다) 리눅스 2.4 하에서
작동한다. <A
HREF="http://www.cs.berkeley.edu/~daw/janus"
TARGET="_top"
>Janus</A
> 는 제한된 실행
환경내에서 신뢰되지 않은 애플리케이션을 sandboxing 하기 위한 보안
도구이다. 어떤 사람은 sandbox 구현으로 "Linux on Linux" 을 구현한 <A
HREF="http://user-mode-linux.sourceforge.net"
TARGET="_top"
>User-mode Linux</A
> 도
사용했다. 더욱 복잡한 보안 모델을 구현하기 위한 많은 다른 접근 방법이 있기 
때문에 Linus Torvals 는 상이한 보안 정책이 삽입될 수 있도록 일반적인 
접근 방법이 개발되어야 한다고 요청했다; 이에 대한 더욱 자세한 정보는 
<A
HREF="http://mail.wirex.com/mailman/listinfo/linux-security-module"
TARGET="_top"
>http://mail.wirex.com/mailman/listinfo/linux-security-module</A
> 를 
보라.&#13;</P
><P
>&#13;다양한 유닉스 계열 시스템에서 보안에 대해 많은 다른 확장들이
있지만 이는 실제로 이 문서가 다루는 범위를 넘어선다.&#13;</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="INPUT"
>4&#51109;. 모든 입력을 확인해라 </A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>Wisdom will save you from the ways of wicked men,
from men whose words are perverse...</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Proverbs 2:12 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><P
>&#13;
어떤 입력은 신뢰할 수 없는 사용자로부터 올 수 있는데 이런 입력들은
사용하기 전에 그 정당성을 입증하거나 필터링되어야 한다. 무엇이 합법적인
것인가를 결정해서 그 정의와 일치하는 않는 모든 것을 거절해야 한다.
무엇이 비합법적인 것인가를 식별해서 그러한 경우를 거절하는 코드를
작성하는 것과 같은 반대의 경우는 하지마라. 비합법적인 입력의 중요한
실례를 다루는 것을 잊을 수 있기 때문이다.&#13;</P
><P
>&#13;
그렇지만 비합법적인 값을 식별해야 하는 좋은 이유가 있는데 이는 반드시
확인 (validation) 코드를 철두철미하게 작성하기 위한 일련의 테스트 (보통
머리속에서 실행되는) 와 같다. 저자는 입력 필터를 설정할 때 필터링되지
않을 수 있는 비합법적인 값이 있는지 보기 위해 마음속으로 필터를
공격한다. 다음은 입력에 따라 입력 필터가 예방할 필요가 있는 공통된
비합법적인 값들의 예이다: 빈 문자열, ".", "..", "../", "/" 또는 "." 로
시작하는 모든 것, 안에 "/" 또는 "&#38;" 가 있는 모든 것, 모든 제어 문자
(특히 NIL 과 개행) 와/또는 "high bit" 이 설정되어 있는 모든 문자 (특히
십진수 254 와 255 값). 다시 한번 작성한 코드는 "bad" 값에 대해 검사되지
않아야 한다: 반드시 패턴이 입력 값을 합법적인 값으로 엄격히 제한하도록
이를 마음속으로 검사해야 한다. 패턴이 충분히 엄밀하지 않다면 다른 문제가
있는 지를 살펴 보기 위해 패턴을 주의깊게 재조사해야 한다.&#13;</P
><P
>&#13;
최대 문자 길이 (적절하다면 최소 길이) 를 제한하고 그러한 길이가 초과될
때 반드시 제어가 되도록 해라 (버퍼 오버플로우에 대한 더욱 많은 정보는
<A
HREF="#BUFFER-OVERFLOW"
>5&#51109;</A
> 을 보라).&#13;</P
><P
>&#13;다음은 신뢰되지 않은 사용자로부터 온 것들 사용하기 전에 확인해야 하는
약간의 공통적인 데이타 타입과 입력들이다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;문자열에 대해서는 합법적 문자 또는 합법적 패턴 (예, 정규 표현) 을
식별해서 그 형태와 일치하지 않는 모든 것을 거절해라. 문자열이 제어 문자
(특히 개행 또는 NIL) 또는 쉘 메타문자를 포함할 때는 특별한 문제가 있다;
대개 입력을 받자마자 그러한 메타문자가 뜻하지 않게 보내지지 않도록
그러한 메타문자를 이스케이프 ( escape, 의미 해제) 하는 것이 최선이다. CERT
는 더 나아가서 이스케이프를 필요로 하지 않는 문자 목록에 없는 모든
문자를 이스케이프하라고 추천한다 [CERT 1998, CMU 1998].  호출 (call out)
제한에 대해 더욱 자세한 정보는 <A
HREF="#LIMIT-CALL-OUTS"
>7.2&#51208;</A
> 을
보라.&#13;</P
></LI
><LI
><P
>&#13;모든 숫자를 최소 (대개 0) 와 최대 허용 값으로 제한해라.&#13;</P
></LI
><LI
><P
>&#13;완전한 이메일 주소 검사기는 실제 매우 복잡하다. 이는 모든 포맷을 지원하려는 경우
확인을 매우 복잡하게 하는 레거시 포맷들이 있기 때문이다; 이러한 검사가 필요하다면 
더욱 자세한 정보는 mailaddr(7) 과 IETF RFC 822 [RFC 822] 를 보라. 대개 간단하게 할 수 
있는데 단지 ``공통적인" 인터넷 주소 포맷만을 허용해라.&#13;</P
></LI
><LI
><P
>&#13;파일 이름도 확인해야 하는데 보통 ".." (상위 디렉토리를 의미한다) 를 신뢰되지 
않은 사용자로부터의 합법적인 값으로 포함하길 원하지 않을 것이다. 물론 상황에 따라 
변할 수 있다. 특히 문제를 야기할 수 있는 개행 문자를 빠뜨리면서 허용할 문자들만을 
리스트하길 원할 수도 있다. 파일 이름에서 예를 들어 일련의 합법적인 문자 집합에 "/"
를 포함하지 않음으로써 디렉토리내의 모든 변경을 금지하는 것이 최선이다. 대개 
``*", ``?", ``[" (matching ``]") 과 ``{" (matching ``}") 들을 사용하여 파일 이름을 전개하는 
``globbing" 을 지원하지 않아야 한다. 예를 들어 ``ls *.png" 명령은 모든 PNG 파일들을 
열거하도록 ``*.png" 를 globbing 한다. C 의 fopen(3) 명령은 globbing 하지 않지만 일반적인
쉘은 디폴트로 globbing 을 수행하며 C 에서는 glob(3) 을 사용해 globbing 을 요청할 수 있다.
Globbing 을 필요로 하지 않는다면 가능한 globbing 하지 않는 호출 (예, fopen(3)) 만을
사용하거나 이를 금지 (예, 쉘에서 globbing 문자들을 이스케이프해라) 해라. 
Globbing 을 허용한다면 특별히 주의해라. Globbing 이 유용할 수 있지만 복잡한 glob 는 
매우 많은 계산 시간이 걸릴 수 있다. 예를 들어 어떤 ftp 서버에서 이러한 몇개의 요청을
실행시킴으로써 쉽게 전체 머신에 대해 서비스 부인을 야기할 수 있다.&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>ftp&#62; ls */../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*</PRE
></TD
></TR
></TABLE
><P
>&#13;Globbing 패턴을 제한하면서 globbing 을 허용하려는 것은 아마도 허사일 것이다. 대신
반드시 그러한 모든 프로그램들을 별개 프로세스로 실행시키고 이들이 소비할 수 있는
CPU 와 다른 자원들의 양을 제한하는 프로세스 한계를 사용해라. 이에 대한 더욱 자세한
정보는 <A
HREF="#MINIMIZE-RESOURCES"
>6.3.8&#51208;</A
> 를 보고 이러한 한계 설정 방법에 대한
더욱 자세한 정보는 <A
HREF="#QUOTAS"
>3.6&#51208;</A
> 를 보라.&#13;</P
></LI
><LI
><P
>&#13;URL 을 포함하여 URI  는 그 타당성을 검사해야 한다. 웹 서버 또는 웹 서버와 같은 프로그램을 
구현하고 있고 URL 이 데이타에 대한 요청인 경우와 같이 직접적으로 URI 에 따라 행동한다면  
URI 가 합법적인지 반드시 확인하고 문서 루트 (서버가 응답하고 있는 파일 시스템의 영역) 를
``이스케이프" 하려고 하는 URI 에 특히 주의해라.
문서 루트를 이스케이프하는 가장 일반적인 방법은 ``.." 또는 심볼릭 링크를 통하는 것인데 
따라서 대부분의 서버는 모든 ``.." 디렉토리 자체를 검사하거나 특별히 관리되지 않느다면 
심볼릭 링크를 무시한다. 또한 URL 인코딩 또는 UTF-8 인코딩을 통해 모든 인코딩 우선 
디코딩하는 것을 기억해라. 그렇지 않으면 인코드된 ``.." 이 슬쩍 빠져나갈 수 있다. URI 는 
UTF-8 인코딩을 포함하지 않도록 요구되고 있는데 따라서 가장 안전한 것은 high bit 이 
설정되어 있는 문자들을 포함하는 모든 URI 를 거절하는 것이다.&#13;</P
><P
>&#13;URI/URL 을 데이타로 사용하는 시스템을 구현하고 있다면 전혀 성공하지 못한다. 
악의있는 사용자가 다른 사용자들에게 피해를 입힐 수 있는 URI 를 삽입할 수 없도록 보장할
필요가 있다. 더욱 자세한 정보는 <A
HREF="#VALIDATING-URIS"
>4.10.4&#51208;</A
> 를 보라.&#13;</P
></LI
><LI
><P
>&#13;쿠키값을 받아들일 때 사용하고 있는 모든 쿠키에 대한 도메인 값이 예상된 값인지를 반드시
확인해라. 그렇지 않으면 관련된 사이트 (아마도 파괴된 사이트) 가 변조된 쿠키를 삽입할 수도 있다. 
다음은 이러한 검사를 하지 않는 것이 어떻게 문제를 야기할 수 있는가에 대한 IETF 
RFC 2965 로부터의 예이다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;사용자 에이전트가 victim.cracker.edu 에 요청을 하고 쿠키 session_id 1234 를 가져온 후 
디폴트 도메인을 victim.cracker.edu 로 설정한다.&#13;</P
></LI
><LI
><P
>&#13;사용자 에이전트가 spoof.cracker.edu 에 요청을 하고 도메인이 ".cracker.edu" 로 설정되어 
있는 쿠키 session_id 1111 을 가져온다.&#13;</P
></LI
><LI
><P
>&#13;사용자 에이전트가 victim.cracker.edu 에 다시 요청을 하고 다음을 건네준다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>         Cookie: $Version="1"; session_id="1234",
                 $Version="1"; session_id="1111"; $Domain=".cracker.edu"</PRE
></TD
></TR
></TABLE
><P
>&#13;victim.cracker.edu 의 서버는 도메인 속성이 자신의 도메인 속성이 아님을 알아차림으로써 
두번째 쿠키가 자신이 생성했던 것이 아님을 탐지해 이를 무시해야 한다.&#13;</P
></LI
></UL
></LI
></UL
><P
>&#13;위에 언급한 사항을 고려하지 않는다면 합법적 문자 패턴에 프로그램 내부
또는 결과로써 생기는 출력에 대해 특별한 의미를 갖는 문자들 또는 일련의 문자들을
포함하지 않아야 한다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;문자 시퀀스 (sequence) 는 프로그램 내부 스토리지 포맷에 대해 특별한
의미를 가질 수도 있다. 예를 들어 범위를 갖는 문자열 (delimited strings) 에
데이타를 (내부적 또는 외부적으로) 저장하려면 분리자 (delimiter) 가
허용된 데이타 값이 아님을 확인해라. 많은 프로그램은 콤마 (,) 또는 콜론
(:) 으로 분리된 텍스트 파일에 데이타를 저장하는데 입력에 분리자를 써넣을
때 프로그램이 이를 고려하지 않는다면 (즉, 분리자를 써넣는 것을 허용하지
않거나 몇몇 방식으로 이를 인코드함으로써) 문제가 생길 수 있다. 문자열을
둘러싸는데 사용되는 단독 및 이중 인용부호와 SGML, XML 과 HTML 에서 태그
시작을 나타내는 "&#60;" (less-than) 들은 종종 이런 문제를 일으키는 문자들이다 
(이 포맷으로 데이타를 저장하는 경우 이는 중요하다). 대부분의 데이타
포맷은 이런 경우를 다루기 위해 이스케이프 시퀀스를 갖고 있다; 이를
사용하거나 입력시 이런 데이타를 필터링해라.&#13;</P
></LI
><LI
><P
>&#13;문자 시퀀스가 사용자에게 되돌려지는 경우 이는 특별한 의미를 가질 수 있다.
일반적인 예는 추후 다른 구독자에게 게시될 수 있는 데이타 입력에 HTML
태그를 허용하는 경우이다 (예, 게스트북 또는 ``독자 주해" 영역). 그러나
이러한 문제는 더욱 일반적이며 이 주제에 대한 일반적인 논의와 HTML
필터링에 대한 특정한 논의를 보기 위해서는 각각 <A
HREF="#CROSS-SITE-MALICIOUS-CONTENT"
>6.13&#51208;</A
> 과 <A
HREF="#FILTER-HTML"
>4.10&#51208;</A
>
을 보라.&#13;</P
></LI
></UL
><P
>&#13;이러한 테스트는 추후 수정을 위해 타당성 테스트를 쉽게 살펴볼 수 있도록 한
곳에 집중되어 있어야 한다.&#13;</P
><P
>&#13;타당성 테스트가 실제로 정확함을 확인해라; 이는 다른 프로그램이 사용할 입력
(파일 이름, 이메일 주소 또는 URL 등) 을 검사할 때 특히 문제가 된다. 대개 
이러한 테스트는 검사 프로그램과 실제 데이타를 사용하는 프로그램이 다른
가정을 하는 경우 미묘한 에러를 갖는데 소위 "대리 (deputy) 문제" 를
야기한다. 관련된 표준이 있다면 이를 살펴보고 또한 프로그램이 각자가 알아야 
필요가 있는 확장을 가지고 있는지 살펴보기 위해 검색해라.&#13;</P
><P
>&#13;사용자 입력을 해석할 때 일시적으로 모든 권한을 없애거나 더 나아가서
별개의 프로세스를 생성하는 것 (파서의 권한을 영구적으로 없애고 다른
프로세스가 파서 요청에 대해 보안 검사를 수행한다) 은 좋은 생각이다. 이는
파싱 태스크가 복잡하거나 (lex 또는 yacc 와 유사한 도구를 사용하는 경우)
또는 프로그래밍 언어 (예, C 와 C++) 가 버퍼 오버플로우에 대해 보호하지
않는다면 특히 들어맞는다. 권한 최소화에 대해 더욱 자세한 정보를 얻기
위해서는 <A
HREF="#MINIMIZE-PRIVILEGES"
>6.3&#51208;</A
> 을 보라.&#13;</P
><P
>&#13;보안 결정 (예, 사용자에게 로그인 허용) 에 데이타를 사용할 때 반드시 신뢰할 수 
있는 채널을 사용해라. 예를 들어 공개 인터넷에서 사용자를 인증하는 유일한 
방법으로 머신 IP 주소 또는 포트 넘버를 사용하지 마라. 대부분의 환경에서 이 정보는 
어쩌면 악의있는 사용자에 의해 설정될 수 있다. 더욱 자세한 정보는 
<A
HREF="#TRUSTWORTHY-CHANNELS"
>6.9&#51208;</A
> 를 보라.&#13;</P
><P
>&#13;다음 하부 절은 다양한 종류의 입력을 논의한다; 입력은 환경 변수, umask 값
등과 같은 프로세스 상태를 포함함을 주목해라. 모든 입력이 신뢰할 수 없는
사용자에 의해 제어될 수는 없는데 따라서 이러한 사용자가 제어할 수 있는
그러한 입력에 대해서만 주의를 기울이면 된다.&#13;</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="COMMAND-LINE"
>4.1. 명령 행</A
></H2
><P
>&#13;많은 프로그램은 명령 행 (command line) 에서 입력을 받는다. 신뢰할 수
없는 사용자는 setuid/setgid 프로그램의 명령행 데이타를 제공하는데 따라서
setuid/setgid 프로그램은 잠재적으로 위협이 되는 명령 행 값들로부터
자신을 보호해야 한다. 공격자는 execve(3) 호출과 같은 명령 행을 통해 그저
모든 종류의 데이타를 보낼 것이다. 따라서 setuid/setgid 프로그램은 명령
행 입력을 완벽히 확인해야 하며 명령 행 인수 0  으로 보고된 프로그램
(공격자는 이를 NULL 을 포함한 어떠한 값으로도 설정할 수 있다) 의 이름을
믿어서는 안된다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="ENVIRONMENT-VARIABLES"
>4.2. 환경 변수</A
></H2
><P
>&#13;
디폴트로 환경 변수는 부모 프로세스로부터 상속된다. 그러나 프로그램이
다른 프로그램을 실행시킬 때 호출하는 프로그램이 환경 변수를 임의의
값으로 설정할 수 있다. 이는 setuid/setgid 프로그램의 경우 이들의
호출자가 주어진 환경 변수들을 완벽히 제어할 수 있기 때문에 위험하다.
환경 변수는 보통 상속되기 때문에 이는 또한 과도적으로 적용되는데
보안적인 프로그램이 어떤 다른 프로그램을 호출할 수도 있으며 특별한 조치가
없다면 잠재적으로 위험한 환경 변수를 자신이 호출한 프로그램에 넘겨줄 수
있다. 다음 하부 절은 환경 변수 및 이를 갖고 하는 일을 논의한다.&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ENV-VARS-DANGEROUS"
>4.2.1. 몇몇 환경 변수는 위험하다</A
></H3
><P
>&#13;몇몇 환경 변수들은 모호한, 미묘한 또는 비공인된 (undocumented) 방식으로
많은 라이브러리와 프로그램을 제어하기 때문에 위험하다. 예를 들어 IFS
변수는 어떤 문자가 명령 행 인수들을 구분하는 지를 결정하기 위해
<B
CLASS="EMPHASIS"
>sh</B
> 과 <B
CLASS="EMPHASIS"
>bash</B
> 쉘에 의해 사용된다. 쉘은 몇가지 하위 수준
호출 (C 에서 system(3) 과 popen(3) 또는 펄에서 back-tick 연산자) 에 의해
호출되기 때문에 IFS 변수를 예외적인 값으로 설정한다면 명백히 안전한
호출을 파괴할 것이다. 이 동작은 sh 와 bash 에 문서화되어 있지만 그
의미는 모호하다; 많은 오래된 사용자들만이 실제로 의도된 목적에 사용하기
때문이 아니라 보안을 깨뜨리는데 IFS 변수를 사용하기 때문에 이에 대해
알고 있다. 다욱 바람직하지 않은 것은 모든 환경 변수가 문서화되어 있지
않으며 있다고 하더라도 다른 프로그램이 위험한 환경 변수를 변경 및 추가할
수도 있다는 것이다. 따라서 이 문제에 대한 유일한 실제 해결책 (밑부분에
기술되듯이) 은 필요한 환경 변수만 선택하고 나머지 모든 변수는 버리는
것이다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ENV-STORAGE-DANGEROUS"
>4.2.2. 환경 변수 저장 포맷은 위험하다</A
></H3
><P
>&#13;일반적으로 프로그램은 환경 변수에 접근하기 위해 표준 접근 루틴을 사용하는데 
예를 들어, C 에서는 getenv(3) 을 이용하여 환경 변수를 얻고 POSIX 표준 루틴 
putenv(3) 또는 BSD 확장 setenv(3) 를 이용하여 이를 설정하며 unsetenv(3) 을 
이용하여 이를 제거한다. setenv(3) 는 리눅스에서도 구현되어 있음을 저자는 
언급한다.&#13;</P
><P
>&#13;그러나 크랙커가 그렇게 영리할 필요는 없으며 크랙커는 execve(2) 를 사용하여 
프로그램에 넘겨지는 환경 변수 데이타 영역을 직접적으로 제어할 수 있다. 이는 
다소의 다루기 힘든 공격을 허용하며 환경 변수가 실제로 어떻게 작동하는지 알아야만 
이해할 수 있다. 리눅스에서 환경 변수의 실제 작동 방법에 대한 요약은 environ(5) 을 
볼 수 있다. 요약하면 환경 변수는 내부적으로 문자에 대한 포인터 배열의 포인터로 
저장되는데 이 배열은 순서적으로 저장되며 NULL 포인터 (이를 통해 배열이 언제 
끝나는지를 알 수 있다) 로 끝난다. 문자에 대한 포인터들은 차례로 ``NAME=value" 
형태의 NIL 로 끝나는 문자열 값을 가리킨다. 이는 몇가지 함축된 의미을 갖는데 
예를 들어 환경 변수 이름은 = 기호 를 포함할 수 없으며 이름과 값은 NIL 문자를 
내장할 수 없다. 그러나 이 포맷의 더욱 위험한 함축된 의미는 동일 변수 이름을 
갖으나 다른 값을 갖는 다중 엔트리를 허용한다는 것이다 (예, SHELL 에 대해 
한가지 이상의 값). 일반적인 명령 쉘은 이를 금지하는 반면 지역적으로 작업을 하는 
크랙커는 execve(2) 를 이용하여 이런 상황을 만들 수 있다.&#13;</P
><P
>&#13;이런 스토리지 포맷(과 설정되는 방식) 과 관련된 문제는 프로그램이 이 값을이 
유효한지 보기 위해 이러한 값들 중 하나를 검사할 수 있지만 실제로는 다른 값을 
사용할 수도 있다는 것이다. 리눅스에서 GNU glibc 는 이로부터 프로그램을 
보호하려고 하는데 glibc 2.1 에서 getenv 은 늘 처음 일치하는 엔트리를 얻고 
setenv 와 putenv 는 늘 처음 일치하는 엔트리를 설정하며 unsetenv 는 실제로 모든 
일치하는 엔트리의 설정을 해제할 것이다 (이런 방식으로 unsetenv 를 구현한 
GNU glibc 구현자에게 축하!). 그러나 몇몇 프로그램은 직접적으로 환경 변수로 
가서 모든 환경 변수에 대해 반복 적용하는데 이런 경우 처음이 아닌 마지막으로 
일치하는 엔트리를 사용할 수도 있다. 따라서 처음 일치하는 엔트리에 대해서는 
크래커로부터 보호할 수 있지만 실제 사용된 값이 마지막으로 일치하는 엔트리라면 
크랙커는 이를 이용해 보호 루틴을 피할 것이다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ENV-VAR-SOLUTION"
>4.2.3. 해결방안 - 추출 및 제거</A
></H3
><P
>&#13;보안적인 setuid/setgid 프로그램에 대해 입력될 필요가 있는 환경
변수의 간단한 리스트가 주의깊게 추출되어야 한다. 그 후 전체 환경 변수를
지우고 필요한 약간의 환경 변수들을  안전한 값으로 재설정해야 한다. 하위
프로그램을 호출한다면 실제로 더욱 좋은 방법은 없다: 모든 위험한 값을
열거할 수 있는 실제적인 방법은 없다. 직접적 또는 간접적으로 호출할 모든
프로그램의 소스 코드를 검토한다고 하더라도 코드를 작성한 후 누군가가
새로운 비공인된 환경 변수를 추가할 수 있으며 이들 중 하나를
공격에 이용할 수도 있다.&#13;</P
><P
>&#13;C/C++ 에서 환경을 지우는 간단한 방법은 전역 변수 <B
CLASS="EMPHASIS"
>environ</B
> 를 NULL 로 설정하는 것이다. 전역 변수
environ 은 &#60;unistd.h&#62; 파일에 정의되어 있는데 C/C++ 사용자는 이
헤더 파일을#include 를 써서 이용할 수 있다. 쓰레드를 생성하기 전에
environ 을 조작할 필요가 있지만 프로그램 실행 초기 (보통 쓰레드가
생성되기 전) 에 이를 조작하기 때문에 거의 문제가 되지 않는다.&#13;</P
><P
>&#13;전역 변수 environ 의 정의는 여러가지 표준에 정의되어 있다; 공식적 표준이
이 값의 직접적 변경을 묵과하는 지는 명확하지 않으며 저자는 이를
변경하는데 있어 문제가 있었던 유닉스 계열 시스템은 잘 모르고 있다.
저자는 보통 environ 을 직접적으로 수정한다; 이러한 하위 수준 컴포턴트를
조작하는 것은 아마도 이식가능하지 않지만 이는 깨끗한 (안전한)
환경을 얻을 수 있게 보증한다. 추후 전체 변수 집합에 접근할 필요가 있는
드문 경우에는 environ 변수 값을 어디든 저장할 수 있으나 이는 거의
필요하지 않다; 거의 모든 프로그램은 이들중 단지 일부 값만을 필요로 하며
나머지는 버린다.&#13;</P
><P
>&#13;환경을 지우는 또 다른 방법은 비공인된 clearenv() 함수를
사용하는 것이다. clearenv() 함수는 별다른 역사를 갖고 있는데 이는 POSIX
1 에 정의되어 있다고 알려져 있지만 어떤 연유인지 전혀 이 표준에 포함되지
않았다. 그러나 clearenv() 는 POSIX 9 (포트란 77 의 POSIX 바인딩) 에
정의되어 있으며 따라서 이에 대해 준 공식 상태로 있다. 리눅스에서
clearenv() 는 &#60;stdlib.h&#62; 파일에 정의되어 있지만 #include 를
써서 포함하기 전에 __USE_MISC 가 #define 에
의해 정의되어 있는지 확인해야 한다. 약간 더욱더 공식적인 접근 방법은
__USE_MISC 를 정의해서 _SVID_SOURCE
또는 _BSD_SOURCE 가 #define 에 의해 정의되게 하여
&#60;features.h&#62; 파일을 #include 에 의해 포함하는 것이다 - 이는
공식적인 특징을 갖는 테스트 매크로이다.&#13;</P
><P
>&#13;거의 확실히 재추가해야 하는 환경 변수는 프로그램 실행을 위해 검색되는
디렉토리 목록인 PATH 이다; PATH 는 현재 디렉토리를 포함하지 않아야 하며
보통 ``/bin:/usr/bin" 과 같이 간단한 형태이다. 일반적으로 IFS (디폴트는
공백이 첫 문자인 `` \t\n") 와 TZ (timezone, 시간대) 를 설정할 수 있다.
리눅스가 IFS 또는 TZ 가 설정되지 않았다고 해서 작동하지 않는 것은
아니지만 어떤 System V 에 기초한 시스템은 TZ 값을 설정하지 않는 경우
문제의 소지가 된다. 어떤 쉘은 IFS 값이 설정되어야 한다는 루머도 있다.
리눅스에서 설정할 수 있는 공통된 환경 변수 목록을 얻기 위해서는
environ(5) 를 보라.&#13;</P
><P
>&#13;
실제로 사용자가 제공한 값들이 필요하다면 그 값이 합법적인 값에 대한
패턴과 일치하는지 어떤 합당한 최대 길이내에 있는지를 보증하기 위해
우선적으로 검사해라. 원칙적으로는 /etc 디렉토리에 표준적인 안전한 환경
변수 값에 대한 정보를 갖고 있는 신뢰할 수 있는 표준 파일이 있을 수도
있지만 현재 이러한 목적을 위해 정의된 표준 파일은 없다. 비슷한 이유로
PAM 모듈을 갖고 있는 시스템에 대해 pam_env 를 조사할 수도 있다.&#13;</P
><P
>&#13;프로그래밍 언어로 쉘을 사용하려 한다면 ``-" 옵션을 사용해 ``/usr/bin/env"
프로그램을 사용할 수 있다 (실행되는 프로그램의 모든 환경 변수를 지운다).
기본적으로 /usr/bin/env 를 호출하여 이에 ``-" 옵션을 주고 설정하려고
하는 변수와 값 (name=value 형태로) 을 쓴 후 실행시킬 파일 이름과 그
인수를 설정한다. 대부분은 완전한 경로 이름 (/usr/bin/env) 을 사용하여
프로그램을 호출하길 원하는데 ``env" 와는 달리 사용자가 위험한 PATH 값을
만들 수 있다. GNU env 는 ``-i" 와 ``--ignore-environment" 옵션 (시작하는
프로그램의 환경을 지운다) 을  동일하게 허용함을 주목해라. 그러나 이를
다른 버전의 env 에 이식할 수는 없다.&#13;</P
><P
>&#13;환경을 직접적으로 재설정할 수 없도록 하는 언어로 setuid/setgid
프로그램을 작성한다면 다른 접근 방법은 ``wrapper" 프로그램을 생성하는
것이다. wrapper 는 환경 프로그램을 안전한 값으로 설정한 후 다른 프로그램을
호출한다. 주의: wrapper 가 실제로 의도하는 프로그램을 호출할 것인지를
확인해라; 인터프리티드 프로그램이라면 인터프리터로 하여금 특별한 setuid/setgid
권한이 주어진 프로그램외에 다른 프로그램을 적재할 수 있게 하는 가능한
경쟁 상태가 없음을 확인해라.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FILE-DESCRIPTORS"
>4.3. 파일 기술자</A
></H2
><P
>&#13;프로그램은 일련의 "오픈 파일 기술자" 즉 미리 열려 있는 파일을
넘겨받는다. setuid/setgid 프로그램은 사용자가 어떤 파일을 오픈할 것인지
및 무엇에 오픈할 것인지 (허가 한계내에서) 를 선택할 수 있다는 사실을
처리해야 한다. setuid/setgid 프로그램은 새로운 파일을 열때 늘 고정된
파일 기술자 id 로 열릴 것이라고 가정하지 않아야 한다. 또한 표준 입력
(stdin), 표준 출력 (stdout) 과 표준 에러 (stderr) 이 터미널을 참조하는지
또는 동등하게 열려 있는지 가정하지 않아야 한다.
 

 </P
><P
>&#13;
이에 대한 논리적 근거는 쉽다; 공격자가 프로그램 시작전에 파일
기술자를 열거나 닫을 수 있기 때문에 예기치 않은 상황을 생성할 수 있다는
것이다. 공격자가 표준 출력을 닫는 다면 프로그램이 다음 파일을 열 때 이
파일이 표준 출력인 것처럼 열려질 것이며 곧 모든 표준 출력을 그 파일로
보낼 것이다. 어떤 C 라이브러리는 stdin, stdout 와 stderr 이 (/dev/null 에) 이미 
열려져 있지 않다면  이들을 자동적으로 열 것이다. 물론 모든 유닉스
계열 시스템에 동일하게 적용되지는 않는다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FILE-CONTENTS"
>4.4. 파일 컨텐츠</A
></H2
><P
>&#13;프로그램이 파일로부터 명령을 받는다 하더라도 특히 단지 신뢰할 수 있는
사용자만이 그 내용을 제어할 수 없다면 그 파일을 신뢰하지 않아야 한다.
보통 이는 신뢰할 수 없는 사용자가 파일, 그 디렉토리 또는 모든 조상
디렉토리를 변경할 수 없어야 한다는 것을 의미한다. 그렇지 않다면 그
파일을 조심스럽게 다뤄야 한다.&#13;</P
><P
>&#13;파일내 명령이 신뢰할 수 없는 사용자로부터 온 것이라면 파일로부터의
입력이 이 책을 통해 기술한 바와 같이 보호되고 있는지를 확인해라. 특히 일련의
합법적인 값들과 일치되는지 버퍼 오버플로우가 없는 지를 검사해라.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="WEB-APPS"
>4.5. 웹 기반 애플리케이션 입력 (특히 CGI 스크립트)</A
></H2
><P
>&#13;CGI 스크립트와 같은 웹 기반 애플리케이션은 다소의 신뢰된 서버에서 실행되고 
웹을 통해 어떻게든 입력 데이타를 얻어야 한다. 입력 데이타는 일반적으로 
신뢰할 수 없는 사용자로부터 오기 때문에 이 입력 데이타의 정당성은 입증되어야 
하는데 실은 이 정보가 실제 신뢰할 수 없는 제 삼자로부터 올 수도 있다; 더욱 
자세한 정보는 <A
HREF="#CROSS-SITE-MALICIOUS-CONTENT"
>6.13&#51208;</A
> 을 보라. 
예를 들어, CGI 스크립트는 일련의 표준 환경 변수들과 표준 입력을 통해 이 정보를
넘겨받는다. 이 텍스트의 나머지는 CGI 스크립트가 동적 웹 컨텐트를
구현하는 가장 공통된 기술이기 때문에 이를 구체적으로 논의할 것이다. 물론
일반적인 핵심은 대부분의 다른 동적 웹 컨텐트 기법에 동일하게 적용된다&#13;</P
><P
>&#13;많은 CGI 스크립트의 입력은 소위 ``URL-encoded" 포맷으로 제공되기 때문에,
즉 어떤 값이 %HH 포맷 (HH 는 그 바이트에 대한 십육진수 코드) 으로
쓰여 있기때문에 한가지 추가적인 복잡성을 더한다. 각자 또는 CGI
라이브러리는 입력을 URL-decoding 한 후 그 바이트 값이 받아들일 수 있는지
검사함으로써 이러한 입력을 정확히 다뤄야 한다. %00 (NIL) 과
%0A (개행) 과 같은 문제가 있는 값을 포함한 모든 값을 정확히
다뤄야 한다. 입력을 한 번 이상 디코드하지 마라. 그렇지 않으면
%2500 같은 입력은 이상하게 다뤄질 것이다 (``%25" 는
``%" 로 전환되며 그 결과 생긴 ``%00" 은 틀리게 NIL 문자로
전환될 것이다).&#13;</P
><P
>&#13;
CGI 스크립트는 일반적으로 입력에 특별 문자를 포함함으로써 공격받는데
위의 설명을 보라.&#13;</P
><P
>&#13;웹 기반 애플리케이션에 사용할 수 있는 다른 데이타 형태는 ``쿠키"이다.
사용자는 임의의 쿠키 값을 제공할 수 있으며 따라서 특별한 사전 조치를
취하지 않는다면 신뢰될 리 없다. 또한 쿠키는 사용자 추적에 사용할 수
있는데 이는 많은 사용자들에 대해 사생활 침해 문제를 야기할 수 있다. 그
결과 많은 사용자는 쿠키를 금지하고 있으며 따라서 가능하다면 웹
애플리케이션은 쿠키 사용이 필요치 않도록 설계되어야 한다 (그러나 각 사용자들을
인증해야 할때에 대한 저자의 논의를 보라). 저자는 현재 세션이 종료된 후에도 
남아있는 영속적인 쿠키 사용을 피하거나 제한하도록 권한다. 정말로 미국의 
에이전시들은 특별한 환경을 제외하고는 사생활 침해에 대한 우려때문에 영속적인 
쿠키 사용이 금지되어 있다; <A
HREF="http://cio.gov/files/lewfinal062200.pdf"
TARGET="_top"
>OMB guidance
in memorandum M-00-13 (June 22, 2000)</A
> 를 보라. 쿠키를 사용할 때 몇몇 
브라우저는 당신은 사생활 프로파일 (서버의 루트 디렉토리내에 p3p.xml 이라는) 을 갖고 있다고 주장할 수 있음에 주의해라.&#13;</P
><P
>&#13;몇몇 HTML 폼은 어떤 비합법적인 값을 예방하기 위해 클라이언트 측에서의
입력 검사를 포함하고 있으며 이는 일반적으로 자바스크립트/ECMA 스크립트
또는 자바를 사용하여 구현된다. 이 검사는 어떠한 네트워크 접근도 요하지
않으면서 ``즉각적"으로 할  수 있기 때문에 사용자에게 유용할 수 있다.
그러나 이 종류의 입력 검사는 공격자가 검사를 받지 않고도 웹 서버에
직접적으로 비합법적인 값을 보낼 수 있기때문에 보안에 대해서는
무용지물이다. 이를 막는 것이 어려지는 않지만 임의의 데이타를 웹
애플리케이션에 보내는 프로그램을 작성하지 않아야 한다. 일반적으로 서버는
클라이언트가 이 검사를 보안적으로 수행하도록 할 수 없기 때문에 모든
자신의 입력 (폼 데이타, 쿠키 등) 에 대해 검사를 수행해야 한다. 요약하면
일반적으로 클라이언트는 ``신뢰할 수 있는 채널"이 아니라는 것이다. 이에
대한 더욱 자세한 정보는 <A
HREF="#TRUSTWORTHY-CHANNELS"
>6.9&#51208;</A
> 을 보라.&#13;</P
><P
>&#13;마이크로소프트사의 Active Server Pages (ASP) 를 사용하는 사람들은 입력 유효화에 
대한 짧은 논의를 <A
HREF="http://heap.nologin.net/aspsec.html"
TARGET="_top"
>http://heap.nologin.net/aspsec.html</A
> 의
Jerry Connolly 로부터 얻을 수 있다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="OTHER-INPUTS"
>4.6. 다른 입력</A
></H2
><P
>&#13;프로그램은 모든 입력이 제어되고 있는지를 보증해야 한다; 이는 setuid/setgid
프로그램의 경우 매우 많은 입력이 있기 때문에 특히 어렵다. 프로그램이
고려해야 하는 다른 입력으로는 현재 디렉토리, 시그널, 메모리 맵 (mmaps),
System V IPC 와 umask (새롭게 생성된 파일의 디폴트 허가를 결정한다) 가
있다. 프로그램 시동시 디렉토리를 적절한 완전한 이름을 갖는
디렉토리로 변경 (chdir(2) 를 사용하여) 하는 것을 고려해라.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LOCALE"
>4.7. 인간 언어 (로케일) 선택</A
></H2
><P
>&#13;더욱 많은 사람들이 컴퓨터를 갖게되고 인터넷을 이용할 수 있게 됨에 따라
많은 언어와 문화를 지원하는 프로그램에 대한 요구가 점점 증대되어 왔다.
이러한 언어와 다른 문화적 요소의 결합을 보통 ``로케일 (locale)" 이라고
한다. 다수의 로케일을 지원할 수 있도록 프로그램을 수정하는 과정과
프로그램에 각 로케일의 정보를 제공하는 과정을 각각 ``국제화
(internalization)" (i18n) 와 ``지역화 (localization)" (l10n) 라고 한다.&#13;</P
><P
>&#13;전반적으로 국제화는 훌륭한 작업이지만 보안 악용에 대한 다른 기회를
제공한다. 잠재적으로 신뢰할 수 없는 사용자가 원하는 로케일에 대한 정보를
제공하기 때문에 로케일 선택은 적절히 보호되지 못한다면 공격에 악용될 수
있는 또다른 입력이 된다.&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="HOW-LOCALES-SELECTED"
>4.7.1. 로케일 선택 방법</A
></H3
><P
>&#13;setuid/setgid 프로그램을 포함하여 로컬로 실행되는 프로그램에서 로케일
정보는 환경 변수에 의해 제공된다. 따라서 다른 모든 환경 변수와 같이 이
값은 추출되어 사용전 유효한 패턴에 대해 검사되어야 한다.&#13;</P
><P
>&#13;웹 애플리케이션의 경우 이 정보는 (Accept-Language request header 를
통해) 웹 브라우저에서 얻을 수 있다. 그러나 모든 웹 브라우저가 이 정보를
적절히 넘겨주지 않기 때문에 (모든 사용자가 적절히 웹 브라우저를 설정하지
못하기 때문에) 생각하는 것보다 그다지 많이 사용되지 않고 있다. 대개 웹
브라우저에서 요청된 언어는 폼 값으로 단순히 넘겨지는데  이 값은 다른
모든 폼 값과 마찬가지로 사용전에 그 타당성이 검사되어야 한다.&#13;</P
><P
>&#13;각각의 경우에 있어 로케일 정보는 정말로 이전 절에서 논의한 입력의 특별한
경우이다. 그러나 이 입력은 거의 고려되고 있지 않기 때문에 저자는 이를
별도로 논의하는 것이다. 특히 뒤에서 논의할 포맷 문자열과 결합될 때
사용자가 제어하는 문자열은 공격자로 하여금 다른 프로그램으로 임의의 명령
실행, 데이타 파괴 및 다른 부적당한 행위를 할 수 있게 한다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LOCALE-SUPPORT-MECHANISMS"
>4.7.2. 로케일 지원 메카니즘</A
></H3
><P
>&#13;유닉스 계열 시스템에는 로케일 선택 메세지를 지원하는 ``catgets" 와
``gettext" 라 불리는 두 중요한 라이브러리 인터페이스가 있다. catgets
방법에서 모든 문자열에는 메시지 테이블을 색인하는데 사용될 수 있는 고유
숫자가 할당된다. 반대로 gettext 방법에서는 원래 문자열을 전환시킨
테이블을 검색하는데 문자열 (보통 영어로 된) 이 사용된다. catgets(3) 은
X/Open Portability Guide, Volume 3 과 Single Unix Specificatoin 을 통해
수용된 표준이며 따라서 프로그램이 이를 사용할 수 있다. gettext
인터페이스는 본래 UniForum 제안임에도 불구하고 공식 표준은 아닌데 저자는
이것이 보다 널리 사용되고 있는 인터페이스라고 생각한다 (썬과 본질적으로 모든
GNU 프로그램에 의해 사용되고 있다).

 </P
><P
>&#13;이론상 catgets 가 약간 더 빠르지만 오늘날 머신에서는 기껏해야 최소한
(이차적인 문제) 이며 catgets() 에서 고유 식별자를 유효하게 하려는 부기
(bookkeeping) 노력은 gettext() 인터페이스를 더욱 사용하기 쉽게 만들고
있다. 저자는 단지 gettext() 가 사용하기에 더욱 쉽기 때문에 이를
사용하라고 권해왔다. 그러나 저자의 말을 곧이듣지는 마라; 더욱 길고
설명적인 비교를 위해서는 gettext 에 대한 GNU 문서 (info:gettext#catgets)
를 보라.&#13;</P
><P
>&#13;catget(3) 호출 (과 관련 catopen(3) 호출) 은 환경 변수 NLSPATH 가
국제화된 메시지를 얻는데 사용되는 파일이름을 제어하는데 사용될 수 있기
때문에 특히 보안 문제에 취약하다. GNU C 라이브러리는 setuid/setgid
프로그램에 대해 NLSPATH 를 무시하는데 이는 유용하지만 다른 구현에서
실행되고 있는 프로그램을 보호하지 못하며 또한 이러한 보호가 필요치 않아
보이는 CGI 스크립트와 같은 다른 프로그램도 보호하지 못한다.&#13;</P
><P
>&#13;널리 사용되고 있는 ``gettext" 인터페이스는 저자가 알기로 악의성있는
NLSPATH 설정에 적어도 공격받을 가능성은 없다. 그러나 저자는 악의성있는
LC_ALL 또는 LC_MESSAGES 설정은 문제를 야기할 수 있을
것같다고 생각한다. 또한 cat-compat.c 파일내 gettext 의 bindtextdomain()
루틴을 사용한다면 이는 NLSPATH 에 의존한다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LOCALE-LEGAL-VALUES"
>4.7.3. 합법적인 값</A
></H3
><P
>&#13;우선 신뢰할 수 없는 사용자에게 원하는 로케일에 대한 정보 설정을
허용한다면 제공된 국제화 정보가 단지 규칙에 맞는 로케일 이름만을
허용하는 엄밀한 (narrow) 필터를 만족시키는지 확인해라. 사용자 프로그램
(특히 setuid/setgid 프로그램)  의 경우 이러한 값은 NLSPATH, LANGUAGE,
LANG, 예전 LINGUAS, LC_ALL 과 다른 LC_* (특히
LC_MESSAGES 및 LC_COLLATE, LC_CTYPE,
LC_MONETARY, LC_NUMERIC 와 LC_TIME 를 포함) 값을
통해 들어올 것이다. 웹 애플리케이션의 경우 사용자가 요청한 언어 정보의
설정은 Accept-Language request header 또는 폼 값을 통해 이루어 질 것이다
(애플리케이션은 Content-Language heading 를 통해 반환되는 데이타의 실제
언어 설정을 나타내야 한다). 사용자가 환경 변수를 설정할 수 있거나 (예,
setuid/setgid 프로그램) 입력 필터링의 일부분으로 설정할 수 있다면 (예,
CGI 스크립트에 대해) 환경 변수 필터링시 이 값을 검사해야 한다. GNU C
라이브러리 glibc 는 setuid/setgid 프로그램에 대해 LANG 에 몇몇 값 (특히
"/" 로 시작하는 모든 값) 을 허용하지 않지만 필터링에서 에러가 발견되어
왔다 (레드햇사는 2000년 9월 1일에 glibc 버그 수정을 하여 갱신판을
배포하였다). 이러한 종류의 필터링이 모든 표준이 필요로 하지는 않는데
따라서 각자 자신이 필터링하는 것이 더욱 안전하다. 저자는 언어 설정 필터링에 
대한 어떤 본보기도 발견하지 못했으며 다음은 이 문제에 대한
저자의 연구에 기초한 제안이다.&#13;</P
><P
>&#13;우선 합법적인 설정 값에 대해 몇마디. 언어 설정은 일반적으로 IETF RFC
1766 에 정의된 표준 태그를 사용하여 설정된다 (기본 태그로 두 문자의 국가
코드를 사용하며 대시기호로 구분되는 선택적인 하부 태그가 따를 수 있다;
저자는 환경 변수 설정이 대신 밑줄을 사용함을 발견했다). 그러나 이것은
그다지 유연하지 않으며 따라서 세 문자의 국가 코드가 곧 사용될 수도 있다.
또한 두개의 주요하지만 그다지 호환되지 않는 확장 포맷인 X/Open 포맷과
CEN 포맷 (European Community Standard) 이 있다; 둘 모두를 허용하고
싶을지도 모른다. 일반적인 값은 ``C" (C 로케일), ``EN" (영어), ``FR_fr" (
프랑스 영역권의 프랑스어) 를 포함한다. 또한 많은 사람들이 표준이 아닌
이름을 사용하고 있는데 이는 이 문제에 대처하기 위해 ``alias" 시스템을
개발하기 위해 프로그램이 가졌던 이름이다 (GNU gettext 와 X11 경우 각각
/usr/share/locale/locale.alises 와 /usr/lib/X11/locale/locale.aliases 를
보라); 이들은 보통 허용되어야 한다. gettext() 같은 라이브러리는 모든
이러한 변형을 허용해야 하며 가능한 적절한 값을 찾아야 한다. 더욱 자세한
정보는 FSF [1999] 를 참조하는 것이 좋다. 그러나 필요치 않은 문자, 특히
(신뢰할 수 있는 디렉토리에서 벗어날 수 있게 하는) ``/" 과 (상위
디렉토리로 이동할 수 있게 하는) ``.." 문자는 필터가 허용하지 않아야
한다. NLSPATH 에서 다른 위험한 문자는 (대체를 나타내는) ``%" 과
(디렉토리 구분자인) ``:" 이다; 다른 머신에 대한 문서에서는 어떤 구현은
다른 값을 위해 이들을 사용할 수 있다고 제안하지만 이들을 금지하는 것이
가장 안전한 것이다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LOCALE-BOTTOM-LINE"
>4.7.4. 최종 결과</A
></H3
><P
>&#13;요약하면 저자는 신뢰된 사용자가 값을 제공하지 않도록 한다면 
NLSPATH 를 단순히 지우거나 재설정하도록 권한다. HTTP 에서
Accept-Language heading, 로케일을 지정하는 폼 값 및 LANGUAGE, LANG, 예전
LINGUAS,  LC_ALL 과 다른 LC_* 값에 대해 null (empty) 값을
허용하거나 또는 다음의 정규 표현식과 전부 일치하는 값들만을 허용하기
위해 신뢰되지 않은 사용자로부터의 로케일을 필터링해라:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> [A-Za-z][A-Za-z0-9_,+@\-\.]*</PRE
></TD
></TR
></TABLE
><P
>&#13;저자는 이 패턴과 일치하지 않는 어떠한 합법적인 로케일도 발견하지
못했지만, 이 패턴은 로케일 공격에 대해서 보호하는 것처럼 보인다. 물론
요청된 로케일에서 얻을 수 있는 메시지가 있다고 보증할 수는 없지만 그러한
경우 이런 루틴들은 디폴트 메시지 (보통 영어)로 돌아갈 것이며 적어도
이것이 보안 관련 문제가 되지는 않는다.&#13;</P
><P
>&#13;물론 언어는 성문 (written) 심볼을 나타내는 표준적인 방식으로 지원되어야
하며 이는 문자 인코딩 논의로 이끈다.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CHARACTER-ENCODING"
>4.8. 문자 인코딩</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="CHARACTER-ENCODING-INTRO"
>4.8.1. 문자 인코딩 소개</A
></H3
><P
>&#13;
미국인들은 오랫동안 아스키 문자셋을 이용하여 텍스트를 서로 교환했다;
본래 미국의 모든 시스템들이 아스키를 지원하기 때문에 영어 텍스트를
손쉽게 교환할 수 있다. 불행히도 아스키는 거의 모든 다른 언어의 문자를
다루기에는 부적절하다. 오랫동안 여러 나라들은 다른 언어로 텍스트를
교환하는 여러가지 기법을 채택해왔으며 이는 더욱 더 상호 연결된 세상에서
데이타를 교환하는 것을 어렵게 만들고 있다.&#13;</P
><P
>&#13;더욱 최근에 ISO 는 ISO 10646, Universal Multiple-Octet Coded Character
Set (UCS) 을 개발했는데 UCS 는 세상의 모든 문자 각각에 대해 유일한 31
비트 값을 정의하는 코드화된 문자셋이다. UCS 의 첫 65536 문자 (따라서 16
비트에 꼭맞다) 는 Basic Multilingual Plane (BMP) 이라고 칭하며 BMP 는
거의 오늘날 모든 구어를 다루려고 한다. Unicode 포럼은 유니코드 표준을
개발하고 있는데 이는 UCS 에 중점을 두어 상호 이용을 돕기 위해 약간의 추가적인
합의를 추가한다. 역사적으로 유니코드와 ISO 10646 은 경쟁 그룹이
개발했지만 고맙게도 두 그룹은 공동 작업의 필요성을 깨달았으며 현재 서로
협력하며 개발하고 있다.&#13;</P
><P
>&#13;
국제화된 문자를 다루는 새로운 소프트웨어를 작성하고 있다면 국제적인
문자를 다루기 위한 기초로 ISO 10646/유니코드를 사용해야 한다. 그러나
다양한 옛날 (언어에 특정적인) 문자셋으로 쓰여진 옛날 문서를 처리할
필요가 있을 수 있는데 이 경우에 있어 신뢰되지 않은 사용자가 다른 문서의
문자셋 설정을 제어할 수 없도록 보증할 필요가 있다 (이는 문서의 해석에
상당히 영향을 미칠 수 있기 때문이다).&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CHARACTER-ENCODING-UTF8"
>4.8.2. UTF-8 소개</A
></H3
><P
>&#13;대부분의 소프트웨어는 16 비트 또는 32 비트 문자를 다루도록 설계되지
않았는데 이제부터 8 비트 이상의 포괄적인 문자셋을 생성하는 것이 필요하게 
되었다. 따라서 기존 프로그램 및 라이브러리가 더욱 쉽게 다룰 수 있는
포맷으로 이러한 잠재적으로 국제적인 문자를 인코드할 수 있도록 UTF-8
이라는 특정 포맷이 개발되었다. UTF-8 은 다른 곳중에서 IEFT-RFC 2279 에
정의되어 있으며 이 때문에 자유로이 읽혀지고 사용될 수 있는 잘 정의된
표준이다. UTF-8 은 가변 너비 (variable-width) 인코딩으로 0 에서 0x7f
(127) 까지 번호가 매겨진 문자들 자신을 싱글 바이트로 인코드하며 반면
더욱 큰 값을 갖는 문자들은 그 값에 따라 정보가 2 에서 6 바이트로
인코드된다. 인코딩은 특히 다음의 정확한 특성을 갖도록 설계되어왔다 (이
정보의 출처는 RFC 및 리눅스 utf-8 맨페이지이다):&#13;</P
><P
></P
><UL
><LI
><P
>&#13;
고전적인 미국 아스키 문자 (0 에서 0x7f) 는 자신으로 인코드되는데 따라서 
단지 7 비트 아스키 문자들을 포함한 파일 및 문자열은 아스키와 UTF-8
하에서 동일한 인코딩을 갖는다. 이는 많은 기존 미국 프로그램과 데이타
파일에 대해 역행 호환성을 제공하기 때문에 놀라운 것이다.&#13;</P
></LI
><LI
><P
>&#13;
0x7f 를 초과하는 모든 UCS 문자는 0x80 에서 0xfd 의 범위내의 바이트로만
구성되는 멀티바이트 시퀀스로 인코드된다. 이는 어떠한 아스키 바이트도
다른 문자의 일부분으로 나타날 수 없음을 의미한다. 다른 많은 인코딩은
프로그램의 실패를 야기하는 임베디드 NIL 과 같은 문자를 허용한다.&#13;</P
></LI
><LI
><P
>&#13;
UTF-8 및 2 바이트 또는 4 바이트 고정 폭을 갖는 문자 표현사이에 변환이
쉽다. (이들은 각각 UCS-2 및 UCS-4 로 불린다)&#13;</P
></LI
><LI
><P
>&#13;
UCS-4 문자열의 사전학적 정렬 순서가 유지되며 Boyer-Moore 의 fast 검색 
알고리듬이 UTF-8 데이타에 직접적으로 사용될 수 있다.&#13;</P
></LI
><LI
><P
>&#13;
모든 가능한 2^31 UCS 코드가 UTF-8 을 사용해서 인코드될 수 있다.&#13;</P
></LI
><LI
><P
>&#13;
하나의 아스키가 아닌 UCS 문자를 표현하는 멀티바이트 시퀀스의 첫번째
바이트는 늘 0xc0 과 0xfd 사이의 범위에 있으며 이러한 멀티바이트 시퀀스의
길이를 가리킨다. 멀티바이트 시퀀스내에서 모든 뒤의 바이트는 0x80 과 0xbf
사이의 범위에 있다. 이는 쉬운 재동기를 허용하는데 한 바이트를 생략하는
경우 ``다음" 문자로 건너뛰는 것은 쉬우며 또한 ``다음" 또는 ``이전"
문자로 이동하는 것은 늘 쉽다.&#13;</P
></LI
></UL
><P
>&#13;요약하면 UTF-8 변환 포맷은 다른 정확한 특성을 갖을 뿐 아니라 모든 세계의
언어를 지원할 수 있고 지금으로서는 미국 아스키 파일과 역행 호환성을 갖고
있기 때문에 국제화 텍스트 정보를 교환하는데 있어 가장 유력한 방법이 되고
있다. 많은 경우에 있어 저자는 이를 사용하길 추천하며 특히 텍스트
파일내에서 데이타를 정렬할 때는 이를 사용하길 바란다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="UTF8-SECURITY-ISSUES"
>4.8.3. UTF-8 보안 쟁점</A
></H3
><P
>&#13;UTF-8 을 언급하는 이유는 어떤 바이트 시퀀스가 비합법적인 UTF-8 이며
이것이 악용될 수 있는 보안 구멍일 수도 있기 때문이다. UTF-8 인코더는
``가능한 가장 짧은" 인코딩을 사용한다고 알려져 있지만 순진한 디코더가
필요이상으로 긴 인코딩을 받아들일 수도 있다. 정말로 더욱 초기의 표준은 디코더가
``non-shortest form" 인코딩을 받아들이도록 허용했다. 여기서의 문제는 이것이 
잠재적으로 위험한 입력이 다수의 방식으로 표현될 수 있으며 따라서 위험한 입력을 
검사하는 보안 루틴을 무력화시킬 수도 있다는 것을 의미한다는 것이다. 
RFC 는 다음과 같이 문제점을 기술하고 있다:&#13;</P
><A
NAME="AEN717"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;UTF-8 을 구현한 사람은 비합법적인 UTF-8 시퀀스 처리 방법의 보안 측면을
고려할 필요가 있다. 어떤 경우에 있어 공격자가 UTF-8 파서에 UTF-8
구문에서 허용되지 않는 옥텟 (팔중수, octet) 시퀀스를 보냄으로써
조심성없는 파서를 악용할 수 있을 것이라고 상상할 수 있다.&#13;</P
><P
>&#13;
특히 미묘한 형태의 이 공격이 UTF-8 로 인코드된 입력 폼에 대해 보안에
중대한 유효성 검사를 수행하지만 어떤 비합법적인 옥텟 시퀀스를 문자로
해석하는 파서에 대해 수행될 수 있다. 예를 들어 싱글 옥텟 시퀀스
00 으로 인코드될 때는 NUL 문자를 금지하지만 C0 80 (필요이상으로
길기때문에 비합법적이다) 의 비합법적인 두 옥텟 시퀀스는 허용해서 이를
NUL 문자 (00) 으로 해석할 수도 있다. 다른 예는 옥텟 시퀀스 2F 2E 2E 2F
("/../") 를 금지하지만 아직까지는 비합법적인 옥텟 시퀀스 2F C0 AE 2E 2F 를
허용하는 파서일 것이다.&#13;</P
></BLOCKQUOTE
><P
>&#13;이에 대한 더욱 자세한 논의는 <A
HREF="http://www.cl.cam.ac.uk/~mgk25/unicode.html"
TARGET="_top"
>http://www.cl.cam.ac.uk/~mgk25/unicode.html</A
>
에서 Marjus Kuhn 의 <B
CLASS="EMPHASIS"
>UTF-8 and Unicode FAQ for
Unis/Linux</B
> 로부터 얻을 수 있다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="UTF8-LEGAL-VALUES"
>4.8.4. UTF-8 합법적인 값</A
></H3
><P
>&#13;따라서 UTF-8 입력을 받아들일 때 유효한 UTF-8 인지를 검사할 필요가 있다.
표 4-1 은 모든 합법적인 UTF-8 시퀀스 목록이다; 이 표와 일치하지 않는
모든 문자 시퀀스는 합법적인 UTF-8 시퀀스가 아니다. 표에서 첫번째 열은 
UTF-8 로 인코드되는 다양한 문자값들이다. 두번째 열은 이 문자들이 어떻게 바이너리 
값으로 인코드되는 지를 보여준다; ``x" 는 데이타 (0 또는 1) 가 놓이는 곳을 나타낸다. 
그러나 몇몇 값들은 가능한 가장 짧은 인코딩이 아니기 때문에 허용되지 않아야 한다.
마지막 열은 각 바이트가 가질 수 있는 (16진법) 유효한 값을 나타낸다. 
따라서 프로그램은 모든 문자가 세번째 열의 패턴 중의 하나와 일치하는지 검사해야 한다. 
``-" 는 합법적인 값 (포괄적인 ) 의 범위를 나타낸다. 물론 시퀀스가 합법적인
UTF-8 시퀀스라고 해서 이를 수용해야 한다는 것을 의미하지는 않으며 (스스로 다른 
검사를 할 필요가 있다) 일반적으로 다른 검사를 하기 전에 UTF-8 합법성에 대해 
모든 UTF-8 데이타를 검사해야 한다.&#13;</P
><DIV
CLASS="TABLE"
><A
NAME="AEN726"
></A
><P
><B
>&#54364; 4-1. 합법적인 UTF-8 시퀀스 </B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL
WIDTH="1*"
TITLE="UCS"><COL
WIDTH="1*"
TITLE="BINARY-RANGE"><COL
WIDTH="1*"
TITLE="HEX"><THEAD
><TR
><TH
>UCS Code (Hex)</TH
><TH
>Binary UTF-8 Format</TH
><TH
>Legal UTF-8 Values (Hex)</TH
></TR
></THEAD
><TBODY
><TR
><TD
>00-7F</TD
><TD
>0xxxxxxx</TD
><TD
>00-7F</TD
></TR
><TR
><TD
>80-7FF</TD
><TD
>110xxxxx 10xxxxxx</TD
><TD
>C2-DF 80-BF</TD
></TR
><TR
><TD
>800-FFF</TD
><TD
>1110xxxx 10xxxxxx 10xxxxxx</TD
><TD
>E0 A0*-BF 80-BF</TD
></TR
><TR
><TD
>1000-FFFF</TD
><TD
>1110xxxx 10xxxxxx 10xxxxxx</TD
><TD
>E1-EF 80-BF 80-BF</TD
></TR
><TR
><TD
>10000-3FFFF</TD
><TD
>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</TD
><TD
>F0 90*-BF 80-BF 80-BF</TD
></TR
><TR
><TD
>40000-FFFFFF</TD
><TD
>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</TD
><TD
>F1-F3 80-BF 80-BF 80-BF</TD
></TR
><TR
><TD
>40000-FFFFFF</TD
><TD
>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</TD
><TD
>F1-F3 80-BF 80-BF 80-BF</TD
></TR
><TR
><TD
>100000-10FFFFF</TD
><TD
>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</TD
><TD
>F4 80-8F* 80-BF 80-BF</TD
></TR
><TR
><TD
>200000-3FFFFFF</TD
><TD
>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</TD
><TD
>too large; see below</TD
></TR
><TR
><TD
>04000000-7FFFFFFF</TD
><TD
>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</TD
><TD
>too large; see below</TD
></TR
></TBODY
></TABLE
></DIV
><P
>&#13;앞에서 언급했듯이 문자셋에 대한 표준에는 ISO 10646 과 Unicode 두개가 있으며 
이들은 문자 지정을 동기화하는데 동의하였다. ISO/IEC 10646 과 IETF RFC 내의 
UTF-8 의 정의는 Uniforum 의 Unicode 가 지원하는 범위밖의 문자들을 인코드하기 위해 
현재 5 와 6 바이트 시퀀스를 지원한다. 그러나 이 값들이 Unicode 문자를 지원하는데 
사용할 수 없으며 ISO 10646 의 향후 버전에서도 동일한 한계를 갖을 것으로 생각된다. 
따라서 대부분의 목적에 대해 5 와 6 바이트 UTF-8 인코딩은 합법적이지 않으며 보통 이를 
버려야 한다 (특별한 목적이 아닌 경우라면).&#13;</P
><P
>&#13; 이러한 일련의 유효한 값들을 결정하는 것은 어려우며 사실 이 문서의 초기 버전에는 다소의 
틀린 엔트리를 갖고 있었다 (어떤 경우에 있어 너무 긴 문자를 허용했다). 언어 개발자들은 
라이브러리에 유효한 UTF-8 값을 검사하는 함수를 포함해야 하는데 이를 올바르게 검사하는 것은 
매우 어렵기 때문이다. &#13;</P
><P
>&#13;어떤 경우에 있어서 16진법 시퀀스 C0 80 을 부주의하게 자르고 (내부적으로
사용하고) 싶을 수도 있다고 저자는 언급한다. 이는 허용되는 경우
아스키 NUL (NIL) 을 나타낼 수 있는 너무 긴 시퀀스이다. C 와 C++ 에서
보통 문자열에 NIL 문자를 포함하는 것은 문제가 생기기 때문에 NIL 을
데이타 스트림의 일부분으로 나타내길 원할 때 이 시퀀스를 사용해왔다;
자바조차도 이러한 예를 사용하고 있다. 데이타를 처리할 때 C0 80 을
내부적으로는 자유롭게 사용해라 그러나 기술적으로 이를 데이타에 저장하기
전에 다시 00 으로 실제적으로 전환해야 한다. 필요에 따라 UTF-8 데이타
스트림내의 입력으로 C0 80 을 부주의하게 받아들일 수도 있다. 이 시퀀스는
상호운용성에 도움을 주기 때문에 보안에 해를 끼치지 않는다면 이 시퀀스를
수용하는 것이 아마도 좋은 습관이다.&#13;</P
><P
>&#13;이를 다루는 것은 어려울 수 있다. 변환을 다루기 위해 <A
HREF="ftp://ftp.unicode.org/Public/PROGRAMS/CVTUTF/ConvertUTF.c"
TARGET="_top"
>ftp://ftp.unicode.org/Public/PROGRAMS/CVTUTF/ConvertUTF.c</A
> 에서 
얻을 수 있는 Unicode 에서 개발한 C 루틴을 살펴볼 수도 있다. 
저자에게 이 루틴이 오픈 소스 소프트웨어인지 명확하지는 않다 (라이센스에 
수정가능 여부가 명확히 언급되어 있지 않다) 따라서 주의해라.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="UTF8-RELATED-ISSUES"
>4.8.5. UTF-8 관련 쟁점</A
></H3
><P
>&#13;이 절에서는 UTF-8 을 기술했는데 이는 가장 널리 쓰이는 UCS 멀티바이트
인코딩이기 때문이다. 이는 많은 국제화 텍스트 처리 문제를 간단하게 한다.
그러나 UTF-8 만이 유일한 인코딩은 아니며 UTF-8 과 같은 종류의 문제점을
갖고 같은 연유로 인해 유효성을 평가해야 하는 UTF-16 과 UTF-7 과 같은
다른 인코딩도 있다.  &#13;</P
><P
>&#13;다른 문제는 ISO 10646/유니코드에서 한가지 이상의 방법으로 어떤 구
(phrase) 가 표현될 수 있다는 것이다. 예를 들어 어떤 강조된 문자는
악센트를 갖는 하나의 문자 및 일련의 문자 (기본 문자 + 별도의 구성
악센트) 로 표현될 수 있다. 이러한 두 형태는 동일하게 나타날 수도 있다.
또한 끼워 넣을 수 있는 zero-width 공백으로 이는 외관상 유사한 아이템이
다르게 생각되도록 한다. 이러한 숨겨진 텍스트가 프로그램을 방해할 수 있는
상황을 조심해라. 이는 일반적으로 해결하기 어려운 문제이다; 대부분의
프로그램은 완벽히 특별한 시퀀스가 나타날 수 있는 방법을 클라이언트가 알
수 있게끔 엄격한 제어를 하지 못한다 (이는 클라이언트의 폰트, 디스플레이
특성, 로케일 등에 의존하기 때문이다).&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INPUT-PROTECTION-CROSS-SITE"
>4.9. 입력에서 교차 사이트의 악의있는 컨텐트를 예방해라</A
></H2
><P
>&#13;
어떤 프로그램은 신뢰되지 않은 한 사용자로부터 데이타를 받아 이를 두
번째 사용자에게 넘겨주는데 그 후 두 번째 사용자의 애플리케이션은 두 번째
사용자에게 해로운 방식으로 그 데이타를 처리할 수도 있다. 이는 특히 웹
애플리케이션에 일반적인 문제로 ``cross-site malicious content" 라고
부를 것이다. 요약하면 입력에 대한 검사, 필터링 또는 인코딩을 한 후 이를
받아들여야 한다. 더욱 자세한 정보는 <A
HREF="#CROSS-SITE-MALICIOUS-CONTENT"
>6.13&#51208;</A
> 을 보라.&#13;</P
><P
>&#13;
기본적으로 이는 모든 웹 애플리케이션 입력이 (이 문제를 야기할 수 있는
문자들이 제거되도록) 필터링, (이 문제를 야기할 수 있는 문자들이 문제를
예방하는 방식으로 인코드되도록) 인코딩 또는 (단지 "안전한" 데이타만이
목적지에 도달함을 보증하기 위해) 유효화되어야 함을 의미한다. 필터링과
유효화는 대개 입력에서 행해져야 하지만 인코딩은 입력 또는 출력시 행해질
수 있다. 데이타를 분석없이 그저 통과시키려면 아마도 입력시 데이타를
인코딩하는 것이 더욱 좋지만 (이 경우는 잊지 않을 것이다) 데이타를
처리한다면 출력시 인코딩에 대해서는 논의들이 있다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FILTER-HTML"
>4.10. 다시 보내질 수도 있는 HTML/URIs 를 필터링해라</A
></H2
><P
>&#13;Cross-site malicious content 를 예방해야 하는 한가지 특별한 경우는 한
사용자로부터 HTML 또는 XHTML 을 받아 이를 다른 사용자에게 전달하도록
설계된 웹 애플리케이션이다 (이에 대한 더욱 자세한 정보는 <A
HREF="#CROSS-SITE-MALICIOUS-CONTENT"
>6.13&#51208;</A
> 을 보라). 다음 하부 절은 이러한
특정 종류의 입력을 필터링하는 것이 공통 요구사항이기 때문에 이에 대해
논의한다.&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="REMOVE-HTML-TAGS"
>4.10.1. 몇몇 HTML 데이타를 제거 및 금지해라</A
></H3
><P
>&#13;모든 가능한 (X)HTML 태그가 어떤 것이라도 영향을 끼칠 수 없도록 이를
제거하는 것이 가장 안전한데 이의 제거는 비교적 쉽다. 위에서 언급했듯이
합법적인 문자 목록을 확인해서 목록에 없는 그러한 문자들을 거절 또는
제거해야 한다. 이 필터에서 합법적인 문자 목록에 있는 다음 문자는 다만
포함시키지 마라: ``&#60;", ``&#62;" 와 ``&#38;" (속성에 사용된다면 이중
인용부호 ``quot;"). 브라우저가 HTML 스펙에 따라 작동한다면 ``&#62;" 는
제거될 필요는 없지만 실제로는 제거되어야 한다. 이는 어떤 브라우저는
페이지 저자가 실제로 시작 ``&#60;" 태그를 놓아 ``도움이 되도록" 하나를
끼워넣었다고 가정하기 때문으로 공격자는 이 동작을 악용하여 바람직하지
못한 ``&#60;" 를 만들기 위해 ``&#62;" 를 사용할 수 있다.&#13;</P
><P
>&#13;보통 HTML 전송에 사용되는 문자셋은 ISO-8859-1 (국제화 텍스트를 보낼
때에도) 이며 따라서 필터는 또한 대부분의 제어 문자 (개행과 탭은
무방하다) 및 고차 (high-order) 비트가 설정되어 있는 문자를 제거해야
한다.&#13;</P
><P
>&#13;이러한 접근방법의 문제점은 실제로 사용자를 놀라게 할 수 있다는 것으로
모든 국제화 텍스트가 말없이 제거된다면 이를 적은 사람은 당혹스러울
것이다. 무효한 문자가 경고없이 조용히 제거된다면 그 데이타는 돌이킬 수
없이 분실되어 추후 다시 얻을 수 없을 것이다. 한가지 대안은 그러한 문자를
금지하여 이 문자를 사용하려고 하는 사용자에게 에러 메세지를 되돌려
보내는 것이다. 이는 적어도 사용자에게 경고를 하지만 사용자들이 찾는
기능성을 주지는 않는다. 다른 대안은 이 데이타를 인코딩 또는 유효화하는
것이다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ENCODING-HTML-TAGS"
>4.10.2. HTML 데이타 인코딩</A
></H3
><P
>&#13;거의 안전한 대안은 결정적인 문자를 변환시켜 이들이 HTML 에서 통상적인
의미를 가질 수 없도록 하는 것이다. 이는 모든 "&#60;", "&#62;" 와 "&#38;"
를 각각 "&#38;lt;", "&#38;gt;" 와 "&#38;amp;" 로 변환시킴으로써 행해질
수 있다. 임의의 국제화 문자는 "&#38;#value;" 포맷을 이용하여 Latin-1
으로 인코딩될 수 있다 - 마지막의 세미콜론을 잊지 마라. 국제화 문자를
인코딩한다는 것은 물론 입력 인코딩이 무엇인지를 알아야 함을 의미한다.&#13;</P
><P
>&#13;여기서 한가지 가능한 위험은 이러한 인코딩이 우연히 두번 해석된다면
공격당하기 쉬울 것이라는 것이다. 그러나 적어도 이 접근 방법은 추후
사용자에게 입력의 "의도" 를 볼 수 있도록 허용한다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="VALIDATING-HTML-TAGS"
>4.10.3. HTML 데이타 확인</A
></H3
><P
>&#13;어떤 애플리케이션이 여하튼 작동하기 위해서는 제 삼자로부터 HTML 을
받아들여 이를 사용자들에게 전송해야 한다. 주의 - 이 시점에서 위험한 곳을
걷고있다 ; 실제로 이를 행하길 원하는지를 확신해라. 임의의 곳에서 온 HTML
을 받아들인다는 아이디어는 이를 올바르게 이해하는 것이 무척 어렵기
때문에 상당한 보안 견습자들 사이에서도 의견이 분분하다.&#13;</P
><P
>&#13;그러나 애플리케이션이 HTML 을 받아들여야 하고 이럴만한 가치가 있다고
믿는다면 적어도 안전한 HTML 명령 목록을 확인하여 단지 이들만을
허용해라.&#13;</P
><P
>&#13;다음은 애플리케이션 (게스트북과 같은) 에 유용할 수 있는 최소한의 안전한
HTML 태그셋이다: &#60;p&#62; (paragraph), &#60;b&#62; (bold), &#60;i&#62;
(italics), &#60;em&#62; (emphasis), &#60;strong&#62; (strong emphasis),
&#60;pre&#62; (preformatted text), &#60;br&#62; (forced line break - 마침
태그가 필요하지 않음을 주목해라) 과 이들의 마침 태그들.&#13;</P
><P
>&#13;단지 적은 일련의 ``안전한" HTML 명령들만이 수용됨을 보증할 필요가 있을뿐
아니라 이들이 적절히 포개지고 닫힘을 보증할 필요가 있다. XML 에서는 이를
``well-formed" 데이타라고 한다. 표준 HTML (&#60;p&#62; 앞에 제공되지 않은
내포된 &#60;/p&#62; 를 지원하는 것은 무방할 것이다) 을 수용하려면 약간의
예외가 있을 수 있지만 완전히 일반적인 HTML 을 수용하려고 하는 것은
대부분의 애플리케이션에서 필요하지 않다. 실로 HTML 대신 XHTML 을
고수하려고 한다면 well-formedness 가 요구된다. 또한 HTML 태그는 대소문자
구분을 하지 않는데 태그는 대문자, 소문자 또는 이들의 조합일 수 있다.
그러나 XHTML 을 수용하려고 한다면 모든 태그를 소문자로 표현할 필요가
있다 (XML 은 대소문자를 구분하는데 XML 을 사용하는 XHTML 은 소문자로
태그를 표현해야 한다).&#13;</P
><P
>&#13;다음은 이를 위해 임의로 뽑은 약간의 팁이다. 제공된 텍스트가 메인
사이트로부터의 (변조를 예방하기 위해) 텍스트로 잘못 해석될 수 없도록 보통
무엇이 HTML 텍스트와 허용 태그셋을 둘러쌀지를 설계해야 한다. 속성 형태와
그 값을 검사하지 않는다면 모든 속성을 수용하지 마라; 사용자들에게 문제를
야기할 수 있는 자바스크립트와 같은 것을 지원하는 많은 속성들이 있다. 위
목록에서 저자가 어떠한 속성도 포함하지 않았음을 알아차렸을 것이다. 이는
가장 안전한 방침이다. 불안전한 태그가 사용되면 될 수 있는 한 경고
메세지를 주어야 하지만 실제로 쓸모있는 것이 아니라면 중대한 문자를
인코딩 (예, "&#60;" 는 "&#38;lt;" 로) 함으로써 사용자를 안전하게 보호함과
동시에 데이타 손실을 예방한다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="VALIDATING-URIS"
>4.10.4. 하이퍼텍스트 링크 (URIs/URLs) 확인</A
></H3
><P
>&#13;주의깊은 독자라면 저자가 하이퍼텍스트 링크 태그 &#60;a&#62; 를 안전한 HTML
태그로 포함하지 않았음을 알아차렸을 것이다. 분명히 &#60;'a href="safe
URI"&#62; (하이퍼텍스트 링크) 를 안전한 목록 (속성의 내용을 검사하지
않았다면 다른 모든 속성을 허용하지 않으며) 에 추가할 수 있을 것이다.
애플리케이션이 이를 필요로 한다면 그렇게 해라. 그러나 제삼자에게 링크
생성을 허용하는 것은  안전한 URI <A
NAME="AEN815"
HREF="#FTN.AEN815"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
> 를 정의하는 것이 매우 힘든
것으로 알려져 있기 때문에 비교적 덜 안전하다. 많은 브라우저는 사용자에게
위험할 수 있는 모든 종류의 URI 를 받아들인다. 이 절은 다른 사용자에게
다시 건네줄 제삼자로부터의 URI 를 확인하는 방법을 HTML 내로 병합된 URI 를
포함해서 논의한다.&#13;</P
><P
>&#13;우선 다양한 스펙에 정의된 것과 같이 URI 구문을 간략히 살펴보자.
URIs 는 절대적 또는 상대적일 수 있다. 절대적 URI 의 구문은 다음과 같다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>scheme://authority[path][?query][#fragment]</PRE
></TD
></TR
></TABLE
><P
>&#13;URI 는 "http" 와 같은 스킴 이름, "://" 문자, "www.dwheeler.com" 과 같은
authority, 디렉토리 또는 파일 이름과 같이 보이는 경로, 질의 앞의 물음표
및 단락 (fragment) 식별자 앞의 해시 ("#") 로 시작한다. 각괄호는 선택적인
부분을 둘러싼다 - 예로 많은 URIs 는 실제로 질의 또는 단락을 포함하지는
않는다. 몇몇 스킴은 데이타중 일부를 허용하지 않을 수 있으나 (예, 경로,
질의 또는 단락) 많은 스킴은 그 고유의 추가적인 요건을 갖는다. 많은
스킴은 authority 필드가 다음 구문을 사용하여 선택적인 사용자 이름,
패스워드 및 포트를 식별할 수 있게 한다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> [username[:password]@]host[:portnumber]</PRE
></TD
></TR
></TABLE
><P
>&#13;"host" 는 이름 ("www.dwheeler.com") 또는 IPv4 숫자 주소 (127.0.0.1) 일
수 있다. 상대적 URI 는 현재 객체에 대해 한 객체를 참조하며 구문은 파일
이름과 같이 보인다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>path[?query][#fragment]</PRE
></TD
></TR
></TABLE
><P
>&#13;대부분의 URI 에서 허용된 문자는 제한된 수로 따라서 이 문제를 피하기
위해서는 다른 8-비트 문자를 %hh 와 같이 URL 인코드할 수도 있다 (hh 는
8비트 문자의 16진법 값이다). 유효한 URIs 에 대한 더욱 세부적인 정보는
IEFT RFC 2396 및 관련 스펙을 보라.&#13;</P
><P
>&#13;URIs 의 구문을 보았기 때문에 각 부분의 위험을 조사해보자:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;스킴 (Scheme): 많은 스킴들은 매우 위험하다. 자바스크립트 스킴을 끼워넣는
것을 누군가에게 허가하는 것은 그들에게 흔해빠진 서비스 부인공격을 허용할
수 있을 것이다 (예, 되풀이하여 윈도우를 생성함으로써 사용자 머신은 동결
(freeze) 또는 불안정하게 된다). 더욱 심각하게 자바스크립트 구현시 알려진
취약한 부분을 악용할 수도 있을 것이다. "mailto:" 와 같은 어떤 스킴은
메일링이 예상되지 않을 때 귀찮은 스킴일 수 있으며 어떤 스킴은 클라이언트
머신에서 충분히 보안적이지 않을 수도 있다. 따라서 허용된 일련의 스킴들을 몇가지
안전한 스킴으로 제한하는 것이 필요하다.&#13;</P
></LI
><LI
><P
>&#13;Authority: 원칙적으로 사용자 링크를 안전한 사이트로 제한해야 하지만 이를
실제적으로 하는 것은 어렵다. 그러나 여러분은 사용자 이름, 패스워드 및
포트 넘버에 대해서는 이를 확실히 할 수 있다: 이를 금지해야 한다. 특히
패스워드와 함께 사용자 이름을 묻는 시스템은 아마도 더욱 중요한
무엇인가를 지키고 있다; 이는 공개적으로 게시되는 URIs 에는 거의 필요치
않으나 사용자에게 그들이 접근한 정보를 보였고 또는/그리고 이를 이용하여 정보를
수정하였음을 납득시키도록 이 기능성을 누군가가 
사용하려고 할 것이다. 패스워드가 없는 사용자 이름은 브라우저가 일반적으로
패스워드를 캐시하기 때문에 그다지 위험하지 않다. 다른 포트들은 다른
프로토콜을 예상하며 그 결과 프로토콜 혼동은 악용될 수 있기 때문에 포트
지정을 허용하지 않아야 한다. 예를 들어 gopher 스킴을 사용하고 SMTP
(이메일) 포트를 지정하여 사용자로 하여금 공격자가 선택한 곳으로 이메일을
보내도록 하는 것이 가능하다. 여러분은 http 8008 과 8080 포트와 같이
약간의 특별한 경우를 허용할 수도 있지만 대체로 그렇게 할만한 가치는 없다.
호스트는 이름에 의해 지정될 때 실제로 적절히 제한된 문자셋을 갖는다 (DNS
표준을 사용하여). 기술적으로 표준은 언더라인 "_" 문자를 허용하지 않지만
마이크로소프트는 표준의 이 부분을 무시했으며 어떤 상황에서는 이
언더라인의 사용을 필요로 한다. 따라서 아마도 이를 허용해야 한다. 또한
DNS 이름에서 국제화 문제를 지원하는데 있어 많은 연구가 있어왔는데 여기서는 
더욱 세부적으로 논의되지 않는다.&#13;</P
></LI
><LI
><P
>&#13;경로: 경로 허가는 보통 무방하지만 불행히도 어떤 애플리케이션은 경로의
일부분을 질의 데이타로 사용해서 다음에 논의할 구멍을 만든다. 또한
서투르게 구축된 웹서버에서 기밀성의 데이타를 드러낼 수 있는 ".." 와 같은
구절을 포함한 경로도 허용된다; 이는 예전보다 그다지 중요한 문제는 아니며 웹서버에 의해
수정되어야 한다. 특별한 것은 단지 ".." 구절이기 때문에 경로를 살펴서
(아마도 질의 데이타도) 컨텐트로 "../" 를 금지하는 것이 바람직하다.
그러나 확인자가 URL 이스케이프를 허용한다면 이는 어려울 것이다; 이러한
문자가 이스케이프되는 버전을 예방할 필요가 있으며 또한 이런 문자들의
다양한 비합법적인 문자 인코딩을 처리해야 한다.&#13;</P
></LI
><LI
><P
>&#13;질의: ? 로 시작하는 질의 포맷도 어떤 질의 포맷이 실제로 서버측에서 어떤
명령이 실행되게 할 수 있기 때문에 보안 위험이 될 수 있다. <A
HREF="#AVOID-GET-NON-QUERIES"
>4.11&#51208;</A
> 에 더욱 자세히 논의된 바와 같이 질의
포맷과 애플리케이션이 서버측에서 어떤 명령을 실행할 수 있게 해서는 안된다. 
그러나 이것이 중요한 문제라고 인정해야 한다. 덧붙여 많은 웹사이트는 실제로 
리디렉터이다 -
이들은 사용자가 어디로 리디렉트되어야 하는 지를 지정하는 인수를 받아
사용자를 새 위치로 리디렉팅시키는 명령을 돌려준다. 공격자가 이런
사이트를 참조해 리디렉션값으로 더욱 위험한 URI 를 제공하고 브라우저가
부주의하게 리디렉션을 따른다면 문제가 발생할 수 있다. 사용자 브라우저는
더욱 주의를 기울여야 하는데 모든 사용자가 충분히 신중한 것은 아니다.
또한 많은 웹 애플리케이션은 특정 질의 값을 통해 악용될 수 있는 취약한
가능성을 갖고 있기 때문에 일반적으로 이를 예방하는 것은 어렵다. 공식 URI
스펙은 "+" 문자를 인정하지 않지만 실제적으로 "+" 문자가 종종 공백 문자를
나타낸다.&#13;</P
></LI
><LI
><P
>&#13;단락 (Fragment): 단락은 기본적으로 문서 일부의 위치를 나타낸다; 저자는
구문이 합법적이기만 하다면 이에 기초한 공격에 대해서는 모르지만 구문의 적법성을
검사할 필요가 있다. 그렇지 않다면 공격자가 이중 인용부호와 같은 문자를
끼워넣을 수 있으며 보다 앞에서 URI 를 닫을 수 있다. (어떤 검사를
실패시킨다)&#13;</P
></LI
><LI
><P
>&#13;URL 이스케이프: URL 이스케이프는 임의의 8 비트 문자를 표현할 수 있기
때문에 유용하다; 이들은 같은 연유로 인해 매우 위험할 수 있다. 특히 URL
이스케이프는 제어 문자를 나타낼 수 있는데 서투르게 구축된 많은 웹서버가
이에 공격당하기 쉽다. 사실 URL 이스케이프가 가능 또는 불가능하거나 
많은 웹 애플리케이션은 (백슬래쉬, 앰퍼샌드 등) 의 어떤 문자에 공격당하기 
쉽지만 이를 일반화하는 것은 어렵다.&#13;</P
></LI
><LI
><P
>&#13;상대 URIs: 상대 URIs 는 어떤 애플리케이션에 있어서 이들을 허용할 많한
이유가 없음에도 불구하고 웹사이트를 잘 운영하고 있다면 꽤 안전하다.&#13;</P
></LI
></UL
><P
>&#13;물론 단순함과의 절충이 있다. 간단한 패턴이 이해하기 더욱 쉽지만 그다지 
세련되지는 않다 (따라서 세련된 패턴에 비해 너무 허가적이거나 너무
제한적일 수 있다). 복잡한 패턴은 더욱 엄격할 수 있지만 더욱 많은 에러를 
가질 것 같이 보이며 사용하기 위해 더 많은 성능을 필요로 하며 어떤 상황에
있어 구현하기 어렵다.&#13;</P
><P
>&#13;다음은 매우 간단하며 직접 손으로 또는 정규 표현식을 통해 구현될 수 있는
"간단하고 일반적으로 안전한 (simple mostly safe)" URI 패턴에 대한 저자의
제안이다; 다음 패턴을 허용해라:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>(http|ftp|https)://[-A-Za-z0-9._/]+</PRE
></TD
></TR
></TABLE
><P
>&#13;이 패턴은 질의, 단락, 포트 또는 상대 URIs 와 같이 많은 잠재적으로 위험한
능력을 허용하지 않으며 단지 약간의 스킴만을 허용한다. 이는 URL
이스케이프 및 서버가 다룰 수 없을 수도 있는 문자를 지정하기 위해 사용될 수
있는 "%" 문자의 사용을 금지한다. 이는 ":" 또는 URL 이스케이프를 허용하지
않기 때문에 포트 넘버 지정을 허용하지 않으며 이를 이용해서 더욱
위험한 URI 로 리디렉션시키는 것은 어려울 것이다 (이스케이프 문자가 없기
때문에). 또한 많은 다른 문자의 사용을 예방한다: 많은 서툴리 설계된 웹
애플리케이션은 많은 예기치 못한 문자를 다룰 수 없을 것이다.&#13;</P
><P
>&#13;그럼에도 불구하고 "일반적으로 안전한 (mostly safe)" URI 는 하부 디렉토리
("/" 를 통해) 와 상위 디렉토리로 올라가려는 시도 (".." 를 통해) 와 같은
많은 의심스러운 URIs 를 허용한다; 이러한 종류의 비합법적인 질의는 서버가
잡아야한다. 저자가 이러한 비합법적인 질의가 보안 약점인 경우를 모름에도
불구하고 이는 어떤 비합법적인 호스트 식별자 (예, "20.20") 를 허용한다.
어떤 웹 애플리케이션은 하부 디렉토리를 질의 데이타로 처리한다 (더
나쁘게는 명령 데이타로); 이는 모든 서투르게 설계된 웹 애플리케이션을
발견할 수는 때문에 일반적으로 예방하기 힘들다. 여러분이
모든 경로의 사용을 금지할 수도 있지만 이는 대부분의 인터넷 정보를 참조하는
것을 불가능하게 만들 것이다. 패턴은 지역적 서버 정보에 대한 참조 ("http:///",
"http://localhost/" 와 "http://127.0.0.1" 과 같은 패턴을 통해) 및 내부
네트워크상의 서버에 접근하는 것을 허용한다; <A
HREF="#AVOID-GET-NON-QUERIES"
>4.11&#51208;</A
> 에 권고된바와 같이 resulting HTTP Get
요청을 동작에 대한 요청이 아닌 정보에 대한 요청으로만 정확히 해석하는
서버에 의존해야 할 것이다. 이 패턴은 질의 폼을 허용하지 않기 때문에 많은
경우에 있어 이는 충분해야 한다.&#13;</P
><P
>&#13;
불행히도 "일반적으로 안전한" 패턴은 또한 많은 수의 규칙에 맞고 유용한
URIs 를 막는다. 예를 들어, 많은 웹사이트는 "?" 문자를 사용하여 특정
문서를 식별한다 (예, 뉴스 사이트상의 기사들). "#" 문자는 문서의 특정
절을 지정하는데 유용하며 상대 URIs 를 허용하는 것은 논의에서 다뤄질
것이다. 다양한 허용 문자와 URL 이스케이프는 "일반적으로 안전한" 패턴에
포함되어 있지 않다. 예를 들어 URL 이스케이프를 허용하지 않는다면 많은
비영어권 페이지를 접근하는 것은 어렵다. 정말로 그런 기능성을 필요로
한다면 사용자로 하여금 더욱 높은 위험에 노출되도록 하는 반면 더욱 많은
기능성을 주고 있음을 깨달으면서 덜 안전한 패턴을 사용할 수 있다.&#13;</P
><P
>&#13;질의를 허용하지만 적어도 사용되는 프로토콜과 포트를 제한하는 한 패턴은
다음과 같은데 필자는 이를 "간단하고 어느정도 안전한 패턴 (simple
somewhat safe pattern)" 이라고 부를 것이다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> (http|ftp|https)://[-A-Za-z0-9._]+(\/([A-Za-z0-9\-\_\.\!\~\*\'\(\)\%\?]+))*/?</PRE
></TD
></TR
></TABLE
><P
>&#13;이 패턴은 비합법적인 이스케이프, 다중 질의, ftp 에서의 질의 등을
허용하기 때문에 실제로 효과적이지는 않다. 이는 비교적 간단한 것을 이용한다.&#13;</P
><P
>&#13;실제로 URIs 를 합법적인 값으로 제한하는 "어느정도 안전한 (somewhat
safe)" 패턴을 생성하는 것은 꽤 어렵다. 다음은 저자가 "복잡하지만
어느정도 안전한 패턴 (sophisticated somewhat safe pattern)" 이라도
부르는 패턴으로 공백은 무시되며 주석은 "#" 으로 시작된다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> (
 (
  # Handle http, https, and relative URIs:
  ((https?://([A-Za-z0-9][A-Za-z0-9\-]*(\.[A-Za-z0-9][A-Za-z0-9\-]*)*\.?))|
    ([A-Za-z0-9\-\_\.\!\~\*\'\(\)]|(%[2-9A-Fa-f][0-9a-fA-F]))+)?
  ((/([A-Za-z0-9\-\_\.\!\~\*\'\(\)]|(%[2-9A-Fa-f][0-9a-fA-F]))+)*/?) # path
   (\?(                                                              # query:
       (([A-Za-z0-9\-\_\.\!\~\*\'\(\)\+]|(%[2-9A-Fa-f][0-9a-fA-F]))+=
        ([A-Za-z0-9\-\_\.\!\~\*\'\(\)\+]|(%[2-9A-Fa-f][0-9a-fA-F]))+
        (\&#38;([A-Za-z0-9\-\_\.\!\~\*\'\(\)\+]|(%[2-9A-Fa-f][0-9a-fA-F]))+=
         ([A-Za-z0-9\-\_\.\!\~\*\'\(\)\+]|(%[2-9A-Fa-f][0-9a-fA-F]))+)*)
       |
       (([A-Za-z0-9\-\_\.\!\~\*\'\(\)\+]|(%[2-9A-Fa-f][0-9a-fA-F]))+  # isindex
       )
   ))?
   (\#([A-Za-z0-9\-\_\.\!\~\*\'\(\)\+]|(%[2-9A-Fa-f][0-9a-fA-F]))+)? # fragment
  )|
 # Handle ftp:
 (ftp://([A-Za-z0-9][A-Za-z0-9\-]*(\.[A-Za-z0-9][A-Za-z0-9\-]*)*\.?)
  ((/([A-Za-z0-9\-\_\.\!\~\*\'\(\)]|(%[2-9A-Fa-f][0-9a-fA-F]))+)*/?) # path
  (\#([A-Za-z0-9\-\_\.\!\~\*\'\(\)\+]|(%[2-9A-Fa-f][0-9a-fA-F]))+)? # fragment
  )
 )</PRE
></TD
></TR
></TABLE
><P
>&#13;위와 같은 복잡한 패턴도 모든 비합법적인 URIs 를 금지하지는 않는다. 예를
들어 다시 "20.20" 은 합법적인 도메인 이름이 아니지만 패턴은 이를
허용한다; 그러나 저자가 아는한 이는 어떠한 보안 문제도 야기하지 않는다.
복잡한 패턴은 제어문자를 나타내는 URL 이스케이프를 금지한다 (예, $1F 를
통해 %00) - 허용된 가장 작은 이스케이프 값은 %20 (아스키 스페이스) 이다.
제어 문자를 금지함으로써 어떤 문제를 예방하지만 또한 제한적이다; 모든
제어 문자를 임의의 웹 애플리케이션으로 전송하는 것을 지원하려면 "2-9" 를
"0-9" 로 변경해라. 이 패턴은 경로에 모든 다른 URL 이스케이프 값을
허용하는데 국제화 문자에 유용하지만 이를 다룰 수 없는 약간의 시스템에서
문제를 야기할 수 있다. 패턴은 적어도 공백, 개행, 이중인용부호 및 다른
위험한 문자가 URI 에 사용됨을 금지하며 따라서 URI 를 생성 문서에 병합할
때 다른 종류의 공격을 예방한다. 많은 곳에서 패턴이 "+" 를 허용함을
주목해라. 실제적으로 "+" 는 종종 질의와 단락에서 공백 문자 대신
사용된다.&#13;</P
><P
>&#13;불행히 위에서 언급했듯이 질의 데이타를 허용하는 모든 기법을 통해 작동할
수 있는 공격이 있는데 질의가 허용되어 있다면 이에 대해 실제적으로 훌륭한
방어는 없을 것 같다. 그래서 위 패턴에서 질의 데이타의 사용을 제거할 수
있지만 "복잡하고 일반적으로 안전한 (sophisticated mostly safe)" 패턴을
산출하는 다른 폼을 허용해야 한다.&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> (
 (
  # Handle http, https, and relative URIs:
  ((https?://([A-Za-z0-9][A-Za-z0-9\-]*(\.[A-Za-z0-9][A-Za-z0-9\-]*)*\.?))|
    ([A-Za-z0-9\-\_\.\!\~\*\'\(\)]|(%[2-9A-Fa-f][0-9a-fA-F]))+)?
  ((/([A-Za-z0-9\-\_\.\!\~\*\'\(\)]|(%[2-9A-Fa-f][0-9a-fA-F]))+)*/?) # path
   (\#([A-Za-z0-9\-\_\.\!\~\*\'\(\)\+]|(%[2-9A-Fa-f][0-9a-fA-F]))+)? # fragment
  )|
 # Handle ftp:
 (ftp://([A-Za-z0-9][A-Za-z0-9\-]*(\.[A-Za-z0-9][A-Za-z0-9\-]*)*\.?)
  ((/([A-Za-z0-9\-\_\.\!\~\*\'\(\)]|(%[2-9A-Fa-f][0-9a-fA-F]))+)*/?) # path
  (\#([A-Za-z0-9\-\_\.\!\~\*\'\(\)\+]|(%[2-9A-Fa-f][0-9a-fA-F]))+)? # fragment
  )
 )</PRE
></TD
></TR
></TABLE
><P
>&#13;저자가 말할 수 있는 건 단지 이러한 패턴이 사용자에 의해 선택된
하이퍼텍스트 앵커 (&#60;a&#62; 태그) 를 검사하기 위해서만 사용된다면 이
접근 방법은 또한 웹 버그의 삽입을 예방한다. 웹 버그는 메인 페이지를
생성한 웹서버 이외의 누군가에게 누가 컨텐트를 읽었는지 및 언제
읽었는지와 같은 정보를 추적할 수 있도록 하는 단순한 텍스트이다 - 더욱
자세한 정보는 <A
HREF="#EMBEDDED-CONTENT-BUGS"
>7.6&#51208;</A
> 을 보라. 이는
동일한 검사 규칙을 갖고서 &#60;img&#62; (이미지) 태그를 사용한다면 그렇지 않다
 - 이미지 태그는 즉각적으로 로드되어 누군가에게 웹 버그를 추가할
수 있도록 한다. 다시 한번 말해서 이는 어떠한 속성도 허용하지 않았다고
추정한다; 많은 속성들은 꽤 위험하며 여러분이 제공하려고 하는 보안을
돌파할 수 있다&#13;</P
><P
>&#13;이러한 모든 패턴들은 전체 URI 가 패턴과 일치함을 요구함을 주목하기
바란다. 이러한 패턴들의 부적절함은 이들이 많은 유용한 패턴을 금지하는
방식으로 허용가능한 패턴을 제한한다는 것이다 (예, 이들은 새로운 URI
스킴의 사용을 방해한다). 또한 어떤 패턴도 어떤 웹사이트가 질의를 받았을
때 이 이상으로 수행하는 실제적인 문제를 예방할 수는 없다 - 그리고 이러한
웹사이트는 조직에 내부적이다. 그 결과로 GET 질의를 action 으로
받아들이는 웹사이트가 있어야만 URI 가 실제로 안전할 것이다 (<A
HREF="#AVOID-GET-NON-QUERIES"
>4.11&#51208;</A
>을 보라). 합법적인 URLs/URIs 에 대한
더욱 자세한 정보는 IEFT RFC 2396 을 보라; 도메인 네임 구문은 IEFT RFC
1034 에서 더욱 심도있게 논의되고 있다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="OTHER-HTML-TAGS"
>4.10.5. 다른 HTML 태그</A
></H3
><P
>&#13;아마도 더욱 많은 HTML 태그의 지원을 고려할 수도 있다. 명백한 다음 선택은
&#60;ol&#62; (ordered list), &#60;ul&#62; (unordered list) 및 &#60;li&#62;
(list item) 과 같은 리스트 지향 태그들이다. 그러나 어떤 시점 후에는
실제로 완전한 출판 관련 태그를 허용하고 있다 (이런 경우 제공자를
신뢰하거나 여기 논의될 것보다 더욱 엄격한 검사를 수행할 필요가 있다).
더욱더 중요하게 추가되는 모든 새로운 기능성은 에러에 대한 기회를
생성한다 (또한 악용될 수도 있다).&#13;</P
><P
>&#13;다른 예로는 동일한 URI 패턴을 갖고 &#60;img&#62; 태그를 허용할 수 있을
것이다. 이는 제삼자에게 문서를 누가 언제 읽었는지 식별할 수 있는 웹
버그를 문서에 끼워넣는 것을 허용하기 때문에 대체로 덜 안전하다고 알려져 있다.
웹 버그에 대해 더욱 자세한 정보는 <A
HREF="#EMBEDDED-CONTENT-BUGS"
>7.6&#51208;</A
>
을 보라.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="RELATED-ISSUES"
>4.10.6. 관련 쟁점</A
></H3
><P
>&#13;웹 애플리케이션은 명시적으로 문자셋 (보통 ISO-8859-1) 을 지정해야 하며
신뢰되지 않은 사용자로부터의 데이타가 사용된다면 다른 문자를 허용하지
않아야 한다. 더욱 자세한 정보를 얻기 위해서는 <A
HREF="#OUTPUT-CHARACTER-ENCODING"
>8.5&#51208;</A
> 을 보라.&#13;</P
><P
>&#13;이러한 종류의 입력을 필터링하는 것이 잘못되는 것은 쉽기 때문에 다른 
대안들도 또한 논의되어 왔다. 한가지 옵션은 사용자들에게 HTML 보다 더욱 
간단한 여러분이 설계한 다른 언어를 사용할 것인지 묻는 것이다 - 그 언어에는 
매우 제한된 기능성을 부여한다. 다른 접근 방법은 HTML 을 어떤 내부의 
"안전한" 포맷으로 분석한 후 그 안전한 포맷을 다시 HTML 으로 전환하는 것이다&#13;</P
><P
>&#13;입력, 출력 또는 둘 모두에 대해 필터링을 행할 수 있다. CERT 는 데이타가
동적 페이지의 일부분이 되기 전인 출력 동안에 데이타를 필터링하도록
권고한다. 이는 올바르게 행해진다면 이러한 접근 방법이 모든 동적 컨텐트가
필터링됨을 보장하기 때문이다. CERT 는 동적 컨텐트가 HTTP 이외의 다른
방법을 통해 웹사이트의 데이타베이스에 들어갈 수 있기때문에 입력 시의
필터링은 그다지 효과적이지 않으며 이런 경우에 있어 웹 서버는 입력
프로세스의 일부분으로의 데이타를 전혀 볼 수 없을 것이라고 믿고 있다.
동적 페이지가 들어가는 모든 곳에서 필터링이 구현되지 않는다면 데이타
요소는 손상된 채로 남아있을 수도 있다.&#13;</P
><P
>&#13;그러나 저자는 모든 경우에 대해 이점에 대해 CERT 에 동의하지 않는다.
문제는 입력만큼 모든 출력을 필터링하는 것을 잊는 것은 쉬우며
손상된 입력을 시스템으로 넣는 것을 허용하는 것은 어쨋든 일어나길
기다리는 재앙이라는 것이다. 보안적인 프로그램은 그 입력을 어쨋든
필터링해야하며 따라서 입력 필터링의 일부분으로 모든 이러한 검사를
포함하는 것이 때때로 더욱 좋다 (그래서 관리자는 규칙이 실제로 무엇임을
볼 수 있을 것이다). 마지막으로 어떤 보안적인 프로그램에서 값을 출력할 수
있는 많은 다른 프로그램 위치가 있지만 데이타가 입력으로 들어갈 수 있는
방식과 위치는 몇가지 만이 있다는 것이다.; 이러한 경우에 있어서 입력
필터링을 하는 것이 더욱 좋은 견해일 것이다.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AVOID-GET-NON-QUERIES"
>4.11. 비질의를 수행하는 HTTP GET 을 금지해라</A
></H2
><P
>&#13;HTTP 를 사용하는 웹 기반 애플리케이션은 질의외의 다른 것에 대해 HTTP
``GET" 또는 ``HEAD" 메쏘드를 사용하지 못하도록 한다. HTTP 는 여러가지 많은
메쏘드들을 포함하고 있는데 가장 널리 사용되고 있는 두가지 메쏘드는 GET 과
POST 이다. GET 과 POST 모두 폼으로 데이타를 전송하는데 사용할 수 있는데
GET 메쏘드는 URL 로 데이타를 전송하는 반면 POST 메쏘드는 데이타를 개별적으로
전송한다.&#13;</P
><P
>&#13;비질의 (데이타 변경, 돈 이체 또는 서비스 서명과 같은) 를 수행하기 위해
GET 메쏘드를 사용할 때의 보안 문제는 공격자가 악의있는 폼 데이타를
포함하는 URL 과 하이퍼텍스트 링크를 생성할 수 있다는 것이다. 공격자가
속는 사람이 링크 (하이퍼텍스트 링크의 경우) 를 클릭하거나 또는 그저
페이지 (HTML 의 img 태그를 갖는 이미지와 같은 다른 곳에 포함된
transcluded 정보의 경우) 를 보도록 납득시킨다면 속는 사람은 GET 을
수행할 것이다. GET 이 수행될 때 공격자가 생성한 모든 폼 데이타는 속는
사람에 의해 지정된 링크로 보내질 것이다. 이것이 <A
HREF="#CROSS-SITE-MALICIOUS-CONTENT"
>6.13&#51208;</A
> 에서 심도있게 논의될 cross-site
malicious attack 이다.&#13;</P
><P
>&#13;악의있는 cross-site 공격이 수행할 수 있는 단 하나의 동작은 사용자로
하여금 예상치 못한 데이타를 보도록 하는 것으로 이는 그다지 심각한 문제는
아니다. 그러나 이 능력을 이용해서 어떤 공격을 행할 수 있기 때문에
여전히 문제가 될 수 있다. 예를 들어 비합법적인 또는 연루시킬 수 있는
자료 (material) 을 요청하는 것으로부터 나올 수 있는 예기치 못했지만 실제
세계에 영향을 끼칠 수 있는 무엇인가를 요청하는 사용자때문에 또는
사용자로 하여금 보통은 노출될 수 없지만 공격자에게 노출될 지 모를 어떤
방식으로 정보를 요청하게끔 함으로써 프라이버시가 손실될 가능성이 있다.
그러나 악의적인 공격자가 데이타 보기만이 아니라 cross-site 링크를 통해
데이타 변경을 야기할 수 있다면 더욱 더 심각한 효과를 야기할 수 있다.&#13;</P
><P
>&#13;
대부분의 CGI 라이브러리와 같은 전형적인 HTTP 인터페이스는 데이타를
얻는데 있어 GET 과 POST 를 동일한 방식을 갖는 메쏘드로 다루는 것이
도움이 되기 때문에 보통 이 둘의 차이를 감춘다. 그러나 실제로 데이타
질의이외의 무엇인가를 야기하는 동작에 대해서는 요청이 POST 이외의 어떤
것인지를 알기 위해 검사해라; 만약 그렇다면 주어진 데이타로 채워진 폼을
보여서 사용자들에게 그들이 요청한 것인지를 확인하도록 물어라. 이는
cross-site malicious content 공격을 예방할 것이며 동시에 한 번의
클릭으로 동작을 확인케 하는 편의성을 사용자에게 제공하는 것이다.&#13;</P
><P
>&#13;정말 이 동작은 HTTP 스펙에 의해 강력히 추천되고 있다. HTTP 1.1 스펙
(IEFT RFC 2616 9.1.1. 절) 에 따르면 GET 과 POST 메쏘드는 검색이외의 다른
동작을 취하는 의미를 가져서는 안된다. 이러한 메쏘드들은 안전하다고
고려되어야 한다. 이는 사용자 에이전트로 하여금 특별한 방식으로 POST, PUT
과 DELETE 와 같은 다른 메쏘드를 나타낼 수 있게 하며 따라서 사용자는 아마도
안전하지 못한 동작이 요청되고 있다는 사실을 알게 된다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIMIT-TIME"
>4.12. 합당한 입력 시간 및 로드 레벨을 제한해라</A
></H2
><P
>&#13;특히 들어오는 네트워크 데이타에 타임아웃과 로드 레벨 한도를 설정해
놓아라. 그렇지 않다면 공격자가 끊임없이 서비스를 요청함으로써 서비스
부인 공격을 쉽게 할 수 있을 것이다.&#13;</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="BUFFER-OVERFLOW"
>5&#51109;. 버퍼오버플로우 피하기 </A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>An enemy will overrun the land;
he will pull down your strongholds and
plunder your fortresses.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Amos 3:11 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><P
>&#13;극히 공통적인 보안 결함은 "버퍼 오버플로우" 에 대한 취약성이다. 버퍼
오버플로우는 "버퍼 오버런" 이라고도 하는데 "stack smashing" 과 "heap
smashing" 공격을 포함하여 많은 종류의 버퍼 오버플로우 공격이 있다.
기술적으로 버퍼 오버플로우는 프로그램의 내부적인 구현과 관련된
문제이지만 저자가 이를 독자적인 장에서 다룰만큼 널리 알려진 심각한
문제이다. 이 주제가 얼마나 중요한 지에 대해 이해시키기 위해 CERT 에서는
1998 년에는 13 개 권고안 중 9개 및 1999 년에는 적어도 절반의 권고안에
버퍼 오버플로우를 포함했다. 버그트랙에 대한 1999 년의 비공식적 조사는
대략 응답자의 2/3 가 버퍼 오버플로우가 시스템 보안을 취약하게 하는 주된
요인이였다고 느꼈음을 발견했다 (나머지 응답자는 오설정을 주된 요인으로
식별하였다) [Cowan 1999]. 이는 잘 알려진 오래된 문제로 아직껏 계속해서
문제로 대두되고 있다 [McGraw 2000].&#13;</P
><P
>&#13;버퍼 오버플로우는 보통 문자들의 문자열인 일련의 값들을 고정된 길이를
갖는 버퍼에 작성하고 적어도 한 값을 버퍼의 경계 외부 (보통 버퍼 경계를
넘어선다) 에 작성할 때 일어난다. 버퍼 오버플로우는 사용자로부터의 입력을 
버퍼내로 읽어들일 때 일어날 수 있지만 또한 프로그램내에서 다른 종류의 프로세싱
동안에 일어날 수도 있다.&#13;</P
><P
>&#13;보안적인 프로그램이 버퍼 오버플로우를 허용한다면 이는 대개 공격자에 의해
악용될 수 있다. 버퍼가 지역적인 C 변수라면 오버플로우는 함수로 하여금
공격자가 선택한 코드를 실행시키도록 하는데 사용될 수 있다. 이러한 특정
변형을 대개 "stack smashing" 공격이라고 한다. 힙에서 버퍼는 더욱 좋지 않은데
공격자가 프로그램내의 다른 변수를 제어하기 위해 오버플로우 등을 사용할
수 있을 지도 모른다. 더욱 세부적인 사항은 Aleph1 [1996], Mudge[1995]
또는 Nathan P. Smith 의 "Stack Smashing Security Vulnerabilities"
웹사이트 <A
HREF="http://destroy.net/machines/security/"
TARGET="_top"
>http://destroy.net/machines/security/</A
>
에서 찾을 수 있다.&#13;</P
><P
>&#13;대부분의 상위 수준 프로그래밍 언어는 자동적으로 배열의 크기를 조정하거나
(예, 펄) 또는 보통 버퍼 오버플로우를 탐지해서 예방하기 때문에 (예,
Ada95) 본질적으로 이 문제는 없다.그러나 C 언어는 이 문제에 대해 어떠한
보호도 제공하지 않으며 C++ 도 또한 이 문제를 야기할 수 있는 방식으로
쉽게 사용될 수 있다. 어셈블러도 또한 어떠한 보호도 제공하지 않는데 보통 이러한
보호를 제공하는 어떤 언어 (예, Ada 와 파스칼) 들은 이 보호 기능을
성능적인 측면에서 금지할 수 있다. 대부분의 프로그램이 다른 언어로
작성된다 하더라도 많은 라이브러리 루틴은 C 또는 C++ 로 작성되어 있으며 
결과적으로 이 루틴을 호출하는 glue 코드도 마찬가지인데 따라서 원하는 만큼 
다른 언어들은 버퍼 오버플로우에 대한 완전한 보호를 제공하지는 않는다.&#13;</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DANGERS-C"
>5.1. C/C++ 에서의 위험</A
></H2
><P
>&#13;C 사용자는 경계 (bound) 를 검사하지 않는 위험한 함수가 경계가 절대로
초과되지 않을 것이다라는 보장을 하지 않는다면 이를 사용하는 것을 피해야
한다. 대부분의 경우에 있어 피해야 될 (또는 보호를 보장해야할) 함수는
strcpy(3), strcat(3), sprintf(3) (이와 유사한 vsprintf(3)) 과 gets(3)
인데 이들은 각각 strncpy(3), strncat(3), snprintf(3) 과 fgets(3) 으로
대체되어야한다. 밑부분의 논의를 보라. strlen(3) 함수도 있어야 될 종결 
NIL 문자가 있을 것이다라고 보장하지 못한다면 피해야 한다. scanf(3),
fscanf(3), sscant(3), vscanf(3), vsscanf(3) 과 vfscant(3) 과 같은
scanf() 계열도 사용하기에는 위험하다; 문자열의 최대 길이를 제어함이 없이
데이타를 문자열로 보내기 위해 이 함수들을 사용하지 마라 (%s 포맷이 특히
널리 알려진 문제이다). 어디에 사용하느냐에 따라 버퍼 오버런을 허용할 수
있는 다른 위험한 함수로는 realpath(3), getopt(3), getpass(3),
streadd(3), strecpy(3) 과 strtrns(3) 들이 있다. getwd(3) 함수에
주의해야하는데 getwd(3) 함수에 보내지는 버퍼는 적어도 PATH_MAX
바이트 길이여야 한다.&#13;</P
><P
>&#13;불행히 snprintf() 변형들은 추가적인 문제를 갖고 있다. sprintf() 가 ISO
1990 (ANSI 1989) 표준내의 표준 C 함수이지만 공식적으로 snprintf() 는
표준 C 함수가 아니며 따라서 모든 시스템들이 snprintf() 를 포함하지
않는다. 더욱 안좋은 것은 어떤 시스템의 snprintf() 가 실제적으로 버퍼
오버플로우에 대한 보호를 제공하지 않는다는 것이다; 시스템들이 그저
sprintf 를 직접적으로 호출한다. 리눅스 libc4 의 예전 버전들은 이러한
끔직한 문제를 야기하는 "libbsd" 에 의존했으며 저자는 예전의 어떤 HP
시스템들도 동일한 문제가 있음을 들었다. snprintf 의 리눅스 현재 버전은
적절히 작동한다고 알려져 있다. 즉, 이는 실제적으로 요청된 경계를
침해하지 않는다. snprintf() 의 반환값도 마찬가지로 갖가지이다; Single
Unix Specification (SUS) 버전 2 와 C99 표준은 snprintf() 가 반환하는
값에 차이가 있다. 마지막으로 적어도 snprintf 의 어떤 버전은 문자열이 NIL
로 끝날 것임을 보장하지 않는 것처럼 보인다; 문자열이 너무 길면 NIL 을
전혀 포함하지 않는다. GTK 의 기본으로 GNU C 라이브러리인 glibc 와는 다른
glib 라이브러리는 g_snprintf() 를 갖고 있음을 주목해라. 이는
일관성있는 반환 의미 체계를 갖으며 늘 NIL 로 끝나고 가장 중요한 것은 늘
버퍼 길이를 침범하지 않는다는 것이다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBRARY-C"
>5.2. C/C++ 에서의 라이브러리 솔루션</A
></H2
><P
>&#13;C/C++ 에서 한가지 해결방법은 버퍼 오버플로우 문제를 갖지 않는 라이브러리
함수를 사용하는 것이다. 첫 하부 절은 작동될 수 있지만 단점을 갖는 표준 C
라이브러리 솔루션을 기술하며 다음 절은 버퍼에 대한 고정된 길이 및 동적으로
재할당된 접근 방법에 대한 일반적인 보안 쟁점을 기술한다. 다음 하부 절은
strlcpy 와 libmib 와 같은 다양한 대체 라이브러리를 기술한다.&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BUFFER-STANDARD-SOLUTION"
>5.2.1. 표준 C 라이브러리 솔루션</A
></H3
><P
>&#13;C 에서 버퍼 오버플로우를 예방하는 표준적인 해결방법 (몇몇 C++ 프로그램에서도 
사용된다) 은 이러한 문제에 대해
보호하는 표준 C 라이브러리 호출을 사용하는 것이다. 이러한 접근 방법은
표준 라이브러리 함수인 strncpy(3) 과 strncat(3) 에 매우 의존한다. 이
접근 방법을 선택한다면 다음에 주의해라: 이 호출은 약간은 놀랄만한 의미를
갖으며 적절히 사용하기가 어렵다. strncpy(3) 함수는 소스 문자열 길이가
적어도 수신지 문자열 길이와 같다면 수신지 문자열을 NIL 로 끝내지 않는데
따라서 strncpy(3) 을 호출한 후 수신지 문자열의 마지막 문자를 확실히 NIL 로
설정해라. 동일한 버퍼를 여러번 재사용하려고 하다면 효과적인 접근 방법은
버퍼가 실제보다 한 문자 짧으며 사용하기 전에 마지막 문자를 NIL 로
설정한다고 strncpy() 에 알려주는 것이다. strncpy(3) 과 strncat(3) 둘
모두는 사용할 수 있게 남아있는 공백을 건네줄 것을 요구하는데 이는 
틀리기 쉬운 계산으로 이를 틀린다면 버퍼 오버플로우 공격을 허용할 것이다. 
오버플로우가 일어났는 지를 결정하기 위한 단순한 메카니즘을 절대로
제공하지 마라. 마지막으로 strncpy(3) 은 <B
CLASS="EMPHASIS"
>strncpy(3)
이 수신지의 나머지를 NIL 로 채우기때문에</B
> 아마 대체되는
strcpy(3) 에 비해 성능면에서 상당한 불이익을 갖고 있다. 저자는 이러한
마지막 사항에 대해 놀라움을 표현한 이메일을 받았는데 이는 Kernighan 과
Ritchie 두번째판 [Kernighan 1988, page 249] 에 명확히 설명되어 있으며 이
동작은 리눅스, FreeBSD 및 솔라리스 맨페이지에 명백히 문서화되어 있다.
이는 단지 strcpy 대신 strncpy 를 쓰는 것은 대부분의 경우에 있어 어떠한
적당한 이유없이 성능면에서 가차없는 저하를 야기할 수 있음을 의미한다.&#13;</P
><P
>&#13;버퍼 오버플로우를 예방하는 동시에 sprintf() 를 사용할 수 있지만 이때
주의를 기울일 필요가 있다; 추천하기 어려울만큼 이를 잘못 적용하는 것이
쉽다. sprintf 제어 문자열은 다양한 변환 지정자 (예, "%s") 를 포함할 수
있으며 제어 지정자는 선택적인 필드 너비 (예, "%10s") 와 정확도 ("%.10s")
지정을 가질 수 있다. 이는 꽤 유사하게 보이지만 (단지 차이는 마침표이다)
이들은 매우 다르다. 필드 너비는 단지 <B
CLASS="EMPHASIS"
>최소</B
> 길이를
지정하며 버퍼 오버플로우를 예방하는데 있어 완전히 쓸모없다. 반대로
정확도 지정은 그 특정 문자열이 문자열 변환 지정자로 사용될 때 출력에서
가질 수 있는 최대 길이를 지정한다 - 따라서 버퍼 오버플로우에 대해
보호하기 위해 사용될 수 있다. 정확도 지정은 문자열을 다룰 때 단지 총
최대 길이를 지정함을 주목해라; 다른 변환 연산과는 다른 의미를 갖는다.
크기가 "*" 로 주어지면 최대 크기를 변수로서 넘겨줄 수 있다 (예, sizeof()
연산의 결과). 이는 예로서 가장 쉽게 보여진다 - 다음 버퍼 오버플로우에
대해 보호하는 틀린 그리고 옳은 방식이다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> char buf[BUFFER_SIZE];
 sprintf(buf, "%*s",  sizeof(buf)-1, "long-string");  /* WRONG */
 sprintf(buf, "%.*s", sizeof(buf)-1, "long-string");  /* RIGHT */</PRE
></TD
></TR
></TABLE
><P
>&#13;이론상 sprintf() 는 복잡한 포맷을 지정하는데 사용할 수 있기 때문에 매우
도움이 되는 반면 슬프게도 sprintf() 를 틀리게 사용하는 것은 쉽다. 포맷이
복잡하다면 수신지가 <B
CLASS="EMPHASIS"
>전체</B
> 포맷의 가능한 최대 크기에
대해 충분히 크며 정확도 필드는 단지 한 변수의크기만 제어하는지를 확인할 
필요가 있다. "가능한 가장 큰 (largest
possible)" 값은 복잡한 출력이 생성되고 있을 때 결정하기 어렵다.
프로그램이 가능한 가장 긴 조합에 대해 충분한 공간을 할당하지 않는다면
버퍼 오버플로우 공격을 받기 쉬울 것이다. 또한 sprintf() 는 전체 연산이
끝난 후 수신지에 NUL 을 추가한다 - 이 여분의 문자는 잊기 쉬우며 이 문자 하나가 
없음으로써 에러가 생길 수 있는 기회를 생성한다. 그래서 이것이 작동하더라도 
어떤 상황에서 사용하는 것은 무척 곤란할 수 있다.&#13;</P
><P
>&#13;또한 위 코드에 대한 언급 - sizeof() 연산이 배열의 크기를 사용했음을
주목해라. 코드가 변경되어 "buf" 가 어떤 할당 메모리에 대한 포인터라면
모든 "sizeof()" 연산은 변경되어야 할 것이다 (또는 sizeof 는 단지
포인터의 크기를 측정할 것이며 이는 대부분의 값에 대해 충분한 공간이
아니다).&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="STATIC-VS-DYNAMIC-BUFFERS"
>5.2.2. 정적 및 동적 할당 버퍼</A
></H3
><P
>&#13;strncpy 와 같은 함수들은 정적으로 할당된 버퍼를 다둘 때 유용한데 이는
버퍼가 "가장 긴 유용한 크기 (longest useful size)" 에 대해 할당되어
그때부터 고정된 크기로 머물러 있는 프로그래밍 접근 방법이다. 대안은
버퍼를 필요로 할때마다 그 크기를 동적으로 재할당하는 것이다. 두 접근
방법 모두 보안에 밀접하게 관련되어 있다.&#13;</P
><P
>&#13;고정된 길이의 버퍼를 사용할 때 일반적인 보안 문제가 있는데 버퍼가 고정된
길이를 갖는 다는 사실이 악용될 수 있다. 이는 strncpy(3) 및 strncat(3),
snprintf(3), strlcpy(3), strlcat(3) 과 다른 그러한 함수들과 관련된
문제이다. 기본 개념은 공격자가 실제 긴 문자열을 설정해서 문자열의 끝이
잘릴 때 마지막 결과가 공격자가 원했던 것 (개발자가 의도했던 것 대신에)
일 것이다라는 것이다. 아마도 문자열은 여러 작은 조각으로부터 연결된다;
공격자가 전체 버퍼와 길이가 같은 첫 조각을 만들 수도 있으며 따라서 추후 
모든 문자열을 연결하려는 시도는 무용지물이 된다. 다음 약간의 특정 예이다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;gethostbyname(3) 을 호출하는 코드를 상상하라. 만약 성공한다면 strncpy
또는 snprintf 를 사용하여 즉각적으로 hostent-&#62;h_name 을
고정된 길이의 버퍼로 복사해라. strncpy 또는 snprintf 를 사용한다면 매우
긴 FQDN (fully qualified domain name) 의 오버플로우에 대해 보호를 할 수
있으며 따라서 모든 것이 끝났다고 생각할 수 있다. 그러나 FQDN 의 마지막은
잘려질 것이다. 이는 다음에 무엇이 발생할지에 따라 매우 바람직하지 않을
수 있다.&#13;</P
></LI
><LI
><P
>&#13;파일시스템 객체의 절대 경로를 어떤 버퍼에 복사하기 위해 strncpy,
strncat, snprintf 등을 사용하는 코드를 상상해라. 더구나 원래 값은 신뢰되지 않은 
사용자에 의해 제공되었으며 복사 과정이 그 다음 계산을 함수에 전달하는
프로세스의 일부분이라고 상상해보라. 안전하게 보이는가 그런가? 지금
공격자가 처음 경로에 많은 수의 "/" 를 채워넣었다고 상상해보라.
프로그램이 결과가 안전한 것일라는 믿음으로 값을 추가한다면 프로그램은
악용될 수도 있다. 또는 공격자가 버퍼 길이에 가까운 긴 파일 이름을 고안할
수 있으며 따라서 파일 이름에 추가하려는 시도는 소리없이 실패할 것이다
(또는 악용될 수 있게끔 단지 부분적으로 일어날 것이다).&#13;</P
></LI
></UL
><P
>&#13;정적으로 할당된 버퍼를 사용할 때 소스 및 수신지 인수의 길이를 실제로
고려할 필요가 있다. 입력과 결과되는 중간 계산의 정상성 (sanity) 을
검사함으로써 또한 이를 다룰 수 있다.&#13;</P
><P
>&#13;다른 대안은 고정된 크기의 버퍼를 사용하는 대신 모든 문자열을 동적으로
재할당하는 것이다. 이러한 일반적인 접근 방법은 프로그램이 임의 크기의
입력을 다룰 수 있기 때문에 (메모리를 다 소비할 때까지) GNU 프로그래밍
지침에 의해 추천되고 있다. 물론 동적으로 할당된 문자열과 관련된 주요
문제는 메모리가 부족할 수도 있다는 것이다. 메모리는 버퍼 오버플로우에 대해
걱정했던 부분이라기 보다는 프로그램내의 어떤 다른 곳에서 소비될 수도
있다; 모든 메무리 할당이 실패할 것이다. 또한 동적 재할당은 메모리가
비효율적으로 할당되게 하기 때문에 기술적으로 프로그램이 쓸 수 있는
충분한 가상 메모리가 있다고 하더라도 메모리가 부족하게 되는 것은
전적으로 가능하다. 이외에도 메모리가 부족하기 전에 프로그램이 아마도
많은 가상 메모리를 사용할 것이다; 이는 "thrashing" 즉 컴퓨터가 모든
시간을 디스크와 메모리사이를 왕복하는데 (유용한 작업을 하는 대신)
소비하는 상황으로 끝날 것이다. 이는 서비스 부인 공격과 같은 효과를 가질
것이다. 입력 크기에 대한 어떤 합리적인 제한이 도움이 될 것이다.
일반적으로 프로그램은 동적으로 할당된 문자열을 사용하는 경우 메무리가
고갈될 때 안전하게 실패하도록 설계되어야 한다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="STRLCPY"
>5.2.3. strlcpy and strlcat</A
></H3
><P
>&#13;OpenBSD 에 의해 사용된 대안은 Miller 와 de Raadt [Miller 1999] 에 의한
strlcpy(3) 과 strlcat(3) 이다. 이는 C 문자열 복사 및 연결에 다른 (에러가
덜 생기는) 인터페이스를 제공하는 최소한의 정적 크기를 갖는 버퍼 접근
방법이다. 이 함수의 소스와 문서는 <A
HREF="ftp://ftp.openbsd.org/pub/OpenBSD/src/lib/libc/string/strlcpy.3"
TARGET="_top"
>ftp://ftp.openbsd.org/pub/OpenBSD/src/lib/libc/string/strlcpy.3</A
>
에서 새로운 BSD 스타일 오픈 소스 라이센스하에서 얻을 수 있다.&#13;</P
><P
>&#13;우선 다음은 원형 (prototype) 이다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>size_t strlcpy (char *dst, const char *src, size_t size);
size_t strlcat (char *dst, const char *src, size_t size);</PRE
></TD
></TR
></TABLE
><P
>&#13;두 함수 모두 인수로서 (복사되는 문자의 최대 수가 아닌) 수신지 버퍼의
절대 크키를 취하며 마지막을 종결 문자 NIL 로 채우는 것을 보장한다 (크기가
0보다 크다면). size 에 NIL 을 위한 바이트를 포함해야 함을 기억해라.&#13;</P
><P
>&#13;strlcpy 함수는 NUL 로 끝나는 문자열 소스를 NIL 로 끝나는 결과인 dst
(destination) 로 size-1 문자까지 복사한다. strlcat 함수는 dst 끝에 NIL
로 끝나는 문자열 소스를 추가한다. 이는 기껏해야 size-strlen(dst)-1 바이트를
NIL 로 끝나는 결과에 추가할 것이다.&#13;</P
><P
>&#13;strlcpy(3) 과 strlcat(3) 의 한가지 중요하지 않은 단점은 대부분의 유닉스
계열 시스템에 디폴트로 설치되어 있지 않다는 것이다. OpenBSD 에는
&#60;string.h&#62; 내에 존재한다. 이는 그렇게 어려운 문제는 아니며 이들은
작은 함수이기 때문에 각자 프로그램 소스에 이들을 포함할 수 있으며 이들을
적재할 수 있는 별도의 작은 패키지를 만들 수도 있다. 이를 자동적으로
다루기 위해 autoconf 를 사용할 수도 있다. 더욱 많은 프로그램이 이들
함수를 사용한다면 오래지 않아 이들은 리눅스 배포판 및 다른 유닉스 시스템
계열의 표준 부분이 될 것이다. 또한 이 함수들은 glib 라이브러리에 최근에
추가되었으며 (필자는 이를 위해 패치를 제출하였다) 따라서 glib 를
사용함으로써 이들을 이용할 수 있을 것이다 (미래에). glib 에서는 glib
라이브러리 네이밍 관례에 일치하는 g_strlcpy 와 g_strlcat
로 이름지어졌다.&#13;</P
><P
>&#13;또한 strlcat(3) 은 제공된 크기가 0 이거나 또는 수신지 문자열 dst (주어진 문자내에서) 
내에 NIL 문자가 없다면 약간 다른 의미를 갖는다. OpenBSD 에서는 크기가 0 이면 
수신지 문자열의 길이는 0 으로 간주된다. 
크기가 0 이 아니지만 수신지 문자열 (문자의 크기 수내에서) 내에 NIL 문자가 없다면 
수신지의 길이가 크기와 같다고 간주한다. 이러한 규칙들은 내장 NIL 문자가 없는 
문자열을 일관성있게 다룬다. 불행히 적어도 솔라리스는 원래 문서에 이러한 규칙들으 
들을 구체적으로 명시하지 않았기 때문에 이들을 따르지 않는다. 저자는 Todd Miller 에게 
말했으며 둘 모두 OpenBSD 의미 체계가 옳다는 것에 동의하였다 (솔라리스는 옳지 않다). 
증명은 간단하다: 어떠한 조건하에서도 strlcat 또는 strlcpy 가 크기 범위밖에서 
수신지 내의 문자들을 조사하지 않아야 한다; 이러한 접근은 범위가 초과된 
메모리를 접근함으로써 코어 덤프를 야기할 수도 있으며 더 나아가서는 기억 
장치 대응 입출력 (memory-mapped I/O) 를 통해 하드웨어 상호작용을 야기할 수도 있다. 
따라서, 다음과 같은 경우:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  a = strlcat ("Y", "123", 0);</PRE
></TD
></TR
></TABLE
><P
>&#13;정확한 답은 3 (0+3=3) 이지만 솔라리스는 수신지내의 "크기" 길이를 넘어서는 
문자를 부정확하게 보기때문에 답이 4 라고 주장할 것이다. 우선 저자는 크기가 
0 이거나 수신지가 NIL 문자를 갖지 않는 경우를 피하라고 제안한다. 
glib 의 향후 버전에서는 이 차이가 없을 것이며 늘 OpenBSD 의 의미 체계를 
사용할 것이다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LIBMIB"
>5.2.4. libmib</A
></H3
><P
>&#13;자동적으로 문자열을 동적으로 재할당하는 C 의 한가지 툴셋은 ``libmib 할당
문자열 함수" 이다. 이는 Forrest J. Cavalier III 에 의한 것으로 <A
HREF="http://www.mibsoftware.com/libmib/astring"
TARGET="_top"
>http://www.mibsoftware.com/libmib/astring</A
> 에서 얻을 수 있다.
libmib 에는 두가지 변형이 있는데 ``libmib-open" 은 수정과 재배포를
허용하는 X11과 유사한 라이센스하의 오픈 소스처럼 보이지만 재배포시 다른
이름을 선택해야 한다. 그러나 개발자는 이것이 ``완벽히 검사되지 않았을
지도 모른다" 라고 말하고 있다. 계속해서 발전된 libmib 를 얻기 위해서는 
가입을 위해 돈을 지불해야 한다. 문서는 오픈소스가 아니지만 자유로이 사용할 수
있다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="STD-STRING"
>5.2.5. C++ std::string class</A
></H3
><P
>&#13;C++ 개발자는 내장되어 있는 std::string 클래스를 사용할 수 있다. 이는 
스토리지가 필요한만큼 커지는 동적인 접근 방법이다. 그러나 이 클래스의 
데이타가 버퍼 오버플로우 문제가 발생할 수 있는 ``char *" 로 소리없이 
변환될 수 있음을 언급하는 것은 중요하다. 따라서 이 클래스로부터 변환할 때 
주의할 필요가 있다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LIBSAFE"
>5.2.6. Libsafe</A
></H3
><P
>&#13;루슨트 테크놀로지사의 Arash Baratloo, Timothy Tsai 와 Navjot Singh 는
stack smashing 공격에 취약하다고 알려진 몇가지 라이브러리 함수의
wrapper 인 Libsafe 를 개발했다. 이 wrapper (이들은 미들웨어라고 부른다)
는 strcpy(3) 과 같은 C 라이브러리 함수의 수정 버전을 포함한 간단한 동적
적재 라이브러리로 이 수정 버전은 원래 기능성을 구현하지만 모든 버퍼
오버플로우가 현재 스택 프레임내에 포함되어 있음을 보장하는 방식으로
구현되어 있다. 초기 성능 분석은 이 라이브러리의 오버헤드가 매우 작다고
제안한다. Libsafe 논문과 소스 코드는 <A
HREF="http://www.bell-labs.com/org/11356/libsafe.html"
TARGET="_top"
>http://www.bell-labs.com/org/11356/libsafe.html</A
>
에서 얻을 수 있다. Libsafe 소스코드는 완전한 오프 소스 LGPL 라이센스하에
얻을 수 있으며 많은 리눅스 배포업체들이 이를 사용하려고 하고 있다.&#13;</P
><P
>&#13;Libsafe 의 접근 방법은 어느 정도 유용한 것처럼 보인다. Libsafe 는 리눅스
배포업자에 의한 포함이 확실히 고려되고 있으며 또한 다른 점에 의해서도
고려할 가치가 있다. 예를 들어 저자는 맨드레이크 7.1 버전이 이를 포함함을
알고 있다. 그러나 소프트웨어 개발자로서 Libsafe 는 철저한 방어
(defense-in-depth) 를 지원하는 유용한 메카니즘이만 실제로 버퍼
오버플로우를 예방하지는 못한다. 코드 개발동안에 Libsafe 에만 의존하지
않아야 할 몇가지 이유가 다음에 설명된다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;Libsafe 는 단지 명백한 버퍼 오버플로우 문제를 갖는 적은 수의 알려진
함수만을 보호한다. 이 문서 작성시점에서 이 목록은 이 문제가 있다고
알려진 이 책에 있는 함수 목록보다 상당히 적다. 또한 버퍼 오버플로우를
야기하는 각자가 작성한 코드에 대해 보호를 하지 못할 것이다 (예, while
루프).&#13;</P
></LI
><LI
><P
>&#13;libsafe 가 배포판에 설치되어 있더라도 설치된 방식이 사용에 영향을
미친다. 문서는 libsafe 의 보호 기능을 동작하도록 LD_PRELOAD 를
설정할 것을 추천하지만 문제는 사용자가 이 환경 변수의 설정을 해제할 수
있다는 것이다. 따라서 보호 기능이 금지되는 것이다.&#13;</P
></LI
><LI
><P
>&#13;Libsafe 는 반환 주소로의 스택의 오버플로우에 대해서만 보호를 한다;
아직도 프로시져 프레임에서 힙 또는 다른 변수들을 오버런시킬 수 있다.&#13;</P
></LI
><LI
><P
>&#13;모든 사용되고 있는 플랫폼이 libsafe (또는 이와 유사한) 를 사용할 것이라고
보장하지 못한다면 libsafe 가 없을 때처럼 프로그램을 보호해야 할
것이다.

 </P
></LI
><LI
><P
>&#13;Libsafe 는 유보된 (saved) 프레임 포인터가 각 스택 프레임의 처음에 있다고
가정한 듯하다. 이것이 늘 옳은 것은 아니다. gcc 와 같은 컴파일러는
최적화를 할 것이며 특히 -fomit-frame-pointer 옵션은 libsafe 가 필요할 것
같은 정보를 제거한다. 따라서 libsafe 가 어떤 프로그램에 대해서는
작동하지 않을 수도 있다.&#13;</P
></LI
></UL
><P
>&#13;Libsafe 개발자 자신은 소프트웨어 개발자가 libsafe 만 의존해서는
안된다라고 인정하고 있다. 다음은 이들의 말이다:&#13;</P
><A
NAME="AEN957"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;버퍼 오버플로우 공격에 대한 최상의 해결책은 결함있는 프로그램을 수정하는
것이라고 일반적으로 받아들여지고 있다. 그러나 결함있는 프로그램을
수정하는 것은 특별한 프로그램이 결함이 있다는 것을 알아야만 한다.
libsafe 및 다른 대안 보안 조치를 사용함으로써 얻게 되는 이익은 아직까지
취약하다고 알려지지 않은 프로그램에 대한 미래의 공격에 대한 보호이다.&#13;</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="OTHER-BUFFER-LIBRARIES"
>5.2.7. 다른 라이브러리</A
></H3
><P
>&#13;glibc 가 아닌 glib 라이브러리는 C 프로그래머에게 많은 유용한 함수를
제공하고 있는 널리 사용될 수 있는 오픈 소스 라이브러리이다. GTK+ 과
GNOME 모두 glib 를 사용한다. 앞에서 언급한 바와 같이 glib 버전 1.3.2 에
저자가 제출한 패치를 통해 g_strlcpy() 와 g_strlcat() 가
추가되었다. 이는 glib 의 나중 버전이 사용될 수 있기만 하다면 이러한
함수를 이식성있게 사용하는 것을 더욱 쉽게 한다. 현재 시점에서 저자는
glib 라이브러리 함수가 버퍼 오버플로우에 대해 보호함을 명백히 보이는
분석을 하지 않았다. 그러나 많은 glib 함수는 자동적으로 메모리를 할당하며
자동적으로 <B
CLASS="EMPHASIS"
> 실패를 가로챌 어떠한 합당한 방식이 없이
실패</B
>한다 (예, 대신 다른 어떤 것을 하려고 함이 없이). 그
결과로 많은 경우에 있어 대부분의 glib 함수는 대부분의 보안적인
프로그램에 사용될 수 없다. GNOME 지침은 g_strdup_printf()
와 같은 함수 사용을 추천하는데 이는 메모리 고갈이 발생할 때 프로그램이
즉각적으로 크래쉬해도 무방하다면 좋다. 그러나 이를 받아들일 수 없다면
이런 루틴을 사용하는 것은 적절하지 못하다.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="COMPILATION-C"
>5.3. C/C++ 에서의 컴파일 솔루션</A
></H2
><P
>&#13;완전히 다른 접근 방법은 경계 검사를 하는 컴파일 방법을 사용하는 것이다
([Sitaker 1999] 를 참조해라). 저자 의견으로는 이러한 도구는 다수의 보호
계층를 갖는 경우 매우 유용하지만 유일한 보호책으로 이 기법을 사용하는
것은 현명하지 않다. 이에 대해서는 적어도 두가지 이유가 있다. 우선 대부분의
이러한 도구들은 버퍼 오버플로우에 대한 부분적인 보호만을 제공한다
(완전한 보호는 일반적으로 12-30 배 정도 느리다); C 와 C++ 은 단순히 
버퍼 오버플로우에 대해 보호하도록 설계되지 않았다. 두번째 오픈 소스
프로그램에 대해 프로그램을 컴파일하기 위해 어떤 도구가 사용될 것이라는
것을 확신할 수 없다; 주어진 시스템에 대해서 ``통상적인" 컴파일러를
사용하는 것이 갑자기 보안 결함을 제공할 수도 있다.&#13;</P
><P
>&#13;가장 유용한 도구중의 하나는 표준 GNU C 컴파일러 gcc 를 수정한
"StackGuard" 이다. StackGuard 는 ``canary" 라고 불리는 ``guard" 값을
반환 주소 앞에 추가함으로써 작동한다; 버퍼 오퍼플로우가 반환 주소를
겹쳐쓰면 canary 값이 변경되어 시스템은 이를 사용하기 전에 이를 탐지한다.
이는 매우 유익하지만 다른 값을 겹쳐쓰는 버퍼 오버플로우 공격을
예방하지는 못한다. canary 를 ``PointGuard" 라고 불리는 다른 데이타
아이템에 추가할 수 있도록 StackGuard 를 확장한 작업이 있다. PointGuard
는 자동적으로 특정 값을 보호할 것이다 (예, 함수 포인터 및 longjump
버퍼). 그러나 PointGuard 를 사용해서 다른 변수 타입을 보호하기 위해서는 특정
프로그래머의 중재를 필요로 한다 (프로그래머는 canary 를 이용해 어떤
데이타 값이 보호되어야 하는 지를 식별해야 한다). 이는 유익할 수 있지만
보호가 필요하다고 (그러나 어쨋든 보호가 필요한) 생각하지 못했던 데이타
값에 대한 보호를 우연히 생략하기가 쉽다 . StackGuard, PointGuard 및 다른
대안에 대해 더욱 자세한 정보는 Cowan [1999] 를 참조해라.&#13;</P
><P
>&#13;관련 문제로써 리눅스에서는 커널을 수정해서 스택 세그먼트를
실행불가능하게 만들 수 있다; 이러한 패치가 존재한다 (Solar Designer 의
패치를 보라 <A
HREF="http://www.openwall.com/linux/"
TARGET="_top"
>http://www.openwall.com/linux/</A
>
). 그러나 이 문서 작성 시점에서 이는 리눅스 커널내로 구축되지 않았다. 이
근본적 이유의 일부분은 이것이 생각하는 것만큼 보호를 하지 않는다는
것이다; 공격자가 간단히 시스템으로 하여금 프로그램내 다른 ``interesting"
위치를 호출하도록 할 수 있다 (예, 라이브러리, 힙 또는 정적 데이타
세그먼트내). 또한 때때로 리눅스에서는 예를 들어 시그널 및 GCC
``trampolines" 를 구현하기 위한 경우와 같이 스택에 실행가능한 코드가
있어야 한다. Solar Designer 패치는 이런 경우를 다루지만 패치를 복잡하게
만든다. 개인적으로 저자는 이것이 어느정도 공격을 어렵게 만들고 기존의
다양한 공격들에 대해 보호하기 때문에 주요 리눅스 배포판에 결합되는 것을
보고 싶다. 그러나 저자는 이것이 생각하는 것만큼 많은 보호를 추가하지
못하며 비교적 쉽게 뚫어질 수 있다는 리누스 토발즈와 다른 이에 동의한다.
<A
HREF="http://lwn.net/980806/a/linus-noexec.html"
TARGET="_top"
>http://lwn.net/980806/a/linus-noexec.html</A
>
에서 이 지원을 포함하지 않는 리누스 토발즈의 설명을 읽을 수 있다.&#13;</P
><P
>&#13;요약하면 자체적으로 버퍼 오버플로우를 보호하는 정확한 프로그램을 개발하는 데
우선적으로 중점을 두는 것이 더욱 좋다. 따라서 여러분이 이를 다 읽은 후
반드시 추가적인 안전망으로써 StackGuard 와 같은 기법 및 도구를 사용해라.
코드 자체에서 버퍼 오버플로우를 제거하기 위해 더욱 더 작업한다면 보호를
위해 StackGuard 가 호출될 "약점"은 없을 것이기때문에 StackGuard 는
더욱 더 효과적일 것같다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="OTHER-LANGUAGES"
>5.4. 다른 언어</A
></H2
><P
>&#13;버퍼 오버플로우 문제는 펄, 파이썬, 자바 및 아다95 와 같은 다른
프로그래밍 언어를 사용하자는 주장에 대한 훌륭한 이유이다. 결국 오늘날
사용되는 거의 모든 프로그래밍 언어 (어셈블러이외의) 들은 버퍼
오버플로우를 예방한다. 이러한 다른 언어를 사용한다고 해서 모든 문제를
제거하는 것은 물론 아니다; 특히 NIL 문자와 관련해서 <A
HREF="#LIMIT-CALL-OUTS"
>7.2&#51208;</A
> 의 논의를 보라. 그러한 다른 언어의 인프라
(예, 런타임 라이브러리) 를 쓸 수 있고 이 인프라가 안전함을 보장해야 하는 다른
문제가 있다. 여러분은 버퍼 오버플로우를 예방하는 보안적인 프로그램을
개발할 때 다른 프로그래밍 언어를 사용하는 것을 확실히 고려해야 한다.&#13;</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="INTERNALS"
>6&#51109;. 프로그램 내부 구조화 및 접근 방법 </A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>Like a city whose walls are broken down is a man who lacks self-control.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Proverbs 25:28 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FOLLOW-GOOD-PRINCIPLES"
>6.1. 보안적인 프로그램에 대해 훌륭한 소프트웨어 엔지니어링 원리를 
따르라</A
></H2
><P
>&#13;
Saltzer [1974] 와 나중에 Saltzer 과 Schroeder [1975] 는 보안적인 보호
시스템 설계 원리에 대한 다음 목록을 작성했는데 이는 현재까지도
유효하다:

 </P
><P
></P
><UL
><LI
><P
>&#13;<B
CLASS="EMPHASIS"
>최소한의 권한 (Least privilege)</B
>. 각
사용자와 프로그램은 가능한 최소한의 권한을 사용하여 작동해야 한다. 이
원리는 사고, 에러 또는 공격으로부터의 손상을 제한하며 또한 권한을 갖는
프로그램간의 잠재적인 상호작용의 수를 저하시는데 따라서 의도되지 않은,
원하지 않은 또는 부적절한 권한 사용이 덜 일어나게 할 것이다.  이 개념은
프로그램의 내부로 확장될 수 있는데 이러한 권한을 필요로하는 프로그램의
가장 작은 부분만이 이러한 권한을 가져야 한다. 권한 제한을 어떻게 하는
지에 대한 더욱 자세한 정보는 <A
HREF="#MINIMIZE-PRIVILEGES"
>6.3&#51208;</A
> 을
보라.&#13;</P
></LI
><LI
><P
>&#13;<B
CLASS="EMPHASIS"
>메카니즘의 효율적 사용/단순 (Economy of
mechanism/Simplicity)</B
>. 보호 시스템 설계는 가능한 단순하고
작아야 한다. 이들은 "소프트웨어의 라인별 검사 및 보호 메카니즘을
구현하는 하드웨어의 물리적 조사와 같은 기법들이 필요하다. 이러한 기법이
성공적이기 위해서는 작고 단순한 설계가 절대적으로 필요하다" 라고
논의하고 있다. 이는 때때로 "KISS ("keep it simple, stupid")" 라고
기술된다.&#13;</P
></LI
><LI
><P
>&#13;<B
CLASS="EMPHASIS"
>오픈 설계 (Open design)</B
>. 보호 메카니즘은
공격자의 무지에 의존하지 않아야 한다. 대신 메카니즘은 패스워드 또는
비밀키와 같은 비교적 소수 (쉽게 변경될 수있는) 아이템의 기밀성에 의존하며 
공개적이여야 한다. 오픈 설계는 상세한 공개적 조사를 가능하게 하며 또한
사용자 자신이 사용하고 있는 시스템이 합당함을 깨닫게 할 수 있다. 
솔직히 널리 배포되어 있는 시스템에 대해 기밀을 유지하려고 하는 것은 
현실적이지 않다; 디컴파일러와 파괴된 하드웨어는 구현시의 어떤 비밀을
재빨리 드러낼 수 있다. Bruce Schneier 은 스마트 엔지니어는 소스 코드가
폭넓은 검토를 받았으며 모든 확인된 문제가 수정되었음을 보장해야 할뿐만
아니라 보안과 관련된 모든 것에 대해 오픈 소스 코드를 요구해야 한다고
주장하고 있다 [Schneier 1999].&#13;</P
></LI
><LI
><P
>&#13;<B
CLASS="EMPHASIS"
>완벽한 조정 (Complete mediation)</B
>. 모든
접근 시도가 검사되어야 하는데 메카니즘이 파괴될 수 없도록 이를 위치시켜라. 
예를 들어 클라이언트-서버 모델에서 일반적으로 서버는 사용자가
자신의 클라이언트를 구축 또는 수정할 수 있기 때문에 모든 접근 검사를
해야 한다. 이것이 <A
HREF="#SECURE-INTERFACE"
>6.2&#51208;</A
> 뿐만이 아니라 <A
HREF="#INPUT"
>4&#51109;</A
> 의 요지이다.&#13;</P
></LI
><LI
><P
>&#13;<B
CLASS="EMPHASIS"
>고장 안전 디폴트 (Fail-safe defaults (예, 허가권 기반
접근 방법)</B
>. 디폴트는 서비스 부인이어야 하며 보호 체계가
접근이 허가되는 조건을 확인해야 한다. 더욱 자세한 정보를 얻기 위해서는
<A
HREF="#SAFE-CONFIGURE"
>6.5&#51208;</A
> 및 <A
HREF="#FAIL-SAFE"
>6.7&#51208;</A
> 을 보라.&#13;</P
></LI
><LI
><P
>&#13;<B
CLASS="EMPHASIS"
>권한 분리 (Separation of privilege)</B
>.
원칙적으로 객체에 대한 접근은 한가지 이상의 조건에 의존해야 하며 따라서
한가지 보호 시스템을 무너뜨려도 완전한 접근을 할 수 없을 것이다.&#13;</P
></LI
><LI
><P
>&#13;<B
CLASS="EMPHASIS"
>최소한의 공통 메카니즘 (Least common
mechanism)</B
>. 공유 메카니즘 (예, /tmp 또는 /var/tmp 디렉토리
사용) 의 수와 그 사용을 최소화해라. 공유 객체는 정보 흐름 및 의도되지 않은
상호작용에 대해 잠재적으로 위험한 채널을 제공한다. 더욱 자세한 정보를
얻기 위해서는 <A
HREF="#AVOID-RACE"
>6.8&#51208;</A
> 을 보라.&#13;</P
></LI
><LI
><P
>&#13;<B
CLASS="EMPHASIS"
>심리학적 수용성/사용의 편리함 (Psychological
acceptability/Easy to use)</B
>. 휴먼 인터페이스는 사용하기 쉽도록
설계되어야 하며 따라서 사용자는 일상적 및 자동적으로 보호 메카니즘을
정확히 사용할 것이다. 보안 메카니즘이 사용자가 보호하려는 목적의 정신적
이미지와 밀접하게 일치된다면 실수는 줄어들 것이다.&#13;</P
></LI
></UL
><P
>&#13;보안에 대해 훌륭한 여러가지 다른 설계 원리들은 
<A
HREF="http://www.csl.sri.com/neumann/chats2.html"
TARGET="_top"
>Peter Neumann's CHATS Principles</A
> 에서 얻을 수 있다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECURE-INTERFACE"
>6.2. 인터페이스를 안전하게 해라</A
></H2
><P
>&#13;인터페이스는 최소한 (가능한 단순한),  정밀한 (단지 필요로 한 기능만을
제공) 및 고려된 (non-bypassable) 것이야 한다. 신뢰는 최소화되어야
한다. 사용자가 볼 수 있는 데이타를 제한하는 것을 고려해라.&#13;</P
><P
>&#13;애플리케이션 및 데이타 뷰어들이 외부에서 개발된 파일을 표시하기 위해
사용될 수 있으며 따라서 보안적인 sandbox 를 생성하기 위해 필요한 상세한
작업을 할 필요가 없고 의향이 없다면 일반적으로 뷰어들이 프로그램 (스크립트 또는
매크로) 을 받아들이는 것을 허용하지 마라. 가장 위험한 것은
애플리케이션이 적재될 때 및/또는 데이타가 초기에 표시될 때 실행되는 자동
실행 매크로이다; 보안 관점에서 보았을 때 매크로가 무엇을 할 것인지를
극히 강력하게 제어하지 않는다면 발생하길 기다리는 재앙인 것이다. 그리고
예전 경험은 실제 sandbox 를 구현하는 것은 어렵다고 보여왔다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="MINIMIZE-PRIVILEGES"
>6.3. 권한을 최소화해라</A
></H2
><P
>&#13;앞에서 언급했듯이 프로그램이 그 작업을 하는데 필요한 최소한의 권한을
갖는 것은 중요한 일반적인 원리이다 (이는 "최소한의 권한" 이라고
지칭된다). 이런 방식에서 프로그램이 파괴된다하더라고 그 손상은 제한된다.
가장 극단적인 예는 단순히 보안적인 프로그램을 전혀 작성하지 않는 것이다
-이럴 수 있다면 보통 이렇게 해야 한다. 예를 들어 가능하다면 프로그램을
setuid 또는 setgid 프로그램으로 만들지 마라; 그저 일반적인 프로그램을
만들어 이를 실행시키기 전에 관리자가 그 자격으로 로그인하도록 해라.&#13;</P
><P
>&#13;리눅스와 유닉스에서 프로세스의 권한을 기본적으로 결정하는 것은
프로세스와 관련된 id 셋이다; 각 프로세스는 사용자와 그룹에 대해 실제
(real), 유효 (effective) 및 유보 (saved) id 를 갖고 있다. 리눅스는 또한
파일시스템 uid 와 gid 를 갖는다. 이러한 값을 조작하는 것은 권한을
최소한으로 유지하는데 있어서 결정적인데 이를 최소화하는 몇가지 방법이
있다 (밑부분에 논의된다). 또한 chroot(2) 를 이용해서 프로그램이 볼 수
있는 파일을 최소화할 수 있다. 리눅스와 유닉스에서는 권한을 결정하는 
약간의 다른 값들이 있는데 예를 들어 POSIX 능력 (리눅스 2.2 이상 및 
몇몇 다른 유닉스 계열 시스템이 이를 지원한다) 이 있다. &#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MIMIMIZE-PRIVILEGES-GRANTED"
>6.3.1. 허가되는 권한을 최소화해라</A
></H3
><P
>&#13;아마 가장 효과적인 기법은 허가된 가장 높은 권환을 단순히 최소화하는
것이다. 특히 프로그램에게 가능한 루트 권한을 주지 않도록 해라.
프로그램이 단지 작은 파일셋에 접근할 필요만 있다면 프로그램을 <B
CLASS="EMPHASIS"
>setuid root</B
> 로 만들지 마라; 여러 기능에 대해
별개의 사용자 또는 그룹 생성을 고려해라.&#13;</P
><P
>&#13;공통적인 기법은 특별 그룹을 생성해서 파일의 그룹 소유권을 이 그룹으로
변경한 후 프로그램을 이 그룹에 <B
CLASS="EMPHASIS"
>setgid</B
> 로
만드는 것이다. 그룹 멤버십이 더욱 적은 권한을 허가하기 때문에 (특히 파일
허가권을 변경할 권한을 주지는 않는다) 프로그램을 <B
CLASS="EMPHASIS"
>setuid</B
> 대신 <B
CLASS="EMPHASIS"
>setgid</B
>
로 만드는 것이 더욱 좋다.&#13;</P
><P
>&#13;이는 게임에서 고득점의 경우에 보통 행해진다. 게임은 대개 setgid
<B
CLASS="EMPHASIS"
>games</B
> 으로 득점 파일은 그룹 <B
CLASS="EMPHASIS"
>games</B
> 가 소유하고 프로그램 그 자체와 이들의 설정
파일은 다른 누군가 (루트) 가 소유한다. 따라서 게임에 침입한 공격자가
고득점을 변경할 수는 있지만 게임의 실행 또는 그 설정 파일을 변경할
권한을 얻지는 못한다. 후자는 중요하다; 공격자가 게임의 실행 또는 그 설정
파일 (실행 파일이 무엇을 작동시킬 건지를 제어할 수 있는) 을 변경할 수
있다면 게임을 즐기는 사용자들을 제어할 수도 있다.&#13;</P
><P
>&#13;새로운 그룹 생성이 충분하지 않다면 일련의 자원들을 관리하는 새로운
준사용자 (실제로 특별한 역할을 하는) 생성을 고려해라. 웹서버가
전형적으로 이런 방식인데 때때로 웹서버는 다른 사용자와 분리될 수
있도록 특별한 사용자 (``nobody") 로 설정된다. 정말로 웹서버는 이점에서
교육적이다: 웹서버는 구동하기 위해 전형적으로 루트 권한을 필요로 하지만
(포트 80 에 부착될 수 있도록) 일단 시작되면 대개 모든 권한을 버리고
``nobody" 사용자로서 작동한다. 대개 준사용자는 자기가 실행시킨 기본
프로그램을 소유하지 않으며 따라서 그 계정에 침입한다고 해서 프로그램
자체를 변경할 수는 없다. 그 결과로 작동중인 웹서버에 침입하는 것이
일반적으로 전체 시스템의 보안을 자동적으로 파괴하지는 못한다.&#13;</P
><P
>&#13;프로그램에 루트 권한을 주어야 한다면 프로그램이 이용할 수 있는 권한을 
최소화하자마자 POSIX 능력 사용을 고려해라. POSIX 는 리눅스 2.2 이상 
및 다른 유닉스 계열 사용할 수 있다. 프로그램 
시작후에 즉각적으로 cap_set_proc(3) 또는
리눅스 고유의 capsetp(3) 을 호출함으로써 프로그램의 능력을 영구히 단지
실제 필요로 하는 능력으로 감소시킬 수 있다. 예를 들어 네트워크 시간 데몬 (
ntpd) 는 현재 시간을 수정할 필요가 있기때문에 전통적으로 루트 권한으로 
실행된다. 그러나 ntpd 가 단지 하나의 능력 CAP_SYS_TIME 만이 필요하도록 
패치가 개발되었으며 따라서 공격자가 ntpd 에 대한 제어를 얻는다 하더라도 
프로그램을 악용하는 것은 더욱 어려울 것이다. &#13;</P
><P
>&#13;다른 조치가 취해지지 않는다면 POSIX 능력을 사용해 권한을 유지하는 것은 
프로세스가 루트 사용자 id 를 계속해서 가져야 함을 요구하기 때문에 저자는 
``어느 정도 제한적" 이라고 말하고 싶다. 설정 파일, 바이너리 등의 많은 중요한 
파일은 루트가 소유해야 하기 때문에 이러한 제한된 능력을 갖는 프로그램을 
제어하는 공격자는 여전히 주요 시스템 파일 수정 및 완전한 루트 수준의 권한을 
얻을 수 있다. 리눅스 커널 확장 (버전 2.4.X 및 2.2.19 이상에서 쓸 수 있다) 은 
사용가능한 권한을 제한하는 더욱 좋은 방법을 제공한다; 프로그램이 모든 
POSIX 능력을 갖는 루트로 실행되어 불필요한 능력은 제거하고 
prctl(PR_SET_KEEPCAPS,1) 을 호출한 후 루트가 아닌 프로세스로 변경하기 
위해 setuid() 를 사용할 수 있다. PR_SET_KEEPCAPS 설정은 프로세스가 
0 이 아닌 값으로 setuid 를 할 때 POSIX 능력이 제거되지 않도록 프로세스에 
표시를 하며 이 프로세스 설정은 exec() 에서 제거된다. 그러나 PR_SET_KEEPCAPS 
는 더욱 새로운 리눅스 커널 버전에 대한 리눅스 고유의 확장이라는 것에 주의해라.&#13;</P
><P
>&#13;허가되는 권한의 최소화를 단순하게 하기 위해 사용할 수 있는 리눅스 고유의
한가지 도구는 SuSe 에 의해 개발된 ``compartment" 도구이다. 이는
파일시스템 루트, uid gid 및/또는 capability set 을 설정한후 프로그램을
실행시킨다. 이는 특히 어떤 다른 프로그램을 수정하지 않고 실행시키는데
편리하게 이용할 수 있다. 다음은 0.5 버전의 구문이다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;Syntax: compartment [options] /full/path/to/program

Options:
   --chroot path    path 로 chroot 한다
   --user user      uid 를 user 의 uid 로 변경한다
   --group group    gid 를 group 의 gid 로 변경한다
   --init program   최우선적으로 이 programe 을 실행시킨다
   --cap capset     capset 이름을 설정한다. 여러번 지정할 수 있다
   --verbose        자세한 정보를 보여준다
   --quiet          syslog 에 기록하지 않는다</PRE
></TD
></TR
></TABLE
><P
>&#13;따라서 anonymous ftp 서버를 더욱 안전하게 구동시킬 수 있다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  compartment --chroot /home/ftp --cap CAP_NET_BIND_SERVICE anon-ftpd</PRE
></TD
></TR
></TABLE
><P
>&#13;이 문서 작성 시점에서 도구는 미완성이고 전형적인 리눅스 배포판에서 얻을
수는 없지만 상황은 빠르게 변할 것이다. <A
HREF="http://www.suse.de/~marc"
TARGET="_top"
>http://www.suse.de/~marc</A
> 에서
프로그램을 다운로드받을 수 있다.&#13;</P
><P
>&#13;모든 유닉스 계열 시스템이 POSIX 능력을 구현하지는 않으며 
PR_SET_KEEPCAPS 은 현재 리눅스에서만 지원함을 주목해라. 
따라서 이 접근 방법은 이식성을 한다; 그러나 도움이 되는 경우에만 
이를 단지 선택적인 보호수단으로 사용한다면 실제적으로 이식성을 제한하지는 
않을 것이다. 또한 리눅스 커널 2.2 버전 이상은 하위 수준 호출을 포함하지만 
이들을 사용하기 용이하게 하는 C 수준 라이브러리는 몇몇 리눅스 배포판에는 
설치되어 있지 않아 애플리케이션에서 이들의 사용을 약간 복잡하게 하고 있다. 
리눅스에서 POSIX 능력 구현에 대해 더욱 자세한 정보는 <A
HREF="http://linux.kernel.org/pub/linux/libs/security/linux-privs"
TARGET="_top"
>http://linux.kernel.org/pub/linux/libs/security/linux-privs</A
>
를 보라.&#13;</P
><P
>&#13;FreeBSD 는 권한 제한을 위해 jail() 함수를 갖고 있다: 더욱 자세한 정보는
<A
HREF="http://docs.freebsd.org/44doc/papers/jail/jail.html"
TARGET="_top"
>jail
문서</A
> 를 보라. 또한 권한 제한을 위해 많은 전문화된 도구 및
확장들이 있다; <A
HREF="#UNIX-EXTENSIONS"
>3.10&#51208;</A
> 을 보라.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MINIMIZE-TIME-PRIVILEGE-USABLE"
>6.3.2. 권한이 사용될 수 있는 시간을 최소화해라</A
></H3
><P
>&#13;가능한 빨리 영구적으로 권한을 포기해라. 리눅스를 포함한 몇몇 유닉스 계열
시스템은 ``이전" ID 값을 저장하고 있는 ``유보된 (saved)" ID 를
구현한다. 가장 간단한 접근 방법은 적절한 경우 (예, setgroups(2) 사용) 모든 
추가된 그룹을 재설정한 후 신뢰되지 않은 id 에 다른 id 를 두번
설정하는 것이다. setuid/setgid 프로그램에서는 특히 fork(2) 실행 직후에
실제 uid 와 gid 에 대개 유효 uid 와 gid 를 설정해야 하며 특별한 이유가
없다면 이를 당연히 해야 한다. 루트에서 다른 권한으로 축소시킬 때 gid 를
우선적으로 변경시켜야 하며 이렇지 않은 경우 작용하지 않는다는 것을
주목해라 - 루트 권한을 버린다면 더 이상 변경 시킬 수 없을
것이다.&#13;</P
><P
>&#13;이러한 최소화를 방해하기 위해 POSIX 능력을 사용하는 잘 알려진 관련
버그가 있음을 언급하는 것은 가치가 있다. 이 버그는 리눅스 커널 2.2.0
에서 2.2.15 및 아마도 POSIX 능력을 갖는 많은 다른 유닉스 계열 시스템에
영향을 미친다. 더욱 자세한 정보는 http://www.securityfocus.com 의
버그트랙 id 1322 를 보라. 다음은 요약이다:&#13;</P
><A
NAME="AEN1053"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;POSIX 능력은 최근 리눅스 커널에 구현되었다. 이 능력은 권한을 갖는
프로세스가 할 수 있는 것을 더욱 명백히 제어할 수 있는 권한 제어의
추가적인 형태로 세가지 비트 필드로 구현되어 있는데 각 비트는 권한을 갖는
프로세스가 수행할 수 있는 특정 동작을 나타낸다. 특정 비트를 설정함으로써
권한을 갖는 프로세스의 동작이 제어될 수 있다 -- 다양한 함수들에 대해 그들을
필요로 하는 프로그램의 특정 부분에 대해서는 접근 허가를 받을 수 있다.
이는 보안 조치이다. 문제는 능력이 fork() execs 와 함께 복사된다는 것인데
이는 능력이 부모 프로세스에 의해 수정된다면 작업이 끝나지 않은 채 능력이 
넘겨짐을 의미한다. 이는 세가지 비트 필드 각각에 능력을 0 으로 설정 (
모든 비트가 off 임을 의미) 한 후 루트 권한으로 실행된 경우 (센드메일이
하는 것과 같이) 위험할 수 있는 코드를 실행시키기 전에 권한을
축소시키려고 하는 setuid 프로그램을 실행시킴으로써 악용될 수 있다.
sendmail 은 setuid(getuid()) 를 사용해서 권한을 축소시키려고 할 때 그
비트 필드에 권한 축소에 필요한 능력을 갖지 못하고 반환값 검사없이
실패한다. sendmail 은 슈퍼유저 권한으로 계속 실행되며 루트로서 
사용자의 .forward 파일을 실행시켜 완전한 손상을 야기한다. &#13;</P
></BLOCKQUOTE
><P
>&#13;sendmail 이 사용하는 한가지 접근 방법은 setuid(getuid()) 후에 setuid(0)
를 하려고 하는 것이다; 일반적으로 이는 실패해야 한다. 성공한다면
프로그램은 중지해야 한다. 더욱 자세한 정보는
http://sendmail.net/?feed=000607linuxbug 를 보라. 장기적으로 보았을 때
기본적인 시스템을 갱신하는 것이 더욱 좋은 접근 방법임에도 불구하고
단기적으로 이는 다른 프로그램에서 좋은 개념일 수 있다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MINIMIZE-TIME-PRIVILEGE-ACTIVE"
>6.3.3. 권한이 필요한 시간을 최소화해라</A
></H3
><P
>&#13;프로그램이 필요할 때만 유효한 권한을 갖음을 보장하기 위해서 setuid(2),
seteuid(2) 와 관련 함수를 사용해라. 위에 언급했듯이 사용자 입력을
해석하는 동안은 권한이 금지되도록 더욱 일반적으로는 권한이 실제
필요할 때만 권한이 유효함을 보장하고 싶을 것이다. 어떤 버퍼 오버플로우
공격은 성공한다면 프로그램으로 하여금 임의의 코드를 실행시키게 할 수
있으며 코드는 일시적으로 축소되었던 권한을 다시 이용할 수 있음을
주목해라. 따라서 가능한 권한을 완전히 축소시키는 것이 늘 더욱 좋다.
더욱이 허가권을 일시적으로 금지하는 것은 프로그램이 파일내에 작성하지
않으려고 했던 것을 작성하도록 납득시키는 기법같은 모든 종류의 공격을
예방한다. 이 기법은 많은 공격을 에방하기 때문에 프로그램의 어떤 부분에서
권한의 완전 축소를 할 수 없는 경우 사용할 가치가 있다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MINIMIZE-PRIVILEGED-MODULES"
>6.3.4. 권한이 허가된 모듈을 최소화해라</A
></H3
><P
>&#13;단지 약간의 모듈들에만 권한이 허가된다면 그들이 보안적인지를 결정하는 것은 더욱
쉽다. 이를 행하는 한가지 방법은 하나의 모듈로 하여금 권한을 사용하게
하고 그 후 이를 축소하는 것으로 따라서 추후 호출되는 다른 모듈이 권한을
오용할 수 없다. 다른 접근 방법은 별개 실행 파일에 별개의 명령을 갖는
것이다; 한 명령이 권한을 갖는 사용자 (예, 루트) 를 위해 방대한 양의
태스크를 수행할 수 있는 복잡한 도구이며 한편 다른 도구는 setuid 로 적은
수의 명령 부분집합만을 허용하는 작고 단순한 도구이다. 작고 단순한 도구는
입력이 수용 가능한 다양한 조건을 충족시키는지를 검사하며 따라서 입력이
수용가능하다고 결정하면 데이타를 복잡한 도구로 건네준다. 작고 단순한
도구가 입력 검사와 복잡한 도구로 무엇을 건네줄 것인지를 제한하는 철저한
작업을 해야함을 주목해라 그렇지 않다면 이는 공격당하기 쉬울 수 있다.
이러한 접근 방법은 몇가지 방식으로 계층화 (layered) 될 수 있는데 예를
들어 복잡한 사용자 도구는 다음에 다른 복잡한 신뢰된 도구로 정보를
건네주는 단순한 setuid "wrapping" 프로그램 (입력이 안전한 값인지를
검사한다) 을 호출할 수 있다. 이 접근 방법은 GUI 에 기초한 프로그램에
특히 도움이 된다; GUI 부분을 일반 사용자로 실행시키고 보안 관련 요청을
실제 실행할 수 있는 특별 권한을 갖는 다른 프로그램에 넘겨줘라.&#13;</P
><P
>&#13;어떤 운영체제는 하나의 프로세스에 다중 신뢰 계층 개념을 갖고 있는데
Multics' rings 이 한예이다. 표준 유닉스와 리눅스는 이와같은 싱글
프로세스내에서 함수를 이용해 다중 신뢰 계층을 분리하는 방법을 갖고 있지
않다; 커널의 호출은 권한을 증가시키지만 그렇지 않으면 주어진 프로세스는
하나의 신뢰 수준을 갖는다. 리눅스와 다른 유닉스 계열 시스템은 프로세스를
각각 다른 권한을 갖는 다중 프로세스로 분기함으로써 이 능력을 때때로
모사할 수 있다. 이렇게 하기 위해 보안적인 통신 채널 (보통 언네임드 파이프
또는 언네임드 소켓이 사용된다) 을 설정한 후 다른 프로세스로 분기하여 각
프로세스 권한을 가능한 많이 축소시켜라. 그리고 단순한 프로토콜을
사용해서 덜 신뢰된 프로세스로 하여금 더욱 신뢰된 프로세스로부터의 동작을
요청하도록하며 더욱 신뢰된 프로세스는 단지 제한된 요청셋을 지원하도록
보장해라.&#13;</P
><P
>&#13;이는 자바 2 및 Fluke 가 장점을 갖는 분야인데 예를 들어 자바 2 는 단지
특정 파일을 열 수있는 허가권과 같이 미세화된 (fine-grained) 허가권을 지정할
수 있다. 그러나 범용 운영체제는 일반적으로 현재 이러한 능력을 갖고 있지
않다; 이는 가까운 미래에는 변할 수 있다. 자바에 대한 더욱 자세한 정보는
<A
HREF="#JAVA"
>9.6&#51208;</A
> 를 보라.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CONSIDER-FSUID"
>6.3.5. 권한을 제한하기 위해 FSUID 사용을 고려해라</A
></H3
><P
>&#13;
각각의 리눅스 프로세스는 파일시스템 사용자 id (fsuid) 와 파일시스템 그룹
id (fsgid) 라는 리눅스 고유의 두개의 상태값을 갖는다. 이 두값은
파일시스템 허가권을 검사할 때 사용되는데 임의 사용자를 위한 파일 서버 (NFS
와 같은) 로 작동하는 프로그램을 작성하려면 이러한 리눅스 확장의 사용을
고려할 수 있다. 이 확장을 사용하기 위해서는 루트 권한을 보유하는 동시에
일반 사용자 대신 파일을 접근하기 전에 단지 fsuid 와 fsgid 를 변경해라.
이 확장은 매우 유용하며 다른 (아마 필요한) 권한을 제거하지 않고서
파일시스템 접근 권한을 제한하는 메카니즘을 제공한다. 단지 fsuid (euid 는
아니다) 를 설정함으로써 지역 사용자는 프로세스에 시그널을 보낼 수 없다.
또한 이러한 상황에서 경쟁 상태는 더욱 쉽게 피해진다. 그러나 이러한 접근
방법의 단점은 이러한 호출이 모든 유닉스 계열 시스템으로 이식할 수 없다는
것이다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CONSIDER-CHROOT"
>6.3.6. 사용할 수 있는 파일을 최소화하기 위해 Chroot 사용을 고려해라</A
></H3
><P
>&#13;chroot(2) 를 사용해서 프로그램이 볼 수 있는 파일을 제한할 수 있다. 이는
디렉토리를 주의깊게 설정하고 (choot jail 이라고 불린다) 디렉토리에
정확하게 들어가야 함을 요한다. 이는 프로그램의 보안을 향상시키는 매우
효과적인 기법이다 - 볼 수 없는 파일을 방해하는 것은 어렵다. 그러나 이는
전체적인 가정, 특히 프로그램이 루트 권한이 없어야 한다는 가정에
의존한다. 루트 권한을 획득할 어떠한 방법도 없어야 하며 chroot jail 이
적절히 설정되어야 한다. 저자는 이 방법이 적절한 경우에 chroot(2) 를 사용할
것을 추천하지만 이에만 의존하지만 마라; 대신 이를 계층화된 보호셋의
부분이 되도록 해라. 다음은 chroot(2) 사용에 대한 약간의 주의들이다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;프로그램이 전체 머신을 통해 공유되고 있는 파일시스템이 아닌 객체를
사용할 수 있다 (System V IPC 객체와 네트워크 소켓). 또한 모든 유닉스
계열 시스템은 사용자를 구분할 수 있기 때문에 별도의 준사용자 및/또는
그룹을 사용하는 것이 최우선이다; 이는 적어도 파괴된 프로그램이 다른
프로그램에 미칠 수 있는 손해를 제한할 것이다. 현재 리눅스를 포함하여
대부분의 유닉스 계열 시스템이 상호작용하고 있는 프로그램을 의도적으로
분리하지 않을 것임을 주목해라; 악의있는 프로그램이 상호작용하는 것에
대해 걱정하고 있다면 어떤 강제적인 접근 제어를 구현하고/하거나 숨겨진
채널을 제한하는 시스템을 얻을 필요가 있다.&#13;</P
></LI
><LI
><P
>&#13;외부 파일에 대한 파일 시스템 기술자를 추후 사용하지 않는다면 이들이 모두
닫힌 것을 확인해라. 특히 chroot jail 외부 디렉토리에 어떠한 기술자도
열지 말고 그렇지 않다면 유닉스 소켓 또는 예전 /proc 구현과 같이
기술자를 줄 수 있는 상황을 설정해라. chroot jail 외부
디렉토리에 대한 기술자를 프로그램에게 준다면 이는 chroot jail 을
벗어나는데 사용될 수 있다.&#13;</P
></LI
><LI
><P
>&#13;chroot jail 은 보안적으로 설정되어야 한다. 일반 사용자의 홈 디렉토리
(또는 하부 디렉토리) 를 chroot jail 로 사용하지 마라; 별도 위치 또는
특히 이 목적으로 준비해 놓은 홈 디렉토리를 사용해라. 이 디렉토리에
파일의 절대적인 최소수를 설정해라. 일반적으로 여러분은 /bin, /etc/, /lib
및 아마 한 두개 다른 디렉토리 (ftp 서버라면 /pub) 를 갖고 있을 것이다.
/bin 내에는 chroot() 를 한 후 실행할 필요가 있는 것들만 놓아라; 때때로
아무것도 필요가 없을 것이다 (쉘을 거기에 두지 않으려고 해라 물론 어쩔
수 없이 놓을 수 있다). 파일 목록이 어떤 정확한 이름을 보일 수 있도록
/etc/passwd 와 /etc/group 를 필요로 할 수도 있지만 그렇다면 실제 시스템
값을 포함하지 않도록 하고 확실히 모든 패스워드를 "*" 로 대체해라.&#13;</P
><P
>&#13;/lib 에는 필요한 것만 놓아라; ldd(1) 프로그램을 사용해서 /bin 내의 각
프로그램이 필요한 것을 찾도록 질의하고 이들만을 /lib 에 놓아라.
리눅스에서는 아마도 ld-linux.so.2 와 같은 약간의 기본적인 라이브러리가
필요하며 더 이상은 필요치 않다. 대안으로 모든 프로그램들이 동적 적재
라이브러리를 필요로 하지 않도록 프로그램을 정적으로 다시 컴파일해라.&#13;</P
><P
>&#13;하드 링크를 하는 대신 모든 파일을 복사해서 완전히 갖고 있는 것이 보통
더욱 현명한 것이다; 이것이 약간의 시간 및 하드 공간을 소비하지만 chroot
jail 에 대한 공격이 정규 시스템 파일로 자동적으로 전파되지 않도록 그렇게
해라. /proc 파일시스템을 마운팅하는 것은 (지원되는 시스템에서) 일반적으로 현명하지 않다. 사실
chroot 된 프로그램의 이스케이프를 허용할 수 있는 준 디렉토리가 /proc
내에 있었기 때문에 리눅스 예전 버전 (2.0.x 버전, 2.0.38 버전까지) 에서는
잘 알려진 보안 결함이였다. 리눅스 커널 2.2 는 이 알려진 문제를
수정했지만 다른 문제가 있을 수 있으며 가능하다면 이렇게 하지 마라.&#13;</P
></LI
><LI
><P
>&#13; Chroot 는 프로그램이 루트 권한을 얻는다면 실제로 효과적이지 않다. 예를
들어 프로그램이 mknod(2) 와 같은 호출을 사용해서 물리 메모리를 볼 수
있는 디바이스 파일을 생성한 후 이 디바이스 파일을 이용해 원하는 권한을
얻을 수 있도록 커널 메모리를 수정할 수 있을 것이다. chroot 를 이용해서
루트 프로그램을 파괴할 수 있는 다른 예는 <A
HREF="http://www.suid.edu/source/breakchroot.c"
TARGET="_top"
>http://www.suid.edu/source/breakchroot.c</A
>
에 예시되어 있다. 이 예에서 프로그램은 현재 디렉토리의 파일 기술자를
열어 하부디렉토리를 생성 및 chroot 해 현재 디렉토리를 이전에 열린
현재 디렉토리로 설정해서 현재 디렉토리 (이는 현재 디렉토리의
외부이기때문에 chroot 는 실제 파일시스템 루트로 계속해서 올라간다)
로부터 계속해서 상위 디렉토리로 옮겨간 후 결과에 대해 chroot 를
호출한다. 여러분이 이를 읽을 때까지 이 약점이 보완됐을 수도 있지만
실제로 루트 권한은 일반적으로 모든 권한을 의미하여 이를 제거하기는
어렵다. 계속적으로 루트 권한을 필요로 하는 프로그램은 chroot() 를
사용함으로써 단지 조심스럽게 도움이 될 것이다라고 가정하는 것이 더욱
좋다. 물론 적어도 프로그램의 일부분만이 chroot jail 내에 있을 수 있도록
프로그램을 나눌 수 있을지도 모른다.&#13;</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MINIMIZE-ACCESSIBLE-DATA"
>6.3.7. 접근할 수 있는 데이타의 최소화를 고려해라</A
></H3
><P
>&#13;사용자가 접근할 수 있는 데이타의 양을 최소화하는 것을 고려해라. 예를 들어
사용자가 데이타를 직접적으로 볼 필요가 없다면 CGI 스크립트에서 이
스크립트가 사용하는 모든 데이타를 문서 트리 외부에 놓아라. 어떤 사람은
공개적으로 링크를 제공하지 않음으로써 어떤 누구도 데이타에 접근할 수
없다는 잘못된 생각을 갖고 있는데 이는 간단히 말해서 옳지 않다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MINIMIZE-RESOURCES"
>6.3.8. 사용가능한 자원의 최소화를 고려해라</A
></H3
><P
>&#13;주어진 프로세스가 사용가능한 컴퓨터 자원을 최소화하는 것을 고려해라. 따라서 
고장난다고 하더라도 손상을 제한할 수 있다. 이는 서비스 부인 공격을 예방하는 
기본적인 방법이다. 네트워크 서버의 경우 공통적인 접근 방법은 각 세션에 대해 
별개의 프로세스를 설정하고 각 프로세스에 대해 세션이 사용할 수 있는 
총 CPU 시간 등을 제한하는 것이다. 이렇게 함으로써 공격자가 메모리를 소비하거나 
모든 CPU 를 사용하는 요청을 하는 경우 한도가 적용되어 그 하나의 세션이 
다른 태스크를 방해하지 못하도록 할 것이다. 물론 공격자가 많은 세션을 만들 수 
있지만 이는 적어도 공격을 방해할 수 있다. 한도 설정 방법 (예, ulimit(1)) 
대한 더욱 자세한 정보는 <A
HREF="#QUOTAS"
>3.6&#51208;</A
> 를 보라. &#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AVOID-SETUID"
>6.4. Setuid/Setgid 스크립트 생성을 피해라</A
></H2
><P
>&#13;많은 유닉스 계열 시스템 특히 리눅스는 앞에서 기술한 경쟁 상태를 피하기
위해 스크립트에 설정되어 있는 setuid 와 setgid 비트를 단순히 무시한다.
setuid 스크립트의 지원 여부는 유닉스 계열 시스템들마다 다르기 때문에
가능한 새로운 애플리케이션에서는 최우선적으로 피해진다. 특별한 경우로 펄은
setuid 펄 스크립트를 지원하기 위해 특별한 설정을 포함하고 있으며 따라서
정말로 이러한 기능성이 필요하다면 setuid 와 setgid 사용은 가능하다.
자신의 인터프리터에 이러한 기능성을 지원할 필요가 있다면 펄에서 어떻게 하는
지를 조사해라. 그렇지 않은 경우 간단한 접근 방법은 안전한 환경 (환경
변수 제거 및 설정) 을 생성하는 작은 setuid/setgid 실행가능한 스크립트를
"wrap" 한 후 스크립트의 절대 경로를 사용해서 이를 호출하는 것이다.
스크립트가 공격자에 의해 변경될 수 없음을 확인해라. 쉘 스크립팅 언어는
추가적인 문제를 갖고 있으며 실제로 setuid/setgid 로 설정되지 않아야
한다. 더욱 자세한 정보는 <A
HREF="#SHELL"
>9.4&#51208;</A
> 을 보라.
 </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SAFE-CONFIGURE"
>6.5. 안전하게 설정하고 안전한 디폴트를 사용해라</A
></H2
><P
>&#13;설정은 현재 보안 문제를 야기하는 가장 중요한 원인으로 고려되고 있다.
따라서 처음 설치를 보안적으로 하여 시스템을 보안적으로 유지한채
재설정이 쉽게 되도록 노력해야 한다.&#13;</P
><P
>&#13;절대로 설치 루틴이 ``default" 패스워드를 설치하도록 하지 마라. 새로운
"users"를 설치할 필요가 있다면 좋다 - 관리자에게 패스워드를 설정할
시간을 주고 (패스워드가 설정되기 전에 시스템이 보안적으로 유지하면서)
그저 불가능한 패스워드를 갖고 이들을 설치해라. 관리자는 아마도 수백개의
패키지를 설치하고 거의 확실히 패스워드 설정을 잊어버릴 것이다 - 디폴트
패스워드를 생성한다면 관리자는 이를 설정하는 것을 알려고 하지도 않을 것
이다.&#13;</P
><P
>&#13;프로그램은 관리자가 접근 정책을 설정할 기회를 갖을 때까지 가장 제한적인 접근
정책을 가져야 한다. 시작 설정으로 ``sample" 과 같이 실제 쓸 수 있는
사용자 또는 ``모든 것에 접근을 허용하는" 설정을 생성하지 말기 바란다:
많은 사용자는 그저 ``모든 것을 설치하며" (모든 사용할 수 있는 서비스를
설치하며) 많은 서비스를 설정할 시간은 절대로 내지 않는다. 어떤 경우에는
프로그램이 기존 인증 시스템에 의존함으로써 더욱 관대한 정책이
바람직하다라고 결정할 수 있을 지도 모르는데 예를 들어 ftp 서버는
사용자의 디렉토리로 로그인할 수 있는 사용자는 자신의 파일에 접근할 수
있어야 한다고 결정할 수 있다. 그러나 이러한 가정에 주의해라.&#13;</P
><P
>&#13;
설치 스크립트가 가능한 안전하게 프로그램을 설치하도록 해라. 디폴트로
루트 또는 어떤 다른 시스템 사용자에 의해 소유되는 모든 파일들을 설치하고
이들을 others 에게는 쓸 수없게 만들어라; 이는 루트 아닌 사용자가
바이러스를 설치하는 것을 예방한다. 정말로 이 파일들을 신뢰된
사용자외에는 어느 누구도 읽을 수 없게 만드는 것이 최선이다. 또한 루트
권한이 없는 사용자와 설치자를 완전히 믿지 못하는 관리자가 여전히
프로그램을 사용할 수 있도록 루트 아닌 설치를 허용해라.&#13;</P
><P
>&#13;설치할 때 반드시 보안에 필요한 모든 가정이 옳은지 검사해라. 몇몇 라이브러리
루틴들은 어떤 플랫폼에서는 안전하지 않다; 이에 대한 논의는 
<A
HREF="#CALL-ONLY-SAFE"
>7.1&#51208;</A
> 를 보라. 애플리케이션이 실행될 플랫폼들을 
알고 있다면 플랫폼들의 특정적인 특징을 검사할 필요는 없지만 이러한 경우 
반드시 프로그램이 이러한 플랫폼들중의 하나에만 설치되는지를 검사해라. 
그렇지 않다면 설치 결과가 보안적인지 아닌지 모르기 때문에 수작업으로 
프로그램을 설치해야 한다.&#13;</P
><P
>&#13;설치후의 설정을 포함하여 가능한 설정이 쉽고 명백하도록 만들어라. 가능한
``보안적인" 접근 방법을 사용해라 그렇지 않다면 많은 사용자가 위험을
이해함이 없이 비보안적인 접근 방법을 사용할 것이다. 리눅스에서는
사용자가 기존 인프라를 사용하여 그들의 시스템을 쉽게 설정할 수 있도록
linuxconf 와 같은 도구를 이용해라.&#13;</P
><P
>&#13;
설정 언어가 있다면 디폴트는 사용자가 명확하게 접근을 허용할 때까지 이를
거절해야 한다. 관리자가 설정이 무엇을 하는 지를 이해할 수 있도록 예제
설정 파일에 많은 명확한 주석을 포함해라 (있다면).&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INIT-SAFE"
>6.6. 안전하게 초기화값을 적재해라</A
></H2
><P
>&#13;많은 프로그램들은 그들의 디폴트 설정을 허용하는 초기화 파일을 읽는데
공격자가 어떤 초기화 파일이 사용되는지를 변경할 수 없으며 이 파일을 생성 또는
수정할 수 없도록 보증해야 한다. 프로그램이 편집기 또는 브라우저로써
사용된다면 사용자가 다른 누군가에 의해 제어되는 디렉토리를 볼 수도 있기
때문에 대개 현재 디렉토리를 초기화 관련 정보의 출처로 사용해서는 안된다. 대신
프로그램이 일반적인 사용자 애플리케이션이라면 사용자의 홈디렉토리에
포함되어 있는 숨겨진 파일 또는 디렉토리로부터 모든 사용자의 디폴트를
적재해야 한다. 프로그램이 setuid/setgid 인 경우 이를 신뢰되지 않은 
(잠재적으로 적의있는) 입력으로 필터링하지 못한다면 사용자에 의해
제어되는 모든 파일을 읽지 마라. 신뢰된 설정 값이 어떤 다른 곳에서 전부 
적재되어야 한다 (일반적으로 /etc 내의 파일들로부터).&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FAIL-SAFE"
>6.7. 고장 안전</A
></H2
><P
>&#13;보안적인 프로그램은 오류가 발생하였을 때 그것을 한 부분에 국한시켜 전체
시스템이 완전히 마비되는 것을 방지하고 수행을 계속할 수 있도록
설계되어야 한다, 즉 프로그램이 실패하더라도 가장 안전한 결과가 나올 수
있도록 설계되어야 한다. 보안이 결정적인 프로그램의 경우 이는 어떤 종류의
오작동이 탐지된다면 ("can't get here" 상태에 도달하는 기형의 입력 등)
프로그램이 즉각적으로 서비스를 거절하고 그 요청 처리를 중지해야 한다.
사용자가 무엇을 원했는지 이해하려고 하지 마라; 그저 서비스를 거절해라.
때때로 이는 사용자 관점에서 신뢰성 또는 사용성을 감소시키지만 보안은
증가시킨다. 이것이 바람직하지 않은 약간의 경우도 있지만 (예, 서비스
부인이 기밀성 또는 무결성 손실보다 더욱 나쁜 경우가 있다) 거의 드문
경우이다.&#13;</P
><P
>&#13;저자가 ``전체적으로 실패해라" 가 아닌 ``요청 처리를 중지하라"는 것에 주목해라.
특히 대부분의 서버는 기형의 입력을 받을 때 완전히 멈춰서는 안되는데 이런
경우 서비스 부인 공격 (공격자가 서비스 사용을 방해하기 위해 그저 가비지
비트를 보낸다) 에 대한 사소한 기회를 제공하기 때문이다. 때때로
전체 서버를 다운시키는 것이 필요한데 특히 "can't get here" 상태에 이르는
것은 계속하는 것이 어리석을 만큼 격렬한 문제임을 알리는 것일 수도 있다.&#13;</P
><P
>&#13;실패가 탐지될 때 어떤 에러 메시지를 보여줄지를 주의깊게 고려해라.
아무것도 보여주지 못한다면 문제를 진단하는 것은 어렵지만 너무 많은
정보를 보여준다면 무심결에 공격자를 도울 수 있다. 보통 최선의 접근 방법은
"접근 거절 (access denied)" 또는 "기타 에러 생성 (miscellaneous error
encountered)" 으로 응답한 후 더욱 세부적인 정보를 감사 로그 (누가 정보를
보는 지에 대해 더욱 많은 제어를 할 수 있다) 에 기록하는 것이다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AVOID-RACE"
>6.8. 경쟁 상태를 피해라</A
></H2
><P
>&#13;``경쟁 상태 (race condition)" 는 "이벤트들의 상대적인 타이밍에 대한
돌발적인 임계 의존성때문에 발생하는 이상한 동작" 으로 정의될 수 있다
[FOLDOC]. 경쟁 상태는 일반적으로 파일 또는 변수와 같은 공유 자원을
접근하는 하나 또는 그 이상의 프로세스를 포함하는데 이러한 다중 접근이
적절히 제어되지 않는 것이다.&#13;</P
><P
>&#13;일반적으로 프로세스는 원자적으로 (atomically) 실행되지 않는데 다른
프로세스가 본래 어떤 두 명령 사이에서 이를 인터럽트할 수도 있다.
보안적인 프로그램의 프로세스가 이러한 인터럽션에 대비하지 않았다면 다른
프로세스가 이 프로세스를 방해할 수도 있다. 다른 프로세스의 임의의 코드가
두 연산 사이에 실행된다 하더라도 모든 연산쌍이 실패해서는 안된다.&#13;</P
><P
>&#13;경쟁 상태 문제는 개념적으로 다음의 두 범주로 분류할 수 있다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;신뢰되지 않은 프로세스에 의한 간섭. 어떤 보안 분류법은 이 문제를
``시퀀스 (sequence)" 또는 "비원자적 (non-atomic)" 상태라고 부른다. 이는
다른 여러가지 프로그램들을 실행하고 있는 프로세스들에 의해 야기되는
상태로 보안적인 프로그램의 단계들 사이에 다른 동작을 몰래 넣는 것으로
이러한 다른 프로그램들은 문제를 야기하려는 공격자에 의해 호출될 수도
있다. 이 책은 이를 시퀀싱 (sequencing) 문제라고 부를 것이다.&#13;</P
></LI
><LI
><P
>&#13;신뢰된 프로세스에 의한 간섭 (보안적인 프로그램의 관점에서). 어떤
분류법은 이를 교착 상태 (deadlock), livelock 또는 locking failure
상태라고 부른다. 이는 동일한 프로그램을 실행하고 있는 프로세스들에 의해
야기되는 상태이다. 이러한 다른 프로세스들이 동일한 권한을 가질 수도 있기
때문에 적절히 제어되지 않는다면 다른 프로그램들이 실행될 수 없게끔 
서로를 간섭할 수 있다. 때때로 이러한 유형의 간섭이 악용될 수 있다. 이
책은 이를 로킹 (locking) 문제라고 부를 것이다.&#13;</P
></LI
></UL
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="NON-ATOMIC"
>6.8.1. 시퀀싱 (비원자적) 문제</A
></H3
><P
>&#13;일반적으로 모든 연산쌍에 대해 임의의 코드가 이들 사이에서 실행될 때
코드가 실패할 수 있는지 검사해야 한다.&#13;</P
><P
>&#13;공유 변수 적재 및 저장은 보통 별개의 연산으로 구현되며 원자적이 아님을
주목해라. 이는 ``증가 변수 (increment variable)" 연산이 보통 적재, 증가
그리고 저장 연산으로 변환됨을 의미하며 따라서 변수 메모리가 공유된다면 다른
프로세스가 증가하기를 간섭할 수도 있다.

 </P
><P
>&#13;보안적인 프로그램이 요청이 허가되었는지를 결정해야 하며 그렇다면 그
요청에 따라 작동해야 한다. 신뢰되지 않은 사용자가 프로그램이 요청에
따라 작동하기 전에 허가권 결정에 사용되는 어떤 것도 변경시킬 수 있는
방법은 없어야 한다. 이러한 유형의 경쟁 상태는 때때로 "time of check -
time of use" (TOCTOU) 경쟁 상태로 지칭된다.&#13;</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="ATOMIC-FILESYSTEM"
>6.8.1.1. 파일시스템에서의 원자적 동작</A
></H4
><P
>&#13;원자적 동작을 수행할 수 없다는 문제는 파일시스템에서도 되풀이하여
나온다. 일반적으로 파일시스템은 많은 프로그램들이 사용하는 공유 자원으로
어떤 프로그램들은 다른 프로그램들이 이를 사용하는 것을 간섭할 수도 있다.
보안적인 프로그램들은 허가된 요청인지를 결정하기 위해 access(2) 를
사용하는 것을 피해야 한다. 다음 호출은 open(2) 로 사용자들이 아마도
심볼릭 링크 또는 자신들이 선택한 파일을 생성함으로써 access(2) 와
open(2) 호출 사이에 파일을 자주 옮길 수도 있기 때문이다. 보안적인
프로그램은 대신 자신의 유효 id 또는 파일시스템 id 를 설정한 후
직접적으로 open 함수를 호출해야 한다. access(2) 를 안전하게 사용하는
것은 가능한데 단지 사용자가 파일 또는 파일시스템 루트로부터 경로에
존재하는 모든 디렉토리에 영향을 미칠 수 없을 때만 가능하다.&#13;</P
><P
>&#13;파일을 생성할 때는 O_CREAT | O_EXCL 모드를 사용해서 열고
단지 매우 제한된 허가 (단지 현재 사용자에게만) 를 주어야 한다; 또한 open
실패에 대비할 필요가 있다. 파일을 오픈할 필요가 있다면 (예, 서비스
부인을 예방하기 위해) 반복적으로 ``임의의" 파일 이름을 생성해, 이 이름의 파일을 
오픈하고 오픈 성공시 이러한 반복을 중지할 필요가 있다.&#13;</P
><P
>&#13;일반 프로그램들은 파일을 적절히 생성하지 않는 경우 보안 약점을 가질 수
있다. 예를 들어 ``joe" 텍스트 편집기는 "DEADJOE" 심볼릭 링크 취약성이라고
불리는 약점을 갖고 있다. 시스템 크래쉬, xterm 닫기 또는 네트워크 연결
끊김과 같이 비표준 방식으로 joe 가 종료될 때 joe 는 오픈 버퍼를
"DEADJOE" 파일에 무제한으로 덧붙일 수 있다. 이는 루트가 일반적으로 joe
를 사용할 수 있는 디렉토리에 DEADJOE 심볼릭 링크를 생성함으로써 악용될
수 있다. 이러한 방법으로 joe 는 가비지를 잠재적으로 문제가 될 수 있는
파일에 덧붙이는데 사용될 수 있으며 이는 서비스 부인 및/또는 본의아닌
접근을 야기할 것이다.&#13;</P
><P
>&#13;다른 예로서 파일의 메타 정보에 일련의 연산 (소유자 변경, 파일 stat-ing
또는 허가권 비트 변경과 같은) 을 수행할 때 우선 파일을 오픈한 후 이에
연산을 적용해라. 이는 chown(), chgrp() 와 chmod() 와 같이 파일 이름을
취하는 함수들 대신 fchown(), fstat() 또는 fchmod() 시스템 호출을
사용한다는 것을 의미하며 프로그램을 작동시키는 도중에 파일이 대체되는
것을 막을 수 있을 것이다 (가능한 경쟁 상태). 예를 들어 파일을 닫은 후
chmod() 를 사용해서 허가권을 변경한다면 공격자가 이 두 단계 사이에 파일을
이동 및 제거해서 다른 파일 (/etc/passwd 과 같은) 에 대한 심볼릭 링크를
생성할 수도 있다. 다른 재미있는 파일은 /dev/zero 로 이는 프로그램에
무한히 긴 입력 데이타 스트림을 제공할 수 있다; 공격자가 파일의 중간
스트림을 ``교환" 할 수 있다면 결과는 위험할 수 있다.&#13;</P
><P
>&#13;그러나 이는 복잡해진다 - 파일들을 생성할 때 이들에게 가능한 최소한의
권한셋을 주어야 하며 그 후 원할 때 권한을 더욱 확대 변경해야 한다.
일반적으로 이는 단지 사용자와 사용자 그룹에 대해 초기 접근을 제한하기
위해 umask 및/또는 open 매개변수를 사용해야 함을 의미한다. 예를 들어
초기에 모두 다 읽을 수 있는 파일을 생성한 후 ``world-readable" 비트를
없애려고 하면 허가권 비트가 무방하다고 말한 동안에 공격자는 파일을 오픈하려고 할
수 있다. 대부분의 유닉스 계열 시스템에서 허가권은 오픈시에만 검사되는데
따라서 공격자가 의도한 것보다 더욱 많은 권한을 갖게 될 것이다.&#13;</P
><P
>&#13;일반적으로 다수의 사용자가 유닉스 계열 시스템의 디렉토리에 쓰기를 할 수
있으려면 그 디렉토리에 ``sticky" 비트를 설정하는 것이 더욱 좋을 것이다.
이러한 sticky 디렉토리는 더욱 잘 구현되어왔다. 그러나 문제를 완전히
피하는 것이 더욱 좋은데 단지 신뢰된 특별 프로세스만이 접근할 수 있는
디렉토리를 만들어라 (그 후 이를 주의깊게 구현해라). 전통적인 유닉스의
일시적인 디렉토리 (/tmp 와 /var/tmp) 는 보통 ``sticky" 디렉토리로
구현되지만 다음에 보듯이 모든 유형의 모든 문제가 역시 표면화할 것이다.&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="TEMPORARY-FILES"
>6.8.1.2. 임시 파일</A
></H4
><P
>&#13;원자적 연산을 정확히 수행하는 문제는 임시 파일들을 생성할 때 특히
나타난다. 유닉스 계열 시스템에서 임시 파일들은 모든 사용자들이 공유하는
/tmp 또는 /var/tmp 디렉토리에 일반적으로 생성된다. 공격자들이 공통적으로
사용하는 수법은 보안적인 프로그램이 작동하는 동안 임시 디렉토리내에 어떤
다른 파일 (예, /etc/passwd) 에 대한 심볼릭 링크를 생성하는 것이다.
공격자의 목적은 보안적인 프로그램이 주어진 파일 이름이 존재하지 않는다고
결정할 상황을 만드는 것으로 공격자가 다른 파일에 대한 심볼릭 링크를 만든 후에 
보안적인 프로그램이 어떤 연산을 수행 (그러나 실제로는 의도하지 않은 파일을
오픈했다) 하게 된다. 때때로 중요한 파일들은 이런식으로
타격을 받거나 수정될 수 있다. 일반 파일 생성과 같이 이 공격의 많은
변형이 있는데 이들은 모두 공격자가 임시 파일들에 대해 보안적인
프로그램이 사용하는 동일 디렉토리에 파일시스템 객체를 생성 (또는 접근)
할 수 있다는 개념에 기초한다.&#13;</P
><P
>&#13;이러한 공유 디렉토리에 파일들을 생성할 때 일반적인 문제는 사용하려고
하는 파일 이름이 생성시 이미 존재하지 않음을 보장해야 한다는 것이다.
파일 생성 전에 이를 검사하는 것은 효과적이지 않은데 이는 검사 후에 그러나 
생성 전에 다른 프로세스가 그 파일 이름을 갖는 파일을 생성할 수 있기 때문이다. 
``예측할 수 없는" 또는 ``유일한" 파일 이름 사용도 다른 프로세스가 성공할 때까지
반복적으로 이름을 추측할 수 있기 때문에 일반적으로 효과적이지 않다.&#13;</P
><P
>&#13;기본적으로 공유 (sticky) 디렉토리에 임시 파일을 생성하기 위해서는 (1)
``임의의" 파일 이름 생성, (2) O_CREAT | O_EXCL 및 매우
제한된 허가권을 사용한 오픈 및 (3) 오픈 성공시 중지 이들을 반복적으로
해야한다.&#13;</P
><P
>&#13;1997 년 ``Single Unix Specification" 에 따르면 임의의 임시 파일을 생성할
때 선호되는 방법은 tmpfile(3) 이다. tmpfile(3) 함수는 임시 파일을
생성하여 해당 스트림을 오픈하며 그 스트림을 반환한다 (반환하지 않는다면
NULL). 불행히도 스펙은 파일이 보안적으로 생성될 것인지에 대해 아무런
보장도 하지 않고 있는데 저자 자신도 모든 구현이 이를 안전하게 하는지
보증할 수 없기 때문에 염려하고 있다고 이 책의 초기 버전에서 말했다. 
그 후 예전 System V 시스템이 tmpfile(3) (와 tmpnam(3) 및tempnam(3)) 를 
비보안적으로 구현했음을 발견했다. tmpfile(3)의 라이브러리 구현은 임시 파일을 
보안적으로 생성해야 하지만 사용자가 시스템 라이브러리가 이러한 보안 결점을 
갖고 있다고 늘 인식하지는 못하며 때때로 사용자가 할 수 있는 것은 아무 것도 없다.&#13;</P
><P
>&#13;Kris Kennaway 는 일반적으로 임시 파일들을 만들때 mkstemp(3) 를
사용하라고 추천한다. 그의 논리적 근거는 이 태스크를 수행하기 위해서는
각자의 함수를 돌리는 대신 잘 알려진 라이브러리 함수를 사용해야 하며 이
함수가 잘 알려진 의미 체계를 갖고 있다는 것이다. 이는 확실히 근거있는
견해이다. 저자는 mkstemp(3) 를 사용하려면 단지 소유자에게만 임시 파일 허가권을 
제한하기 위해 반드시 umask(2) 를 사용하라고 덧붙인다.
이는 mkstemp(3) 의 몇몇 구현 (기본적으로 예전 구현) 이 임시 파일을 all readable 및 
writable 하게 만들어 공격자가 디렉토리내에 비밀 자료를 읽거나 쓸 수 있는 상태를 
만들 수 있기 때문이다.
약간 귀찮은 것은 mkstemp(3) 가 환경 변수 TMP 또는 TMPDIR 를 직접적으로 지원하지 
않는다는 것인데 따라서 환경 변수를 지원하려면 코드를 추가해야 한다. 
다음은 이러한 목적 및 TMP 와 TMPDIR 에 대한 지원을 추가할 때 mkstemp(3) 
를 사용하는 방법을 설명하는 C 프로그램이다.&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;sys/types.h&#62;
#include &#60;sys/stat.h&#62;

void failure(msg) {
 fprintf(stderr, "%s\n", msg);
 exit(1);
}

/*
 * 임시 파일이름에 대한 "패턴"이 주어지면
 * (디렉토리 위치로 시작해 XXXXXX 로 끝나는)
 * 파일을 생성해 이를 반환해라.
 * 이 루틴은 파일을 언링크시키며 따라서 보통 디렉토리 리스팅시
 * 이 파일은 보이지 않을 것이다.
 * 패턴은 최종 파일이름을 보이도록 변경될 것이다.
 */

FILE *create_tempfile(char *temp_filename_pattern)
{
 int temp_fd;
 mode_t old_mode;
 FILE *temp_file;

 old_mode = umask(077);  /* 제한적인 허가권을 갖는 파일을 생성 */
 temp_fd = mkstemp(temp_filename_pattern);
 (void) umask(old_mode);
 if (temp_fd == -1) {
   failure("Couldn't open temporary file");
 }
 if (!(temp_file = fdopen(temp_fd, "w+b"))) {
   failure("Couldn't create temporary file's file descriptor");
 }
 if (unlink(temp_filename_pattern) == -1) {
   failure("Couldn't unlink temporary file");
 }
 return temp_file;
}


/*
 * "태그" (XXXXXX 로 끝나는 상대적 파일 이름) 가 주어지면
 * 태그를 사용해 임시 파일을 생성한다. 환경 변수 TMP 또는
 * TMPDIR 에 정의되어 있고 setuid/setgid 가 아니라면 이 변수에
 * 지정된 디렉토리에 파일이 생성될 것이다.
 * 그렇지 않은 경우는 /tmp 디렉토리에 생성될 것이다.
 * 루트 (및 su 된 루트) 는 TMPDIR or TMP (이 정의되어 있다면)
 *  를 사용할 것임을 주목해라.
 */
FILE *smart_create_tempfile(char *tag)
{
 char *tmpdir = NULL;
 char *pattern;
 FILE *result;

 if ((getuid()==geteuid()) &#38;&#38; (getgid()==getegid())) {
   if (! ((tmpdir=getenv("TMPDIR")))) {
     tmpdir=getenv("TMP");
   }
 }
 if (!tmpdir) {tmpdir = "/tmp";}

 pattern = malloc(strlen(tmpdir)+strlen(tag)+2);
 if (!pattern) {
   failure("Could not malloc tempfile pattern");
 }
 strcpy(pattern, tmpdir);
 strcat(pattern, "/");
 strcat(pattern, tag);
 result = create_tempfile(pattern);
 free(pattern);
 return result;
}



main() {
 int c;
 FILE *demo_temp_file1;
 FILE *demo_temp_file2;
 char demo_temp_filename1[] = "/tmp/demoXXXXXX";
 char demo_temp_filename2[] = "second-demoXXXXXX";

 demo_temp_file1 = create_tempfile(demo_temp_filename1);
 demo_temp_file2 = smart_create_tempfile(demo_temp_filename2);
 fprintf(demo_temp_file2, "This is a test.\n");
 printf("Printing temporary file contents:\n");
 rewind(demo_temp_file2);
 while (  (c=fgetc(demo_temp_file2)) != EOF) {
   putchar(c);
 }
 putchar('\n');
 printf("Exiting; you'll notice that there are no temporary files on exit.\n");
}</PRE
></TD
></TR
></TABLE
><P
>&#13;Kennaway 는 mkstemp(3) 를 사용할 수 없다면 mkdtemp(3) 를 사용하여 
외부로부터 보호되는 디렉토리를 각자 만들라고 언급하고 있다. 마지막으로 실제
비보안적인 mktemp(3) 를 사용해야 한다면 많은 X 를 사용해라 - 그는 파일
이름이 쉽게 추측될 수 없도록 10 (libc 가 이를 허용한다면) 을 제안하고
있다 (단지 6 개의 X 를 사용한다는 것은 5 개를 PID 가 차지하여 단지
한개의 임의 문자를 남기고 공겨자로 하여금 손쉽게 경쟁 상태를 허용함을
의미한다). 저자는 tmpname(3) 사용을 피해야 한다고 부언한다 - 이들 사용의
일부는 쓰레드가 존재할 때 신뢰할 수 없으며 TMP_MAX 사용 (가장
실용적으로 사용하는 것은 루프 내에서이다) 후에 적절히 작동할 것이라고
보장하지 않는다.&#13;</P
><P
>&#13;일반적으로 mktemp(3) 또는 tmpnam(3) 과 같은 함수의 비보안성에 대처할
특별한 조치를 취하지 않았거나 보안적인 라이브러리 구현을 설치 작업의 일부분으로 
테스트하지 않았다면 이들의 사용을 피해야 한다. 그럼에도 /tmp 또는 
world-writable 디렉토리 (또는 그룹을 신뢰하지 않는 경우
group-writable) 내에 파일을 만들려고 하면서 mk*temp() 를 사용하지 않으려고 한다면
(예, 파일 이름이 예측될 수 있게 하려면) 늘 open() 에 O_CREAT 와
O_EXCL 플래그를 사용하고 반환값을 검사해라. open() 호출을 할 수 
없다면 원래대로 복귀해라 (예, exit).&#13;</P
><P
>&#13;GNOME 프로그래밍 지침은 공유 (임시) 디렉토리에 보안 오픈 임시 파일들에
대한 파일시스템 객체를 생성할 때 다음 코드를 추천한다[Quintero 2000]:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> char *filename;
 int fd;

 do {
   filename = tempnam (NULL, "foo");
   fd = open (filename, O_CREAT | O_EXCL | O_TRUNC | O_RDWR, 0600);
   free (filename);
 } while (fd == -1);</PRE
></TD
></TR
></TABLE
><P
>&#13;비보안적인 tempnam(3) 함수가 사용되고 있음에도 불구하고 보안 약점에
대처하기 위해 O_CREAT 와 O_EXCL 을 사용하여 루프내에서
wrapped 됨을 주목해라. 파일 이름을 free() 할 필요가 있음을 주목해라.
작업을 마친 후 파일을 close() 및 unlink() 해야 한다. 표준 C I/O
라이브러리를 사용하길 원한다면 파일 기술자를 FILE * 로 변환시키기 위해
"w+b" 모드로 fdopen() 을 사용할 수 있다. 이 접근 방법은 예전 NFS 가
정확히 O_EXCL 을 지원하지 않기 때문에 NFS 버전 2 에서는
작동되지 않음을 주목해라. 한가지 중요하지 않은 단점은 tempnam 이
비보안적으로 사용될 수 있기 때문에 다양한 컴파일러와 보안 스캐너가 이
사용에 대해 가짜 경고를 줄 수 있음을 주목해라. 이러한 문제는 mkstemp(3)
에는 없다.&#13;</P
><P
>&#13;쉘 스크립트에서 임시 파일이 필요하다면 파이프, 지역 디렉토리 (예, 사용자
홈디렉토리 내부의 어떤 디렉토리) 또는 어떤 경우에는 현재 디렉토리를
사용하는 것이 아마 가장 좋다. 이런 방식에서는 사용자가 허용하지
않는다면 어떠한 공유하는 것도 없다. 정말로 /tmp 와 같은 공유
디렉토리내에 임시 파일을 원하거나/필요하다면 템플릿에 프로세스 id 를
사용해서 단지 "&#62;" 같은 일반 연산자를 사용하여 파일을 생성하는
전통적인 쉘 기법을 사용하지 마라. 쉘 스크립트가 PID 를 지정하기 위해
"$$" 를 사용할 수 있지만 PID 는 동일한 이름을 갖는 파일 또는 링크를 미리
생성할 수 있는 공격자에 의해 쉽게 결정 또는 추측될 수 있다. 따라서
다음의 "일반적인" 쉘 스크립트는 안전하지 않다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   echo "This is a test" &#62; /tmp/test$$  # DON'T DO THIS.</PRE
></TD
></TR
></TABLE
><P
>&#13;쉘 스크립트에 임시 파일 또는 디렉토리가 필요가고 이를 /tmp 밑에 놓길
원한다면 쉘 스크립트에서 사용할 목적으로 만들어진 mktemp(1) 가 아마도
해결책이다. mktemp(1) 과 mktemp(3) 은 다른 함수임을 주목해라 - 안전한 
함수는 mktemp(1) 이다. 솔직히
저자는 공유 디렉토리에 임시 파일을 생성하는 쉘 스크립트에 흥미를 느끼지
않는다; 기밀 디렉토리에 이러한 파일을 생성하거나 대신 파이프를 사용하는
것이 일반적으로 바람직하다. 그러나 정말로 이렇게 하고 싶다면 다음을
사용해라; mktemp(1) 은 템플릿을 취한 후 O_EXCL 을 사용해서 파일
또는 디렉토리를 생성하고 그 이름을 반환한다; 이는 O_EXCL 을
사용하기 때문에 디렉토리가 NFS 버전 2 를 사용하지 않는다면 /tmp 같은
공유 디렉토리에 대해 안전한다. 다음 Bourne 쉘 스크립트에서 mktemp(1) 을
정확히 사용한 예이다; 이 예는 mktemp(1) 맨 페이지에서 얻을 수 있다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> # mktemp(1) 의 간단한 사용예로 스크립트가 안전한 임시 파일을
 # 얻을 수 없다면 종료하는 스크립트이다.

   TMPFILE=`mktemp /tmp/$0.XXXXXX` || exit 1
   echo "program output" &#62;&#62; $TMPFILE

  # 에러를 잡으려고 하는 경우의 간단한 예:

   TMPFILE=`mktemp -q /tmp/$0.XXXXXX`
   if [ $? -ne 0 ]; then
      echo "$0: Can't create temp file, exiting..."
      exit 1
   fi</PRE
></TD
></TR
></TABLE
><P
>&#13;처음에 보안적인 임시 파일 이름을 얻었다고 하더라도 이 이름을 재사용하지
마라 (제거한 후 다시 생성해라). 공격자가 두번째로 이를 재생성하기 전에 원래
파일 이름을 보고 있다가 이를 낚아챌 수 있다. 물론 늘 적절한 파일 허가권을 
사용해라. 예를 들어 파일에 world 또는 group 접근이 필요하다면
world/group 접근만 허용해라 그렇지 않다면 0600 모드로 유지해라 (즉,
소유자만이 읽고 쓸 수 있다).
 </P
><P
>&#13;디렉토리 엔트리는 없어지지만 이를 가리키고 있는 마지막 파일 기술자가
닫힐 때까지 파일 자체는 접근할 수 있도록 exit 핸들러를 사용하거나 유닉스
파일시스템 의미 체계 사용 및 생성 후 즉각적으로 파일을 unlink() 함으로써
스스로 정리해라. 
파일 기술자를 건네줌으로써 프로그램내에서 이를 계속해서
접근할 수 있는데 파일을 unlinking 하는 것은 코드 유지 보수에 많은 장점이
있다: 프로그램의 크래시 여부에 상관없이 파일은 자동적으로 지워진다.
즉각적인 unlinking 과 관련된 한가지 사소한 문제는 관리자가 단순히
이름만으로 파일시스템을 조사할 수 없기 때문에 관리자가 얼마나 많은 디스크
공간이 사용되고 있는지 보는 것을 어렵게 한다는 것이다. &#13;</P
><P
>&#13;유닉스 계열 시스템의 코드는 TMP 또는 TMPDIR 환경변수 값들의 제공자가
신뢰된다면 이들을 침해하지 않음을 보증하는 것을 고려할 수 있다. 이렇게
함으로써 사용자가 그들의 임시 파일을 그들의 홈디렉토리내 하부디렉토리와
같은 비공유디렉토리로 이동하는 것을 가능하게 한다. 최근 Bastille
버전에서는 사용자들간의 공유를 제한하기 위해 이러한 변수들을 설정할
수 있다. 
불행히 많은 사용자들은 TMP 또는 TMPDIR 을 /tmp 와 같은 공유
디렉토리로 설정하는데 따라서 이러한 환경 변수가 설정된다 하더라도
보안적인 프로그램이 정확히 임시 파일을 생성해야 한다. 이는 GNOME 접근
방법의 장점 중의 하나로 적어도 어떤 시스템에서 tempnam(3) 이 자동적으로
TMPDIR 을 사용하는 반면 mkstemp(3) 접근 방법은 이를 하기 위해 더욱 많은
코드를 필요로 하기 때문이다. 임시 디렉토리를 위해 더욱 많은 환경 변수들
(TEMP 와 같은) 을 생성하지 않기를 바라며 특히 각각의 애플리케이션에 대해
다른 환경 이름을 생성하지 않기를 바란다 (예, MYAPP_TEMP 를
사용하지 마라). 이렇게 하는 것은 시스템 관리를 굉장히 복잡하게 하는데
특정 애플리케이션을 위해 특별 임시 디렉토리를 원하는 사용자는 그
애플리케이션을 운용할 때에 한해 환경 변수를 설정할 수 있다. 물론 이러한
환경 변수가 신뢰되지 않은 소스에 의해 설정된다면 이들을 무시해야 한다 -
<A
HREF="#ENV-VAR-SOLUTION"
>4.2.3&#51208;</A
> 의 충고를 따른다면 어떤 방식으로든 할
수 있다.&#13;</P
><P
>&#13;이러한 기법은 임시 디렉토리가 NFS 버전 2 (NFSv2) 를 사용해서 원격적으로
마운트된다면 작동하지 않는데 NFSv2 가 O_EXCL 을 적절히 지원하지
않기 때문이다. 더욱 자세한 정보는 <A
HREF="#LOCKING-USING-FILES"
>6.8.2.1&#51208;</A
>
을 보라. NFS 버전 3 이상은 O_EXCL 을 적절히 지원한다; 간단한
해결 방법은 임시 디렉토리가 로컬이거나 NFS 를 사용해 마운트된 경우 NFS
버전 3 이상을 사용해서 마운트되는 지를 보증하는 것이다. NFS v2 에서
link(2) 와 stat(2) 를 사용함으로써 안전하게 임시 파일을 생성하는 기법이
있지만 복잡하다; 이에 대해 더욱 자세한 정보는 <A
HREF="#LOCKING-USING-FILES"
>6.8.2.1&#51208;</A
> 을 보라.&#13;</P
><P
>&#13;여담으로 FreeBSD 가 파일이름의 PID 컴포넌트 제거 및 전체를 base-62
인코드 randomness 로 대체하기 위해 mk*tem() 계열 함수를 최근에
변경했음을 언급하는 것은 가치가 있다. 이는 과감하게 6 X 의 디폴트
사용법에 대해 가능한 임시 파일의 수를 증가시키며 매우 빈번히 사용하는 경우를
제외하고는 6 X 를 갖는 mktemp(3) 가 추측에 합리적으로 (통계적으로)
보안적임을 의미한다. 그러나 이 문서의 지침을 따른다면 문제를 제거할 수
있다.&#13;</P
><P
>&#13;임시 파일에 대한 이 정보의 많은 부분은 <A
HREF="http://lwn.net/2000/1221/a/sec-tmp.php3"
TARGET="_top"
>Kris Kennaway's posting to
Bugtraq about temporary files on December 15, 2000</A
> 에서
유래한다.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LOCKING"
>6.8.2. 로킹</A
></H3
><P
>&#13;
프로그램이 파일, 디바이스 및/또는 특별한 서버 프로세스에 대해 유일한
권한을 갖음을 보장해야하는 상황이 종종 있다. 자원을 잠그는 모든 시스템은
프로그램이 로크 (lock) 를 정리하지 못한다면 로크, 더 자세히 말하면 교착
상태 (deadlocks("deadly embraces")), livelocks 와 releasing "stuck"
로크들의 표준적인 문제를 다뤄야 한다. 교착 상태는 프로그램들이 자원들을
해제하기 위해 서로 기다리면서 교착되어 있다면 일어날 수 있다. 예를 들어
교착 상태는 프로세스 1 이 자원 A 를 로크하며 자원 B 를 기다리는 반면
프로세스 2 는 자원 B 를 로크하며 자원 A 를 기다리고 있다면 발생할 수
있다. 많은 교착 상태는 다중 자원을 로크하는 모든 프로세스들에게 그들을
동일한 순서 (예, 알파벳 이름순으로) 로 로크하도록 요구함으로써 예방될 수
있다.&#13;</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="LOCKING-USING-FILES"
>6.8.2.1. 로크로서 파일 사용</A
></H4
><P
>&#13;유닉스 계열 시스템에서 자원 로킹 (잠금, locking) 은 전통적으로 로크를
지정하는 파일을 생성함으로써 전통적으로 이루어졌는데 이러한 방법이 매우
이식성이 높기 때문이다. 이는 관리자가 어떤 로크가 설정되었는지 보기 위해
단지 파일시스템만 검사하면 되기 때문에 교착된 로크를 정리하는 것을 쉽게
한다. 교착된 로크는 프로그램이 실행 후 정리하는데 실패하거나 (예, 크래시
또는 오기능 (malfunctioned)) 전체 시스템이 정지했기 때문에 발생할 수
있다. 이들이 권고 (advisory) 로크 (강제 (mandatory) 로크가 아닌) 임을 주목해라 - 모든
프로세스는 자원이 이러한 로크를 사용하기 위해 협력해야 함을 필요로한다.&#13;</P
><P
>&#13;그러나 피할 수 있는 몇몇 속임수가 있다. 첫번째 creat() 함수 호출 또는
파일 모드를 0 으로 설정하고 (허가권 없음) O_WRONLY |
O_CREAT | O_TRUNC open() 모드인 open() 등가 함수를
호출하는 유닉스 C 프로그램의 매우 오래된 기법을 사용하지 마라. 일반적인
파일시스템에서 일반 사용자에게 이는 작동하지만 사용자가 루트 권한을 가질
때 파일을 로크할 수 없다. 루트는 파일이 이미 존재할 때라도 늘 이 연산을
수행할 수 있다. 사실 오래된 유닉스 버전들은 오래된 에디터 "ed" 에 이러한
특별한 문제를 갖고 있다 -- 증상은  때때로 패스워드 파일의 일부분이
사용자 파일내에 놓일 수 있는 것이다 [Rochkind 1985, 22]. 대신 지역적
파일시스템에서 프로세스에 대한 로크를 생성하려면 O_WRONLY |
O_CREAT | O_EXCL 플래그를 갖고 open() 을 사용할 수 있다
(동일한 소유자의 다른 프로세스들이 로크를 할 수 없도록 허가권은 없다).
독점적인 파일을 생성하는 공식적인 방식인 O_EXCL 의 사용을
주목해라; 이는 로컬 파일시스템에서 루트에 대해서도 작용한다 [Rochkind
1985, 27].&#13;</P
><P
>&#13;두번째 로크 파일이 NFS 로 마운트된 파일시스템에 있다면 NFS 버전 2 가
일반 파일 의미 체계를 완벽히 지원하지 않는다는 문제를 갖는다. 이는
클라이언트에 로컬이라고 간주되는 작업에 대해서도 문제가 되는데 어떤
클라이언트가 로컬 디스크를 갖지 못하고 모든 파일이 NFS 를 통해
원격적으로 마운트될 수도 있기 때문이다. <B
CLASS="EMPHASIS"
>open(2)</B
> 메뉴얼은 이런 경우 처리 방법을 설명한다
(루트 프로그램의 경우도 또한 다룬다):&#13;</P
><P
><SPAN
CLASS="QUOTE"
>""로킹 태스크를 수행하기 위해 [open(2) 의 O_CREAT 와 O_EXCL
플래그] 에 의존하는 프로그램들은 경쟁 상태를 포함할 것이다. 로크파일을
사용해서 원자적 파일 로킹을 수행하기 위한 해결 방안은 동일
파일시스템에서 유일한 파일을 생성하고 (예, 호스트네임과 pid 를 병합),
로크파일에 대한 링크를 만들기 위해 link(2) 를 사용한 후 그 링크 카운트가
2 로 증가되었는지 검사하기 위해 유일한 파일에 stat(2) 를 사용하는
것이다. link(2) 호출의 반환값을 사용하지 마라"
"</SPAN
></P
><P
>&#13;
명백히 이 해결방안은 로킹을 하는 모든 프로그램이 협동하고 모든 협동하지
않는 프로그램들의 간섭이 허용되지 않는 경우에만 작용한다. 특히 파일
로킹을 위해 사용하고 있는 디렉토리는 파일 생성 및 제거를 위한 허용된
파일 허가권을 가져서는 안된다.&#13;</P
><P
>&#13;NFS 버전 3 은 open(2) 에 O_EXCL 모드에 대한 지원이 추가하였다;
IEFT RFC 1813 을 보라 특히 "CREATE" 의 "mode" 인수에 대한 "EXCLUSIVE"
값을 보라. 슬프게도 모든 사람이 이 문서를 작성하는 시점에 NFS 버전 3
이상으로 전환하지 않았으며 따라서 이식성있는 프로그램에서는 아직까지 이에
의존할 수 없다. 결국은 이 문제는 없어질 것이다.&#13;</P
><P
>&#13;디바이스 또는 로컬 머신에서 프로세스의 존재를 로킹하려면 표준적인 합의를
사용하도록 해라. 저자는 FHS 를 사용하기를 추천한다; 이는 리눅스 시스템에
의해 널리 참조되고 있으며 또한 다른 유닉스 계열 시스템의 개념을
병합하려고 하고 있다. FHS 는 파일들에 대한 파일 네이밍, 위치 및 표준
컨텐츠를 포함해서 파일 로킹 등에 대해 표준적인 합의를 기술한다 [FHS
1997]. 서버가 주어진 머신에서 한번 이상 실행되지 않았음을 확인하려 
한다면 보통 컨텐츠와 같이 pid 를 갖는 /var/run/NAME.pid 프로세스
식별자를 생성해야 한다. 동일 맥락으로 디바이스 로크 파일 등을 위해 로크
파일을 /var/lock 밑에 놓아야 한다. 이 접근 방법은 프로그램이 갑자기
정지하는 경우 파일들이 쓸데없이 시간을 보내게 하는 단점이 있지만 이는 
표준적인 합의로 다른 시스템 도구에 의해 쉽게 다뤄진다.&#13;</P
><P
>&#13;로크를 나타내기 위해 파일 사용에 협동하고 있는 프로그램들은 동일한
디렉토리 이름만이 아니라 동일한 디렉토리를 사용하는 것이 중요하다. 이는
네트워크화된 시스템에 관련된 문제이다. FHS 는 명시적으로 /var/run 과
/var/lock 는 공유할 수 없는 반면 /var/mail 은 공유할 수 있다고 언급한다.
따라서 하나의 머신에서 로크가 작동하길 원하지만 다른 머신을 간섭하지
않길 원한다면 /var/run 과 같은 공유할 수 없는 디렉토리를 사용해라 (예,
각 머신에게 자신의 서버를 구동하도록 허용하길 원하는 경우). 그러나
네트워크에서 파일을 공유하는 모든 머신들이 로크를 따르길 원한다면
공유하고 있는 디렉토리를 사용할 필요가 있다; /var/mail 이 이러한
위치이다. 이 주제에 대해 더욱 자세한 정보를 얻기 위해서는 FHS 절을
보라.&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="OTHER-LOCKING"
>6.8.2.2. 로킹에 대한 다른 접근 방법</A
></H4
><P
>&#13;물론 로크를 나타내기 위해 파일을 사용할 필요는 없다. 네트워크 서버들은
대개 신경쓸 필요가 없다: 단지 포트에 바인딩한다는 것만이 일종의 로크로서
작용하는데 주어진 포트에 바운드된 기존 서버가 있다면 어떠한 다른 서버도
이 포트에 바인딩 할 수 없기 때문인다.&#13;</P
><P
>&#13;로킹에 대한 다른 접근 방법은 "discretionary lock" 로서 fcntl(2) 를 통해
구현된 POSIX 레코드 로크를 사용하는 것이다. 이는 임의로, 즉 이를
사용하는 것은 로크를 필요로 하는 프로그램들의 협동을 필요로 한다 (
로크를 나타내기 위해 파일을 사용하는 접근방법과 마찬가지로). POSIX
레코드 로크를 추천하는 많은 이유가 있다: POSIX 레코드 로킹은 거의 모든
유닉스 계열 플랫폼 (POSIX 1 에 의해 강제적으로 요구되는) 에서 지원되며,
전체 파일만이 아닌 파일의 일부분을 로크할 수 있으며 또한 읽기와 쓰기
로크간의 차이를 다룰 수 있다. 더욱 유용한 것은 프로세스가 소멸하면
이 프로세스의 로크도 자동적으로 제거된다는 것으로 이는 보통 원하는
사항이다.&#13;</P
><P
>&#13;System V 의 mandatory 로킹 스킴에 기초한 강제 로크도 또한 사용할 수
있다. 이는 단지 로크된 파일의 setgid 비트가 설정되어 있지만 그룹의 실행 
비트가 설정되어 있지 않은 파일만에 적용된다. 또한 강제 파일
로크를 허용하기 위해 파일시스템을 마운트해야 한다. 이런 경우 모든
read(2) 와 write(2) 는 로킹을 위해 검사된다; 이는 권고 로크보다 더욱
철저하지만 더욱 느리다. 또한 강제 로크는 다른 유닉스 계열
시스템으로 널리 이식되지는 않는다 (리눅스와 System V 에 기초한
시스템에서는 사용할 수 있지만 다른 시스템에서는 필요한 것은 아니다). 루트
권한을 갖는 프로세스는 강제 로크에 의해 또한 정지될 수 있음을
주목해라. 이는 서비스 부인 공격의 기초가 될 수 있게끔 한다.&#13;</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="TRUSTWORTHY-CHANNELS"
>6.9. 단지 신뢰할 수 있는 체널만 신뢰해라</A
></H2
><P
>&#13;일반적으로 신뢰할 수 있는 채널로부터의 정보 (입력 및 결과) 만을 신뢰해라. 
예를 들어 getlogin(3) 및 ttyname(3) 은 지역 사용자에 의해 제어될 수 있는 정보를 
반환하는데 따라서 보안 목적에 맞게 이들을 신뢰하지 마라.&#13;</P
><P
>&#13;대부분의 컴퓨터 네트워크 (및 대개 인터넷의 경우) 에서 인증받지 못한
전송은 신뢰할 수 없다. 예를 들어 인터넷을 통해 전송되는 패킷은 전송중 언제라도 
볼 수 있고 수정될 수 있으며 임의의 새로운 패킷이 변조될 수도 있다. 이러한 변조된 
패킷은 머신 (IP) 주소 및 포트와 같은 송신자 또한 수진자에 대한 변조된 정보를 
포함할 수도 있다. 따라서 이들을 (가령 암호화를 사용해) 인증할 수 없다면 
이러한 값들을 보안 결정을 위한 근본적인 기준으로 사용하지 않아야 한다.&#13;</P
><P
>&#13;이는 특별한 상황을 제외하고는 TCP/IP 에서 사용자 인증을 하는 두 가지 예전 
방법이 유일한 인증 기구로 사용될 수 없음을 의미한다. 한 방법은 데이타 패킷내의 
``from" 머신 주소를 검사함으로써 사용자를 ``특정 머신"으로 제한하는 것이다; 
다른 방법은 송신자가 ``신뢰된" 포트 넘버 (1024보다 작은 넘버) 를 사용하도록 
함으로써 접근을 제한하는 것이다. 문제는 많은 환경에서 공격자가 이러한 값들을 
변조할 수 있다는 것이다.&#13;</P
><P
>&#13;어떤 환경에서는 이러한 값들을 (송신하는 머신 주소 및/또는 포트) 을 검사하는 
것이 상당히 유용할 수 있는데 따라서 프로그램에서 옵션으로 그러한 검사를 
지원하는 것이 나쁜 개념은 아니다. 예를 들어 시스템이 방화벽뒤에서 작동하고 
있고 방화벽이 파괴되거나 우회될 수 없고 방화벽이 내부로부터 왔다고 주장하는 
외부 패킷을 막을 수 있다면 내부로부터 왔다고 말하는 모든 패킷은 실제로 내부에서 
왔다고 주장할 수 있다. 그러나 패킷이 왔다고 주장하는 머신으로부터 
실제로 왔다고 확신할 수는 없음을 주목해라 - 따라서 내부 위협이 아닌 외부 위협에 
대처해야 한다. 파괴된 방화벽, 선택적인 경로 및 모바일 코드는 이러한 가정을 더욱 
의심하게 한다.&#13;</P
><P
>&#13;문제는 누군가를 인증하는 방법으로 신뢰할 수 없는 정보를 지원하고 있는 것이다. 
신뢰되지 않은 네트워크를 통해 신뢰할 수 있는 채널이 필요하다면 어떤
암호화 서비스가 필요하다 (최소한 암호학적으로 안전한 해시); 암호화
알고리듬과 프로토콜에 대한 더욱 자세한 정보는 <A
HREF="#CRYPTO"
>10.5&#51208;</A
> 을
보라. ftp 와 rlogin 과 같은 표준적이지만 본질적으로 비보안적인 프로토콜을 
구현하고 있다면 안전한 디폴트를 제공하고 가정들을 명확하게 문서화해라.&#13;</P
><P
>&#13;DNS (Domain Name Server) 는 컴퓨터 이름과 IP 간의 매핑 (mapping) 을 위해
인터넷에서 널리 사용되고 있다. ``역 (reverse) DNS" 라는 기법은 어떤
간단한 스푸핑 공격을 제거하며 호스트 이름을 결정하는데 있어 유용하다.
그러나 이 기법은 인증 결정을 할만큼 신뢰할 수 있는 것은 아니다. 문제는
결국 DNS 요청이 결과적으로 공격자가 제어할 수도 있는 어떤 원격 시스템으로
보내질 것이라는 것이다. 따라서 DNS 결과를 확인이 필요한 입력으로
처리하고 엄격한 접근 제어를 위해 이를 신뢰하지 마라.&#13;</P
><P
>&#13;임의의 이메일 (주소의 "from" 값들을 포함해) 도 또한 변조될 수 있다.
디지털 인증서 사용이 이러한 많은 공격을 방해하는 방법인데 더욱 손쉬운 
방법은 특별히 임의로 생성된 값을 갖고 이메일이 송수신되야 함을
요구하는 것으로 이는 공개 메일링 리스트에 서명하는 것과 같은 중요하지 않은 
트랜잭션에 대해 보통 허용할 수 있다.&#13;</P
><P
>&#13;CGI 를 포함하여 모든 클라이언트/서버 모델에서 서버는 클라이언트 (또는 
클라이언트와 서버사이에서 중재하는 누군가) 가 모든 값을 수정할 수 있다고 
가정함을 주목해라. 예를 들어 소위 숨겨진 필드와
쿠키 값은 CGI 프로그램이 받기 전에 클라이언트에 의해 변경될 수 있다.
이들은 특별한 예방 조치를 취하지 않았다면 신뢰될 수 없다. 예를 들어
서버가 서명을 검사하는 한 클라이언트가 변조할 수 없도록 숨겨진 필드가
서명될 수 있을 것이다. 숨겨진 필드는 또한 단지 신뢰된 서버만이
복호화할 수 있도록 키를 사용해서 암호화될 수 있다 (이 방법이 Kerberos
인증 시스템의 기본 개념이다). InfoSec 랩은 히든 필드와 암호화 적용에
대해 더욱 깊은 논의를 하고 있다 <A
HREF="http://www.infoseclabs.com/mschff/mschff.htm"
TARGET="_top"
>http://www.infoseclabs.com/mschff/mschff.htm</A
>.
일반적으로 클라이언트/서버 모델에서 관심있는 데이타를 서버쪽에 유지하는
것이 더욱 좋다. 같은 맥락으로 CGI 프로그램에서 인증을 위한
HTTP_REFERER 는 사용자 브라우저 (웹서버가 아닌) 에 의해 보내지기
때문에 이에 의존하지 마라.&#13;</P
><P
>&#13;이 논의는 다른 데이타를 참조하는 데이타에도 또한 적용된다. 예를 들어
HTML 또는 XML 은 참조에 의해 원격적으로 저장될 수도 있는 다른 파일 (예,
DTD 및 스타일시트) 을 포함하도록 한다. 그러나 이러한 외부 참조는
사용자가 의도한 바와 매우 다른 문서를 보도록 수정될 수 있다;
스타일시트가 중요한 위치의 단어들을 여백으로 하고 외양을 흉하게 하거나
새로운 텍스트를 추가하기 위해 수정될 수 있다. 외부 DTD 는 문서의 사용을
방해 (유효성을 깨뜨리는 선언 추가를 통해) 또는 문서에 다른 텍스트를
추가하기 위해 수정될 수 있다 [St. Laurent 2000].&#13;</P
><P
>&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="TRUSTED-PATH"
>6.10. 신뢰된 경로를 설정해라</A
></H2
><P
>&#13;신뢰할 수 있는 채널 (<A
HREF="#TRUSTWORTHY-CHANNELS"
>6.9&#51208;</A
> 를 보라) 이 필요한 
또다른 이유는 사용자가 사용하려고 의도했던 프로그램 또는 시스템을 실제로 
사용하고 있음을 보장하는 것이다.&#13;</P
><P
>&#13;전통적인 예는 ``가짜 로긴" 프로그램이다. 시스템의 로긴 스크린처럼 보이는 
프로그램이 작성된다면 이는 실행된 상태로 남아있을 수 있다. 따라서 사용자가 
로그인하려고 할 때 가짜 로긴 프로그램은 추후 사용을 위해 사용자의 패스워드를 
알아낼 수 있다.&#13;</P
><P
>&#13;이 문제에 대한 해결 방법은 ``신뢰된 경로" 이다. 신뢰된 경로는 공격자가 어떤 정보가 
전해지고 있는지를 가로채거나 수정할 수 없음을 보장하면서 사용자가 통신하려고 
했던 사용자와 통신하고 있다는 확신을 제공한다. &#13;</P
><P
>&#13;패스워드를 요청하려면 신뢰되는 경로를 설정하려고 해라. 
불행히 리눅스와 대부분의 다른 유닉스는 
일반 로긴 과정에서조차 신뢰되는 경로를 갖고 있지 않다. 한가지 접근 
방법은 윈도우 NT/2000 에서 로깅전에 "control-alt-delete" 키를 사용하는 것과 
같이 변조할 수 없는 키를 누르도록 요청하는 것이다; 윈도우에서 일반 프로그램은 
이 키를 가로챌 수 없기 때문에 이러한 접근 방법은 신뢰된 경로를 생성한다. 
리눅스에도 <A
HREF="http://lwn.net/2001/0322/a/SAK.php3"
TARGET="_top"
>Secure Attention Key
(SAK)</A
> 라는 동일한 방법이 있다; ``control-alt-pause" 로 사상되는 것이 
추천된다. 불해이 이 문서 작성 시점에는 SAK 는 미완성이고 리눅스 배포판에 의해 
잘 지원되지 않고 있다. 
신뢰되는 경로를 지역적으로 구현하는 다른 접근 방법은 단지 로그인 
프로그램만이 수행할 수 있는 별도의 화면 표시를 
제어하는 것이다. 예를 들어 단지 신뢰된 프로그램만이 키보드 
light (Num Lock, Caps Lock 및 Scroll Lock 를 나타내는 LED) 를 수정할 수 
있다면 로그인 프로그램은 실제 로그인 프로그램이라는 것을 나타내는 구동 
패턴을 표시할 수 있다. 불행히 현재 리눅스에서 일반 사용자가 LED 를 변경할 
수 있기 때문에 LED 가 신뢰된 경로를 확인하기 위해 사용될 수는 없다. &#13;</P
><P
>&#13;네트워크화된 애플리케이션, 특히 웹 기반 애플리케이션에 대해 신뢰된 경로를 
갖는 것만으로 충분하지 않다고 판명되었다. 
웹 브라우저 사용자로 하여금 실제 어떤 장소에 있지만 사실 이때 다른 장소에 있도록 생각하게 
하는 공인된 방법들이 있다. 예를 들어 Felten [1997] 은 사용자가 어떤 웹 페이지를 
보고 있지만 사실 이때 그들이 보는 모든 웹 페이지가 공격자의 사이트 (
모든 트래픽을 감시하고 양방향으로 보내지는 모든 데이타를 수정할 수 있다) 로부터 
전송되는 것인 ``웹 스푸핑" 을 논의하고 있다. 이는 URL 을 재작성함으로써 가능한데, 
재작성된 URL 은 상태 라인, 위치 라인 등에서 모든 가능한 증거를 감추는 다른 
기술 (자바스크립트와 같은) 을 사용해 거의 안보이게 만들 수 있다. 
더욱 세부적인 사항은 논문을 보라.
이러한 URL 을 감추는 다른 방법은 거의 사용되지 않는 URL 구문을 악용하는 것이다. 
예를 들어 ``http://www.ibm.com/stuff@mysite.com'' URL 은 이상한 사용자 이름 
``www.ibm.com/stuff" 를 이용해 ``mysite.com" (어쩌면 악의있는 사이트) 을 보기 위해 
요청하는 것이다. URL 이 충분히 길다면 실제 URL 은 표시되지 않을 것이며 따라서 
사용자는 악용되고 있음을 알아차리지 못할 것같다.
다른 방법은 ``실제" 사이트와 고의적으로 유사하게 보이는 이름을 갖는 사이트를 
만드는 것이다. 
이런 모든 경우에 있어 단순히 암호화하는 것은 그다지 유용하지 않다 - 
공격자는 보여지는 모든 것을 제어할 수 있으며 동시에 암호화된 데이타에 매우 만족할 수
있다. &#13;</P
><P
>&#13;이러한 문제를 대처하는 것은 더욱 어렵다; 현재 저자는 웹 사용자를 기만하지 
못하도록 하는 어떠한 좋은 해결 방법도 없다. 웹 브라우저 개발자에게 이러한 ``기만" 
을 쉽게 식별할 수 있도록 대처하라고 권할 것이다. 사용자가 정확한 사이트에 
올바르게 연결하는 것이 중대하다면 사용자로 하여금 위협에 대처할 수 있는 간단한 
절차를 사용하도록 해라. 브라우저를 종료시킨 후 재시작하게 하고 웹 주소가 매우 
간단하며 일반적으로 철자를 잘못 쓰지 않았는지 확인하도록 해라. 
어떤 ``비슷하게" 발음되는 DND 이름을 소유하고 또한 공격자를 찾기 위해 그러한 
다른 DNS 이름을 찾고 싶을 수도 있다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INTERNAL-CHECK"
>6.11. 내부의 일관성을 검사하는 코드를 사용해라</A
></H2
><P
>&#13;프로그램은 호출 인수 및 기본적인 상태에 대한 가정이 유효한지 확인하기 위해 
검사해야 한다. C 에서 assert(3) 와 같은 매크로가 유용할 수도 있다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SELF-LIMIT-RESOURCES"
>6.12. 스스로 자원을 제한해라</A
></H2
><P
>&#13;네트워크 데몬에서 과도한 부하를 줄이거나 제한해라. 사용될 자원들을
제한하기 위해 setrlimit(2) 를 사용해서 한계값을 설정해라. 최소한
setrlimit(2) 를 사용해서 ``코어" 파일의 생성을 못하도록 해라. 예를 들어
디폴트로 리눅스는 프로그램이 비정상적으로 종료된 경우 모든 프로그램
메모리를 저장하고 있는 코어 파일을 생성하는데 이 파일이 패스워드 또는 다른
기밀을 다루는 데이타를 포함할 수도 있다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CROSS-SITE-MALICIOUS-CONTENT"
>6.13. 교차 사이트의 악의있는 컨텐트를 예방해라</A
></H2
><P
>&#13;어떤 보안적인 프로그램은 신뢰되지 않은 사용자 (공격자) 로부터 데이타를
받아 이를 다른 사용자 애플리케이션 (victim) 에 건네준다. 보안적인
프로그램이 victim 을 보호하지 못한다면 victim 의 애플리케이션
(웹 브라우저) 은 victim 에 해를 끼치는 방식으로 그 데이타를 처리할 수도
있다. 이는 특히 HTML 또는 XML 을 사용하는 웹 애플리케이션에 일반적인
문제로 이는 ``cross-site scripting", ``malicious HTML tags" 및
``malicious content" 등 여러 이름으로 불리고 있다. 이 문제가 스크립트
또는 HTML 에 제한되어 있지 않고 그 기본적인 본질이 교차 사이트적이기
때문에 이 책에서는 이를 ``cross-site malicious content" 로 부를 것이다.
이 문제가 웹 애플리케이션으로만 한정되지 않음을 주목해라 그러나 웹
애플리케이션에 대한 특별한 문제이기 때문에 이 논의의 나머지는 웹
애플리케이션을 강조할 것이다. 때때로 공격자는 victim 으로 하여금 victim
에서 보안적인 프로그램으로 데이타를 보내도록 할 수 있으며 따라서
보안적인 프로그램은 이를 보호해야 한다.&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXPLAIN-CROSS-SITE"
>6.13.1. 문제 설명</A
></H3
><P
>&#13;간단한 예로 시작하자. 어떤 웹 애플리케이션은 나중에 다른 독자들에게 
공표될 데이타 입력에 HTML 태그를 허용하도록 설계되어 있다
(게스트북 또는 "reader comment"). 이를 막기 위해 아무 것도 하지 않는다면
이러한 태그는 스크립트, 자바 참조 (악의있는 애플릿에 대한 참조를
포함해서), DHTML 태그, 처음의 문서 끝표시 (&#60;/HTML&#62;), 폰트 크기
요청 등을 끼워넣음으로써 다른 사용자들을 공격하기 위해 악의있는 사용자가
사용할 수 있다. 이 능력은 SSL 암호화된 연결 노출, 클라이언트를 통한
제한된 웹사이트 접근, 도메인에 기초한 보안 정책 위반, 웹페이지를 읽을 수
없게 만들기, 웹페이지를 사용하기에 불쾌하게 만들기 (화나게 하는 배너 및
공격적인 material), 프라이버시 침입 허용 (특정 페이지를 누가 읽는지
정확히 알수 있도록 하는 웹버그 삽입을 함으로써), 서비스 부인 공격 생성
(무수히 많은 윈도우 생성을 통해) 및 매우 파괴적인 공격 (스크립팅 언어
또는 브라우저에 버퍼 오버플로우와 같은 보안 취약성을 삽입함으로써) 들과
같은 다양한 효과를 위해 악용될 수 있다. 악의있는 FORM 태그를 적소에
삽입함으로써 침입자는 사용자를 속여 기밀을 다루는 정보를 드러내도록 할
수도 있다 (기존 폼의 동작을 수정함으로써). 이것이 문제의 완전한 목록은
결코 아니지만 이것이 심각한 문제를 초래할 수 있음을 깨닫게 하는데
충분하다.&#13;</P
><P
>&#13;대부분의 ``논의 보드 (discussion board)" 는 이미 이 문제를 알고 있으며
대부분은 이미 다양한 사람들의 논의의 일부분으로 텍스트화되어 이를
예방하기 위한 조치를 취하고 있다. 불행히 많은 웹 애플리케이션 개발자들은
이것이 더욱 일반적인 문제라고 깨닫지 못하고 있다. 한 사용자에서 다른
사용자로 보내지는 <B
CLASS="EMPHASIS"
>모든</B
> 데이타값은 임의의 HTML 이
예상되는 명백한 경우가 아니더라도 잠재적으로 cross-site malicious
포스팅의 소스가 될 수 있다.  사용자는 다른 사이트를 통해 데이타를
공급하도록 속을 수 있기 때문에 악의있는 데이타는 사용자 자신에 의해서도
공급될 수 있다. 다음은 악의있는 데이타를 사용자가 다른 사이트로 
전송하게끔 하는 HTML 링크의 예이다 (CERT 로부터):&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> &#60;A HREF="http://example.com/comment.cgi?mycomment=&#60;SCRIPT
 SRC='http://bad-site/badfile'&#62;&#60;/SCRIPT&#62;"&#62; Click here&#60;/A&#62;</PRE
></TD
></TR
></TABLE
><P
>&#13;요약하면 웹 애플리케이션은 입력 (모든 폼 데이타를 포함해서) 을 검사,
필터링 또는 인코딩한 후 받아들여야 한다. 다른 사용자가 몰래 데이타를
제공할 수도 있기 때문에 웹 애플리케이션의 많은 경우 동일 사용자에게 그
데이타를 돌려보내 지 못할 수도 있다. 이러한 material 을 허용하는 것이
시스템 손상을 가져올 수는 없다고 하더라도 이는 시스템이 다른 사용자들에
대한 공격 루트가 될 수 있게끔 할 것이다. 더욱 나쁜 것은 이러한 공격이
시스템에서 나온 것처럼 보일 것이다.&#13;</P
><P
>&#13;CERT 는 권고안은 다음과 같이 이 문제를 기술한다:&#13;</P
><A
NAME="AEN1223"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;웹 사이트가 신뢰할 수 없는 출처로부터의 확인되지 않은 입력에 기초해
동적으로 생성된 페이지에 악의있는 HTML 태그 또는 스크립트를 무심코
포함할 수도 있다 ((<A
HREF="http://www.cert.org/advisories/CA-2000-02.html"
TARGET="_top"
>CERT Advisory
CA-2000-02, Malicious HTML Tags Embedded in Client Web
Requests</A
>).
 </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SOLUTIONS-CROSS-SITE"
>6.13.2. 교차 사이트의 악의있는 컨텐트에 대한 해결방안</A
></H3
><P
>&#13;기본적으로 이는 어떤 사용자가 끼워넣은 모든 웹 애플리케이션 출력은
필터링 (이 문제를 야기할 수 있는 문자가 제거될 수 있도록), 인코딩 (이
문제를 야기할 수 있는 문자가 문제를 예방하는 방식으로 인코드될 수
있도록) 또는 유효화 (안전한 데이타만이 도착하는 것을 보증하기 위해)
되어야 함을 의미한다. 이는 URL 매개변수, 폼 데이타, 쿠키, 데이타베이스
질의, CORBA ORB 결과 및 파일내에 저장된 사용자로부터의 데이타와 같은
입력으로부터 파생된 모든 출력을 포함한다. 많은 경우 필터링과 유효화는
입력시 행해져야 하지만 인코딩은 입력 유효화 또는 출력 생성 동안에 행해질
수 있다. 분석없이 데이타를 단지 통과시키려고 한다면 입력시 데이타를
인코드하는 것이 더욱 좋다 (따라서 잊지 않을 것이다). 그러나 프로그램이
데이타를 처리한다면 출력시 데이타를 인코드하는 것이 더욱 쉬울
것이다. CERT 는 필터링과 인코딩을 데이타 출력동안에 행하라고 추천한다;
이는 나쁜 개념은 아니지만 대신 입력시 이를 하는 것이 의미가 있는 경우가
많이 있다. 중요한 문제는 모든 출력에 대해 모든 경우를 다루는지 확인하는
것이다. 그러나 이는 접근 방법에 상관없이 쉬운 작업은 아니다.&#13;</P
><P
>&#13;경고 - 많은 경우 이러한 기법은 출력의 문자 인코딩에 대해 제어를 하지
못한다면 파괴될 수 있다. 그렇지 않다면 공격자가 여기에 논의된 기법을
파괴하기 위해 예기치 못한 문자 인코딩을 사용할 수 있을 것이다. 고맙게도
이는 어렵지 않다; 출력 문자 인코딩에 대해 제어권을 얻는 것은 <A
HREF="#OUTPUT-CHARACTER-ENCODING"
>8.5&#51208;</A
> 에 논의되어 있다.&#13;</P
><P
>&#13;첫 하부절은 필터링, 인코딩 및 유효화될 필요가 있는 특별 문자의 식별
방법을 논의한다. 다음 절은 이러한 문자를 필터링 또는 인코딩하는 방법을
기술한다. 그러나 일반적으로 데이타 유효화 방법은 논의되지 않으며
일반적으로 입력 유효화에 대해서는 <A
HREF="#INPUT"
>4&#51109;</A
> 을 보라 입력이
HTML 텍스트 또는 URI 라면 <A
HREF="#FILTER-HTML"
>4.10&#51208;</A
> 을 보라. 또한 웹
애플리케이션이 악의있는 cross-postings 를 받을 수 있음을 주목해라.
따라서 비질의도 GET 프로토콜을 금지해야 한다.&#13;</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1234"
>6.13.2.1. 특별 문자 식별</A
></H4
><P
>&#13;다음은 다양한 환경에 대한 특별 문자들이다 (이 목록을 작성한 CERT 에
감사드린다):&#13;</P
><P
></P
><UL
><LI
><P
>&#13;블록 수준 요소의 컨텐트내에서 (예, HTML 의 텍스트 단락의 중간에서 또는
XML 의 블록에서)&#13;</P
><P
></P
><UL
><LI
><P
>&#13;"&#60;" 는 태그를 도입하기 때문에 특별하다&#13;</P
></LI
><LI
><P
>&#13;"&#38;" 는 문자 엔티티를 도입하기 때문에 특별하다&#13;</P
></LI
><LI
><P
>&#13;"&#62;" 는 페이지 작성자가 실제로 시작에 "&#60;" 를 놓는다고 의미했지만
이를 에러로 생략했다는 가정하에 어떤 브라우저가 이를 특별하게 다루기
때문에 특별하다&#13;</P
></LI
></UL
></LI
><LI
><P
>&#13;속성값에서&#13;</P
><P
></P
><UL
><LI
><P
>&#13;이중 인용 부호로 둘러싸인 속성값에서 이중 인용 부호는 속성값의 끝을
표시하기 때문에 G별하다&#13;</P
></LI
><LI
><P
>&#13;단일 인용 부호로 둘러싸인 속성값에서 단일 인용 부호는 속성값의 끝을
표시하기 때문에 특별하다. XML 에서는 합법적이 아님을 주목해라 저자는
이의 사용을 추전하지 않는다.&#13;</P
></LI
><LI
><P
>&#13;어떠한 인용부호도 없는 속성값은 공백 및 탭과 같은 white-space 문자를
특별하게 만든다. XML 에서는 합법적이지 않으며 이는 더욱 많은 문자를
특별하게 만듬을 주목해라. 따라서 동적으로 생성된 속성값을 사용한다면
인용 부호가 없는 속성을 사용하지 않기를 추천한다.&#13;</P
></LI
><LI
><P
>&#13;"&#38;" 는 어떤 속성과 함께 사용될 때 문자 엔티티를 도입하기 때문에
특별하다.&#13;</P
></LI
></UL
></LI
><LI
><P
>&#13;URL 에서 예를 들어 검색 엔진이 검색을 재실행하도록 결과 페이지내에
사용자가 클릭할 수 있는 링크를 제공할 수도 있다. 이는 URL 내의 검색
질의를 인코딩함으로써 구현될 수 있다. 이가 행해질때 추가적인 특별 문자를
도입한다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;공백, 탭과 개행은 URL 의 끝을 표시하기 때문에 특별하다.&#13;</P
></LI
><LI
><P
>&#13;"&#38;" 는 문자 엔티티 또는 별도의 CGI 매개변수를 도입하기 때문에
특별하다.&#13;</P
></LI
><LI
><P
>&#13;아스키가 아닌 문자 (즉, ISO-8859-1 인코딩에서 128 보다 큰 문자) 는 URL 에서
허용되지 않으며 따라서 모두 특별하다.&#13;</P
></LI
><LI
><P
>&#13;"%" 는 HTTP 이스케이프 시퀀스로 인코드된 매개변수가 서버측 코드에 의해
디코드되는 모든 곳에서의 입력으로부터 필터링되어야 한다.
"%68%65%6C%6C%6F" 와 같은 입력이 요청된 웹 페이지에 나타날 때 "hello" 가
된다면 % 는 필터링되어야 한다.&#13;</P
></LI
></UL
></LI
><LI
><P
>&#13;&#60;SCRIPT&#62;&#60;/SCRIPT&#62; 몸체내에서 세미콜론, 괄호, curly braces 와 
개행은 텍스트가 기존 스크립트 태그내에 직접 삽입될 수 있는 상황에서 필터링되어야 한다.&#13;</P
></LI
><LI
><P
>&#13;입력시의 모든 감탄 문자 (!) 를 출력시 이중 인용 부호로 변환하는 서버측
스크립트는 추가적인 필터링이 요구될 수도 있다.&#13;</P
></LI
></UL
><P
>&#13;일반적으로 &#38; 는 HTML 과 XML 에서 특별함을 주목해라.&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1274"
>6.13.2.2. 필터링</A
></H4
><P
>&#13;이러한 특별 문자를 다루는 한가지 접근 방법은 단순히 이를 제거하는 것이다
(보통 입력 또는 출력 동안에)&#13;</P
><P
>&#13;유효한 문자에 대해 입력을 이미 유효화하였다면 (일반적으로 이렇게 해야
한다) 이는 단순히 유효 문자 목록에서 특별 문자를 단순히 생략함으로써
쉽게 행해진다. 다음은 합법적인 문자만 받아들여 필터링하는 펄
프로그램으로 필터가 공백이외의 어떠한 특별 문자도 받아들이지 않기 때문에
인용된 속성과 같은 부문에 꽤 유용하게 사용될 수 있다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> # 단지 합법적인 문자들만 받아들인다:
 $summary =~ tr/A-Za-z0-9\ \.\://dc;</PRE
></TD
></TR
></TABLE
><P
>&#13;그러나 실제 가장 적은 수의 문자만을 제거하길 원한다면 단지 이러한
문자들만을 제거하기 위한 서브루틴을 생성할 수 있다.&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> sub remove_special_chars {
  local($s) = @_;
  $s =~ s/[\&#60;\&#62;\"\'\%\;\(\)\&#38;\+]//g;
  return $s;
 }
 # Sample use:
 $data = &#38;remove_special_chars($data);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1281"
>6.13.2.3. 인코딩</A
></H4
><P
>&#13;
특별 문자를 제거하기 위한 대안은 어떠한 특별한 의미도 갖지 않도록 이들을
인코딩하는 것이다. 이는 문자를 필터링하는 것에 대해 장점을 갖는데 특히
데이타 손실을 예방한다는 것이다. 데이타가 사용자 관점에서 보았을 때
처리에 의해 엉망으로 되면 적어도 인코딩을 이용해 원래 보내졌던 데이타를
재구축하는 것이 가능하다.&#13;</P
><P
>&#13;HTML, XML 과 SGML 은 모두 러닝 텍스트에 인코딩을 도입하기 위한 방식으로
&#38; 를 사용한다; 이러한 인코딩을 HTML 인코딩이라고 부른다. 이러한
문자를 인코드하기 위해서는 단순히 상황에 맞게 특별 문자를 변환해라. 보통
이는 '&#60;', '&#62;', '&#38;' 와 '"" 가 각각 '&#38;lt;', '&#38;gt;',
'&#38;amp;' 와 '&#38;quot;' 로 변환된다. 위에 언급했듯이 이론상 '&#62;'
가 인용될 필요가 없음에도 불구하고 어떤 브라우저가 이를 따르기 때문에
('&#60;' 을 채우기 때문에) 인용될 필요가 있다. 이중 인용 부호와
관련해서는 약간의 사소한 복잡성이 있다. '&#38;quot;' 는 속성내에서만
사용될 필요가 있고 어떤 오래된 브라우저는 이를 적절히 하지 못하기
때문이다. 추가적인 복잡성을 다룰 수 있다면 단지 필요할 때만 '"' 를
인코드하려고 할 수 있지만 단순히 이를 인코드하고 사용자에게 그들의
브라우저를 갱신하라고 요청하는 것이 더욱 쉽다.&#13;</P
><P
>&#13;HTML 인코딩에 대한 이 접근 방법은 어떤 상황에서 충분한 인코딩이 아니다.
<A
HREF="#OUTPUT-CHARACTER-ENCODING"
>8.5&#51208;</A
> 에서 논의되듯이 출력 문자
인코딩 ("charset") 을 지정할 필요가 있다. 데이타 일부가 출력 문자
인코딩외의 다른 문자 인코딩을 이용해 인코드된다면 출력이 일관성있고
정확한 인코딩을 사용하도록 무언가를 해야할 것이다. 또한 ISO-8859-1 외의
출력 인코딩을 선택했다면 "&#60;" 와 같은 특별 문자에 대한 모든 대안
인코딩이 브라우저로 슬쩍 넣을 수 없음을 확인할 필요가 있다. 이는 UTF-7
과 UTF-8 과 같이 널리 쓰이는 몇몇 문자 인코딩과 관련된 문제이다; 대안 
문자 인코딩 예방 방법에 대해 더욱 자세한 정보는 <A
HREF="#CHARACTER-ENCODING"
>4.8&#51208;</A
> 을 보라. 비호환 문자 인코딩을 다루는
한가지 방법은 문자를 내부적으로 ISO 10646 (유니코드와 동일 문자 값을
갖는다) 으로 우선 변환시킨 후 이들을 나타내기 위해 수치 (numeric) 문자
참조 또는 문자 엔티티 참조를 사용하는 것이다.&#13;</P
><P
></P
><UL
><LI
><P
>&#13;수치 문자 참조는 "&#38;#D;" 또는 "&#38;#xH;" 또는 "&#38;#XH" 와 같이
보인다. D 는 십진수, H 는 십육진수이다. 주어진 수는 ISO 10646 문자 id 로
유니코드와 동일한 문자 값을 갖는다. 따라서 &#38;#1048 은 Cyrillic 대문자
"I" 이다. 십육진법 시스템은 SGML 표준 (ISO 8879) 에서 지원되지 않는데
따라서 저자는 출력에 십진법 시스템을 사용하기를 제안한다. 또한 SGML
스펙이 마지막 세미콜론이 어떤 상황에서 생략되는 것을 허용함에도 불구하고
실제로 많은 시스템은 이를 다루지 못한다  - 그래서 마지막 세미콜론을 늘
포함해라.&#13;</P
></LI
><LI
><P
>&#13;문자 엔티티 참조는 동일하지만 숫자 대신 의사 기호 (mnemonic) 이름을
사용한다. 예를 들어 "&#38;lt;" 는 &#60; 기호를 나타낸다. HTML 을
생성한다면  모든 의사 기호 이름을 열거하고 있는 
<A
HREF="http://www.w3.org"
TARGET="_top"
>HTML 스펙</A
> 을 보라.&#13;</P
></LI
></UL
><P
>&#13;숫자 또는 문자 엔티티는 작동한다; 저자는 '&#60;', '&#62;', '&#38;' 와
'"' 에 대해 문자 엔티티 참조를 사용하기를 제안하는데 이는 코드가
사람들이 이해하기 쉽기 때문이다. 그외에는 둘중의 어떤 시스템이 더욱
좋은지는 명백하지 않다. 추후 사람이 직접 출력을 편집한다고 하면 할 수
있는 한 문자 엔티티 참조를 사용해라 그렇지 않다면 저자는 프로그래밍하기
쉬운 십진법 수치 문자 참조를 사용한다. 이러한 인코딩 시스템은 특히
아시아권 언어에 대해 매우 비효율적이다; 이것이 우선 관심사라면 다른 문자
인코딩 (charset) 을 사용하거나 중요한 문자를 필터링하거나 중요한 문자에
대해 어떤 대체 인코딩도 허용되지 않는지 확인하고 싶을 것이다.&#13;</P
><P
>&#13;URI 는 URL 인코딩이라고 하는 자신만의 인코딩 스킴을 갖고 있다. 이러한
시스템에서 URL 에 허용되지 않은 문자는 퍼센트기호와 two-digit
십육진수값으로 표현된다. ISO 10646 (Unicode) 의 모든 것을 다루기 위해서는 우선
코드를 UTF-8 로 변환한 후 이를 인코드하기를 추천한다. 유효한 URI 에
대해서는 <A
HREF="#VALIDATING-URIS"
>4.10.4&#51208;</A
> 를 보라.&#13;</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CAREFUL-TYPING"
>6.14. 데이타 타입에 주의해라</A
></H2
><P
>&#13;사용된 데이타 타입에 주의해라. 특히 인터페이스에서 사용된 데이타 타입에
주의해야 하는데 예를 들어 "signed" 와 "unsigned" 값들은 C 또는 C++ 과
같은 많은 언어들에서 다르게 처리된다.&#13;</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CALL-OUT"
>7&#51109;. 다른 자원을 주의깊게 호출해라 </A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>Do not put your trust in princes, in mortal men, who cannot save.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Psalms 146:3 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><P
>&#13;사실상 정확히 독립적인 프로그램은 없다; 거의 모든 프로그램들은 운영 체제가 
제공하는 프로그램, 소프트웨어 라이브러리 등과 같은 자원에 대해 다른 
프로그램을 호출한다. 때때 다른 자원에 대한 이 호출은 명백하지 않거나 또는 
의존해야 하는 많은 숨겨진 인프라 (예, 동적 라이브러리를 구현하기 위한 
메카니즘) 를 포함하고 있다. 분명히 프로그램이 어떤 다른 자원을 신뢰해야 
하는지에 대해 주의해야 하며 반드시 그들에 요청을 보내야 한다.&#13;</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CALL-ONLY-SAFE"
>7.1. 안전한 라이브러리 루틴만 호출해라</A
></H2
><P
>&#13;때때로 보안과 추상화 (정보 숨기기, Information Hiding) 및 재사용의 개발
원리들간에는 모순이 존재한다. 문제는 어떤 고수준 라이브러리 루틴들이
보안적으로 구현될 수 있는 지 또는 아닌지로 이들의 스펙을 통해 알 수는 
없을 것이다. 특정 구현이 보안적이라 할지라도 루틴의 다른 버전이 보안적인지 
또는 동일한 인터페이스가 다른 플랫폼에서 보안적인 것인지를
보증하는 것은 불가능할 수도 있다. &#13;</P
><P
>&#13;결국 애플리케이션이 보안적이어야 한다면 때때로 각자의 라이브러리
루틴들을 재구현해야 한다. 기본적으로 라이브러리 루틴들이 보안에
요구되는 필요한 동작을 수행할 것이라고 확신할 수 없다면 루틴들을
재구현해야 한다. 더구나 어떤 경우 라이브러리의 구현은 수정되어야 하는데
보안에 취약한 라이브러리 루틴을 선택한다면 손해를 입을 수 있는 사람은
사용자들이다. 할 수 있다면 무엇인가를 재구현해야 할 때는 고수준
인터페이스를 사용하려고 노력해라 - 이렇게 함으로써 그 사용이 보안적인
시스템에서 고수준 인터페이스로 전환할 수 있다. &#13;</P
><P
>&#13;할 수 있다면 루틴이 보안적인지 또는 그렇지 않은 지를 보기위해 검사하고 
보안적이라면 이를 사용해라 - 
원칙적으로는 컴파일 또는 설치의 한 부분으로 이 검사를 수행할
수 있다 (예, "autoconf" 스크립트의 한부분으로). 어떤 조건에서는 이러한 
종류의 런타임 검사가 비현실적이지만 다른 조건에서는 많은 문제들을
제거할 수 있다. 
라이브러리를 재구현하지 않는다면 최소한 안전한지 확인하고 그렇지 않다면 
설치를 중지해라. 이렇게 함으로써 사용자가 뜻하지 않게 비보안적인 프로그램을 
설치하지 않을 것이며 문제가 무엇인지를 알 것이다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIMIT-CALL-OUTS"
>7.2. 호출을 합당한 값으로 제한해라</A
></H2
><P
>&#13;
반드시 모든 다른 프로그램에 대한 호출이 모든 매개변수에 대해 타당하고
예상한 값들만을 허용하게 해라. 이는 많은 라이브러리 호출들
또는 명령들이 잠재적으로 예기치 않은 방식으로 더욱 저수준 루틴들을
호출하기 때문에 생각과는 달리 더욱 어렵다. 예를 들어, popen(3) 과
system(3) 과 같은 몇몇 시스템 호출들은 명령 쉘을 호출함으로써 구현되는데
이는 쉘 메타문자들에 의해 영향을 받을 것임을 의미한다. 비슷하게
execlp(3) 과 execvp(3) 들때문에 쉘이 호출될 수도 있다. 많은 지침들은
프로세스를 생성시키려고 할 때는 popen(3), system(3), execlp(3) 과
execvp(3) 들을 전부 피하고 C 에서 execve(3) 을 직접적으로 사용하라고
제안하고 있다 [Galvin 1998b]. 적어도 execve(3) 을 사용할 수 있을 때는
system(3) 를 사용하는 것을 피해라; system(3) 은 문자들을 전개하기 위해
쉘을 사용하기 때문에 이는 더욱 많은 악영향을 끼칠 기회가 있다. 비슷한
방식으로 펄과 쉘의 backtick (`) 또한 명령쉘을 호출한다; 펄에 대한 더욱
자세한 정보는 <A
HREF="#PERL"
>9.2&#51208;</A
> 을 보라.&#13;</P
><P
>&#13;쉘 메타문자들은 이 문제들 중 가장 다루기 힘든 예들중의 하나로 표준 유닉스
계열 명령쉘 (/bin/sh 에 저장된) 은 많은 문자들을 특별히 해석한다. 이러한
문자들이 쉘로 보내지면 이들의 특별한 해석이 이스케이프되지 않는다면
사용될 것이다; 이 사실이 프로그램을 파괴하는데 사용될 수 있다. WWW 보안
FAQ [Stein 1999, Q37] 에 따르면 이러한 문자들은 다음과 같다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#38; ; ` ' \ " | * ? ~ &#60; &#62; ^ ( ) [ ] { } $ \n \r</PRE
></TD
></TR
></TABLE
><P
>&#13;많은 상황에 있어 탭과 공백 문자들을 이스케이프하길 원할 것이라고 저자는
언급해야 하는데 왜냐하면 이들 (과 개행) 은 디폴트 매개변수 분리자들이기
때문이다. 분리자 값들은 IFS 환경 변수를 설정함으로써 변경될 수 있지만 이
변수의 출처를 믿을 수 없다면 이를 버리거나 어쨌든 환경 변수 처리의 
일부분으로 재설정해야 한다.&#13;</P
><P
>&#13;불행히도 실제 이는 완전한 목록이 아니며 다음은 문제가 있을 수 있는
약간의 다른 문자들이다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;'!' 는 C 에서와 같이 표현에서 "not" 을 의미한다; 프로그램의 반환값이
검사된다면 ! 를 앞에 붙이는 것은 스크립트를 속여서 무엇이 성공했을 때
이것이 실패했다라고 생각하게 할 수 있으며 반대의 경우도 마찬가지이다.
어떤 쉘에서는 "!" 는 또한 명령어 히스토리를 접근하며 이는 실제 문제를
일으킬 수 있다. bash 에서 이는 대화식 모드에서만 일어나지만 tcsh (어떤
리눅스 배포판에서 발견되는 csh 클론) 는 스크립트에서도 "!" 를 사용한다.&#13;</P
></LI
><LI
><P
>&#13;'#' 는 주석 문자로 같은 라인에서 뒤에 오는 모든 텍스트는 무시된다.&#13;</P
></LI
><LI
><P
>&#13;'-' 는 옵션의 첫머리에 있음으로써 잘못 해석될 수 있다 (또는 -- 와 같이
모든 뒤에 오는 옵션을 금지한다). 이것이 파일 이름의 중간에 있다 하더라도
쉘이 whitespace 로 고려하는 것 뒤에 온다면 문제가 발생될 수도 있다.&#13;</P
></LI
><LI
><P
>&#13;' ' (스페이스), '\t' (탭), '\n' (개행), '\r' (리턴), '\v'
(수직스페이스), '\f' (폼 피드) 와 다른 whitespace 문자들은 ``하나의" 파일
이름을 다중 인수들로 바꿀 수도 있다.&#13;</P
></LI
><LI
><P
>&#13;다른 제어 문자들 (특히 NIL) 은 어떤 쉘 도구들에 대해 문제를 일으킬 수도
있다.&#13;</P
></LI
><LI
><P
>&#13;사용에 따라 "." ("현재 쉘에서 실행"의 의미) 과 "=" (변수 설정시
필요) 는 귀찮은 문자들일 수도 있다고 생각할 수도 있다. 그러나 저자가
지금까지 이들이 문제가 된 경우에 대해 발견한 모든 예는 다른 (더욱
안좋은) 보안 문제를 갖고 있다.&#13;</P
></LI
></UL
><P
>&#13;이러한 문자들중 한개라도 잊는다면 재난을 초래할 수도 있는데 예를 들어
많은 프로그램들은 백슬래쉬를 메타문자로서 생략한다 [rfp 1999]. <A
HREF="#INPUT"
>4&#51109;</A
> 에 논의되었듯이 누군가에 의해 추천되는 접근 방법은 적어도
이러한 문자들이 입력일 때 모든 문자를 즉각적으로 이스케이프하는 것이다.
그러나 더욱 최선의 접근 방법은 어떤 문자들을 허용하길 바라는지 식별하여
단지 이러한 문자들만 허용하도록 필터를 사용하는 것이다.&#13;</P
><P
>&#13;많은 프로그램들 특히 대화식으로 설계된 프로그램들은
``특별한" 기능을 수행하는 "escape" 코드를 갖고 있다. 가장 보편적인 (또한
위험한) 이스케이프 코드중의 하나는 명령 행을 초래하는 것이다. 이러한
"escape" 명령들이 포함될 수 없도록 확인해라 (특정 명령이 안전하다고
확신하지 못한다면). 예를 들어, 많은 라인 지향 메일 프로그램 (mail 과
mailx 같은) 들은 틸드 (~) 를 이스케이프 문자로서 사용하는데 이 문자는
많은 명령을 보내기 위해 사용될 수 있다. 그 결과로 "mail admin &#60;
file-from-user" 와 같이 명백히 해롭지 않은 명령들이 임의의 프로그램들을
실행시키기 위해 사용될 수 있다. vi, emacs 와 ed 와 같은 대화식
프로그램들은 사용자들이 그들 세션으로부터 임의의 쉘 명령들을
실행시키도록 허용하는 "escape" 메카니즘을 갖고 있다. 이스케이프
메카니즘을 검색하기 위해서는 호출하는 프로그램들의 문서들을 늘 조사해라.
다른 프로그램에 의해 사용될 프로그램만을 호출하는 것이 최선이다; <A
HREF="#CALL-INTENTIONAL-APIS"
>7.3&#51208;</A
> 를 보라.&#13;</P
><P
>&#13;이스케이프 코드들을 피하는 문제는 더욱 저수준 하드웨어 컴포넌트들과
이들의 에뮬레이터들로 내려간다. 대부분의 모뎀들은 소위 "Hayes"
커맨드셋을 구현하는데 이 커맨드셋이 금지되지 않는다면 문구 ``+++" 인 지연 
및 다른 지연을 야기해 모뎀에게 모든 다음의 텍스트를 모뎀에 대한 명령들로 
해석하게끔 한다. 
이는 서비스 부인 공격 (단절 명령어 ``ATH0" 를 설정함으로써) 또는 
사용자에게 다른 누군가에 연결하도록 하는 것을 구현하는데 사용될 수 있다 
(상급 공격자는 자신의 제어하에 있는 머신을 통해 사용자가 연결하도록 
라우팅 설정을 다시 할 수 있다). 특정 모뎀의 경우 이에 대처하는 것은 쉽지만 
(예, 모뎀 초기화 문자열에 ``ATS2-255" 를 추가한다) 아직도 일반적인 문제는 
남아있다: 하위 수준 컴포턴트 또는 이의 에뮬레이션을 제어하고 있다면 
반드시 커맨드셋을 금지하거나 그렇지 않은 경우 내장되어 있는 
모든 이스케이프 코드를 다루어야 한다.&#13;</P
><P
>&#13;많은 "터미널" 인터페이스들은 VT-100 같은 예전의 오래전에 사라진 물리적
터미널의 이스케이프 코드들을 구현한다. 이러한 코드들은 유용할 수 있는데
예를 들어 문자를 굵게 하기, 폰트색 변경하기 또는 터미널 인터페이스내에서
특별한 위치로 이동하는데 유용할 수 있다. 그러나 임의의 신뢰되지 않은 
데이타가 터미널 스크린으로 직접 보내지도록 허용하지 마라 왜냐하면 이러한
코드들의 일부가 심각한 문제를 일으킬 수 있기 때문이다. 어떤 시스템에서
키들을 다시 배치할 수 있다 (예, 따라서 사용자가 "엔터" 또는 function
키를 누를때 이는 실행시키길 원하는 명령을 보낸다). 어떤 시스템에서는
스크린을 지우고 victim 이 실행시켰으면 하는 일련의 명령들을 표시한 후
이들 명령셋을 다시 돌려보내 victim 에게 키스트로크를 기다리지 않고
공격자가 선택한 명령들을 실행시키게 하는 코드를 보낼 수도 있다. 이는
"페이지 모드 버퍼링" 을 사용해서 일반적으로 구현되는데 이러한 보안
문제가 왜 에뮬레이트된 tty (보통 /dev/ 내의 디바이스 파일들로 표현되는)
들이 이들의 소유자들에게만 쓰기가능하며 다른 누구에게도 허용되지 않는
이유이다 - 이들은 절대로 "other write", 허가권이 설정되어서는 안되며 단지
사용자만이 그룹의 멤버가 아니라면 (즉, "user-private group" 스킴이
아니라면) "group write" 허가권이 터미널에 대해 설정되지 않아야 한다
[Filipski 1986]. 모사된 터미널에서 사용자에게 데이타를 표시하려면
사용자에게 되보내지는 데이타의 모든 제어 문자 (32 미만의 값을 갖는 문자)
들은 안전하다고 확인되지 않는다면 아마도 필터링되어 제거될 필요가 있다. 나쁜
것은 더욱 악화되는데 탭과 개행 (과 아마도 carriage return) 이 안전하다고
식별할 수 있으며 나머지는 모두 제거한다. high 비트가 설정된 문자 (127
보다 큰 값) 들은 어떤 방식에서는 다루기가 더욱 어렵다; 어떤 예전
시스템들은 이들이 설정되지 않은 것처럼 이들을 다루지만 단순히 이들을
필터링하는 것은 많은 국제적 사용을 금지한다. 이런 경우 명확한 상황을
살펴볼 필요가 있다.&#13;</P
><P
>&#13;관련 문제는 NIL 문자 (문자 0) 가 예기치 않은 효과를 가질 수 있다는
것이다. 대부분의 C 와 C++ 함수들은 이 문자가 문자열의 끝을 표시한다고
가정하지만 다른 언어 (펄과 Ada95와 같은) 들에서는 문자열을 다루는
루틴들이 NIL 을 포함한 문자열들을 다룰 수 있다. 많은 라이브러리들과 커널
호출들이 C 관례를 사용하기 때문에 결과적으로 검사된 것이 실제 사용된 것은 
아니다 [rfp 1999].&#13;</P
><P
>&#13;다른 프로그램을 호출하거나 파일을 참조할때는 늘 절대 경로 (예,
/usr/bin/sort) 를 지정해라. 프로그램 호출의 경우 이는 PATH 값이 잘못
설정되어 있더라도 잘못된 명령을 호출할 때의 가능한 에러들을 제거할 것이다.
다른 파일 참조의 경우 이는 올바르지 않은 시작 디렉토리로부터 발생하는
문제들을 줄인다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CALL-INTENTIONAL-APIS"
>7.3. 프로그래머가 사용하도록 의도된 인터페이스만 호출해라</A
></H2
><P
>&#13;프로그램이 사용하도록 의도된 API (application programming interface) 만
호출해라. 보통 프로그램은 대화식 
프로그램들을 포함하여 모든 다른 프로그램들을 호출할 수 있다. 그러나
인간이 호출하는 방식과 동일하게 대화식 
프로그램을 호출하는 것은 보통 현명하지 않다. 문제는 프로그램의 human
인터페이스들이 의도적으로 기능성이 풍부하며 종종 완전히 제어하기
어렵다는 것이다. <A
HREF="#LIMIT-CALL-OUTS"
>7.2&#51208;</A
> 에 논의되었듯이 대화식
프로그램들은 대개 "escape" 코드들을 갖으며 이는 공격자가 해로운 기능들을
수행할 수 있도록 한다. 또한 대화식 프로그램들은 대개 "가장 그럴듯한
(most likely)" 디폴트들을 직감으로 알려고 한다; 이는 예상했던 디폴트가
아닐 수도 있으며 공격자기 이를 악용할 수 있는 방법을 발견할 수도 있다.&#13;</P
><P
>&#13;보통 직접적으로 호출하지 않아야 하는 프로그램들은 mail, mailx, ed, vi 와
emacs 등이 있다. 최소한  이들의 입력을 처음에 검사한 후 이들을 호출해라.&#13;</P
><P
>&#13;보통 프로그램의 기능성에 보다 안전한 접근을 제공하는 매개변수들 또는
프로그램이 사용하도록 의도된 여러 API 또는 애플리케이션이 있다; 대신
이들을 사용해라. 예를 들어 어떤 텍스트를 편집하기 위해 텍스트 에디터
(ed, vi 또는 emacs) 를 호출하는 대신 가능한 sed 를 사용해라.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CHECK-RETURNS"
>7.4. 모슨 시스템 호출 반환을 검사해라</A
></H2
><P
>&#13;에러 상태를 반환할 수 있는 모든 시스템 호출은 그 에러 상태를 검사해야 
한다. 한가지 이유는 거의 모든 시스템 호출들이 제한된 시스템
자원들을 필요로 하며 사용자들은 대개 다양한 방식으로 자원들에
영향을 미칠 수 있다는 것이다. Setuid/setgid 프로그램들은 setrlimit(3) 과 nice(2)
와 같은 호출들을 통해 그들에 대한 한도를 설정할 수 있다. 서버
프로그램들과 CGI 스크립트들의 외부 사용자들이 단순히 많은 수의 동시
요청을 함으로써 자원 고갈을 일으킬 수 있을지도 모른다. 에러가 훌륭히 
다뤄질 수 없다면 앞에서 논의한 바와 같이 에러를 한 부분에 국한시켜 
전체 시스템이 완전히 마비되는 것을 방지하고 수행을 계속할 수 있도록 해라.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AVOID-VFORK"
>7.5. vfork(2) 사용을 피해라</A
></H2
><P
>&#13;유닉스 계열 시스템에서 새로운 프로세스를 생성하는 이식성 있는 방법은
fork(2) 호출을 사용하는 것이다. BSD 는 최적화 기법으로 vfork(2) 라는
변형을 도입하였는데 vfork(2) 에서는 fork(2) 와는 달리 자식은 execve(2V)
또는 exit 호출이 일어날 때까지 부모의 제어 메모리와 쓰레드를 빌린다;
부모 프로세스는 일시 정지된 반면 자식은 그 자원들을 사용하고 있다. 예전
BSD 시스템에서 fork(2) 가 실제로 메모리가 복사되도록 할 수 있는 반면
vfork(2) 는 그렇지 않을 것이다라는 것이 근본적 이유였다. 리눅스는 전혀
이러한 문제가 없었다; 리눅스는 copy-on-write (write 하는 동안 복사) 의미 체계를 내부적으로
사용했기 때문에 페이지들이 변경되었을 때만 단지 이들을 복사한다 (실제로
복사되어야 하는 어떤 테이블이 있는데 대부분 상황에서 이들의 오버헤드가 
큰편은 아니다). 그럼에도 불구하고 어떤 프로그램들은 vfork(2) 에 의존하기
때문에 최근 리눅스는 BSD vfork(2) 의미 체계를 구현하였다 (이전 vfork(2)
는 fork(2) 의 alias 였다).&#13;</P
><P
>&#13;vfork(2) 와 관련해서는 많은 문제가 있다. 이식성 관점에서 보았을 대
vfork(2) 와 관련된 문제는 프로세스가 그 부모를 간섭하지 않는 것이 특히
고수준 언어에서 실제로 매우 어렵다는 것이다. 간섭하지 않는다는 요건은
실제 생성된 머신 코드에 적용되며 많은 컴파일러들은 의도되지 않은 간섭을
일으키는 숨겨진 temporaries 와 다른 코드 구조들을 생성한다. 결과:
vfork(2) 를 사용하는 프로그램들은 코드가 변경될 때 또는 컴파일러 버전이
변경될 때 더욱 실패하기 쉬울 것이다.&#13;</P
><P
>&#13;
보안적인 프로그램의 경우 리눅스 (적어도 2.2.17 까지의 2.2 버전들) 는
vfork() 구현에 있어 경쟁 상태에 취약하기 때문에 리눅스 시스템에서는 더욱
나쁘다. 권한을 갖는 프로세스가 사용자 명령들을 실행시키기 위해
리눅스에서 vfork(2)/execve(2) 쌍을 사용한다면 자식 프로세스가 사용자의
UID 로 이미 작동하고 있지만 아직 execve(2) 로 들어가지 않는 동안 경쟁
상태가 존재한다. 사용자는 이 프로세스에 SIGSTOP 를 포함한 시그널들을
보낼 수 있을지도 모른다. vfork(2) 의 의미 체계때문에 권한을 갖는 부모
프로세스도 또한 블록당할 수 있다. 그 결과 권한이 없는 프로세스가
권한을 갖는 프로세스에게 정지하도록 시킬 수 있으며 권한을 갖는
프로세스의 서비스에 대해 서비스 부인 공격을 초래할 것이다. FreeBSD 와
OpenBSD 는 적어도 이런 경우를 명확하게 다루는 코드를 갖고 있으며 따라서
저자가 알기에 이러한 문제에 취약하지 않다. 리눅스에서 이 문제를
언급하고 "security-audit" 메일링 리스트에 2000년 9월에 문서화한 한 Solar
Designer 에 감사한다.&#13;</P
><P
>&#13;vfork(2) 에 대한 최종 결과는 간단하다: 프로그램에서 vfork(2) 를 사용하지
마라. 이는 어렵지 않아야 한다; vfork(2) 의 기본적인 사용은 vfork 의
의미 체계를 필요로 하는 예전 프로그램을 지원하는 것이다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="EMBEDDED-CONTENT-BUGS"
>7.6. 내장된 컨텐트를 검색할 때 웹버그에 대처해라</A
></H2
><P
>&#13;몇몇 데이타 포맷들은 데이타가 보일 때 자동적으로 검색되는 컨텐트에
참조를 내장할 수 있다 (사용자가 이를 선택하는 것을 기다리지 않는다). 이
데이타가 인터넷을 통해 검색되도록 할 수 있다면 (예, WWW 를 통해)
이 능력을 이용해서 readers 가 모르게 readers 에 대한 정보를 얻을 수
있으며 어떤 경우 reader 에게 동의없이 기능을 수행하도록 시킬 수 있다.
이러한 사생활과 관련된 문제를 때때로 "웹 버그 (web bug)" 라고 부른다.&#13;</P
><P
>&#13;웹 버그에서 참조는 의도적으로 문서에 삽입되며 문서가 어디에서 읽혀지며
얼마나 자주 읽혀지는 지를 추적하기 위해 컨텐트 저자에 의해 사용될 수 있다.
저자는 또한 버그가 있는 문서가 한 사람에서 다른 사람 또는 한 조직에서 다른
조직으로 어떻게 건네지는 지를 감시할 수 있다.&#13;</P
><P
>&#13;HTML 포맷은 얼마동안 이 문제를 갖고 있었다. <A
HREF="http://www.privacyfoundation.org"
TARGET="_top"
>Privacy Foundation</A
> 에
따르면:&#13;</P
><A
NAME="AEN1361"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;
웹 버그들은 추적을 위해 웹 페이지와 HTML 기반 이메일 메세지에서 인터넷
광고 회사들에 의해 오늘날 널리 사용되고 있다. 이들은 일반적으로 추적에
사용되고 있다는 사실을 감추기 위해 스크린상에서 볼 수 없도록 전형적으로
1 by 1 픽셀 크기이다. 그러나 img 태그를 사용한 이미지일 수도 있다; 
웹 버그를 구현할 수 있는 다른 HTML 태그들은 예를 들면 frame, form 호출 및 
script 들이다. 웹 버그를 호출하는 것은 ``bugging" 사이트에 reader IP 주소, 방문한 페이지 
및 브라우저에 관한 다양한 정보를 제공할 것이다; 또한 쿠키를 사용함으로써 
reader 의 명확한 신원을 결정할 수도 있다. 웹 버그에 관한 개론은 
<A
HREF="http://www.securityspace.com/s_survey/data/man.200102/webbug.html"
TARGET="_top"
>http://www.securityspace.com/s_survey/data/man.200102/webbug.html</A
> 
에서 얻을 수 있다.&#13;</P
></BLOCKQUOTE
><P
>&#13;더욱 중요한 것은 다른 문서 포맷들도 또한 그러한 능력을 가지고 있는
듯하다는 것이다. 웹 브라우저로 웹사이트의 HTML 을 볼 때 데이타를 누가
보고 있는지에 대한 정보를 얻는 다른 방법이 있지만 이메일과 같이 다른
포맷의 문서를 보고 있을 때는 문서를 읽는다는 사실 자체가 모니터링 될 수
있다고 예상하는 사용자들은 아무도 없다. 그러나 많은 포맷들의 경우 문서를
읽는지 모니터링 될 수 있다. 예를 들어 마이크로소프트 워드가 웹 버그를
지원할 수 있다는 것이 최근에 결정되었다; 더욱 자세한 정보는 <A
HREF="http://www.privacyfoundation.org/advisories/advWordBugs.html"
TARGET="_top"
>Privacy Foundation advisory</A
> 를 보라. 권고안에 언급되었듯이
마이크로소프트 엑셀과 파워포인트의 최근 버전들도 또한 이러한 웹 버그가
있을 수 있다. 어떤 경우 더욱 자세한 정보를 얻기 위해 쿠키가 사용될 수
있다.&#13;</P
><P
>&#13;웹 버그는 본질적으로 파일 포맷 설계와 관련된 문제이다.사용자가
프라이버시를 중요하게 여긴다면 아마도 포함된 파일의 자동적인 다운로딩을
제한하길 원할 것이다. 한가지 예외는 파일 자체가 다운도드 (웹 브라우저를
통해) 될 때 일 수도 있다; 동일 위치에서 동시에 다른 파일들을 다운로드하는
것은 사용자들을 불안하게 할 것 같지는 않다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HIDE-SENSITIVE-INFORMATION"
>7.7. 기밀을 다루는 정보를 숨겨라</A
></H2
><P
>&#13;기밀을 다루는 정보는 입력과 출력중인 동안과 시스템에 저장될 때 모두
엿보는 사람들로부터 숨겨져야 한다. 기밀을 다루는 정보는 확실히 신용카드
넘버, 계좌 잔액과 집주소를 포함하며 많은 애플리케이션에서는 이름, 이메일 
주소와 다른 개인 정보도 또한 포함한다.&#13;</P
><P
>&#13;웹기반 애플리케이션들은 기밀을 다루는 정보를 포함해서 사용자와의 모든
통신을 암호화해야 한다; 흔한 방법은 (SSL 또는 TLS 위에서 HTTP 가
작동하는) https: 프로토콜을 사용하는 것이다. HTTP 1.1 스펙 (IEFT RFC
2616 15.1.3 절) 에 따르면 HTTP 프로토콜을 사용하는 서비스 사용자들은
기밀을 다루는 데이타를 전송하기 위해 GET 기반 폼들을 사용하지 않아야
한다. 왜냐하면 이것이 데이타가 요청-URI 로 인코드되게 할 수 있기 
때문이다. 많은 기존 서버들, 프락시와 사용자 에이전트들은 요청 URI 를
제삼자에게 보일 수 있을 지도 모르는 어떤 곳에 기록할 것이다. 대신 이
목적을 위해 의도된 POST 기반 전송을 사용해라.&#13;</P
><P
>&#13;이러한 기밀을 다루는 데이타의 데이타베이스들도 또한 디스크상의 파일들과
같은 모든 저장 디바이스에서 암호화되어야 한다. 이러한 암호화가 물론
보안적인 애플리케이션을 깨뜨리는 공격자에 대해서는 보호를 하지 못하며
이는 애플리케이션 또한 암호화된 데이타에 접근하는 방법을 가져야 하기
때문이다. 그러나 암호화는 데이타의 백업 디스크를 어떻게든 얻었지만
이들을 복호화하는데 필요한 키를 얻지못한 공격자들에 대해 상당한 보호를
제공한다. 공격자가 애플리케이션으로 어떻게든 침입하는 것이 아니라 저장된
데이타를 보기에 그저 충분할만큼 부분적으로 관련 시스템내로 침입한다면
암호화는 또한 상당한 보호 방법을 제공한다 - 공격자는 데이타를 얻기 위해
암호화 알고리듬을 깨뜨려야 한다. 데이타가 본의아니게 (예, 코어 파일)
전달될 수 있는 많은 상황이 있는데 암호화는 또한 이를 예방한다. 종종 서버
자체가 파괴되거나 깨뜨려질 수 있기 때문에 암호화가 생각하는 만큼 강력한
보호 방법은 아니라는 것은 언급할만한 가치가 있다.&#13;</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="OUTPUT"
>8&#51109;. 정보를 신중하게 되돌려줘라 </A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>Do not answer a fool according to his folly,
or you will be like him yourself.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Proverbs 26:4 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="MINIMIZE-FEEDBACK"
>8.1. 피드백을 최소화해라</A
></H2
><P
>&#13;신뢰되지 않은 사용자에게 많은 정보를 제공하지 마라; 간단히 성공 또는
실패로 표현하고 실패한 경우 단지 실패했다고 말하고 실패 원인에 대한
정보를 최소화해라. 감사시 단서가 될 수 있는 기록들을 위해 세부적인
정보를 저장해라. 예를 들면 다음과 같다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;프로그램이 일종의 사용자 인증을 필요로하면 (예, 네트워크 서비스 또는
로그인 프로그램을 작성하는 경우) 사용자들이 인증받기 전에는 가능한 적은
정보를 이들에게 제공해라. 특히 인증전에 프로그램의 버전 넘버를 드러내지
마라. 그렇지 않다면 이 버전의 프로그램이 공격에 취약하다고 알려진 경우
이 버전을 갱신하지 않은 사용자들은 공격자들에게 자신들은 공격에
취약하다고 광고하는 것이나 마찬가지이다.&#13;</P
></LI
><LI
><P
>&#13;프로그램이 패스워드가 필요하다면 이를 그대로 다시 나타나게 하지마라;
이는 패스워드가 드러날 수 있는 다른 방법을 만든다.&#13;</P
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="NO-COMMENTS"
>8.2. 주석을 포함하지 마라</A
></H2
><P
>&#13;정보를 반환할 때 반드시 이를 받는 사용자가 주석을 보기를 원하지 않는다면
어떠한 주석도 포함하지 마라. 이는 HTML 같은 파일들을 생성하는 웹
애플리케이션에 대해 특별한 문제이다. 대개 웹 애플리케이션 프로그래머들은
그들의 프로그램에 주석을 첨가하길 바라지만 (이는 훌륭한 작업이다)
단지 주석을 코드내에 두는 대신 사용자에게 반환되는 생성 파일 (보통 HTML
또는 XML) 의 한 부분으로 주석이 포함되게 하라. 문제는 이러한 주석들이
때때로 시스템이 공격을 돕는 방식으로 작동할 수 있는 방법에 대한
통찰력을 제공한다는 것이다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HANDLE-FULL-OUTPUT"
>8.3. 완전한/무반응의 출력을 다뤄라</A
></H2
><P
>&#13;사용자가 자신에게 되돌아오는 보안적인 프로그램의 출력 채널을 방해하거나
응답하지 않게 할 수 있다. 예를 들어, 웹 브라우저가 의도적으로 정지되거나
자신의 TCP/IP 채널 응답을 지연시킬 수 있는데 보안적인 프로그램은 이런
경우를 다뤄야 하며 특히 서비스 부인 공격의 기회를 만들지 않도록 로크를
빨리 해제 (되도록 응답전에) 해야한다. 늘 외부로 나가는 네트워크 지향
쓰기 요청에 대해 타임아웃을 설정해라.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CONTROL-FORMATTING"
>8.4. 데이타 포맷팅을 제어해라 (문자열 포맷)</A
></H2
><P
>&#13;컴퓨터 언어에서 많은 출력 루틴들은 생성되는 포맷을 제어하는 매개변수를
갖고 있다. C 에서 가장 명백한 예는 printf(), sprintf(), fprintf() 등을
포함한 printf() 루틴 계열들로 다른 예는 시스템 로그 정보 작성 syslog()
와 프로세스 식별자 정보를 표시하는데 사용되는 문자열 설정 setproctitle()
이다. ``err" 또는 ``warn" 으로 시작하거나 ``log" 를 포함하거나 또는
"printf" 로 끝나는 이름을 갖는 많은 함수들은 고려할만한 가치가 있다.
파이썬에는 문자열에 대해 비슷한 방식으로 포맷팅을 제어하는 "%" 연산이
있다. 많은 프로그램들과 라이브러리들은 대개 내장 루틴 호출 및 추가적인
프로세싱 (예, glib 의 g_snprintf() 루틴) 을 함으로써 포맷팅 함수들을
정의한다.&#13;</P
><P
>&#13;뜻밖에도 많은 사람들은 이러한 포맷팅 능력의 중요성을 잊고 있으며 신뢰되지 
않은 사용자들로부터의 데이타를 포맷팅 매개변수로 사용하고 있는 것 같다.
신뢰되지 않은 사용자로부터의 필터링되지 않은 데이타를 포맷 매개변수로
절대로 사용하지 마라. 아마도 이는 다음 예에서 가장 잘 볼 수 있다:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  /* 잘못된 방식: */
  printf(string_from_untrusted_user);
  /* 옳은 방식: */
  printf("%s", string_from_untrusted_user); /* 안전하다 */
  fputs(string_from_untrusted_user); /* 단순 문자열의 경우 더욱 좋다 */</PRE
></TD
></TR
></TABLE
>&#13;</P
><P
>&#13;그렇지 않으면 공격자는 포맷팅 문자열을 주의깊게 선택함으로써 모든 종류의
악영향을 일으킬 수 있는데 C 에서 printf() 의 경우가 좋은 예이다. printf()
에서 사용자 제어 포맷 문자열을 어떻게든 악용하는 많은 방법들이 있는데
이들로는 긴 포맷팅 문자열 생성에 의한 버퍼 오버런 (이는 공격자로 하여금
프로그램을 완전히 제어할 수 있게 한다), 전달되지 않은 매개변수를
사용하는 변환 선언 (예기치 않은 데이타를 삽입시킨다) 과 전혀 예상치 못한
결과값들을 산출하는 포맷 생성하기 (가령 위험한 데이타를 앞 또는 뒤에
덧붙임으로써 가능한데 추후 사용시 문제를 일으킨다) 들이 있다. 특히
난처한 경우는 printf 의 "%n" 변환 선언으로 이는 지금까지 작성된 문자들의
수를 포인터 인수내로 쓰는데 공격자는 이를 악용하여 인쇄할 값을 겹쳐쓸 수
있다. 공격자는 실제로 전달되지 않는 매개변수를 지정할 수 있기 때문에
거의 임의의 위치에 언제나 겹쳐쓸 수 있다. 많은 논문들은 이러한 공격들을
더욱 자세하게 논의하는데 예를 들어 <A
HREF="http://www-syntim.inria.fr/fractales/Staff/Raynal/LinuxMag/SecProg/Art4/index.html"
TARGET="_top"
>Avoiding
security holes when developing an application - Part 4: format
strings</A
>를 보라.&#13;</P
><P
>&#13;많은 경우 결과들은 사용자에게 되돌려지기 때문에 이 공격은 스택에 대한
내부 정보를 드러내는데 사용될 수 있다. 이 정보는 추후 StackGuard 와
같은 스택 보호 시스템을 뚫는데 사용될 수 있다; StackGuard 는 공격을
탐지하기 위해 상수 ``canary" 값들을 사용하는데 스택의 내용들이
표시된다면 canary 의 현재 값이 노출되어 공격에 취약할 것이다.

 </P
><P
>&#13;포맷팅 문자열은 국제화에 대한 검색 (look) 을 구현하기 위한 함수 호출
(gettext's _() 를 통해) 을 될 수 있는 한 포함하여 거의 언제나 상수
문자열이여야 한다. 이 검색은 프로그램이 제어하는 값들로 한정되어야 함을
주목해라, 즉 사용자는 프로그램이 제어하는 메시지 파일들로부터만 선택할
수 있어야 한다. 사용자 데이타를 사용하기 전에 이를 필터링하는 것
([A-Za-z0-9] 와 같은 포맷 문자열에 대해 합법적인 문자들을 열거하는
필터를 설계함으로써) 은 가능하지만 보통 상수 포맷 문자열 또는 fput() 을
대신 사용함으로써 문제를 단순히 예방하는 것이 일반적으로 더욱 좋다.
저자는 이를 "출력" 문제로 열거했지만 출력 루틴들이 파일에 저장하거나
또는 snprintf() 를 통해 그와 같은 내부 상태를 생성할 수도 있기 때문에
이는 출력전에 프로그램에 내부적으로 문제를 일으킬 수 있다.&#13;</P
><P
>&#13;보안 문제를 야기하는 입력 포맷팅 문제는 사용되고 있지 않은 가능성은
아닌데 이 약점을 이용해 악용한 예를 CERT Advisory CA 2000-13 에서 보라.
이러한 문제가 어떻게 악용될 수 있는 지에 대한 더욱 자세한 정보는 
<A
HREF="http://www.securityfocus.com"
TARGET="_top"
>Bugtraq</A
> 의
2000년 6월 18일 판에 출판된  Pascal Bouchareine 의 "[Paper] Format bugs"
라는 이메일 기사를 보라. 2000년 12월 현재 gcc 컴파일러 개발 버전은
개발자가 이러한 문제들을 피할 수 있도록 비보안적인 포맷 문자열 사용에
대해 경고 메시지를 지원하고 있다.&#13;</P
><P
>&#13;물론 이 모두는 국제화 검색이 실제 보안적인지 아닌지에 대한 논점을 교묘히
피하는 것인데 각자의 국제화 검색 루틴들을 작성하려면 반드시 신뢰되지 않은 
사용자는 단지 합법적인 로케일만 지정할 수 있으며 임의의 경로와 같은
것들을 지정할 수 없도록 해라.&#13;</P
><P
>&#13;분명히 각자는 국제화를 통해 생성된 문자열을 믿을 수 있는 문자열로
제한하길 원하는데 그렇지 않다면 공격자는 이 능력을 사용해 포맷
문자열에서의 약점, 특히 C/C++ 프로그램에서의 약점을 악용할 수 있다. 이는
Bugtraq 내의 쟁점이었는데 (2000년 6월 26 일 올려진 John Levon 의 Bugtraq 
게시물을 보라) 더욱 자세한 정보를 위해서는 <A
HREF="#LOCALE-LEGAL-VALUES"
>4.7.3&#51208;</A
> 
에서 합법적인 언어 값들만을 사용자가 선택하도록 허용하는 것에 대한 논의를 보라.&#13;</P
><P
>&#13;실제로 프로그래밍 버그일지라도 다른 국가들은 다른 방식으로 숫자들을
표시한다고 언급하는 것은 가치가 있는데 특히 마침표 (.) 와 쉼표 (,) 모두
소수부로부터 정수를 분리하기 위해 사용되고 있다. 데이타를 저장 또는
적재하려면 반드시 사용 로케일이 데이타 처리를 간섭하지 않도록 할 필요가
있다. 그렇지 않다면 저장된 데이타와 검색된 데이타가 다른 분리자를 사용할 
것이기 때문에 프랑스어 사용자와 영어 사용자가 데이타를 교환할 수 없을
수도 있다. 이것이 보안 문제로 사용되고 있는 지는 모르지만 상상할 수 있는
일이다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="OUTPUT-CHARACTER-ENCODING"
>8.5. 출력에서 문자 인코딩을 제어해라</A
></H2
><P
>&#13;일반적으로 보안적인 프로그램들은 그들의 모든 가정들에 클라이언트들을
동기화시킴을 보증해야 한다. 대개 웹 애플리케이션에 영향을 미치는 한가지
문제는 출력의 문자 인코딩 지정을 잊는다는 것이다. 이는 모든 데이타가
신뢰된 출처로부터 온다면 문제가 되지 않지만 데이타 중 일부가 신뢰되지 않은 
출처로부터 온다면 보안적인 프로그램이 예상한 것과 다른 인코딩을
사용하는 신뢰되지 않은 출처로부터의 데이타가 실제 데이타내에 몰래
삽입될 수도 있다. 이는 cross-site malicious content 공격에 대해 보안
구멍을 만드는 것으로 더욱 자세한 정보는 <A
HREF="#INPUT-PROTECTION-CROSS-SITE"
>4.9&#51208;</A
> 를 보라.&#13;</P
><P
>&#13;<A
HREF="http://www.cert.org/tech_tips/malicious_code_mitigation.html"
TARGET="_top"
>CERT's
tech tip on malicious code mitigation</A
> 은 지정되지 않은 문자 인코딩 문제를 매우 잘 설명하는데 이는 다음과 같다:

<A
NAME="AEN1412"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;많은 웹페이지들은 문자 인코딩 (HTTP 에서 "charset" 매개변수) 을 정의하지
않은 채 두고 있다. HTML 과 HTTP 초기 버전에서는 문자 인코딩이 정의되어
있지 않으면 이를 디폴트로 ISO-8859-1 로 간주했는데 사실 많은
브라우저들은 다른 디폴트를 가지며 따라서 ISO-8859-1 디폴트에 의존하는
것은 불가능했다. HTML 버전 4 는 이를 합법화하는데 문자 인코딩이 지정되지
않으면 어떠한 문자 인코딩도 사용될 수 있다.&#13;</P
><P
>&#13;웹 서버가 어떤 문자 인코딩이 사용중인지를 지정하지 않으면 어떤 문자들이
특별한 것인지 알릴 수 없다. 문자 인코딩이 지정되지 않은 웹 페이지들은
대부분의 문자셋이 동일한 문자들에 128 미만의 바이트 값들을 할당하기
때문에 대부분 작동한다. 그러나 128 이상의 값들중에서 어떤 값들이
특별한가? 어떤 16 비트 문자 인코딩 체계들은 "&#60;" 와 같은 특별 문자들에
대해 추가적인 멀티 바이트 표현을 갖고 있으며 어떤 브라우저들은 이러한
대체 인코딩을 인식해서 이에 따라 행동한다. 이는 ``정확한" 거동이지만
악의있는 스크립트를 사용한 공격을 예방하기 더욱 어렵게 만든다. 서버는
어떤 바이트 시퀀스가 특별 문자들을 나타내는지 단순히 모르고 있다.&#13;</P
><P
>&#13;예를 들어 UTF-7 은 "&#60;" 과 "&#62;" 에 대해 대체 인코딩을 제공하며 몇몇
널리쓰이는 브라우저들은 이를 시작 및 끝 태그로 인식한다. 따라서 이는
그러한 브라우저에서는 버그가 아니며 문자 인코딩이 실제로 UTF-7 이라면
이는 정확한 거동이다. 문제는 브라우저와 서버가 인코딩이 일치하지 않은
상황에 놓일 수도 있다는 것이다.&#13;</P
></BLOCKQUOTE
></P
><P
>&#13;고맙게 이 문제를 설명하는 것이 어려움에도 불구하고 HTML 에서 이를
해결하는 것은 간단한데 HTML 헤더에 CERT 로부터의 다음 예와 같이 charset
을 단순히 지정하는 것이다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#60;HTML&#62;
&#60;HEAD&#62;
&#60;META http-equiv="Content-Type"
content="text/html; charset=ISO-8859-1"&#62;
&#60;TITLE&#62;HTML SAMPLE&#60;/TITLE&#62;
&#60;/HEAD&#62;
&#60;BODY&#62;
&#60;P&#62;This is a sample HTML page
&#60;/BODY&#62;
&#60;/HTML&#62;</PRE
></TD
></TR
></TABLE
><P
>&#13;기술적 관점에서 보았을 때 더욱 좋은 접근 방법은 HTTP 프로토콜 출력의
일부분으로 문자 인코딩을 설정하는 것이다. 물론 어떤 라이브러리들은 이를
더욱 어렵게 만들기도 한다. 이는 클라이언트에게 헤더의 메타정보를 읽을 수
있게 하는 문자 인코딩을 결정하기 위해 헤더를 조사하도록 하지 못하기 
때문에 기술적으로 더욱 좋다. 물론 실제로 메타 정보를 읽을 수 없고
이를 정확히 사용할 수 없는 브라우저가 판매 시장에서 성공할 수 없지만
이는 다른 문제이다. 어떤 경우든 이는 서버가 HTTP 프로토콜의 한 부분으로
원하는 값을 갖는 "charset" 을 보낼 필요가 있음을 의미한다. 불행히 어떤
예전 HTTP/1.0 클라이언트들은 명시적인 charset 매개변수를 적절히 다루지
못하기 때문에 이러한 기술적으로 더욱 좋은 접근 방법을 진지하게 추천하는
것은 어렵다. HTTP/1.1 스펙이 클라이언트에게 매개변수를 따르라고
요구함에도 불구하고 이를 유일한 메카니즘이 아닌 정확한 문자 인코딩
사용을 강요하는 부속물로 어떻게든 이를 사용해야 할만큼 충분한지는
의심스럽다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PREVENT-INCLUDE-ACCESS"
>8.6. 포함/설정 파일 접근을 예방해라</A
></H2
><P
>&#13;웹기반 애플리케이션을 개발할 때 사용자들에게 포함 (include) 프로그램과 설정
파일과 같은 파일들을 접근 또는 읽기를 허용하지 마라. 이 데이타는
시스템에 침입하는데 충분한 정보 (예, 패스워드) 를 제공할 수도 있다. 이
지침은 때때로 다른 유형의 애플리케이션에도 또한 적용됨을 주목해라. 이를
위해 취할 수 있는 몇몇 행동들이 있다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;포함/설정 파일들을 웹 문서 루트의 외부에 두어라 (웹 서버가 이러한
파일들을 절대로 제공할 수 없도록)&#13;</P
></LI
><LI
><P
>&#13;포함 파일들을 텍스트로 제공하지 않도록 웹 서버를 설정해라. 예를 들어
아파치를 사용한다면 .inc 파일들에 핸들러 또는 액션을 추가할 수 있다.&#13;</P
></LI
><LI
><P
>&#13;포함 파일들을 .htaccess 를 사용해 보호된 디렉토리에 두고 이들을
제공하지 않을 파일들로 지정해라.&#13;</P
></LI
><LI
><P
>&#13;
파일들에 대한 접근을 거절하기 위해 필터를 사용해라. 아파치 경우 다음과
같다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> &#60;Files ~ "\.phpincludes"&#62;
    Order allow,deny
    Deny from all
 &#60;/Files&#62;</PRE
></TD
></TR
></TABLE
><P
>&#13; 파일 이름과 일치시키기 위해 완전한 정규 표현이 필요하다면 아파치에서는
FilesMatch 지시를 사용해라.&#13;</P
></LI
><LI
><P
>&#13;포함 파일이 서버가 분석할 확실한 스크립트 파일이라면 반드시 이 파일이
사용자가 제공한 매개변수에 따라 행동하지 않으며 안전하게 설계되었는지
확인해라.&#13;</P
></LI
></UL
><P
>&#13;이러한 접근 방법들은 파일들이 world-readable 이라면 이들이 있는
디렉토리에 접근할 수 있는 사용자들로부터는 보호하지 않을 것이다. 단지 웹
서버의 uid/gid 만 이러한 파일들을 읽을 수 있도록 허가권을 변경할 수는
있다. 그러나 이 접근 방법은 사용자가 웹 서버에게 자신의 스크립트를
실행시키도록 할 수 있다면 효과가 없을 것이다 (사용자가 단지 파일에
접근하는 스크립트를 작성할 수 있다). 기본적으로 사이트가 신뢰되지 않은 
사람들과 공유되는 서버에서 호스팅되고 있다면 시스템을 안전하게 하는 것은
어렵다. 한가지 접근 방법은 각자가 다른 허가권을 갖는 다중 웹 서버
프로그램을 실행시키는 것인데 이는 더욱 향상된 보안을 제공하지만 실제로
매우 힘들다. 다른 접근 방법은 이러한 파일들을 각자의 uid/gid 에 의해서만
읽을 수 있도록 설정하여 서버가 ``각자"의 허가권으로 스크립트를
실행시키게 하는 것이다. 이 두번째 방법은 자체적으로 문제를 갖고 있는데
서버의 어떤 부분들이 루트 권한을 가져야 하며 스크립트가 필요 이상의
권한을 가질 수도 있다는 것이다.&#13;</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="LANGUAGE-SPECIFIC"
>9&#51109;. 언어에 특정적인 쟁점 </A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>Undoubtedly there are all sorts of languages in the world,
yet none of them is without meaning.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>1 Corinthians 14:10 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><P
>&#13;언어들에 특정적인 많은 보안 문제들이 있는데 이들은 다음과 같이 요약될 수 있다:

<P
></P
><UL
><LI
><P
>&#13;현실적으로 사용할 수 있는 모든 관련 경고와 보호 메카니즘을 켜라. 컴파일
언어의 경우 이는 컴파일타임 및 런타임 메카니즘 모두를 포함한다.
일반적으로 보안 관련 프로그램들은 모든 경고가 켜진채 새롭게 컴파일
되어야 한다.&#13;</P
></LI
><LI
><P
>&#13;언어에 위험하고 반대되고 있는 연산들을 피해라. 정확히 사용하기 어려운
연산들이 "위험"한 것이다.&#13;</P
></LI
><LI
><P
>&#13;언어의 인프라 (예, 런타임 라이브러리) 가 사용될 수 있는지 안전하게
보호되어 있는 지를 보증해라.&#13;</P
></LI
><LI
><P
>&#13;문자열을 자동적으로 가비지 컬렉트하는 언어들은 기밀 데이타를 즉시
지우는데 특히 주의해야 한다 (특히 비밀키와 패스워드).&#13;</P
></LI
><LI
><P
>&#13;사용하고 있는 연산들의 의미 규칙을 정확히 알아라. 문서내에서 각 연산의
의미 규칙을 찾아라. 적절하다고 확신하지 못한다면 반환값들을 무시하지 마라.
"signed" 와 "unsigned" 값들 사이의 차이를 무시하지 마라. 이는 C 와 같이
예외 처리를 지원하지 않는 언어에서 특히 어렵지만 방법은 있다.&#13;</P
></LI
></UL
></P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="C-CPP"
>9.1. C/C++</A
></H2
><P
>&#13;C 및 C++ 프로그램과 관련된 가장 커다란 보안 문제중의 하나는 버퍼
오버플로우로 더욱 자세한 정보는 <A
HREF="#BUFFER-OVERFLOW"
>5&#51109;</A
> 을
보라. C 는 예외 처리를 지원하지 않는다는 추가적인 약점을 갖고 있는데
이는 중대한 에러 상황을 무시하는 프로그램 작성을 용이하게 한다.&#13;</P
><P
>&#13;C 와 C++ 에서 문자 타입 ``char" 은 컴파일러와 머신에 따라 signed 또는
unsigned 될 수 있다 는것은 한가지 혼란스런 문제이다. 상위 비트가
설정되어 있는 signed char 이 정수로 저장될 때 결과는 음수일 것인데 어떤
경우 이는 악용될 수 있다. 일반적으로 127 (0x71) 보다 큰 값을 가질 수도
있는 문자 데이타를 다룰때 버퍼, 포인터와 캐스트에 대해서는 char 또는
signed char 대신 ``unsigned char" 를 사용해라.&#13;</P
><P
>&#13;C 와 C++ 은 타입 검사 지원에 있어 정의상 상당히 모호하지만 코드에서
모호할 필요는 없다. 가능한 한 많은 컴파일러 경고를 켜고 코드를
변경해서 이와함께 새롭게 컴파일하며 모든 함수 호출이 정확한 타입을
사용하는 지를 보장하기 위해 별도의 헤더 (.h) 파일에 ANSI 원형을 엄격히
사용해라. gcc 를 사용한 C 또는 C++ 컴파일의 경우 적어도 많은 경고
메시지를 켜는 다음을 컴파일 플래그로 사용해 모든 경고를 제거하려고 해라
(어떤 경고는 더욱 높은 최적화 수준에서 수행되는 데이타 플로우 분석에
의해서만 탐지될 수 있기 때문에 -O2 가 사용됨을 주목해라):

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>gcc -Wall -Wpointer-arith -Wstrict-prototypes -O2</PRE
></TD
></TR
></TABLE
>

또한 "-W -pedantic" 을 사용할 수도 있다.&#13;</P
><P
>&#13;많은 C/C++ 컴파일러는 부정확한 포맷 문자열들을 탐지할 수 있다. 예를 들어
gcc 는 함수를 표시하기 위해 __attribute__() 기능 (C 확장) 을 사용한다면
이 함수에 대한 부정확한 포맷 문자열에 대해 경고를 할 수 있으며 코드를
이식불가능하게 만들지 않고서도 이 기능을 사용할 수 있다. 다음은 헤더
(.h) 파일에 있는 예이다:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> /* in header.h */
 #ifndef __GNUC__
 #  define __attribute__(x) /*nothing*/
 #endif

 extern void logprintf(const char *format, ...)
    __attribute__((format(printf,1,2)));
 extern void logprintva(const char *format, va_list args)
    __attribute__((format(printf,1,0)));</PRE
></TD
></TR
></TABLE
>

"format" 속성은 "printf" 또는 "scanf" 를 취하며 숫자들은 각각 포맷
문자열의 매개변수와 첫번째 variadic 매개변수의 수이다. GNU docs 에
이들에 대해 잘 설명되어 있다. "noreturn" 와 "const" 와 같은 다른
__attribute__ 기능들도 있음을 주목해라.&#13;</P
><P
>&#13;가능한 열거되는 값들을 정의하기 위해 특별한 값을 갖는 ``char" 또는
``int" 가 아닌 ``enum" 을 사용해라. 이는 컴파일러가 모든 합법적인 값들이
다루어졌는지 결정하기 위해 사용될 수 있는 switch 문의 값들에 대해 특히
유용하다. &#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PERL"
>9.2. 펄</A
></H2
><P
>&#13;펄 프로그래머들은 보안적인 프로그램 작성과 관련된 많은 문제점들을
설명하는 perlsec(1) 맨 페이지를 우선 읽어야 한다. 특히 perlsec(1) 은
대부분의 보안적인 펄 프로그램들이 사용해야 하는 "taint" 모드를 설명하고
있다. Taint 모드는 real 과 effective 사용자 또는 그룹 ID 가 다르면
자동적으로 허가되며 또한 -T 커맨드 라인 플래그를 사용할 수도 있다 (CGI
스크립트와 같이 어떤 누구가를 대신해 작동시킨다면 이를 추후에 사용해라).
Taint 모드는 경로 디렉토리들이 others 가 write 허가권이 없음을 
확인하기 위해 이들의 검사와 같은 다양한 검사들을 켠다.&#13;</P
><P
>&#13;Taint 모드의 가장 명백한 영향은 프로그램 외부의 어떤 무언가에 우연히
영향을 끼칠 수있는 프로그램 외부로부터 파생된 데이타를 사용하지 못할
수도 있다는 것이다. Taint 모드에서 모든 외부로부터 얻은 입력은
"tainted" 로 표시되며 이에는 커맨드 라인 인수, 환경 변수,
로케일 정보 (perllocale(1) 을 보라), 어떤 시스템 호출의 결과 (readdir,
readlink, getpw* 호출의 gecos 필드) 와 모든 파일 입력들이 있다. Tainted
데이타는 서브 쉘을 호출하는 모든 명령 또는 파일, 디렉토리 또는
프로세스를 변경하는 모든 명령에서 직접적 또는 간접적으로 사용되지 못할
수 있다. 한가지 중요한 예외도 있는데 인수 목록을 system 또는 exec 에
건네준 경우 그 목록의 요소들은 tainedness 에 NOT 으로 체크된다. 따라서
taint 모드에서 system 또는 exec 에 특히 주의해라.&#13;</P
><P
>&#13;Tainted 데이타로부터 파생된 모든 데이타 값도 또한 tainted 된다.  한가지
예외가 있는데 데이타를 untainting 하는 방법은 tainted 데이타로부터 서브
문자열을 추출하는 것이다. 그렇지만 마구잡이로 그저 ".*" 를 서브 문자열로
사용하지 마라 이는 tainting 메카니즘의 보호를 무너뜨릴 수도 있다. 대신
프로그램이 허용하는 ``안전한" 패턴으로 확인된 패턴들만을 식별하고 이들을
사용해 "확실한" 값들을 추출해라. 값을 추출한 후라도 이를 검사할 필요가
있다 (특히 길이에 대해 검사할 필요가 있다).&#13;</P
><P
>&#13;open, glob 와 backtick 함수들은 파일 이름의 와일드카드 문자들을 확장하기
위해 쉘을 사용하는데 이는 보안 구멍을 열기 위해 사용될 수 있다. 이러한
함수들을 전적으로 피하거나 perlsec(1) 에 기술된 것과 같이 권한이 적은
sandbox 에서 이들을 사용할 수 있다. 특히 backtick 은 system()
호출을 사용해 재작성되어야 한다 (또는 더욱 좋은 방법으로는 완전히 더욱
안전한 것으로 변경되어야 한다).&#13;</P
><P
>&#13;펄의 open() 함수는 솔직히 대부분의 보안적인 프로그램에 대해 ``너무나
이상한 방식" 으로 작동하는데 이는 텍스트가 주의깊게 필터링되지 않는다면
많은 보안 문제를 야기할 수 있는 텍스트를 해석한다. 파일 오픈 또는
로크하는 코드를 작성하기 전에 perlopentut(1) 맨 페이지를 참조해라.
대부분의 경우 sysopen() 은 파일 오픈에 더욱 복잡함에도 불구하고 더욱
안전한 방법을 제공하는데 <A
HREF="http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-03/msg02596.html"
TARGET="_top"
>새로운
펄 5.6 에는 매우 복잡한 sysopen() 기능을 필요로 함이 없이 이상한 거동을
끄기 위해 3개의 매개변수를 갖는 open() 호출이 추가되어 있다.</A
>.&#13;</P
><P
>&#13;펄 프로그램은 잠재적으로 위험하거나 쓸모없는 문장들을 경고하는 경고
플래그 (-w) 를 켜야 한다.&#13;</P
><P
>&#13;제한된 환경에서 펄 프로그램을 실행시킬 수도 있는데 더욱 자세한 정보는
표준 펄 배포판에서 "Safe" 모듈을 보라. 저자는 이 모듈이 수행하는 감사의
양을 분명히 모르는데 따라서 보안을 위해 이 모듈을 주의해서 사용해라. 또한 
"Penguin Model for Secure Distributed Internet Scripting" 를 고찰할 수도 있다. 
그러나 이 문서 작성시점에서 코드와 문서가 도움이 되지 않는 것같다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PYTHON"
>9.3. 파이썬</A
></H2
><P
>&#13;모든 언어에서와 같이 반드시 신뢰되지 않은 사용자가 입력에 영향을 미칠 
수 없도록 데이타가 프로그램의 한 부분으로 실행되도록 하는 모든 함수들에
주의해라. 이 함수로는 exec(), eval() 과 exefile() 이 있다 (솔직히
compile() 에 대한 모든 호출을 검사해야 한다). 또한 input() 문도 예기치
않게 위험하다 [Watters 1996, 150].&#13;</P
><P
>&#13;권한이 없는 사용자에 의해 호출될 수 있는 권한을 갖는 파이썬 프로그램들은
(예, setuid/setgid 프로그램) "user (사용자)" 모듈을 import 하지 않아야
한다. user 모듈은 pthonrc.py 파일이 읽혀져 실행되게 한다. 이 파일을 
신뢰되지 않은 사용자가 제어할 수 있기 때문에 user 모듈을 import 하는
것은 공격자에게 신뢰된 프로그램이 임의의 코드를 실행시키도록 할 수 있다.&#13;</P
><P
>&#13;파이썬은 컴파일시 검사를 거의 하지 않는다 -- 본질적으로 컴파일시 어떠한 
타입 정보도 갖지 않으며 건네지는 매개변수의 수가 주어진 함수 또는 메쏘드에 대해 
합법적인지를 전혀 검사하지 않는다. 이는 잠재적인 많은 버그를 야기하는데 
John Viega 와 저자는 이 문제를 경험해왔다. 잘된다면 언젠가 파이썬은 
오랫동안 논의되어온 개념인 선택적인 정적 타이핑 및 타입 검사를 구현할 것이다. 
현재 부분적인 해결 방법은 파이썬 소스 코드내의 일반적인 버그를 검사하는 
lint 같은 프로그램인 PyChecker 로 <A
HREF="http://pychecker.sourceforge.net"
TARGET="_top"
>http://pychecker.sourceforge.net</A
> 에서 얻을 수 있다.&#13;</P
><P
>&#13;파이썬은 RExec 클래스를 통해 ``제한된 실행 (Restricted Execution)" 을
지원한다. 이는 본래 애플릿과 모바일 코드를 실행시키기 위한 것이지만
코드가 외부에서 제공되지 않을 때에도 프로그램내의 권한을 제한하기
위해 또한 사용될 수 있다. 디폴트로 제한된 실행 환경은 파일 읽기 (쓰기가
아닌) 를 허용하지만 네트워크 접근 또는 GUI 상호작용을 위한 연산을
포함하지는 않는다. 이러한 디폴트는 변경될 수 있는데 제한된 환경에서 허점
(loophole) 생성에 주의해라. 특히 사용자에게 클래스에 속성을 제한없이 
추가하도록 허용하는 것은 파이썬 구현이 많은 숨겨진 메쏘드를 호출하기
때문에 환경을 깨뜨릴 수 있는 모든 종류의 방법을 허용한다. 디폴트로
대부분의 파이썬 객체는 참조에 의해 전달됨을 주목해라; 가변값에 대한
참조를 제한된 프로그램의 환경내에 삽입한다면 제한된 프로그램은 제한된
환경 외부에서 보일 수 있게 객체를 변경할 수 있다. 따라서
가변값에 대한 접근을 허용하려면 많은 경우 가변값을 복사하거나 다른
객체에 대한 제한된 접근을 지원하는 Bation 모듈을 사용해야 한다. 더욱
자세한 정보는 Kuchling [2000] 을 보라. 저자는 제한된 실행 능력이
수행하는 감사의 양에 대해 잘 모르며 따라서 프로그래머들은 주의해라.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SHELL"
>9.4. 쉘 스크립팅 언어 (sh 과 csh Deritivatives)</A
></H2
><P
>&#13;저자는 setuid/setgid 보안적인 코드에 대해 csh, sh 와 bash 와 같은 표준
커맨드 쉘 스크립팅 언어를 사용하지 말라고 추천한다. 리눅스와 같은 몇몇 
시스템들은 이들을 완전히 금지하기 때문에 불필요한 이식성 문제를 만들
수 있다. 어떤 오래된 시스템에서 이들은 <A
HREF="#PROCESS-CREATION"
>3.1.3&#51208;</A
>
에서 논의된 바와 같이 경쟁 상태때문에 기본적으로 비보안적이며 다른
시스템에 대해서도 이들은 실제로 좋은 개념이 아니다. 표준 커맨드 쉘은
아직도 명백하지 않은 입력에 의해 영향을 받는 것으로 유명한데  이는
일반적으로 커맨드 쉘이 과감한 공격자에 대해 보호하는 것이 아니라 대화식
사용자들을 위해 자동적으로 작업을 하려고 설계되었기 때문이다. 예를
들어 숨겨진 환경 변수 (예, ENV 또는 BASH_ENV 변수) 는 스크립트가 실행될
수 있기 전이라도 임의의 사용자 정의 코드를 어떻게 연산 또는 더
나아가서는 실행시키는지에 영향을 미칠 수 있다. 실행가능 파일의 이름 또는
디렉토리 내용같은 것들도 영향을 끼칠 수 있는데 예를 들어 많은 Bourne 쉘
구현에서 다음은 루트 권한을 줄 수 있다 (이 악용 설명에 대해 NCSA 에
감사한다).

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> % ln -s /usr/bin/setuid-shell /tmp/-x
 % cd /tmp
 % -x</PRE
></TD
></TR
></TABLE
>

몇몇 시스템은 이 보안 구멍을 막을 수 있지만 문제는 아직 남아있는데
대부분의 커맨드 쉘이 보안적인 setuid/setgid 프로그램을 작성하도록
의도되지 않았다는 것이다. 프로그래밍 목적으로 setuid 쉘 스크립트를
허용하는 시스템이라고 하더라도 이들의 생성을 피해라. 대신 환경을 깨끗이
하기 위해 다른 언어로 작은 프로그램을 작성한 후 이 프로그램이 다른
실행가능한 파일을 호출하도록 해라 (이들 중의 일부는 쉘 스크립트일 수도
있다).&#13;</P
><P
>&#13;아직도 쉘 스크립팅 언어의 사용을 주장한다면 적어도 스크립트를 이동 또는
변경될 수 없는 디렉토리내에 두어라. 스크립트의 맨 앞에 PATH 와 IFS 를
알려진 값들로 설정해라.&#13;</P
><P
>&#13;비슷한 맥락으로 저자는 보안적인 정책을 구현하는 ``제한적인 쉘" 을 신뢰하지 
않아야 한다고 충고한다. 제한적인 쉘은 의도적으로 사용자로 하여금 많은 
작업을 수행하지 못하게 하는 쉘로 그 목적은 사용자에게 단지 아주 소수의 
프로그램들만을 실행시킬 수 있도록 하는 것이다. 제한적인 쉘은 철처한 방어 
(defense-in-depth) 조치로 유용할 수 있지만 정확하게 설정하는 것이 어렵다고 
알려져 있으며 설정되더라도 대개 파괴될 수 있다. 
예를 들어 몇몇 제한적인 쉘은 제한되지 않은 모드에서 어떤 파일 (예, ``.profile) 을 
실행시킴으로써 시작될 수 있다. - 사용자가 이 파일을 변경시킬 수 있다면 쉘은 
변경된 코드를 실행시키는 것이다. 제한적인 쉘은 단지 약간의 프로그랭만을 
실행시킬 수 있도록 설정되어야 하지만 그러한 프로그램중 어떤 프로그램이 
사용자들로 하여금 더욱 많은 프로그램을 실행시키도록 하는 ``쉘 이스케이프" 를 
갖고 있다면 공격자가 이러한 쉘 이스케이프를 사용해 제한적인 쉘을 이스케이프할 
수 있다. 
물론 제한적인 쉘의 PATH 를 설정하지 않아 어떤 프로그램도 실행될 수 없도록 
설정한다 하더라도 공격자는 텍스트 편집기, 메일러 등 많은 프로그램의 쉘 
이스케이프를 사용할 수 있다. 문제는 쉘의 목적이 다른 프로그램을 실행시키는 
것이지만 그러한 다른 프로그램이 의도되지 않은 연산을 허용할 수도 있다는 것이다. 
-- 쉘은 이러한 연산을 못하도록 개입하지 않는다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="ADA"
>9.5. Ada</A
></H2
><P
>&#13;Ada95 에서 Unbounded_String 타입은 필요로하는 만큼 크기가
자동적으로 조절될 수 있기 때문에 String 타입보다 대개 더욱 유연하다.
그러나 패스워드 또는 비밀키와 같이 특히 기밀을 다루는 값들을
Unbounded_String 타입으로 저장하지 마라. 코어 덤프와 페이지
영역이 추후라도 이들을 보유할 수 있다. 대신 이 데이타에는 String 타입을
사용하고 가능한 빨리 데이타를 다른 ' ' 와 같은 어떤 상수값으로  겹쳐 써라.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="JAVA"
>9.6. 자바</A
></H2
><P
>&#13;자바를 사용해서 보안적인 프로그램을 개발하려면 솔직히 자바를 배운 후 첫
단계는 자바 보안에 대한 두 개의 기본 텍스트인 Gong [1999] 와 McGraw
[1999] 를 읽는 것이다 (두번째의 경우 특히 7.1 절을 보라). 또한 <A
HREF="http://java.sun.com/security/seccodeguide.html"
TARGET="_top"
>http://java.sun.com/security/seccodeguide.html</A
>
에서 썬이 게시한 보안 코드 지침들을 보아야 한다. 자바의 보안 모델을
설명하는 일련의 슬라이드들은 <A
HREF="http://www.dwheeler.com/javasec"
TARGET="_top"
>http://www.dwheeler.com/javasec</A
>
에서 얻을 수 있다. 또한 McGraw [1998] 을 볼 수도 있다.&#13;</P
><P
>&#13;명백히 많은 것들은 개발하고 있는 애플리케이션의 유형에 의존하는데 
클라이언트측에서 사용하기 위한 자바 코드는 서버측 코드와는 전혀 다른
환경 (과 신뢰 모델) 을 갖고 있다. 물론 일반적인 원리는 적용된다. 예를
들어 신뢰되지 않은 출처로부터 온 모든 입력을 검사 및 필터링해야 한다.
그러나 자바에는 밑부분에서 논의될 조심해야 할 어떤 숨겨진 입력 또는
잠재적 입력들이 있다. Johnathan Nightingale [2000] 은 자바
프로그래밍에서 많은 문제들을 요약하고 있는 재미있는 문서를 작성했다:

<A
NAME="AEN1496"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;...자바 프로그래밍에서 큰 문제는 상속에 신경을 써야한다는 것이다. 부모,
인터페이스 또는 부모의 인터페이스로부터 메쏘드를 상속한다면 코드에 보안
구멍을 열 것을 각오하는 것이다.&#13;</P
></BLOCKQUOTE
></P
><P
>&#13;다음은 Gong [1999], McGraw [1999], 썬의 길잡이와 저자의 경험에 기초한
중요한 약간의 지침들이다.&#13;</P
><P
></P
><OL
TYPE="1"
><LI
><P
>&#13;public 필드 또는 변수를 사용하지 마라; 이들은 private 으로 선언하고
이들의 접근성을 제한할 수 있도록 이들에 대한 접근자를 제공해라.&#13;</P
></LI
><LI
><P
>&#13;메쏘드를 private 으로 만들지 않을 확실한 이유가 없다면 private 으로
만들어라 (그렇지 않다면 이를 문서화해라). 이러한 non-private
메쏘드들은 tainted 데이타를 받을 수도 있기 때문에 어쨌든 이들을
보호하기 위해 미리 준비하지 않았다면 그들 자신을 보호해야 한다.&#13;</P
></LI
><LI
><P
>&#13;JVM 은 애플릿과는 반대로 애플리케이션에서 런타임시 접근 변경자
(예, private) 를 실제 적용하지 않을 수도 있다. 2000년 11월 7일 "Secure
Programming" 메일링 리스트에서 이를 지적한 John Steven (Cigital Inc.) 에
고맙게 생각한다. 문제는 이 모두가 접근을 요청하는 클래스가 어떤 클래스
로더와 함께 적재되느냐에 의존한다는 것이다. 클래스가 신뢰된 클래스 로더
(null/primordial 클래스 로더를 포함해) 와 함께 적재되면 접근 검사는
접근을 허용하는 "TRUE" 를 반환한다. 예를 들어 이는 적어도 썬의 1.2.2 VM
과 함께 작동하는데 그러나 다른 버전에서는 작동하지 않을 수도 있다:

<P
></P
><OL
TYPE="a"
><LI
><P
>public 필드를 갖는 victim 클래스 (V) 를 작성해 컴파일해라.</P
></LI
><LI
><P
>이 필드에 접근하는 attack 클래스 (A) 를 작성해 컴파일해라.</P
></LI
><LI
><P
>V 의 public 필드를 private 으로 변경한 후 다시 컴파일해라.</P
></LI
><LI
><P
>A 를 실행시켜라 - 이는 V 의 (지금은 private) 필드에 접근할 것이다.</P
></LI
></OL
></P
><P
>&#13;그러나 애플릿의 경우는 상황이 다르다. A 를 애플릿으로 변환하고 애플릿뷰어
또는 브라우저로 이를 실행시키면 A 의 클래스 로더는 더이상 신뢰된 (또는
null) 클래스 로더가 아니다. 따라서 코드는 클래스 A 로부터 V.secret
필드를 접근하려 하고 있다는 메시지와 함께 java.lang.IllegralAccessError
를 발생시킬 것이다.&#13;</P
></LI
><LI
><P
>&#13;정적 필드 변수의 사용을 피해라. 이러한 변수는 클래스 (인스턴스가 아닌)
에 소속된 것으로 모든 다른 클래스가 클래스의 위치를 찾을 수 있다.
그 결과 정적 필드 변수는 모든 다른 클래스가 찾을 수 있으며 따라서 정적
필드 변수를 안전하게 하는 것은 더욱 어렵다.&#13;</P
></LI
><LI
><P
>&#13;잠재적으로 악의있는 코드에 가변 객체를 절대로 반환하지 마라 (코드가 이를
변경하기로 결정할 수도 있기 때문에). 배열은 가변적 (물론 배열의 내용들은
가변적이 아닐지라도) 임을 주목해라. 따라서 기밀을 다루는 데이타를 갖는 내부
배열에 대한 참조를 반환하지 마라.&#13;</P
></LI
><LI
><P
>&#13;절대로 사용자가 제공한 가변 객체 (객체의 배열을 포함해) 를 직접적으로
저장하지 마라. 그렇지 않으면 사용자가 객체를 보안적인 코드에 건네주고 
보안적인 코드가 객체를 검사하게 한 후 보안적인 코드가 데이타를 사용하려고 
하는 동안 데이타를 변경할 수 있다. 배열을 내부적으로 저장하기 전에
복제 (clone) 하고 이에 주의해라 (사용자가 작성한 복제 루틴에 주의해라).&#13;</P
></LI
><LI
><P
>&#13;초기화에 의존하지 마라. 초기화되지 않은 객체를 할당하는 몇몇 방법이
있다.&#13;</P
></LI
><LI
><P
>&#13;확실한 이유가 없다면 모든 것을 final 로 만들어라. 클래스 또는 메쏘드가
final 이 아니라면 공격자가 이를 위험하고 예기치 못한 방식으로 확장하려고
할 수 있다. 물론 이는 보안적이지만 확장성을 잃음을 주목해라.&#13;</P
></LI
><LI
><P
>&#13;보안을 위해 패키지 유효 범위 (scope) 에 의존하지 마라. java.lang 와 같은
약간의 클래스들은 디폴트로 닫혀 있으며 몇몇 JVM (Java Virtual Machine) 은
다른 패키지들을 닫도록 한다. 그렇지 않으면 자바 클래스들은 닫혀있지 않은 
상태이다. 따라서 공격자가 패키지안에 새로운 클래스를 도입해서 이를 사용해
보호하고 있다고 생각하는 것에 접근할 수 있다.&#13;</P
></LI
><LI
><P
>&#13;내부 클래스를 사용하지 마라. 내부 클래스가 바이트 코드로 변환될 때 내부
클래스는 패키지 내의 모든 클래스에 접근할 수 있는 클래스로 변환된다.
더욱 바람직하지 않은 것은 내부 클래스를 갖고 있는 (enclosing) 클래스의
private 필드가 소리없이 non-private 가 되어 내부 클래스에 의한 접근을
허용한다.&#13;</P
></LI
><LI
><P
>&#13;권한을 최소화해라. 가능한 어떠한 특별한 허가권도 요구하지 마라. McGraw 는
더 나아가서 모든 코드에 서명하지 말라고 권하고 있다 ; 저자는 더 나아가서
코드에 서명하지만 (따라서 사용자들은 단지 이 전송자 목록에 의해 서명된
코드만 실행시키기로 정할 수 있다) sandbox 권한셋 이상을 필요로 하지 않는
프로그램을 작성하라고 말한다. 더욱 많은 권한을 가져야 한다면 코드를
특별히 엄하게 감사해라.&#13;</P
></LI
><LI
><P
>&#13;코드에 서명해야 한다면 이를 모두 한 아카이브 파일에 놓아라. 여기서
McGraw [1999] 를 인용하는 것이 최선이다.

<A
NAME="AEN1534"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;이 규칙의 목적은 공격자가 악의있는 클래스와 각자가 서명한 클래스들중 일부를
링크시키거나 절대로 함께 사용되지 않아야 하는 서명된 클래스들을 함께
링크시키는 새로운 애플릿 또는 라이브러리를 구축하는 mix-and-match 공격을
수행하지 못하도록 하는 것이다. 일단의 클래스들을 함께 서명함으로써 이
공격을 더 어렵게 만들어라. 기존의 코드 서명 시스템은 mix-and-match
공격을 예방하기에 부적절한데 따라서 이 규칙이 이러한 공격을 완전히
예방할 수는 없다. 그러나 하나의 아카이브를 사용하는 것이 나쁜 영향을
미칠 수는 없다.&#13;</P
></BLOCKQUOTE
>&#13;</P
></LI
><LI
><P
>&#13;클래스를 복제 불가능하게 만들어라. 자바의 객체 복제 메카니즘은 공격자가
생성자들 중 어떤 것도 실행시키지 않고도 클래스를 인스턴스화할 수 있도록
한다. 클래스를 불제 불가능하게 만들기 위해서는 단지 각 클래스에 다음
메쏘드를 정의해라:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>public final void clone() throws java.lang.CloneNotSupportedException {
   throw new java.lang.CloneNotSupportedException();
   }</PRE
></TD
></TR
></TABLE
>&#13;</P
><P
>&#13;클래스를 정말 복제가능하게 만들 필요가 있다면 공격자가 클론 메쏘드를
재정의하지 못하도록 취할 수 있는 약간의 보호 조치가 있다. 각자의 클론
메쏘드를 정의한다면 단지 이를 final 로 정의해라. 그렇지 않으면 다음을
추가함으로써 최소한 클론 메쏘드가 악의적으로 재정의되는 것을 예방할 수
있다:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>public final void clone() throws java.lang.CloneNotSupportedException {
  super.clone();
  }</PRE
></TD
></TR
></TABLE
>&#13;</P
></LI
><LI
><P
>&#13;클래스를 unserializeable 로 만들어라. 직렬화는 공격자가 객체뿐만 아니라
private 부분들의 내부 상태를 볼 수 있도록 한다. 이를 예방하기 위해
클래스에 다음 메쏘드를 추가해라:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>private final void writeObject(ObjectOutputStream out)
  throws java.io.IOException {
     throw new java.io.IOException("Object cannot be serialized");
  }</PRE
></TD
></TR
></TABLE
>&#13;</P
><P
>&#13;직렬화가 무방한 경우라도 반드시 시스템 자원에 대한 직접적인 핸들과 주소 공간에
대한 정보를 포함하는 필드에 대해 transient 키워드를 사용해라. 그렇지
않으면 클래스를 deserializing 함으로써 부적절한 접근을 허용할 수도 있다.
또한 기밀을 다루는 정보를 transient 로 식별하려고 할 수도 있다.&#13;</P
><P
>&#13;클래스에 대해 각자의 직렬화 메쏘드를 정의한다면 배열을 취하는 모든 
DataInput/DataOutput 에 내부 배열을 전달해서는 안된다. 근본적 이유는 모든
DataInput/DataOutput 메쏘드들은 재정의될 수 있기 때문이다. Serializable
클래스가 DataOutput (write(byte [] b)) 메쏘드에 직접적으로 private
배열을 보낸다면 공격자는 private 배열을 접근 및 변경할 수 있도록 서브
클래스 ObjectOutputStream 을 사용해 write(byte [] b) 메쏘드를 재정의할
수 있다. 디폴트 serialization 은 DataInput/DataOutput 바이트 배열
메쏘드에 private 바이트 배열 필드를 드러내지 않음을 주목해라.&#13;</P
></LI
><LI
><P
>&#13;클래스를 undeserializeable 하게 만들어라. 클래스가 serializeable 하지
않더라도 deserializeable 일 수 있다. 공격자는 자신이 선택한 값을 갖는
클래스의 인스턴스에 우연히 deserialize 할 수 있는 바이트 시퀀스를 생성할
수 있다. 다른 말로 deserialization 은 일종의 public 생성자로 공격자가
객체 상태를 선택할 수 있도록 하는데 이는 명백히 위험한 연산이다. 이를
예방하기 위해 클래스에 다음 메쏘드를 추가해라:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>private final void readObject(ObjectInputStream in)
  throws java.io.IOException {
    throw new java.io.IOException("Class cannot be deserialized");
  }</PRE
></TD
></TR
></TABLE
>&#13;</P
></LI
><LI
><P
>&#13;이름으로 클래스를 비교하지 마라. 결국 공격자는 동일한 이름을 갖는
클래스를 정의할 수 있으며 주의하지 않는다면 이러한 클래스에 부적당한
권한을 허용함으로써 혼동을 일으킬 수 있다. 다음은 객체가 주어진 클래스를
갖는지를 결정하는데 있어 <B
CLASS="EMPHASIS"
>잘못된</B
> 방법의 예이다:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  if (obj.getClass().getName().equals("Foo")) {</PRE
></TD
></TR
></TABLE
>&#13;</P
><P
>&#13;두 객체가 정확히 동일한 클래스를 갖는지 결정할 필요가 있다면 대신 양측에
모두 getClass() 를 사용하고 == 연산자를 사용해 비교해라. 이는 다음과
같이 사용해야 한다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  if (a.getClass() == b.getClass()) {</PRE
></TD
></TR
></TABLE
><P
>&#13;객체가 주어진 클래스이름을 갖는지 정확히 결정할 필요가 있다면 현재
클래스의 ClassLoader 의 현재 이름공간을 사용하는지를 확인할 필요가 있다.
따라서 다음 포맷을 사용할 필요가 있을 것이다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  if (obj.getClass() == this.getClassLoader().loadClass("Foo")) {</PRE
></TD
></TR
></TABLE
><P
>&#13;이 지침은 McGraw 와 Felten 에 의한 것으로 아주 훌륭한 지침인데 저자는
어쨌든 클래스 값들의 비교를 가능한 피하는 것이 언제나 좋은 생각이라고
추가할 것이다. 물론 이를 전혀 할 필요가 없도록 클래스 메쏘드와
인터페이스를 설계하려는 것이 더욱 확실한 방법이다. 그러나 이 방법이 늘
실용적이지는 않으며 따라서 이러한 요령을 아는 것이 중요하다.&#13;</P
></LI
><LI
><P
>&#13;암호화키, 패스워드 또는 알고리듬 같은 비밀을 코드 또는 데이타에 저장하지
마라. 악의가 있는 JVM 들은 빨리 이 데이타를 볼 수 있다. 코드 obfuscation
(애매화) 이 실제로 심각한 공격자들로부터 코드를 숨기지는 않는다.&#13;</P
></LI
></OL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="TCL"
>9.7. TCL</A
></H2
><P
>&#13;TCL 은 "tool command language (툴 커맨드 언어)" 의 약어로 tickle 로
발음한다. TCL 은 언어와 라이브러리 두 부분으로 나누어져 있다. 언어는
간단한 텍스트 언어로 대화식 프로그램에 명령을 내주도록 의도되었으며
기본적인 프로그래밍 능력을 포함하고 있으며 라이브버리는 애플리케이션
프로그램에 내장될 수 있다.&#13;</P
><P
>&#13;<A
HREF="http://www.sco.com/Technology/tcl/Tcl.html"
TARGET="_top"
>TCL WWW
Info</A
> 웹 페이지와 같은 사이트에서 TCL 에 대한 더욱 자세한 정보를
얻을 수 있다. 아마 대부분의 관심사는 WebWiseTclTk 뿐만 아니라 Safe-TCL
(TCL 에서 sandbox 를 생성한다) 과 Safe-TK (Safe-TCL 에 대해 sandboxed 된
이식가능한 GUI 를 구현한다) 툴킷이 TCL 패키지가 World Wide Web
어느곳에서나 자동적으로 위치해 적재될 수 있도록 한다는 것이다. <A
HREF="http://www.cbl.ncsu.edu/software/WebWiseTclTk"
TARGET="_top"
>http://www.cbl.ncsu.edu/software/WebWiseTclTk</A
>
에서 WebWiseTclTk 에 대한 더욱 자세한 정보를 찾을 수 있다. 그러나 이것이
얼마나 많은 코드 검토를 받았는지 저자에게는 명확하지 않은데 더욱 자세한
정보는 <A
HREF="http://www.tclfaq.wservice.com/tcl-faq"
TARGET="_top"
>http://www.tclfaq.wservice.com/tcl-faq</A
>
에 있는 comp.lang.tcl FAQ 시작 페이지에서 얻을 수 있다. 그러나 TCL 을
작고 "단순한" 언어로 만들려고 한 바램이 오히려 제한된 언어를 초래했음을
언급하는 것은 가치가 있는데 <A
HREF="http://sdg.lcs.mit.edu/~jchapin/6853-FT97/Papers/stallman-tcl.html"
TARGET="_top"
>Richard Stallman's ``Why You Should Not Use TCL''</A
> 를 보라. 예를
들어 반드시 단 한가지 데이타 타입 (문자열) 만이 있다는 TCL 개념은
프로그램을 느리게 만들뿐 아니라 많은 프로그램의 작성을 어렵게 만들 수
있다. 또한 저자가 TCL 프로그램을 작성했을 때 악의있는 입력 문자열이
다루기 어렵고 예기치 않은 동작을 일으킬 수있는 TCL 프로그램을 우연히
작성하는 것이 쉬움을 발견했다. 예를 들어 공격자는 내장 스페이스, 이중
인용 부호, curly braces, dollar signs 또는 brackets 과 같이 TCL 에
특별한 의미를 갖는 문자를 TCL 에 보냄으로써 예기지 않은 일을 하게끔
(또는 이러한 문자들이 처리중에 생성되게끔 하는 입력을 생성하게끔) 할
수도 있다. 따라서 저자는 보안 목적을 위한 프로그램을 작성할 때 TCL 을
추천하지 않는다. 그렇게 하려면 특히 사용자 입력이 프로그램을 속일 수
없음을 보증하는데 주의해라. 다른 한편으로 저자는 TCL 프로그램이 모바일
코드를 구현하는 데 사용될 수 없는 어떠한 이유도 모른다. 저자보다 더욱
많은 사용을 옹호하는 TCL 지지자도 분명히 있으며 TCL 은 이미 만들어진
sandbox 구현을 갖고 있는 얼마 안되는 언어중의 하나이다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PHP"
>9.8. PHP</A
></H2
><P
>&#13;SecureReality 는 "A Study in Scarlet - Exploiting Common Vulnerabilities in PHP" 
라는 매우 흥미로운 논문을 발표하였다 [Clowes 2001]. 이 논문은 PHP, 특히 PHP 
4.1.0 이전 버전에서 보안적인 프로그램을 작성하는데 있어서 다소의 문제들을 
논의하고 있다. Clowes 는 ``디폴트 PHP 설정에서 보안적인 PHP 애플리케이션을 
작성하는 것은 각자 노력한다고 하더라도 매우 어렵다" 고 결론지었다.&#13;</P
><P
>&#13;모든 언어에 보안 문제가 있다고 하더라도 PHP 에는 PHP 를 대부분의 언어들보다 
비보안적이게 하는 한가지 특별한 문제가 있다; 이는 데이타를 이름공간에 적재하는 
방식이다. 디폴트로 PHP (버전 4.1.0 이하) 에서는 웹을 통해 PHP 로 보내지는 
모든 환경 변수 및 값이 일반적인 변수들이 적재되는 동일한 이름공간 (전역변수) 내로 
자동적으로 적재된다 - 따라서 공격자는 임의의 변수에 임의의 값을 설정할 수 있으며 
PHP 프로그램이 명시적으로 재설정하지 않는다면 이 값이 유지된다. 게다가 PHP 는 
처음 요청될 때 디폴트 값을 갖는 변수를 자동적으로 생성하는데 따라서 PHP 
프로그램이 변수를 초기화하지 않는 것이 일반적이다. 
변수 설정을 하지 않는 경우 PHP 가 이를 보고할 수는 있지만 디폴트로 그렇게 하지 
않을 것이다 - 이는 단순히 에러 보고로 이러한 에러를 야기하는 예외적인 방식을 
발견한 공격자를 막지 못할 것음을 주목해라. 따라서 디폴트로 PHP 는 프로그램이 
공격자를 무시하기 위해 특별히 주의를 하지 않는다면 공격자가 프로그램내의 
모든 변수 값을 완전히 제어할 수 있도록 한다. 일단 공격자가 프로그램을 제어하게 
된다면 이러한 변수를 재설정할 수 있으며  따라서 각자 어떤 변수(명확하진 않지만 
적어도 한개의 변수) 를 재설정하지 못한다면 PHP 프로그램을 취약하게 만들 수도 있다.&#13;</P
><P
>&#13;예를 들어 다음 PHP 프로그램 (Clowes 로부터의 예제) 은 패스워드를 알고 있는 
사람들에게 단지 어떤 중요한 정보를 얻도록 하지만 공격자는 그 사람들의 웹 
브라우저에 ``auth" 를 설정해 인가 검사를 파괴할 수 있다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> &#60;?php
  if ($pass == "hello")
   $auth = 1;
  ...
  if ($auth == 1)
   echo "some important information";
 ?&#62;</PRE
></TD
></TR
></TABLE
><P
>&#13;저자와 많은 사람들은 이러한 특별히 위험한 문제에 대해 푸념해왔지만 이는 
PHP 가 널리 사용되고 있기 때문에 특별한 문제이다. 
결국 사용하기 쉽다고 알려진 언어는 보안적인 프로그램 작성을 더욱 쉽게한다. 
PHP 에서 ``register_globals" 를 ``off" 로 설정함으로써 이러한 잘못된 특징을 
금지하는 것은 가능하지만 디폴트로 4.1.0 이상의 PHP 버전은 이를 ``on" 으로 
설정하며 4.1.0 이전 PHP 버전은 register_globals 를 off 설정하는 경우 더욱 사용하기 
어렵다. PHP 개발자들은 4.1.0 버전 발표에서 ``다음 semi-major 버전에서는 
PHP 의 신규 설치시 디폴트로 register_globals 를 off 로 설정할 것이다" 라고 공표했다. &#13;</P
><P
>&#13;``register_globals" 가 ``on" 으로 설정되어 있는 경우 중요한 프로그램에 대해 
PHP 는 위험하다 - 비보안적인 프로그램을 작성하는 것이 너무나도 쉽다. 
그러나 ``register_globals" 가 일단 ``off" 로 설정된다면 PHP 는 합당한 개발 언어이다. &#13;</P
><P
>&#13;보안적인 디폴트는 ``register_globals" 를 ``off" 로 설정해야 하며 또한 사용자들이 
외부 출처로부터 받아들일 수 있는 입력을 지정하고 제한하는 것을 더욱 쉽게 하는 
몇몇 함수를 포함해야 한다. 아파치와 같은 웹 서버들은 이러한 보안적인 PHP 설치를 
개별적으로 설정할 수 있다. 사용자들이 받아들이길 원하는 입력 변수를 열거하기 
쉽게 하는 루틴들이 PHP 라이브러리에 놓일 수도 있다; 몇몇 함수들은 이러한 
변수들이 가져야하는 패턴 및/또는 요구되는 변수 타입을 검사해야 한다. 
저자 의견으로는 PHP (register_globals 가 on 으로 설정) 는 현재 훌륭한 
보안적인 웹 개발 언어는 아니다. 그러나 합당한 개발 언어로 사용되도록 
쉽게 수정될 수 있다.&#13;</P
><P
>&#13;PHP 를 사용하기로 한 경우 다음은 얼마간의 저자의 충고이다 (이러한 충고 중 
많은 부분은 Clowes 가 제기한 문제에 대처하기 위한 방법에 기초한다):&#13;</P
><P
></P
><UL
><LI
><P
>&#13;PHP 설정 옵션 ``register_globals" 를 off 로 설정하고 PHP 4.1.0 이상 버전을 사용해라. 
PHP 4.1.0 에는 몇몇 특별한 배열이 추가되어 있는데, 특히 $_REQUEST 는 
``register_globals" 가 off 로 설정되어 있을 때 PHP 로 소프트웨어를 개발하는 것을 
더욱 간단하게 한다. register_globals 를 설정함으로써 대부분의 일반적인 
PHP 공격을 완전히 제거할 수 있는데 이러한 설정이 신규 설치시의 디폴트가 될 때까지 
이에 대비해라. register_globals 가 off 로 설정되어 있다고 가정하더라도 이를 우선적으로 
검사해야 하며 그렇지 않은 경우는 중지해야 한다 - 이렇게 함으로써 프로그램을 
설치한 사람들은 문제가 있음을 재빨리 알아차릴 것이다. 
이러한 설정시 작동하는 제삼자 (third-party) 의 PHP 애플리케이션은 거의 없음을 
주목해라. 따라서 현재 전체 웹 사이트에 대해 이를 off 로 유지하기는 힘들다. 
또한 ``register_globals" 를 금지하는 것이 제삼자에 의해 호스트되고 있을 때는 
더욱더 어렵다. 
단지 몇몇 프로그램에 대해서만 register_globals 를 off 로 설정하는 것이 가능한데 
예를 들어 아파치의 경우 PHP 디렉토리내의 .htaccess 파일에 다음을 삽입할 수 있다 
(또는 이를 더욱 제어하기 위해 Directory 지시를 사용해라).&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> php_flag register_globals Off
 php_flag track_vars On</PRE
></TD
></TR
></TABLE
><P
>&#13;그러나 아파치 웹 서버가 override 를 허가하도록 설정되어 있지 않다면 .htaccess 
파일 자체는 무시된다; 대개 아파치 전역 설정이 되어 있어 AllowOverride 는 None 
으로 설정되어 있다. 
따라서 아파치 사용자를 위해 웹 호스팅 서비스가 설정 파일 (대개 
/etc/http/conf/http.conf) 내에 ``AllowOver 옵션" 을 설정하도록 한다면 그렇게 해라. 
그 후 필요한 데이타 적재를 간단하게 하기 위해 helper 함수를 작성해라.&#13;</P
></LI
><LI
><P
>&#13;널리 사용되고 있는 PHP 애플리케이션을 실행시키면서 register_globals 가 on 으로 
설정될 수도 있는 소프트웨어를 개발해야 한다면 사용자가 제공하지 않은 값을 
언제나 설정하지 마라. PHP 디폴트 값에 의존하지 말고 명시적으로 설정하지 않은 
모든 변수를 신뢰하지 마라. <B
CLASS="EMPHASIS"
>모든</B
> 시작 부분 (예, 모든 
PHP 프로그램 또는 PHP 를 사용하는 HTML 파일) 에 대해 이를 해야 함을 주목해라. 
가장 좋은 접근 방법은 사용할 모든 변수들을 간단히 평범한 디폴트 값 ( "" 또는 0) 
으로 재설정할 예정이라도 이들을 설정함으로써 각각의 PHP 프로그램을 시작하는 
것이다. 이는 포함됨 파일내에서 참조되거나 모든 라이브러리내에서 과도적이라도 
참조되는 전역 변수를 포함한다. 불행히도 자신들이 호출하는 모든 함수에 의해 
사용될 수도 있는 모든 전역 변수를 정확히 알거나 이해하는 개발자들은 거의 
없기 때문에 위의 충고대로 하는 것은 어렵다. 
한가지 대안은 사용자가 데이타를 제공했는지 알아보기 위해 
HTTP_GET_VARS, HTTP_POST_VARS, HTTP_COOKIE_VARS 및 
HTTP_POST_FILES 를 검색하는 것이다 - 그러나 대개 프로그래머들은 
모든 소스를 검사하는 것을 잊어버리는데 PHP 가 새로운 데이타 소스 
(HTTP_POST_FILES 는 예전 PHP 버전에는 없다) 를 추가한다면 
어떤 일이 일어나겠는가.&#13;</P
></LI
><LI
><P
>&#13;에러 보고 수준을 E_ALL 로 설정하고 테스팅 동안에 보고된 모든 에러를 해결해라. 
다른 무엇보다도 이는 PHP 에서의 주요 문제인 초기화되지 않은 변수들에 대해 
에러를 보고할 것이다. 이는 프로그램을 디버깅하는데 도움을 주기 때문에 
PHP 를 사용하려고 할 때 좋은 개념이다. 에러 보고 수준을 설정하는 방법은 
많이 있는데 이는 ``php.ini" 파일 (전역), ``.httpd.conf" 파일 (단일 호스트), 
``.htaccess" 파일 (다중 호스트) 또는 error-reporting 함수를 통해 스크립트의 
상단을 포함한다. 저자는 php.ini 파일 및 스크립트 상단 모두에 에러 보고 수준을 
설정하라고 권한다: 이렇게 함으로써 (1) 스크립트 상단에 명령을 넣는 것을 잊는 
경우 또는 (2) 프로그램을 다른 머신으로 옮기고 php.ini 파일 변경을 잊는 경우 
보호받을 수 있다. 따라서 모든 PHP 프로그램은 다음과 같이 시작해야 한다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  &#60;?php error_reporting(E_ALL);?&#62;</PRE
></TD
></TR
></TABLE
><P
>&#13;이러한 에러 보고는 개발시 설정되어야 하고 실제 사이트에서 실행될 때는 해제되어야 
한다고 (에러 메시지가 공격자에 유용한 정보를 제공할 수 있기 때문에) 주장할 
수도 있다. 문제는 ``실제 사용"시 에러 보고 기능이 금지된다면 개발시 금지된채 
남아있기가 쉽다는 것이다. 따라서 저자는 에러 보고 수준이 설정될 수 있는 모든 
파일에 단순히 이를 포함하는 간단한 방법을 제안한다.&#13;</P
></LI
><LI
><P
>&#13;특히 원격 파일 접근을 예방하기 위해 파일 이름 생성에 사용되는 모든 사용자 
정보를 필터링해라. PHP 는 다른 언어에서 로컬 파일만을 단지 오픈할 수 있는 
fopen() 과 같은 파일-오프닝 명령이 다른 사이트로부터의 웹 또는 ftp 요청을 
수행하는데 사용될 수 있음을 의미하는 ``remote filew" 기능성이 디폴트로 
설정되어 있다.&#13;</P
></LI
><LI
><P
>&#13;예전 스타일의 파일 업로드를 사용하지 마라; HTTP_POST_FILES 배열과 관련된 
함수를 사용해라. PHP 는 특별한 이름을 갖는 어떤 임시디렉토리에 파일을 
업로드함으로써 파일 업로드를 지원한다. PHP 는 그 파일 이름이 존재했던 곳을 
가리키기 위해 원래 많은 변수들을 설정한다. 그러나 공격자가 변수 이름 및 그 
값을 제어할 수 있기 때문에 이들을 사용해 커다란 악영향을 야기할 수 있다. 
대신 업로드된 파일에 접근하기 위해서는 언제나 HTTP_POST_FILES 및 관련된 
함수를 사용해라. 이 경우라도 PHP 는 공격자가 임의의 내용을 갖는 파일을 
업로드할 수 있게 하며 이는 그 자체로 위험함을 주목해라.&#13;</P
></LI
><LI
><P
>&#13;단지 보호된 시작 파일 (entry point) 들만 문서 트리내에 놓아라; 모든 다른 코드 (대부분의 
코드일 것이다) 는 문서 트리 외부에 놓아라. PHP 는 이 주제에 일련의 잘못된 
충고를 하였다. 원래 PHP 사용자는 ``포함 (included)" 파일에 ``.inc" (include) 
확장자를 사용한다고 가정되었다. 그러나 이러한 포함 파일은 대개 패스워드와 
다른 정보를 갖고 있으며 아파치는 ``.inc" 파일이 문서 트리내에 있을 때 요청된 
경우 요청자에게 이 파일의 내용을 제공할 것이다. 
따라서 개발자들은 모든 파일의 확장자를 ``.php" 로 하였다 - 이는 파일 내용이 
보여지지 않지만 entry point 가 전혀 아닌 파일이 entry point 가 되어 악용될 수 
있음을 의미한다. 
초기에 언급했듯이 보통의 보안 충고가 최선이다: 단지 보호된 entry points 만 
문서 트리내에 놓고 라이브러리 등의 다른 코드는 문서 트리 외부에 놓아라. 
문서 트리내에 어떠한 ``.inc" 파일도 있어서는 안된다.&#13;</P
></LI
><LI
><P
>&#13;세션 메카니즘을 피해라. ``세션" 메카니즘은 영구적인 데이타를 저장하는데 유용하지만 
현재 구현은 많은 문제를 갖고 있다. 우선 디폴트로 세션은 임시 파일에 정보를 저장한다 -
따라서 multi-hosted 시스템에 있다면 많은 공격자에 노출될 수 있으며 비밀이 
누설될 수 있다. 현재 multi-hosted 되고 있지 않은 사람일지라도 나중에 multi-hosted 
되고 있는 자신을 발견할 수도 있다. 
이러한 정보를 파일시스템 대신 데이타베이스에 연결시킬 수 있지만 multi-hosted 
데이타베이스의 다른 사람들이 동일한 허가권을 갖고 그 데이타베이스에 접근할 수 
있다면 문제는 동일하다. 주의하지 않는 경우 애매모호한 점이 있는데  
(``세션값인지 아니면 공격자의 값인지?") 이는 공격자에게 그들이 선택한 내용을 
갖고 있는 파일 또는 키를 서버에 놓을 수 있도록 한다. 또한 이는 공격자가 이러한 
자료가 놓일 파일 또는 키의 이름을 어느 정도 제어할 수 있게 한다.&#13;</P
></LI
><LI
><P
>&#13;모든 입력에 대해 다른 언어에서와 같이 받아들일 수 있는지 패턴과의 일치 여부를 
검사하고 그 후 문자열이 아닌 데이타를 요구되는 타입으로 맞추기 위해 타입 
캐스팅을 사용해라. (예상되는) 입력의 선택된 리스트를 쉽게 검사하고 import 하기 
위해 ``helper" 함수를 개발해라. PHP 는 부정확하게 타입이 정해질 수 있는데 
(loosely-typed) 이는 문제를 야기할 수 있다. 
예를 들어 입력 데이타가 "000" 값을 갖는다면 이는 "0" 와 같지 않으며 또한 empty() 
도 아니다. 이는 특히 결합 (associative) 배열의 경우 중요한데 이들의 인덱스가 
문자열이기 때문이다; 이는 $data["000"] 과 $data["0"] 이 다르다는 것을 의미한다. 
예를 들어 $bar 가 double 타입임을 확인하기 위해 (double 에 적합한 포맷을 갖는지 
확인한 후) 다음과 같이 해라:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  $bar = (double) $bar; </PRE
></TD
></TR
></TABLE
></LI
><LI
><P
>&#13;위험한 함수에 특히 주의해라. 코드 실행 함수 (예, require(), include(), eval(), 
preg_replace()), 명령 실행 함수 (예, exec(),passthru(), backtick 연산자, system() 
과 popen()) 과 오픈 파일 함수 (예, fopen(), readfile() 과 file()) 들이 이러한 PHP 
함수들이다. 이는 완전한 목록은 아니다!.&#13;</P
></LI
><LI
><P
>&#13;magic_quotes_gpc() 를 사용해라 - 이는 많은 종류의 공격을 제거한다.&#13;</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SPECIAL"
>10&#51109;. 특별 주제</A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>Understanding is a fountain of life to those who have it, but folly brings punishment to fools.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Proverbs 16:22 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PASSWORDS"
>10.1. 패스워드</A
></H2
><P
>&#13;가능한 패스워드를 다루는 프로그램을 작성하지 마라. 특히 애플리케이션이
로컬이라면 통상적인 로그인 인증에 의존하려고 해라. 애플리케이션이 CGI
스크립트라면 가능한 많은 보호를 제공하는 웹서버에 의존하려고 해라 - 
그러나 웹 서버에 인증을 다루는 것에 대해 밑부분을 보라. 애플리케이션이 
네트워크를 통한 것이라면 패스워드를 가능한 평문으로 보내는 것을 피해라
이는 네트워크 스니퍼에 쉽게 포착되어 추후 재사용될 수 있다. 알고리듬내에
지정된 어떤 키를 사용하거나 어떤 종류의 shrouding 알고리듬을 사용하여
패스워드를 암호화하는 것은 본질적으로 패스워드를 평문으로 보내는 것과
동일하다.&#13;</P
><P
>&#13;네트워크의 경우는 최소한 다이제스트 (digest) 패스워드 사용을 고려해라.
다이제스트 패스워드는 해시로부터 개발된 패스워드이다; 일반적으로 서버는
클라이언트에 어떤 데이타 (예, 날짜, 시간, 서버 이름) 를 보내고
클라이언트는 이 데이타와 사용자 패스워드를 결합하여 이 값 (다이제스트
패스워드로 지칭된) 을 해시한다. 그 후 단지 해시된 결과만 서버에 보내며
서버는 이 해시 값을 대조한다. 이는 패스워드가 어떤 형태로든 실제로
보내지는 것이 절대로 아니기 때문에 잘 작동한다; 패스워드는 단지 해시
값을 추출하기 위해서만 사용된다. 다이제스트 패스워드는 보편적인 의미에서
암호화로 고려되고 있지 않지만 기밀성을 위해 암호화를 강요하는 법을 갖는
나라에서도 대개 받아들여지고 있다. 다이제스트 패스워드는 적극적인  공격
위협에는 취약하지만 수동적인 네트워크 스니퍼에 대해서는 보호한다. 한가지
약점은 다이제스트 패스워드가 작동하기 위해서 서버가 모든 해시되지 않은
패스워드를 가져야 한다는 것으로 이는 서버를 매력적인 공격 목표로
만든다.&#13;</P
><P
>&#13;애플리케이션에서 사용자가 패스워드를 설정할 수 있다면 패스워드를 검사해 
단지 "안전한" 패스워드만을 허용해라 (예, 사전에 있지 않고 어떤 최소 길이를 
갖는 등). 안전한 패스워드를 선택하는 방법에 대해서는 
<A
HREF="http://consult.cern.ch/writeup/security/security_3.html"
TARGET="_top"
>http://consult.cern.ch/writeup/security/security_3.html</A
>
 와 같은 정보를 보고 싶을 것이다. 가능하다면 PAM 을 사용해야 하는데 
이는 장착식 패스워드 체커 (checker) 지원하기 때문이다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="WEB-AUTHENTICATION"
>10.2. 웹에서 인증</A
></H2
><P
>&#13;웹에서 웹 서버는 보통 SSL 및 TLS 또는 서버 인증서를 사용해 사용자에게 
인증받는다 - 그러나 사용자가 누구인지를 인증하는 것은 그만큼 쉽지 않다. 
SSL 과 TLS 는 클라이언트특 인증서를 지원하지만 이들을 실제 사용할 때 
많은 현실적인 문제들이 있다 (예, 웹 브라우저는 유일한 사용자 인증서 포맷을 
지원하지 않으며 사용자가 이를 설치하기는 어렵다). 
자바 및 자바 스크립트를 사용하는 것은 많은 사용자가 이들을 금지하고, 몇몇 방화벽이 
이들을 걸러내고 또한 속도가 느려지기 쉽기 때문에 그 특유의 문제를 갖고 있다. 
대부분의 경우 모든 사용자에게 플러그인을 설치하도록 요구하는 것 또한 
비현실적인데 시스템이 비교적 소수의 사용자들을 위한 인트라넷용이라면 
적합할 수도 있다.&#13;</P
><P
>&#13;인트라넷 애플리케이션을 구축하고 있다면 일반적으로 사용자가 사용하는 
인증 시스템만큼은 사용해야 한다. 따라서 Kerberos 에 의존한다면 
Kerberos 를 사용하도록 시스템을 설계해라. 관리 기관이 추후 인증 시스템을 
변경시킬 수도 있기 (변경시킬 것이기) 때문에 이를 애플리케이션의 나머지 부분과 분리하려고 해라.&#13;</P
><P
>&#13;많은 방법들은 효과적이지 않으며 또한 충분히 효과적이지 않다. 
한가지 접근 방법은 본질적으로 모든 브라우저와 서버에 내장되어 있는 ``기본적인 
인증"을 사용하는 것이다. 불행히 기본적인 인증은 패스워드를 평문으로 보내기 
때문에 패스워드를 훔치기 쉽게 한다; 기본적인 인증 자체는 실제로 쓸모없는 
정보에 대해서만 유용하다. 모든 기본적인 인증 패스워드를 SSL/TLS 연결 (암호화할 
수 있다) 내에 감싸서 보호할 수 있지만 이는 성능의 저하를 야기한다. 
또한 ``다이제스트 인증"을 사용할 수 있는데 좋은 방법이지만 브라우저가 이를 보편적으로 
지원하지 않고 있다. 인증 정보를 사용자가 선택한 URL 내에 저장할 수도 있지만 
대부분의 경우 이렇게 하지 않아야 한다 - 이 정보가 다른 사람에게 누설될 수 있는 
너무나 많은 방법이 있다 (예, 많은 브라우저에 저장되어 있는 브라우저 히스토리 
로그, 프록시의 로그를 통해 누설되거나, 그리고 Referef: 필드를 통해 다른 웹 사이트로 누설될 
수도 있다).&#13;</P
><P
>&#13;따라서 오늘날 웹에서 가장 일반적인 인증 방법은 쿠키를 사용하는 것이다. 
쿠키는 실제 이 목적을 위해 설계되지 않았지만 인증에 사용될 수 있다 - 그러나 
보안 취약성을 만들기 위해 이들을 사용하는 많은 잘못된 방법이 있기 때문에 
주의해라. 쿠키에 대한 더욱 자세하 정보는 이에 대한 예전 스펙과 함께 
IETF RFC 2965 를 보라. 쿠키를 사용하기 어떤 브라우저 (예, 마이크로소프트 
인터넷 익스플로러 6) 가 프라이버시 프로파일 (서버의 루트 디렉토리에 p3p.xml) 
을 가져야 한다고 요구할 수 있음을 주목해라.&#13;</P
><P
>&#13;어떤 사용자는 쿠키를 받아들이지 않음을 주목해라 따라서 이 방법은 아직까지 
다소의 문제를 갖고 있다. 원칙적으로는 이 인증 정보를 HTML 폼의 hidden 필드를 
통해 주고받아야 한다 (이는 거의 모든 브라우저가 중요치 않게 
이를 지원하기 때문이다). 
쿠키를 갖는 것과 같은 동일한 방법을 사용할 것이다 - 단지 데이타를 사용자로부터 
서버로 보내기 위해 다른 기술을 사용할 것이다. 
물론 이 방법을 구현한다면 이 페이지들이 다른 사람들이 사용할 수 있도록 
캐시되지 않음을 보장하는 설정을 포함할 필요가 있다.
그러나 쿠키를 피하는 것이 바람직하다고 저자는 생각하지만 실제로 이러한 다른 
방법들은 대개 더욱 더 많은 개발 노력을 필요로 한다. 
많은 애플리케이션 개발자들을 위해 이를 대규모로 구현하는 것은 어렵기 때문에 
저자는 현재 이러한 방법들을 강조하지 않고 있다. 개발자 또는 사용자에 의해 
정확하게 구현될 수 없을 만큼 어려운 방법을 강조하는 대신 꽤 보안적이며 구현하기 
쉬운 방법을 기술할 것이다. 그러나 별다른 수고없이 이를 구현할 수 있다면 
반드시 폼의 hidden 필드외 암호화된 링크 (예, SSL/TLS) 를 사용해 인증 정보를 
전송하는 것을 지원해라. &#13;</P
><P
>&#13;Fu [2001] 는 제안된 접근 방법과 함께 웹에서의 클라이언트 인증을 논의하고 있다. 
이는 대부분의 웹 사이트에 대해 저자가 추천하는 방법이다. 기본적인 개념은 
클라이언트 인증을 두 부분 ``로긴 절차 (login procedure)" 와 ``일련의 요청 (
subsequent requests) 으로 나누는 것이다. 로긴 절차에서 서버는 사용자 이름과 
패스워드를 요청하고 사용자가 이들을 제공한 후 서버가 ``인증 토큰"을 갖고 
응답한다. 일련의 요청에서 클라이언트 (웹 브라우저) 는 서버에 요청과 함께 
인증 토큰을 보낸다; 서버는 토큰이 유효한지 확인하고 유효하다면 요청된 서비스를 
제공한다. 웹 인증에 대한 다른 좋은 정보 출처는 Seifried [2001] 이다.&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="WEB-AUTHENTICATION-LOGIN"
>10.2.1. 웹에서 인증: 로그인</A
></H3
><P
>&#13;로긴 절차는 일반적으로 HTML 폼으로 구현된다; 웹 브라우저가 다소의 유용한 액션을 
자동적으로 수행할 수 있도록 저자는 필드명으로 ``username" 과 ``password" 를 
사용할 것을 제안한다. 반드시 패스워드가 암호화된 연결 (https: 연결을 통해 
SSL 또는 TLS 를 사용) 을 통해 전송되도록 해라 - 그렇지 않다면 도청을 통해 
패스워드를 수집할 수 있다. 
사용자의 스크린을 볼 수 있는 누군가가 패스워드 텍스트를 볼 수 없도록 반드시 
모든 패스워드 텍스트 필드는 패스워드로 표시해라.&#13;</P
><P
>&#13;사용자 이름과 패스워드가 보내질 때 이는 사용자 계정의 테이타베이스에 대해 
검사되어야 한다. 이 데이타베이스는 패스워드를 ``평문"으로 저장하지 않아야 하는데 
누군가 이 데이타베이스의 복사본을 얻는다면 모든 사람의 패스워드를 갑자기 얻을 
수 있다 (사용자는 대개 패스워드를 재사용한다). 
어떤 사람은 이를 다루기 위해 crypt() 를 사용하지만 crypt 는 단지 소량의 입력만을 
다룰 수 있다. 따라서 저자는 다른 접근 방법을 사용할 것을 추천한다 (이는 저자의 
방법으로 Fu [2001] 은 이를 논의하고 있지 않다). 대신 사용자 데이타베이스는 
사용자에 대한 사용자 이름, salt 와 패스워드 해시를 저장해야 한다. ''salt" 는 단지 
문자들의 임의의 시퀀스로 공격자가 패스워드 데이타베이스를 얻는다 하더라도 
패스워드 결정을 더욱 어렵게 하기 위해 사용된다 - 저자는 8 문자의 임의의 
시퀀스를 추천한다. 암호학적으로 임의적일 필요는 없으며 단지 다른 사용자들에 
대한 값과 다르면 된다. 패스워드 해시는 ``서버 key1", 사용자 패스워드와 salt 를 
연결한 후 암호학적으로 보안적인 해시 알고리듬을 사용해서 계산되어야 한다. 
서버 key1 은 이 서버에 고유한 비밀 키이다 - 이를 패스워드 데이타베이스와 
별도로 보관해라. 
서버 key1 을 가진 사람이 패스워드 데이타베이스를 가졌다면 사용자 패스워드를 
알아내기 위해 프로그램을 실행시킬 수 있다; 서버 key1 은 기억될 필요가 없기 때문에 
길고 복잡한 패스워드일 수 있다. HMAC-SHA-1 또는 HMAC-MD5 가 가장 
보안적일 것이다; SHA-1 (대부분의 웹 사이트는 실제 이 알고리듬이 허용하는 공격에 
대해 걱정하지 않고 있다) 또는 MD5 (MD5 에 대한 논의를 보라) 를 사용할 수도 있다.&#13;</P
><P
>&#13;따라서 사용자가 계정을 만들때 패스워드는 패스워드 데이타베이스내에 해시되어 
놓여진다. 사용자가 로그인하려고 할때 주장된 패스워드는 해시되어 데이타베이스내의 
해시와 비교된다 (이들은 동일해야 한다). 사용자가 패스워드를 변경할 때 예전 및 새로운 
패스워드를 모두 타이핑해야 하며 새로운 패스워드는 잘못 타이핑되지 않았음을 
확인하기 위해 두번 타이핑해야 한다; 또한 패스워드 문자들중 어느 문자도 스크린상에서 
볼 수 없도록 해라. &#13;</P
><P
>&#13;디폴트로 쿠키를 사용하는 클라이언트의 웹 브라우저에 패스워드 자체를 저장하지 
마라 - 사용자들은 때때로 공유되는 클라이언트를 사용할 수도 있다 (가령 커피숍). 
원한다면 사용자에게 브라우저에서 ``패스워드 저장하기" 옵션을 줄 수 있지만 이 경우 
반드시 패스워드가 ``보안적인" 연결을 통해서만 전송되도록 설정하고 사용자가 
명확하게 이를 요청하도록 해라 (디폴트로 이를 하지는 마라).&#13;</P
><P
>&#13;반드시 캐시되지 않는 페이지를 표시해라 그렇지 않다면 서버가 그 페이지를 
사용자에게 다시 제공할 것이다.&#13;</P
><P
>&#13;일단 사용자가 성공적으로 로그인하면 서버는 쿠키내의 ``인증 토큰"을 클라이언트에 
전송할 필요가 있다. 이는 다음에 기술된다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="WEB-AUTHENTICATION-SUBSEQUENT"
>10.2.2. 웹에서 인증: 일련의 행동</A
></H3
><P
>&#13;일단 사용자가 로그인하면 서버는 클라이언트에 인증 토큰을 갖고 있는 쿠키를 
되돌려준다. 제안된 토큰은 다음과 같을 것이다:&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  exp=t&#38;data=s&#38;digest=m</PRE
></TD
></TR
></TABLE
><P
>&#13;t 는 토큰의 만료 시간 (가령 몇 시간) 이고, data 는 사용자 이름 또는 세션 id 들이고 
digest 는 keyed digest 이다. ``data" 의 필드명을 더욱 설명적인 사용자 이름 또는 
세션 id 로 자유롭게 변경할 수 있다. Keyed digest 는 만료 시간과 data 를 연결한 
것의 암호학적인 해시이다. 데이타에 한 필드 이상 (예, 사용자 이름과 세션 id 둘) 을 
갖는다면 반드시 digest 가 인증하려는 필드명과 모든 필드의 data 모두를 사용하도록 
해라; 이들을 필드 data 값 어디에도 있을 수 없는 패턴 
(예, ``%%", ``+" 또는 ``&#38;") 을 이용해 연결해라. Keyed digest 는 별개의 서버 키 
(key2) 를 사용하는 HMAC-MD5 또는 HMAC-SHA1 을 사용해야 한다. 이 key2 가 
손상된다면 누구라도 서버에 인증받을 수 있으며 key2 를 변경하는 것이 쉽다 - 
변경한다면 이는 단순히 현재 ``로그인 해 있는" 사용자에게 재인증받도록 요구할 
것이다. 더욱 자세한 사항은 Fu [2001] 을 보라.&#13;</P
><P
>&#13;그때부터 서버는 이 인증 토큰의 만료 시간과 digest 를 검사해 일치하는 경우에만 
데이타를 제공해야 한다. 토큰이 없다면 사용자 로긴 페이지 (성공적인 로긴시 
어디로 가는 지를 보이는 숨겨진 폼 필드를 갖고 있다) 로 다시 응답할 것이다 .&#13;</P
><P
>&#13;인증 토큰에 세션 id 를 포함하고 있다면 접근을 더욱 제한할 수 있다. 서버는 사용자가 
주어진 세션에서 어떤 패이지를 보았는지 추적할 수 있으며 단지 적절한 페이지에 
대한 접근만 허용할 수 있다 (예, 이러한 페이지들에서 직접적으로 링크되어 있는 
페이지들). 예를 들어 사용자가 foo.html 에 접근할 수 있고 foo.html 페이지가 
자원 bar1.jpg 와 bar2.png 에 대한 포인터를 갖고 있다면 bar4.cgi 에 대한 접근은 
거절될 수 있다. 세션을 종료할 수도 있는데 이는 인증 정보가 유효한 경우에만 해라 
(그렇지 않다면 공격자가 다른 사용자에 대해 서비스 부인 공격을 야기할 수도 있게 
한다). 이는 공격자가 세션을 성공적으로 가로챈다 하더라도 어느 정도 공격자가 
갖는 접근을 제한할 수 있다. 그러나 시간과 인증 토큰을 갖고 있는 공격자는 정상적인 
사용자와 같이 링크를 따라 페이지들을 볼 수 있을 것이다.&#13;</P
><P
>&#13;한가지 결정해야 하는 것은 인증 토큰 및/또는 data 가 보안적인 연결(예, SSL) 을 통해 
보내져야 하는 지 또는 아닌지이다. 인증 토큰을 평문으로 (비보안적으로) 
전송한다면 토큰을 가로챈 누군가는 만료 시간까지 사용자가 할 수 있는 모든 
것을 할 수 있다. 또한 데이타를 암호화되지 않은 링크를 통해 전송할 때 
공격자가 눈에 띄지 않게 변경할 수 있는 위험도 있다; 누군가가 전송중에 
데이타를 변경할 수도 있다고 걱정한다면 전송되어 지는 데이타를 인증할 
필요가 있다. 
암호화 자체는 인증을 보장하지 않지만 변조를 더욱 쉽게 탐지할 수 있게 하며 
일반적인 라이브러리는 TLS/SSL 연결에서 암호화와 인증 모두를 지원할 수 있다. 
일반적으로 메시지를 암호화한다면 또한 이를 인증해야 한다. 필요한 것이 다르다면 
한가지 대안은 두개의 인증 토큰을 생성하는 것이다 - 한개는 중요한 작업을 위해 
``보안적인" 연결에만 사용되고 반면 다른 한개는 덜 중요한 작업에 사용된다. 
단지 보안적인 연결 (일반적으로 암호화된 SSL/TLS 연결) 들만이 사용되도록 
``보안적인" 연결에 사용되는 토큰은 반드시 표시를 해라. 사용자들이 실제로 
다르지 않다면 인증 토큰은 ``data" 를 전적으로 생략할 수 있다.&#13;</P
><P
>&#13;이 인증 토큰을 갖는 페이지들이 반드시 캐시되지 않도록 해라. 또한 다른 적당한 
스킴도 또한 있다; 여기서의 목적은 적어도 한가지 보안적인 해결 방법을 제공하는 
데 있으며 많은 변형된 방법들도 가능하다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="WEB-AUTHENTICATION-LOGOUT"
>10.2.3. 웹에서 인증: 로그아웃</A
></H3
><P
>&#13;사용자에게 ``로그 아웃" 할 수 있는 메카니즘을 늘 제공해야 한다 - 이는 도서관에서와 
같이 많은 사람들이 브라우저를 공유해서 사용하는 경우 특히 유용하다. 
``logout" 루틴이 하는 일은 간단하다 - 클라이언트의 인증 토큰을 단지 설정해제하는 
것이다.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="RANDOM-NUMBERS"
>10.3. 난수</A
></H2
><P
>&#13;많은 경우 보안적인 프로그램들은 적이 추측할 수 없는 임의의 숫자 (난수)
를 생성해야 하는데 예로는 많은 프로토콜, salt 등에 사용되는 세션키, 공개
또는 비밀키, 대칭키, nonces 와 IV 들이 있다. 이론상 난수로는 방사선
소멸 (가이거 카운터 클릭의 정확한 계시를 통해), 대기 소음 또는
전선에서의 열 소음에 기초한 값들과 같은 실제 무작위로 얻어진 데이타를
사용해야 한다. 어떤 컴퓨터는 실제 임의의 (random) 값을 생성하는 역할을
하는 하드웨어 컴포넌트를 갖고 있는데 가능하다면 이를 사용해야 한다.&#13;</P
><P
>&#13;그러나 대부분의 컴퓨터들은 실제 임의의 값들을 생성하는 하드웨어를 갖고
있지 않으며 따라서 대부분의 경우 적이 예측할 수 없을 만큼 충분히
임의적인 난수를 생성할 방법이 필요하다. 일반적으로 이는 다음 세가지를
필요로 함을 의미한다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;"예측 불가능" 상태; 일반적으로 이는 적이 제어할 수 없는 방식으로
키스트로크, 디스크 드라이브 암 지터 (arm jitter) 등과 같은 하위 수준
디바이스의 타이밍의 변동을 측정함으로써 행해진다.&#13;</P
></LI
><LI
><P
>&#13;난수를 생성하기 위해 상태를 사용하는 암호학적으로 강력한 준-난수 발생기
(pseudo-randum number generator, PRNG).&#13;</P
></LI
><LI
><P
>&#13;종자 (seed) 와 사용된 결과 값 모두에 있어 많은 수의 비트. 단지 약간의 가능한
값들을 갖고 있다면 공격자가 brute force 공격을 사용하는 것을 쉽게 하기 때문에
강력한 PRNG 를 갖고 있더라도 쓸모없다. 필요한 비트의 수는 상황에 따라
변하는데 이들이 대개 암호화 키로 사용되기 때문에 키에 대해 보통 경험에
의한 방법이 적용된다. 대칭키 (결과) 의 경우 저자는 적어도 112 비트
(3DES) 를 사용하는데 128 비트는 더욱 좋으며 160 비트 이상은 더욱 더
안전하다.&#13;</P
></LI
></UL
><P
>&#13;일반적으로 PRNG 는 상태를 사용해 어떤 값들을 생성한 후 이 값들중의 일부와 
다른 추측할 수 없는 입력을 이용해 상태를 갱신한다. 이러한
시스템들을 공격하는 많은 방법들이 있는데 예를 들어 공격자가 상태에 대한
입력들 (또는 이들 중의 일부) 을 제어하거나 볼 수 있다면 공격자는 아마
난수를 결정할 수 있을 수도 있다.&#13;</P
><P
>&#13;PRNGs 를 사용하는데 있어 진짜 위험한 것은 대부분의 컴퓨터 언어
라이브러리들이 보안 목적에 <B
CLASS="EMPHASIS"
>부적절한</B
> 많은 PRNG 를
포함하고 있다는 것이다. 다시 한번 말하자: <B
CLASS="EMPHASIS"
>보안을 목적으로 할
때 일반적인 난수 발생기를 사용하지 마라</B
>. 일반적으로
라이브러리 PRNG 는 모사, 게임 등에 사용하기 위한 것인데 이들은 키
생성과 같은 보안 함수들에 사용할 수 있을 정도로 충분히 임의적이지 않다.
대부분의 비암호화 라이브러리 PRNG 는 선형 합동 발생기 (linear
congruential generator) 을 약간 변형시킨 것으로 ``다음" 임의의 값이
(aX+b))mod)m 으로 계산된다 (X 는 이전 값이다). 훌륭한 선형
합동 발생기는 빠르며 유용한 통계적인 성질을 갖고 있어 의도한 사용 목적에
적절하다. 이러한 PRNG 와 관계된 문제는 차후의 값이 임의의 값으로
보임에도 불구하고 공격자에 의해 쉽게 추정될 수 있다는 것이다. 이차 (quadratic) 및
삼차 (cubic) 발생기와 같이 빠르게 난수를 생성하는 다른 알고리듬들도 해독되었다
[Schneier 1996]. 요약하면 보안적인 애플리케이션에서 난수를 생성하기
위해서는 암호학적으로 강력한 PRNG 를 사용해야 한다는 것이다 - 보통의
난수 라이브러리들은 충분하지 않다.&#13;</P
><P
>&#13;키에 대해 실제로 임의의 값들을 정확히 생성하지 못함으로써 Kerberos, X
윈도우 시스템과 NFS 시스템에서의 보안 구멍을 포함하여 많은 문제를
야기하였다 [Venema 1996].&#13;</P
><P
>&#13;가능하다면 암호학적으로 보안적인 임의의 값들을 생성하도록 특별히 설계된
일반적으로 운영체제에서 제공하는 시스템 서비스를 사용해야 한다. 예를
들어 리눅스 커널 (1.3.30 이후) 은 난수 발생기를 포함하고 있는데 이는
보안을 목적으로 한 많은 곳에 충분하다. 이 난수 발생기는 디바이스
드라이버와 다른 출처로부터의 환경 노이즈를 엔트로피 풀로 모으는데
/dev/random 으로 접근될 때 임의의 바이트들만이 엔트로피 풀에서 평가된
노이즈 비트수 내에서 반환된다 (엔트로피 풀이 비어있을 때 호출은 추가적인
환경 노이즈가 모여질 때까지 블록된다). /dev/urandom 으로 접근될 때는
엔트로피 풀이 다 고갈되었다 하더라도 요청된 만큼의 바이트들이 반환된다.
리눅스에서 키 생성과 같은 암호화 목적으로 임의의 값들을 사용하려면
/dev/random 을 사용해라. 하드웨어 난수 발생기를 사용할 수 있고 그
드라이버가 설치되어 있다면 이것이 대신 사용될 것임을 주목해라. 더욱
자세한 정보는 시스템 문서 random(4) 에서 얻을 수 있다.&#13;</P
><P
>&#13;다른 시스템에서는 정말로 임의적인 결과를 얻는 다른 방법으 찾아야 할 것이다. 
다른 유닉스 계열 시스템에 대해서는 Entropy Gathering Daemon (EGD) 가 한가지 
방법으로 이는 시스템 활동을 감시해 이를 임의적으로 값으로 해시한다; 이는
<A
HREF="http://www.lothar.com/tech/crypto"
TARGET="_top"
>http://www.lothar.com/tech/crypto</A
> 
에서 얻을 수 있다. 
PRNG 출력에 암호화 해시 함수 (예, SHA-1) 의 사용을 고려할 수도 있는데
해시 알고리듬을 사용함으로써 PRNG 가 예측가능하다고 판명되었음에도 불구하고
이는 공격자가 또한 해시 함수도 해독해야 한다는 것을 의미한다.&#13;</P
><P
>&#13;강력한 PRNG 를 스스로 구현해야 한다면 암호학적으로 강력하며 특허에 
얽매이지 않은 PRNG 의 좋은 선택은 Yarrow 알고리듬으로 <A
HREF="http://www.counterpane.com/yarrow.html"
TARGET="_top"
>http://www.counterpane.com/yarrow.html</A
>.
에서 Yarrow 에 대해 더욱 자세히 알 수 있다. 약간의 다른 PRNG 도 유용할
수 있지만 널리 사용되고 있는 많은 PRNG 은 애플리케이션에 따라 중요하거나
그렇지 않을 수도 있는 알려진 약점을 갖고 있다. PRNG 를 스스로 구현하기
전에 [Kersey 1998] 과 McGraw [2000a] 와 같은 문헌을 참조해라. 또한<A
HREF="http://www.ietf.org/rfc/rfc1750.txt"
TARGET="_top"
>IETF RFC 1750</A
> 도
조사해야 한다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PROTECT-SECRETS"
>10.4. 사용자가 기억하는 비밀 (패스워드 및 키) 을 특히 보호해라</A
></H2
><P
>&#13;애플리케이션이 패스워드 또는 비공개 키 (세션키, 개인키, 비밀키 등) 를
다뤄야 한다면 이들이 최소한으로 노출되도록 사용한 후 즉각적으로
겹쳐써라. 예를 들어 자바에서 패스워드를 저장하기 위해 문자열 (Sting)
타입을 사용하지 마라 이들은 불변 (immutable) 이기 때문에 가비지 수집
(garbage collection) 및 재사용되기까지 아마도 차후 어느 정도 시간까지는
겹쳐써지지 않을 것이다. 대신 자바에서는 패스워드가 즉시 겹쳐써질 수
있도록 이를 저장하기 위해 char[] 을 사용해라.&#13;</P
><P
>&#13;또한 프로그램이 그러한 비밀 값들을 다룬다면 ulimit 를 통해 반드시 코어
덤프 생성을 금지해라. 그렇지 않으면 공격자가 프로그램을 정지시켜 데이타
덤프에서 비밀 값을 발견할 수 있을지 모른다. 또한 주의해라 - 일반적으로
프로세스들은 디버거 (예, ptrace(2) 및 /proc 준-파일시스템을 통해) 호출을
통해 다른 프로세스들을 모니터링 할 수 있다 [Venema 1996]. 커널은
프로세스가 setuid 또는 setgid 라면 이러한 모니터링에 대해 보통 보호를
한다 (이러한 보호를 하지 않는 약간의 오래된 시스템에서는 실제로
갱신이외에는 보호할 방법이 없다). 따라서 프로세스가 비밀 값들을
관리한다면 이러한 종류의 모니터링을 강제적으로 금지하기 위해 이를 다른
권한이 없는 그룹 또는 사용자에 대해 setuid 또는 setgid 로 만들어야
한다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CRYPTO"
>10.5. 암호화 알고리듬 및 프로토콜</A
></H2
><P
>&#13;대개 암호화 알고리듬과 프로토콜은 시스템을 안전하게 하기 위해 특히
인터넷과 같은 신뢰되지 않은 네트워크를 통해 통신할 때 필요하다. 가능한
정보를 인증하고 정보를 비밀로 유지하기 위해 암호학적인 기법을 사용해라 
(단순한 암호화가 또한 자동적으로 인증할 수 있다고 가정하지 마라). 
일반적으로 애플리케이션을 안전하게 하기 위해 사용가능한 도구를 사용할 
필요가 있다.&#13;</P
><P
>&#13;배경 정보와 코드에 대해서는 아마도 고전적인 텍스트 ``Applied
Cryptography" [Schneier 1996] 를 봐야 한다. 뉴스그룹 ``sci.crypt" 에는
일련의 FAQ 이 있는데 <A
HREF="http://www.landfield.com/faqs/cryptography-faq"
TARGET="_top"
>http://www.landfiel
d.com/faqs/cryptography-faq</A
> 을 포함한 많은
위치에서 이들을 찾을 수 있다. 리눅스에 특정적인 자원들은 <A
HREF="http://marc.mutz.com/Encryption-HOWTO/"
TARGET="_top"
>http://marc.mutz.com/Encryption-HOWTO/</A
>에
있는 Linux Encryption HOWTO 를 포함한다. 프로토콜이 기본적인 알고리듬을
사용하는 방법에 관한 논의는 [Opplinger 1998] 에서 찾을 수 있다.
프로토콜에서 암호학을 적용하는 방법에 관한 유용한 논문 모음은 [Stallings
1996] 에서 찾을 수 있다. 다음은 단지 약간의 설명문으로 이 분야는 상당히
전문화되어 있으며 다른 곳에서 더욱 철저히 다뤄지고 있다.&#13;</P
><P
>&#13;암호화 프로토콜과 알고리듬을 올바르게 이해하기는 어렵다. 따라서 각자
스스로 이들을 만들지 마라. 
대신 될 수 있는한 널리 사용되고 있고 깊히 분석되었으며 보안적이라고 
받아들여진 프로토콜과 알고리듬을 사용해라. 
이들을 만들어야 한다면 폭넓은 공개 검토를 하고 반드시 전문적인 보안 
분석가들이 문제가 있는지 이들을 검사하도록 해라.
특히 암호학 전문가가 아니고 무엇을 하고 있는지 모르며
알고리듬을 전문적으로 검토하는데 시간을 투자할 계획이 없다면 자신의
암호화 알고리듬을 만들지 마라. 암호화 알고리듬 작성은 전문가들만의
작업이다.&#13;</P
><P
>&#13;많은 알고리듬은 특허화되어 있어 소유자가 현재 ``자유로운 사용"을 
허용한다 하더라도 서명된 계약이 없다면 추후에 이 정책을 늘 변경할 수 
있으며 따라서 추후 여러분을 극히 위험한 상황에 놓이게 한다. 
일반적으로 모든 특허화된 알고리듬을 피해라 - 거의 모든 경우에 있어 
최소한 특허화된 알고리듬만큼 우수하거나 기술적으로 더욱 우수한 
특허화되어 있지 않은 접근 방법이 있으며 이를 사용함으로써 많은 법적인 
문제를 피할 수 있다.&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CRYPTO-PROTOCOLS"
>10.5.1. 암호학적 프로토콜</A
></H3
><P
>&#13;프로토콜의 경우 SSL (곧 TLS 가 된다), SSH, IPSec, GnuPG/PGP 및 Kerberos
와 같은 표준을 따르는 프로토콜을 사용하려고 해라. 이들 다수는 기능성에서
어쨋든 중복되지만 각자 특수한 용도 (specialty niche) 를 갖고 있다. SSL
은 http (웹) 트랜잭션을 보호하는 기본적인 방법이며 PGP 와 GnuPG 에
구현된 PGP 호환 프로토콜은 이메일 발송인/수취인 (end to end) 을 보호하는
기본적인 방법이다. Kerberos 는 랜상에서 인증을 지원하고 안전하게 하며 
공유된 비밀을 입증하는 기본적인 방법이다 (따라서 통신을 실제 
보호하기 위한 다른 알고리듬과 함께 사용될 필요가 있다). 
SSH 는 CVS 접근과 같은 다른 데이타 스트림을 안전하게
하는데도 사용되지만 인터넷을 통한 ``원격 터미널"을 안전하게 하는
기본적인 방법이다 (예, telnet 계열과 X 윈도우 연결). SSH 프로토콜에는
두개의 주요 버전이 있으며 몇가지 키 타입을 선택할 수 있음을 주목해라;
더욱 자세한 정보를 위해서는 관련 문서를 보라. OpenSSH 는 SSH 의 
오픈 소스 구현이다. IPSec 는 저수준 패킷과
``모든" 패킷을 안전하게 하기 위한 기본적인 방법으로 가상 사설망과 원격
머신을 안전하게 하는데 특히 유용하다. 인터넷 프로토콜의 새로운 버전인
IPv6 는 IPSec 가 ``내장"되어 있지만 IPSec 는 일반적인 IPv4 프로토콜과도
함께 작동한다.&#13;</P
><P
>&#13;다수의 프로토콜들이 많은 다른 알고리듬을 선택할 수 있게 하는데 따라서 
알고리듬에 대해 합리적인 디폴트를 선택할 필요가 있을 것이다 (예, 암호화).&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYMMETRIC-ENCRYPTION"
>10.5.2. 대칭키 암호화 알고리듬</A
></H3
><P
>&#13;암호화 알고리듬 구현의 사용, 수출 및/또는 수입은 많은 나라에서 
제한되고 있지만 법은 매우 빠르게 변할 수 있다. 암호학을 사용해 
애플리케이션을 구축하려고 하기 전에 규범이 무엇인지 알아내라.&#13;</P
><P
>&#13;비밀키 (벌크 데이타) 암호화 알고리듬의 경우는 공개적으로 알려져 수년간
공격을 견뎌온 암호화 알고리듬만을 사용하고 이들의 특허 상태를 검사해라.
저자는 Rijndahl 로 알려진 새로운 Advanced Encryption Standard (AES) 를 
사용하기를 추천할 것이다 -- 많은 암호학자들이 이를 분석했으며 어떠한 
심각한 약점도 발견하지 못했는데 저자는 현재 AES 가 신뢰할 수 있을만큼 
충분한 분석을 했다고 생각한다. 
AES 에 대한 좋은 대안은 Serpent 알고리듬으로 약간 느리지만 공격에 대한 
저항성이 우수하다. 많은 애플리케이션의 경우 삼중-DES 는 매우 우수한 암호화 
알고리듬인데 이는 꽤 길이기 긴 112 비트 키를 갖으며 특허 문제도 없고
오랫동안 공격에 견뎌왔다 (공개 문헌에 있는 적당한 키 길이를 갖고 있는 
다른 암호화 알고리듬보다 더욱 오랫동안 공격에 견뎌왔다). 
그러나 삼중-DES 는 소프트웨어에서 구현될 때 매우 느리며 따라서 삼중-DES 는
``가장 안전하지만 가장 느리다" 고 고려될 수 있다. Twofish 는 우수한 
암호화 알고리듬이지만 다소의 오래된 문제가 있다 - Sean Murphy 와 Fauzan Mirza 는 
Twofish 가 많은 학자들을 우려하게끔 하는 성질들을 갖고 있음을 보였다 (어느 
누구도 어떻게든 이러한 성질들을 악용하는데 사용할 수는 없었다). 
MARS 는 ``새롭고 참신한" 공격에 대한 저항성이 우수하지만 더욱 복잡하고 
소형 기능의 스마트카드에 대해서는 비실용적이다. 우선 저자는 Twofish 를 
피할 것이다 - 이는 전혀 악용될 수 없을 것 같지만 이를 확신하기는 어려우며 
이러한 문제에 대해 걱정하지 않아도 되는 대안 알고리듬들이 있다. 
IDEA 는 사용하지 마라 - 미국과 유럽에서 특허화되어 있다. 
상수 또는 상수 문자열을 갖는 XOR, ROT (rotation) 스킴, Vinegere 암호 등과 
같은 어리석은 알고리듬을 사용하지 마라 - 오늘날의 켬퓨터에서 이들을 
해독하는 것은 사소할 수 있다. 
``이중 DES" (DES 를 두번 사용) 를 사용하지 마라 - 삼중-DES 가 예방할 수 있는 
``man in the middle" 공격을 당하기 쉽다. 어쨌든 프로토콜은 다수의 
암호화 알고리듬을 지원해야 한다; 이렇게 함으로써 한 알고리듬이 
해독될 때 사용자는 다른 알고리듬으로 변경할 수 있다.&#13;</P
><P
>&#13;대칭키 암호화 (예, 벌크 암호화) 의 경우 2016 동안 정보가 비밀로 유지되길 
원한다면 90 비트보다 작은 키 길이를 사용하지 마라 (매 18개월의 추가적인 
보안을 위해 다른 비트를 추가해라) [Blaze 1996]. 쓸모없는 데이타를 암호화하는 경우는 
예전 DES 알고리듬도 상당히 유용하지만 현재 하드웨어 상황에서 
brute force 공격을 사용해 DES 의 56 비트 키를 해독하는 것은 너무 쉽다. 
DES 를 사용하고 있다면 아스키 텍스트 키를 키로 사용하지 마라 - 
패리티 (parity) 는 가장 덜 중요한 비트에 있다. 따라서 대부분의 DES 알고리듬은 
적들에게 잘 알려진 키값을 사용해 암호화할 것이다. 
대신 키의 해시를 만들고 패리티 비트를 정확히 설정해라 (그리고 암호화 루틴으로부터의 
에러 보고에 주의해라). 소위 ``수출가능한" 암호화 알고리듬은 단지 40 비트의 
유효 키 길이를 갖으며 본질적으로 쓸모없다; 1996년에 공격자는 그러한 키를 
12분내에 해독하는데 10,000 불을 쓰거나 또는 이들을 몇일내에 해독하는데 
유휴 시간을 사용했을 것이다. 두 경우 모두 매 18개월마다 해독 시간이 절반으로 
줄어들었다.&#13;</P
><P
>&#13;블록 암호화 알고리듬은 ``electronic code book" (ECB) 및 ``cipher block chaining" 
(CBC) 와 같은 많은 여러가지 모드에서 사용될 수 있다. 거의 모든 경우 CBC 를 
사용하고 ECB 는 <B
CLASS="EMPHASIS"
>사용하지 마라</B
> - ECB 모드에서는 
동일한 데이타 블록은 스트림내에서 동일한 결과를 반환하며 이는 무엇이 
암호화되었는지를 드러내기에 대개 충분하다. CBC 를 포함하여 많은 모드들은 
``초기화 벡터" (initialization vector, IV) 를 필요로 한다. IV 는 보안적일 필요는 
없지만 공격자가 예측할 수 없어야 한다. 세션을 통해 IV 를 재사용하지 마라 - 
세션을 시작할 때마다 새로운 IV 를 사용해라.&#13;</P
><P
>&#13;많은 여러가지 스트리밍 암호화 알고리듬이 있지만 많은 알고리듬은 특허 
제한을 갖고 있다. 저자는 WAKE 와 관련된 특허 또는 기술적 쟁점에 대해서는 
모른다. RC4 는 RSA Data Security Inc. 의 통상 비밀이다; 그후로 누설되었지만 
저자는 이의 사용에 대한 실제 법적인 장애물은 모른다. 그러나 RSA 는 이의 
사용자들에 대해 법정 소송을 취하겠다고 위협하고 있다 (RSA 가 취할 수 있는 
것이 무엇인지는 명확하지 않지만 사용자들을 쓸데없는 법정 소송에서 
꼼짝못하게 할 수 있음은 의심할 여지가 없다). RC4 를 사용한다면 이를 의도된 
바와 같이 사용해라 - 특히 언제나 생성된 처음 256 바이트를 버려라. 그렇지 
않다면 공격당하기 쉬울 것이다. 
SEAL 은 IBM 이 특허를 낸 것으로 이를 사용하지 마라. 
SOBER 은 특허화되어 있다; 특허 소유자는 사용 허가를 요청한다면 이를 
자유로이 사용할 수 있다고 주장하고 있지만 이는 추후 사용에 대해 장애물이 
될 수 있다. 더욱더 흥미로운 것은 블록 암호화 알고리듬이 이들을 스트림 암호로 
변환시키는 모드에서 사용될 수 있다는 것인데 스트림 암호를 원하는 사용자는 
이 방법을 고려해야 한다 (더욱 공개적으로 얻을 수 있는 알고리듬중에서 
선택할 수 있을 것이다).&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PUBLIC-KEY-ENCRYPTION"
>10.5.3. 공개키 알고리듬</A
></H3
><P
>&#13;공개키 암호화의 경우 (서명과 비밀키 전송에 널리 사용되고 있다) 단지
약간의 알고리듬만이 널리 사용되고 있는데 가장 널리 사용되고 있는
알고리듬 중의 하나는 RSA 이다; RSA 의 알고리듬은 단지 미국에서만
특허화되어 있으며 2000년 9월에 만료되어 자유롭게 사용될 수 있다. 공격자가 
직접적으로 제공한 원값 (raw value) 을 RSA 를 사용해 절대로 복호화하거나 
서명하지 마라. RSA 는 비밀키를 드러낼 수 있기 때문에 결과를 드러낸다 
(대부분의 프로토콜은 원값이 아닌 사용자가 계산한 해시에 서명하는 것을 
포함하거나 결과를 드러내지 않기 때문에 이는 실제 문제가 되지는 않는다). 
절대로 정확히 동일한 원값을 여러번 복호화하거나 서명하지 마라 (원래 값이 
노출될 수 있다). 
이러한 두 문제 모두 임의의 패딩 (padding, 아무런 의미가 없는, 고정 길이를 
갖는 레코드 또는 블록에 무의미한 문자로 채우는 기법) 을 늘 추가함으로써 
해결될 수 있다 (PGP 경우와 같이) - 보통의 접근 방법은 Optimal Asymmetric 
Encryption Padding (OAEP) 라고 불린다.&#13;</P
><P
>&#13;Diffie-Hellman 키 교환 알고리듬은 두 당사자간에 세션키 일치를 허용하는데 
널리 사용되고 있다. 이 자체로는 당사자들이 자신들은 누구이다 라고 말하는 
당사자들임을 보증하지 못하며 또한 중개자도 없다. 그러나 수동적인 
스니퍼에 대해서는 강력한 보호를 제공한다; 이 특허는 1997년에 만료되었다. 
공유되는 비밀을 생성하기 위해 Diffie-Hellman 을 사용한다면 반드시 이를 
우선적으로 해시해라 (공유되는 값을 직접적으로 사용하는 경우 공격이 있을 
수 있다).&#13;</P
><P
>&#13;NIST 는 디지털 서명 생성과 입증을 위해 DSS (Digital Signature Standard, 
디지털 서명 표준) 을 개발했다 (이는 ElGamel 암호화 시스템을 수정한 
것이다); 이것이 개발된 조건중의 하나는 특허에 자유롭다는 것이였다.&#13;</P
><P
>&#13;RSA, Diffie-Hellman 및 El Gamel 기법은 일반적인 대칭키와 비교해서 동일한 
보안을 제공하기 위해 키에 대해 더욱 많은 비트를 필요로 한다; 이러한 시스템에서 
1024 비트 키는 대략 80 비트 대칭키와 동등한데 저자 의견으로는 이것이 
오늘날 사용해야 하는 최소 길이이다. 공개키에 대해 매우 작은 비트를 필요로 
한다면 타원 곡선 (elliptic curve) 암호화를 사용할 수도 있다 (IEEE P1363 에 
다소의 제안된 곡선이 있는데 이러한 곡선을 찾아내는 것은 어렵다). 
그러나 주의해라 - 타원 곡선 암호화는 특허화되어 있지 않지만 어떤 고속화 
기법은 특허화되어 있다 (타원 곡선은 흔히 사용되는 세션 암호화/벌크 
암호화 키 등에는 이러한 속도화가 실제 필요치 않을 만큼 충분히 빠르다). &#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="HASH"
>10.5.4. 암호학적 해시 알고리듬</A
></H3
><P
>&#13;어떤 프로그램들은 일방향 해시 알고리듬, 즉 임의의 데이타들 취해 공격자가 
되돌리기 어려운 고정된 길이의 숫자를 생성하는 함수를 필요로 한다 
(예, 공격자가 동일한 값을 생성하는 여러 데이타셋을 생성하는 것은 어렵다). 
여러해 동안 MD5 가 선호되었지만 최근의 연구는 MD5 의 128 비트 길이가 
충분하지 않을 수도 있으며 [van Oorschot 1994] 어떤 공격이 MD5 의 보호를 
무력화 시킴을 보였다 [Dobbertin 1996]. 
정말로 최고 산업계 암호학자가 MD5 를 해독했지만 종업원 협약에
의해 어쩔 수 없이 기밀로 유지되고 있다는 소문이 있다 (John Viega 가
게시한 2000년 8월 22일 Bugtraq 를 보라). 누군가 소문을 만들 수도
있지만 해독될 수 있다는 생각을 그럴듯하게 만든 충분한 약점이 발견되었다.
새로운 코드를 작성한다면 MD5 대신 SHA-1 을 대신 사용해라. 
원래의 SHA (현재 ``SHA-0" 로 부른다) 를 사용하지 마라; SHA-0 는 MD5 가 
갖고 있는 몇몇 약점을 갖고 있다. 해시 알고리듬에 더욱 많은 비트를 필요로 
한다면 SHA-256, SHA-384 또는 SHA-512 를 사용해라; NIST FIPS PUB 180-2 에서 
스펙을 얻을 수 있다.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ITNEGRITY-CHECK"
>10.5.5. 무결성 검사</A
></H3
><P
>&#13;통신할 때 어떤 종류의 무결성 검사가 필요하다 (암호화에만 의존하지 마라. 
공격자가 정보를 ``임의의" 값으로 변경할 수도 있다). 
해시 알고리듬을 사용해 무결성 검사를 할 수 있지만 단지 해시 함수를 
직접적으로 사용하지는 마라 (이는 사용자를 ``확장" (extension) 공격에 
노출시킨다 - 공격자가 해시값을 사용해 자신들의 데이타를 추가한 후 새로운 
해시를 계산할 수 있다). 보통의 방법은 ``HMAC" 로 다음과 같이 무결성 검사를 
수행한다.&#13;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  H(k xor opad, H(k xor ipad, data)).</PRE
></TD
></TR
></TABLE
><P
>&#13;H 는 해시 함수 (일반적으로 MD5 또는 SHA-1) 이고 k 는 키이다. 
따라서 무결성 검사는 대개 HMAC-MD5 또는 HMAC-SHA-1 이다. 
MD5 가 약간의 약점을 갖고 있지만 저자가 아는한 MD5 는 위와 같이 사용될 때 
취약하지 않으며 따라서 (저자가 알기에) HMAC-MD5 도 취약하지 않음을 
주목해라. 이는 IETF RFC 2104 에 세부적으로 정의되어 있다.&#13;</P
><P
>&#13;HMAC 방법에서 송신자와 같이 수신자도 동일 데이타를 변조할 수 있음을 
주목해라. 이는 대개 문제가 되지 않지만 피해져야 한다면 공개키 방법을 
사용하고 송신자에게 자신의 비밀키로 데이타에 서명하게 해라 - 이는 이러한 
변조 공격을 예방하지만 더욱 많은 비용이 들며 대부분의 환경에서 필요하지는 
않다. &#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CRYPTO-OTHER"
>10.5.6. 다른 암호학적 쟁점</A
></H3
><P
>&#13;중요한 데이타는 암호화와 무결성 검사 모두를 해야한다. 
무결성을 제공하는 암호화에 의존하지 마라 - 공격자가 비트를 다른 값으로 
변경할 수도 있으며 공격자 이를 특정 값으로 변경할 수 없더라도 단지 값을 
변경시키는 것만으로 충분할 수도 있다. 
일반적으로 어떤 미묘한 공격을 예방하기 위해 무결성과 비밀에 다른 키를 
사용해야 한다.&#13;</P
><P
>&#13;대개 충분히 논의되지 않는 한가지 문제는 ``트래픽 분석" 문제이다. 즉, 메시지가 
암호화되어 해독되지 않더라도 적은 암호화된 메시지로부터 매우 많은 것을 
알 수 있다. 예를 들어 두 회사의 사장이 많은 암호화된 이메일 메시지를 
교환하기 시작한다면 두 회사가 합병을 고려하고 있다고 생각할 수도 있다. 
다른 예로는 많은 SSH 구현은 패스워드를 교환하는데 있어 약점을 갖고 있다고 
알려져 있다; 관측자는 패킷을 보고 패스워드 자체는 알아낼 수 없더라도 
패스워드의 길이 (또는 길이 범위) 는 결정할 수 있다. 
또한 패스워드를 해독하는데 상당히 도움이 되는 패스워드 관련 다른 정보를 정할 
수도 있다. &#13;</P
><P
>&#13;반드시 어느 정도 해독하는 것을 가능하게 하지 말고 (신뢰되어지는) 신뢰 
환경이 변할 때 다른 키를 사용해라. 너무 오랫동안 동일한 키를 사용하지 마라 - 
얼마 후에 세션 키 또는 패스워드를 변경해라. 따라서 적은 이들의 해독을 다시 
시작해야 할 것이다.&#13;</P
><P
>&#13;일반적으로 암호화할 것을 압축해야 한다 - 이는 고정된 헤더를 추가해 
별로 좋진 않지만 암호화된 결과를 더욱 작게 만들뿐아니라 메시지에 존재하는 
많은 패턴을 제거한다. 따라서 압축을 통해 결과가 더욱 작아진다면 보통 
``이익" 으로 간주되었다.&#13;</P
><P
>&#13;관련해서 주목할 것은 자신의 고유 통신 프로토콜을 만들어야 한다면 
이전에 무엇이 진행되어 왔는지의 문제를 조사해라. Bruce Schneier [1998], 
Mudge 의 breaking of Microsoft's PPTP implementation 및 후속 작업 
뿐만 아니라 TCP/IP 프로토콜 스위트에서 보안 문제에 대한 Bellvin 
[1989] 의 검토와 같은 고전이 도움이 될 것이다. 물론 반드시 모든 새로운 
프로토콜을 광범위하게 공개적으로 검토해야 가능한 재사용해라.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="USE-PAM"
>10.6. PAM 사용</A
></H2
><P
>&#13;PAM (Pluggable Authentication Module, 장착식 인증 모듈) 은 사용자를
인증하기 위한 유연한 메카니즘으로 솔라리스, 거의 모든 리눅스 배포판
(레드햇, 칼데라와 데비안 버전 2.2) 과 FreeBSD 버전 3.1 등의 많은 유닉스
계열 시스템이 PAM 을 지원한다. PAM 을 사용함으로써 프로그램은 패스워드,
스마트카드 등의 인증 스킴에 독립적일 수 있다. 기본적으로 프로그램은 PAM
을 호출하는데 로컬 시스템 관리자의 설정을 검사함으로써 어떤 ``인증
모듈"이 필요한지를 런타임시 결정한다. 패스워드 입력과 같은 인증을 요하는
프로그램을 작성하고 있다면 PAM 에 대한 지원을 포함해야 한다. <A
HREF="http://www.kernel.org/pub/linux/libs/pam/index.html"
TARGET="_top"
>http://www.kernel.org/pub/linux/libs/pam/index.html</A
>에서
리눅스-PAM 프로젝트에 대한 더욱 자세한 정보를 찾을 수 있다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="TOOLS"
>10.7. 도구</A
></H2
><P
>&#13;몇몇 도구들은 보안 문제를 처리하기 전에 이를 탐지하는데 도움이 될 수
있다. 물론 모든 그러한 문제를 발견할 수는 없지만 지나칠 수 있는 문제를 
잡는데 도움이 될 수 있다. 다음은 오픈 소스/자유 소프트웨어 도구에 중점을 
둔 약간의 도구들이다. &#13;</P
><P
>&#13;한가지 명백한 타입의 도구는 잠재적인 보안 문제를 갖고 있다고 알려진 
패턴을 찾아내는 소스 코드를 검사하는 프로그램이다 (예, 라이브러리 함수 
호출은 대개 보안 취약성의 출처이다). 
이러한 종류의 프로그램은 ``소스 코드 스캐너" (source code scanner) 라고 
불리는데 다음 몇몇 그러한 도구들이다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;Secure Software Solutions 의 RATS (Rough Auditing Tool for Security) 는 
<A
HREF="http://www.securesw.com/rats"
TARGET="_top"
>http://www.securesw.com/rats</A
> 
에서 얻을 수 있다. 이 프로그램은 일반적인 문제에 대해 C/C++ 소스 코드를 
스캔하며 GPL 라이센스하에 있다.&#13;</P
></LI
><LI
><P
>&#13;저자가 개발한 Flawfinder; 이는 <A
HREF="http://www.dwheeler.com/flawfinder"
TARGET="_top"
>http://www.dwheeler.com/flawfinder</A
> 에서 얻을 수 있다. 이도 또한 
일반적인 문제에 대해 C/C++ 소스 코드를 스캔하며 GPL 라이센스하에 있다. 
RATS 와는 달리 flawfinder 는 파이썬으로 구현되어 있다. RATS 와 Flawfinder 
개발자들은 하나의 ``가장 우수한" 오픈 소스 프로그램을 만들기 위해 
함께 공동작업할 방법을 찾는데 의견을 일치하였다.&#13;</P
></LI
><LI
><P
>&#13;Cigital (이전 Reliable Software Technologies, RST) 의 ITS4 는 정적으로
C/C++ 코드를 검사한다. ITS4 는 소스 코드에 패턴 매칭을 수행해 어떤 함수
호출과 같은 위험할 수 있다고 알려진 패턴을 찾아내는데 소스 코드를 포함해
어떤 수정과 재배포 권리와 함께 비상업적 사용을 위해서는 무료로 얻을 수
있다. 이 도구는 <A
HREF="http://www.opensource.org/osd.html"
TARGET="_top"
>Open
Source Definition</A
> (OSD) 에 의해 정의된 것과 같은 ``오픈 소스" 로 
발표되지 않았음을 주목해라. 특히 OSD 조항 6 은 오픈 소스 라이센스에서 
"non-commercial use only" 절을 금지하고 있다. 
ITS4 는 <A
HREF="http://www.rstcorp.com/its4"
TARGET="_top"
>http://www.rstcorp.com/its4</A
>
에서 얻을 수 있다.&#13;</P
></LI
><LI
><P
>&#13;LCLint 는 정적으로 C 프로그램을 검사하는 도구인데 이는 최소한의 노력으로
더욱 좋은 lint (유닉스 운영체제에서 사용되는 프로그램으로서, C 언어의
원시 프로그램을 읽어들여 오류가 있는지를 검사하는 프로그램) 로 사용될 수
있다. 프로그램에 주석을 다는 추가 노력이 행해진다면 LCLint 는 어떤 표준
lint 보다 더욱 강한 검사를 수행할 수 있다. 이 소프트웨어는 GPL
라이센스이며 <A
HREF="http://lclint.cs.virginia.edu"
TARGET="_top"
>http://lclint.cs.virginia.edu</A
>
에서 얻을 수 있다.&#13;</P
></LI
><LI
><P
>&#13;cqual 은 C 프로그램에서 버그를 찾기위한 타입 기반 분석 도구이다. 
이는 C 의 타입 시스템을 특별한 사용자 정의 타입 한정사 (qualifier) 로 
확장하는데 예를 들어 값들이 ``tainted" 또는 ``untainted" 임을 나타낼 수 
있다 (펄의 taint 검사와 유사). 프로그래머는 몇몇 장소에 그들의 프로그램에 
대한 주석을 다는데 cqual 은 주석이 정확한지 검사하기 위해 한정사 추론을 
수행한다. cqual 은 이맥스 기반 인터페이스인 Program Analysis Mode 를 
사용해 분석 결과를 나타낸다. 현재 버전은 C 프로그램의 잠재적인 
포맷-문자열 취약성을 찾아낼 수 있다. Cqual 의 이전 버전인 Carillon 은 
C 프로그램에서 Y2K 문제를 찾아내기 위해 사용되었다. 
소프트웨어는 GPL 라이센스로 <A
HREF="http://www.cs.berkeley.edu/Research/Aiken/cqual"
TARGET="_top"
>http://www.cs.berkeley.edu/Research/Aiken/cqual</A
> 
에서 얻을 수 있다. &#13;</P
></LI
><LI
><P
>&#13;Cyclone 은 C 의 보안 약점을 제거하기 위한 만들어진 C 와 같은 언어이다. 
이론상 ``더욱 보안적인" 언어로 언제나 바꿀 수 있지만 이것이 늘 도움이 되지는 
않는다 (언어는 공통적인 실수를 피하도록 도움을 줄 수는 있지만 각자의 의중을 
읽을 수는 없다). <A
HREF="http://www.securityfocus.com/guest/9094"
TARGET="_top"
>John Viega 는 Cyclone 을 검토하였으며</A
>, 2001년 12월 다음과 같이 
말했다: ``Cyclone 은 명확하게 멋진 언어이다. 
이는 프로그래머에게 실제 이익이 될 수 있는 많은 특징이 있을 뿐만 아니라 
C 언어의 어떠한 능력도 빼앗지 않을 것 같고 게다가 강력한 보안 보증을 
추가한 C 다이어렉트 (dialect, 컴퓨터 언어의 특수한 판) 이다. 불행히 
Cyclone 은 아직 가장 중요한 시간에 준비되어 있지 않았다. Cyclone 을 못쓰게 
만드는 제한들은 예외로 하더라도 아직까지 매우 미성숙된 기술을 
사용하는 위험을 무릅쓰는 것이 가치가 없을만큼 아직 자바 (또는 훌륭한 
툴셋을 갖고 있는 C) 에 대해 충분한 장점을 제공하지 못하고 있다. 
아마도 몇년내에 Cyclone 는 효율면에서 위험할 정도로 C 와 유사한 강력하고 널리 
지원되는 언어로 성숙할 것이다. 그날이 오면 분명히 내가 C 를 포기하는 것을 
볼 것이다." 
Cyclone 컴파일러는 GPL 및 LGPL 라이센스하에 발표되었으며 더욱 자세한 
정보는 <A
HREF="http://www.research.att.com/projects/cyclone"
TARGET="_top"
>Cyclone 웹 사이트</A
> 에서 얻을 수 있다.&#13;</P
></LI
></UL
><P
>&#13;다른 방법은 프로그램내의 약점을 찾기 위해 테스트 패턴을 만들어 프로그램을 
실행시키는 것이다. 다음은 약간의 도구들이다.&#13;</P
><P
></P
><UL
><LI
><P
>&#13;BFBTester, Brute Force Binary Tester, 은 GPL 라이센스 프로그램으로 이진
프로그램의 보안을 빠르게 검사하는데 이 프로그램은 단일 및 다중 인수
커맨드 라인 오버플로우와 환경변수 오버플로우를 검사한다. 버전 2.0 이상은
비보안적인 tempfile 이름을 사용하는지 검사하기 위해 또한 tempfile 을
생성하려는 동작을 감시할 수 있다. 
한때 BFBTester 는 리눅스의 POSIX 쓰레드 구현시의 기술적 문제때문에 
리눅스에서 실행되지 않았지만 버전 2.0.1 에서 수정되었다. 
더욱 자세한 정보는 <A
HREF="http://my.ispchannel.com/~mheffner/bfbtester"
TARGET="_top"
>http://my.ispchannel.com/~mheffner/bfbtester</A
>
에서 얻을 수 있다.&#13;</P
></LI
><LI
><P
>&#13;<A
HREF="http://fuzz.sourceforge.net/"
TARGET="_top"
>fuzz</A
> 프로그램은 다른
소프트웨어를 검사하는 도구로 임의의 데이타로 평가할 프로그램을
공격함으로써 프로그램을 검사한다. 이 도구는 실제 보안에 한정된 것은
아니다.&#13;</P
></LI
></UL
><P
>&#13;많은 보통의 잠재적인 단점을 갖고 있는 ftp 서버 또는 방화벽과 같은
제품을 구축하려면 표준 보안 스캐닝 도구가 유용함을 알 수 있다. <A
HREF="http://www.nessus.org"
TARGET="_top"
>Nessus</A
> 는 한가지 훌륭한 도구로
이외에도 많은 도구들이 있다. 이러한 종류의 도구들은 회귀 검사 (regression 
testing) 을 하는데 매우 유용하지만 이들은 본질적으로 과거의 특정 취약성과 
공통적인 설정 에러 목록을 사용하기 때문에 새로운 프로그램에서 문제점을 
찾아내는데 유용하지 않을 수도 있다.&#13;</P
><P
>&#13;보안적인 인프라를 구현하기 위해 다른 도구를 호출할 필요가 있을 것이다. 
<A
HREF="http://ospkibook.sourceforge.net"
TARGET="_top"
>Open-Source PKI Book</A
> 은 공개키 기반구조 (public key infrastructure, 
PKI) 를 구현하기 위한 많은 오픈 소스 프로그램을 기술하고 있다.&#13;</P
><P
>&#13;물론 비보안적으로 설정된 플랫폼에서 보안적인 프로그램을 실행시키는 
것은 의미가 없다. 공격에 보다 저항적인 시스템 설정을 하거나  수정하기 위해 
강화 시스템을 검사할 수도 있다. 리눅스에서 한가지 강화 시스템은 Bastille 리눅스로 
이는 <A
HREF="http://www.bastille-linux.org"
TARGET="_top"
>http://www.bastille-linux.org</A
> 에서 
얻을 수 있다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="WINDOWS-CE"
>10.8. Windows CE</A
></H2
><P
>&#13;윈도우 CE 디바이스를 안전하게 하려면 <A
HREF="http://msdn.microsoft.com/library/techart/winsecurity.htm"
TARGET="_top"
>http://msdn.microsoft.com/library/techart/winsecurity.htm</A
>에서
Maricia Alforque 의 "Creating a Secure Windows CE Device" 를 읽어야
한다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="WRITE-AUDIT-RECORDS"
>10.9. 감사 레코드 작성</A
></H2
><P
>&#13;프로그램 시동, 세션 시동 및 수상한 행동에 대한 감사 기록을 작성해라.
가치있는 가능한 정보로는 날짜, 시간, uid, euid, gid, egid, 단말기
정보, 프로세스 id 와 커맨드 라인 값들이 있는데 syslog(3) 함수가 감사
로그를 구현하는데 있어 도움이 될 수 있다. 한가지 조심해야할 문제는 모든
로깅 시스템이 많은 정보 (이 정보가 매우 도움이 될 것이기 때문에) 를
기록할 수 있어야 하지만 이 정보가 주의깊게 다뤄지지 않는다면 정보 자체가
공격하는데 사용될 수 있다는 것이다. 결국 공격자는 프로그램에 보내지는
입력의 일부를 제어하는데 있을 수 있는 공격자에 의해 보내진 데이타를
기록할 때는 로그가 손상되지 않도록 ``예상된" 문자들의 목록을 확인하고
모든 ``예기치 않은" 문자들을 이스케이프해라. 이렇게 하지 않으면 실제
문제가 될 수 있다; 사용자가 실제 문제를 일으킬 수 있는 제어 문자들 (특히
NIL 또는 라인 끝) 과 같은 문자를 포함할 수도 있다. 예를 들어 공격자가
개행 문자를 끼워넣는다면 개행 문자뒤에 원하는 로그 엔트리를 놓음으로써
그 엔트리를 변조할 수 있다. 불행히 이러한 문자들을 이스케이핑하는 것에
대한 표준 관례가 있을 것 같지는 않다. 저자는 URL 이스케이핑 메카니즘
(%hh, hh 는 이스케이프되는 바이트의 16진수) 을 특히 좋아하지만 C 관례
(8진수에 대해 \ooo, \X, X 는 특별 심볼로 예, 개행 문자에 대해 \n) 를
포함해 다른 것들도 있다. 또한 캐럿 (caret) 시스템 (^I 는 control-I) 도 있지만 
이 시스템은 127 위의 바이트 값을 다루지는 못한다.&#13;</P
><P
>&#13;시스템이 감사 레코드를 저장하기 위한 자원을 다써버릴 때까지 감사
레코드를 기록되게 하는 매우 많은 수의 이벤트를 수행함으로써 사용자가
서비스 부인 공격 (또는 적어도 감사 중지) 을 만들 수 있는 위험이 있다. 이
위협에 대처하기 위한 한가지 접근 방법은 감사 기록 레코딩의 정도를 제한
(rate limit) 하는 것이다; 너무 많은 감사 레코드들이 기록되고 있다면
의도적으로 응답 속도를 감소시켜라. 또한 의심스러운 공격자에게만 응답
속도를 줄이려고 할 수도 있지만 많은 경우 단독 공격자가 잠재적으로 많은
사용자들로 가장할 수 있다.&#13;</P
><P
>&#13;물론 무엇이 ``수상한 행동"인가를 선택하는 것은 프로그램이 하는 일과 이의
예상된 사용에 의존하는데 초기에 논의한 필터링 검사에서 걸러지지 않는
모든 입력이 아마도 후보이다 (예, NIL 을 포함하여). 정상 사용으로부터
생길수 없는 입력은 될 수 있는한 기록되어야 하는데 특정 요구 필드가
수상한 방식으로 사라지는 CGI 스크립트가 그 예이다. /etc/passwd 또는
/etc/shadow 또는 비슷한 문장을 갖고 있는 모든 입력은 많은 경우 매우
의심스럽다. 비슷하게 윈도우의 "registry" 파일 또는 .pwl 파일에
접근하려는 것은 매우 의심스럽다.&#13;</P
><P
>&#13;감사 레코드에 패스워드를 기록하지 마라. 종종 사람들은 여러 시스템에 대해
패스워드를 우연히 입력하는데 따라서 패스워드를 기록하는 것은 시스템
관리자가 관리 영역 외부의 다른 컴퓨터에 침입할 수 있도록 한다.&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="MISCELLANEOUS"
>10.10. 기타</A
></H2
><P
>&#13;다음은 다른 절에서 기술하기에는 적당하지 않을 것 같은 여러가지 기타 보안
지침들이다:&#13;</P
><P
>&#13;프로그램의 가정들을 사용하기 전에 적어도 (프로그램 시작부분에서)
프로그램이 이들의 일부를 검사하게 하라. 예를 들어 주어진 디렉토리에
설정된 "sticky" 비트에 의존한다면 이를 검사해라. 이러한 검사들은 거의
시간이 걸리지 않지만 심각한 문제를 예방할 수 있다. 각 호출에 대해 약간의
검사에 걸리는 시간이 우려된다면 적어도 설치시에 검사를 하거나 또는 더욱
좋은 것은 애플리케이션 시동시에 적어도 검사를 수행해라.&#13;</P
><P
>&#13;내장 스크립팅 언어를 갖고 있다면 이 언어가 스크립트를 호출하는
프로그램에 나쁜 영향을 미칠 수 있는 환경 변수를 설정하는 것이 가능할
수도 있다. 이에 대처해라.&#13;</P
><P
>&#13;복잡한 설정 언어가 필요하다면 이 언어가 주석 문자를 갖고 있고 주석처리된
많은 보안적인 예들을 포함하는 지 확인해라. 대개 '#'이 주석을 다는데
사용되는데 이 라인의 나머지가 주석이다.&#13;</P
><P
>&#13;가능하다면 setuid 또는 setgid 루트 프로그램을 작성하지 마라; 대신 루트로
사용자 로그인을 해라.&#13;</P
><P
>&#13;코드에 서명해라. 이렇게 함으로써 얻을 수 있는 것이 보내졌던 것인지를 
살펴보기 위해 다른 사람들이 검사할 수 있다.&#13;</P
><P
>&#13;정적으로 링크되는 보안적인 프로그램을 고려해라. 이는 보안적인 프로그램이
동적 링크 라이브러를 사용하지 않음을 확인함으로써 이 메카니즘에 대한
공격에 대응한다. 그러나 이는 몇가지 단점이 있는데 동일한 루틴의 다중
복사때문에 디스크와 메모리 사용을 증가시킬 수 있으며 또한 더욱 바람직
하지 않은 것은 보안 취약성에 대한 라이브러리 갱신을 더욱 어렵게 만든다 -
대부분의 시스템에서 이들은 자동적으로 갱신되지 않을 것이며 개별적으로 
찾아내 구현되어야 한다.&#13;</P
><P
>&#13;코드를 자세히 검토할 때 일치하지 않는 모든 경우를 고려해라. 예를 들어
switch 문이 있다면 cases 중 아무 것도 일치하지 않을 때 무엇이 발생할
것인가? "if" 문이 있다면 조건이 실패할 때 무엇이 발생할 것인가?&#13;</P
><P
>&#13;단지 파일을 ``removing" 한다고 해서 이 디스크로부터 파일 데이타를
제거하는 것은 아니다; 대부분의 시스템에서는 이 내용을 ``deleted" 로
표시하여 추후 재사용에 알맞게 만들며 대개 데이타는 적어도 다른 곳
(메모리, 스왑 파일 및 임시 파일) 에 일시적으로 저장된다. 정말로 단호한
공격에 대항하기 위해서는 데이타를 겹쳐쓰는 것으로는 충분하지 않다.
자성체 미디어를 지우는 문제에 대한 고전적인 논문은 Peter Gutman 의 논문
<A
HREF="http://www-tac.cisco.com/Support_Library/field_alerts/fn13070.html"
TARGET="_top"
>``Secure Deletion of Data from Magnetic and Solid-State
Memory''</A
>이다. 과감한 적은 컴퓨터에서 방출되는 전자기 모니터링
(군사 시스템들은 이를 극복하기 위해 TEMPEST 규칙을 따라야 한다) 및
키보드에 숨겨진 모니터와 같은 비밀 공격 등의 다른 방법을 사용할 수도
있다.&#13;</P
><P
>&#13;보안 취약성을 수정할 때 (현재 수정된) 취약성을 악용하려는 시도를 
탐지해 기록하기 위해 ``경고" 를 추가하는 것을 고려해라. 이는 특히 
공격자가 공격이 효과가 있을 것인지 미리 결정할 방법이 없다면 
진행중인 공격을 노출시키기 때문에 공격 가능성을 감소시킬 것이다. 
요약하면 취약성을 침입 탐지 시스템으로 변환시켜라. 이는 또한 인증전에 
서버 프로그램의 버전을 드러내는 것은 보안에 대해 나쁜 개념이라고 제안한다. 
왜냐하면 버전을 드러냄으로써 공격자가 효과가 있을 공격만을 
사용하는 것을 쉽게 하기 때문이다. 몇몇 프로그램은 공격자가 ``잘못된 공격"을 
사용해 탐지될 수 있도록 의도적으로 버전을 틀리게 말하는 것을 가능하게 
한다. 또한 취약성이 네트워크를 통해 유발된다면 반드시 보안 스캐너가 취약성을 
탐지할 수 있도록 하기바란다. 저자는 <A
HREF="http://www.nessus.org"
TARGET="_top"
>Nessus</A
> 를 사용하기를 추천하는데 반드시 오픈 소스 보안 스캐너가 
문제점을 탐지할 수 있도록 해라. 이렇게 함으로써 갱신에 대해 소프트웨어를 
검사하지 않는 사용자가 최소한 보안 취약성 스캔동안에 문제에 배울 것이다.&#13;</P
><P
>&#13;때때로 이 책과 같은 보안 지침을 검토해라. 최소한 <A
HREF="#CONCLUSION"
>11&#51109;</A
> 
내의 결론을 다시 읽은 후 소개 (<A
HREF="#INTRODUCTION"
>1&#51109;</A
>) 로 되돌아가 
다시 읽어라.&#13;</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CONCLUSION"
>11&#51109;. 결론</A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>The end of a matter is better than its beginning, and
patience is better than pride.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Ecclesiastes 7:8 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><P
>&#13;정말 보안적인 프로그램을 설계하고 구현하는 것은 리눅스 및 유닉스와 같은
유닉스 계열 시스템에서는 실제로 어려운 작업인데 정말 보안적인 프로그램이
잠재적으로 악의있는 사용자가 제어하는 모든 가능한 입력과 환경에 적절하게
응답해야 한다는 것은 어렵다. 보안적인 프로그램 개발자들은 프로그램의
취약성을 줄이기 위해 각자의 플랫폼을 깊게 이해하고 지침들을 찾아 사용한
후 세부 검토 (peer review) 와 같은 보증 프로세스를 사용해야 한다.&#13;</P
><P
>&#13;결론적으로 다음은 이 책에서 기술한 주요 지침들의 일부이다:&#13;</P
><P
></P
><UL
><LI
><P
>&#13;커맨드 라인 입력, 환경 변수, CGI 입력 등 모든 입력을 확인해라. 틀린
입력을 그저 거절하지 마라; 무엇이 수용가능한 입력인지를 정의하고
일치하지 않는 모든 것을 거절해라.&#13;</P
></LI
><LI
><P
>&#13;버퍼 오버플로우를 피해라. 긴 입력 (과 긴 중간 데이타 값) 이 프로그램을
비정상적으로 동작시키는데 사용될 수 없음을 확인해라. 이는 현재 기본적인
프로그램적인 에러이다.&#13;</P
></LI
><LI
><P
>&#13;프로그램 내부를 구조화해라. 인터페이스를 안전하게 하고 권한을 최소로 
하며 초기설정과 디폴트를 안전하게 만들고 오류시 자동적으로 정상상태로 
돌아가게 해라 (fail-safe). 경쟁 상태를 피해라 (예, /tmp 와 같은 공유 
디렉토리내의 모든 파일들을 안전하게 오픈함으로써). 단지 신뢰할 수 있는 
채널만을 신뢰해라 (예, 대부분의 서버가 보안 검사 또는 구입시 아이템 
가격과 같은 기밀을 다루는 데이타에 대해 클라이언트를 신뢰하지 않아야 한다.)&#13;</P
></LI
><LI
><P
>&#13;주의깊게 다른 자원들을 호출해라. 이들의 값들을 유효한 값들로 제한하고 
(특히 메타문자에 주의해라) 모든 시스템 호출 반환 값들을 검사해라.&#13;</P
></LI
><LI
><P
>&#13;정보를 신중하게 응답해라. 특히 피드백을 최소화하고 신뢰할 수 없는
사용자에 대해 완전하거나 무반응의 출력을 다뤄라.&#13;</P
></LI
></UL
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="BIBLIOGRAPHY"
>12&#51109;. 문헌 목록</A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>The words of the wise are like goads, their collected sayings like
firmly embedded nails--given by one Shepherd. 
Be warned, my son, of anything in addition to them.
Of making many books there is no end, and much study wearies the body.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Ecclesiastes 12:11-12 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><P
>&#13;<B
CLASS="EMPHASIS"
>웹상에서 얻을 수 있는 기술적 기사들을 
매우 강조함을 주목해라. 웹은 이러한 종류의 기술적 정보 대부분을 얻을 
수 있는 곳이다.</B
>&#13;</P
><P
>[Advosys 2000]
Advosys Consulting
(formerly named Webber Technical Services).
<B
CLASS="EMPHASIS"
>Writing Secure Web Applications</B
>.
<A
HREF="http://advosys.ca/tips/web-security.html"
TARGET="_top"
>http://advosys.ca/tips/web-security.html</A
></P
><P
>[Al-Herbish 1999]
Al-Herbish, Thamer.
1999.
<B
CLASS="EMPHASIS"
>Secure Unix Programming FAQ</B
>.
<A
HREF="http://www.whitefang.com/sup"
TARGET="_top"
>http://www.whitefang.com/sup</A
>.</P
><P
>[Aleph1 1996] 
Aleph1.
November 8, 1996.
``Smashing The Stack For Fun And Profit''.
<B
CLASS="EMPHASIS"
>Phrack Magazine</B
>.
Issue 49, Article 14.
<A
HREF="http://www.phrack.com/search.phtml?view&#38;article=p49-14"
TARGET="_top"
>http://www.phrack.com/search.phtml?view&#38;article=p49-14</A
>
or alternatively
<A
HREF="http://www.2600.net/phrack/p49-14.html"
TARGET="_top"
>http://www.2600.net/phrack/p49-14.html</A
>.</P
><P
>[Anonymous 1999]
Anonymous.
October 1999.
Maximum Linux Security:
A Hacker's Guide to Protecting Your Linux Server and Workstation
Sams.
ISBN: 0672316706.</P
><P
>[Anonymous 1998]
Anonymous.
September 1998.
Maximum Security : A Hacker's Guide to Protecting Your
Internet Site and Network.
Sams.
Second Edition.
ISBN: 0672313413.</P
><P
>[AUSCERT 1996]
Australian Computer Emergency Response Team (AUSCERT) and O'Reilly.
May 23, 1996 (rev 3C).
<B
CLASS="EMPHASIS"
>A Lab Engineers Check List for Writing Secure Unix Code</B
>.
<A
HREF="ftp://ftp.auscert.org.au/pub/auscert/papers/secure_programming_checklist"
TARGET="_top"
>ftp://ftp.auscert.org.au/pub/auscert/papers/secure_programming_checklist</A
></P
><P
>[Bach 1986]
Bach, Maurice J.
1986.
<B
CLASS="EMPHASIS"
>The Design of the Unix Operating System</B
>.
Englewood Cliffs, NJ: Prentice-Hall, Inc.
ISBN 0-13-201799-7 025.</P
><P
>[Bellovin 1989]
Bellovin, Steven M.
April 1989. 
"Security Problems in the TCP/IP Protocol Suite"
Computer Communications Review 2:19, pp. 32-48.
<A
HREF="http://www.research.att.com/~smb/papers/ipext.pdf"
TARGET="_top"
>http://www.research.att.com/~smb/papers/ipext.pdf</A
></P
><P
>[Bellovin 1994]
Bellovin, Steven M.
December 1994.
<B
CLASS="EMPHASIS"
>Shifting the Odds -- Writing (More) Secure Software</B
>.
Murray Hill, NJ: AT&#38;T Research.
<A
HREF="http://www.research.att.com/~smb/talks"
TARGET="_top"
>http://www.research.att.com/~smb/talks</A
></P
><P
>[Bishop 1996]
Bishop, Matt.
May 1996.
``UNIX Security: Security in Programming''.
<B
CLASS="EMPHASIS"
>SANS '96</B
>. Washington DC (May 1996).
<A
HREF="http://olympus.cs.ucdavis.edu/~bishop/secprog.html"
TARGET="_top"
>http://olympus.cs.ucdavis.edu/~bishop/secprog.html</A
></P
><P
>[Bishop 1997]
Bishop, Matt.
October 1997.
``Writing Safe Privileged Programs''.
<B
CLASS="EMPHASIS"
>Network Security 1997</B
>
New Orleans, LA.
<A
HREF="http://olympus.cs.ucdavis.edu/~bishop/secprog.html"
TARGET="_top"
>http://olympus.cs.ucdavis.edu/~bishop/secprog.html</A
></P
><P
>[Blaze 1996]
Blaze, Matt, Whitfield Diffie, Ronald L. Rivest, Bruce Schneier,
Tsutomu Shimomura, Eric Thompson, and Michael Wiener.
January 1996.
``Minimal Key Lengths for Symmetric Ciphers to Provide
Adequate Commercial Security:
A Report by an Ad Hoc Group of Cryptographers and Computer Scientists.''
<A
HREF="ftp://ftp.research.att.com/dist/mab/keylength.txt"
TARGET="_top"
>ftp://ftp.research.att.com/dist/mab/keylength.txt</A
> and
<A
HREF="ftp://ftp.research.att.com/dist/mab/keylength.ps"
TARGET="_top"
>ftp://ftp.research.att.com/dist/mab/keylength.ps</A
>.</P
><P
>[CC 1999]
<B
CLASS="EMPHASIS"
>The Common Criteria for Information Technology Security Evaluation
(CC)</B
>.
August 1999.
Version 2.1.
Technically identical to International Standard ISO/IEC 15408:1999.
<A
HREF="http://csrc.nist.gov/cc/ccv20/ccv2list.htm"
TARGET="_top"
>http://csrc.nist.gov/cc/ccv20/ccv2list.htm</A
></P
><P
>[CERT 1998]
Computer Emergency Response Team (CERT) Coordination Center (CERT/CC).
February 13, 1998.
<B
CLASS="EMPHASIS"
>Sanitizing User-Supplied Data in CGI Scripts</B
>.
CERT Advisory CA-97.25.CGI_metachar.
<A
HREF="http://www.cert.org/advisories/CA-97.25.CGI_metachar.html"
TARGET="_top"
>http://www.cert.org/advisories/CA-97.25.CGI_metachar.html</A
>.</P
><P
>[Clowes 2001]
Clowes, Shaun.
2001.
``A Study In Scarlet - Exploiting Common Vulnerabilities in PHP''
<A
HREF="http://www.securereality.com.au/archives.html"
TARGET="_top"
>http://www.securereality.com.au/archives.html</A
></P
><P
>[CMU 1998]
Carnegie Mellon University (CMU).
February 13, 1998
Version 1.4.
``How To Remove Meta-characters From User-Supplied Data In CGI Scripts''.
<A
HREF="ftp://ftp.cert.org/pub/tech_tips/cgi_metacharacters"
TARGET="_top"
>ftp://ftp.cert.org/pub/tech_tips/cgi_metacharacters</A
>.</P
><P
>[Cowan 1999]
Cowan, Crispin, Perry Wagle, Calton Pu, Steve Beattie, and
Jonathan Walpole.
``Buffer Overflows: Attacks and Defenses for the Vulnerability
of the Decade''.
Proceedings of DARPA Information Survivability Conference and Expo (DISCEX),
<A
HREF="http://schafercorp-ballston.com/discex"
TARGET="_top"
>http://schafercorp-ballston.com/discex</A
>
SANS 2000.
<A
HREF="http://www.sans.org/newlook/events/sans2000.htm"
TARGET="_top"
>http://www.sans.org/newlook/events/sans2000.htm</A
>.
For a copy, see
<A
HREF="http://immunix.org/documentation.html"
TARGET="_top"
>http://immunix.org/documentation.html</A
>.</P
><P
>[Cox 2000]
Cox, Philip.
March 30, 2001.
Hardening Windows 2000.
<A
HREF="http://www.systemexperts.com/win2k/hardenW2K11.pdf"
TARGET="_top"
>http://www.systemexperts.com/win2k/hardenW2K11.pdf</A
>.</P
><P
>[Dobbertin 1996].
Dobbertin, H.
1996.
The Status of MD5 After a Recent Attack.
RSA Laboratories' CryptoBytes.
Vol. 2, No. 2.</P
><P
>[Felten 1997]
Edward W. Felten, Dirk Balfanz, Drew Dean, and Dan S. Wallach.
Web Spoofing: An Internet Con Game
Technical Report 540-96 (revised Feb. 1997)
Department of Computer Science, Princeton University
<A
HREF="http://www.cs.princeton.edu/sip/pub/spoofing.pdf"
TARGET="_top"
>http://www.cs.princeton.edu/sip/pub/spoofing.pdf</A
></P
><P
>[Fenzi 1999]
Fenzi, Kevin, and Dave Wrenski.
April 25, 1999.
<B
CLASS="EMPHASIS"
>Linux Security HOWTO</B
>.
Version 1.0.2.
<A
HREF="http://www.linuxdoc.org/HOWTO/Security-HOWTO.html"
TARGET="_top"
>http://www.linuxdoc.org/HOWTO/Security-HOWTO.html</A
></P
><P
>[FHS 1997]
Filesystem Hierarchy Standard (FHS 2.0).
October 26, 1997.
Filesystem Hierarchy Standard Group, edited by Daniel Quinlan.
Version 2.0.
<A
HREF="http://www.pathname.com/fhs"
TARGET="_top"
>http://www.pathname.com/fhs</A
>.</P
><P
>[Filipski 1986]
Filipski, Alan and James Hanko.
April 1986.
``Making Unix Secure.''
Byte (Magazine).
Peterborough, NH: McGraw-Hill Inc.
Vol. 11, No. 4.
ISSN 0360-5280.
pp. 113-128.</P
><P
>[Flake 2001]
Flake, Havlar.
Auditing Binaries for Security Vulnerabilities.
<A
HREF="http://www.blackhat.com/html/win-usa-01/win-usa-01-speakers.html"
TARGET="_top"
>http://www.blackhat.com/html/win-usa-01/win-usa-01-speakers.html</A
>.</P
><P
>[FOLDOC]
Free On-Line Dictionary of Computing.
<A
HREF="http://foldoc.doc.ic.ac.uk/foldoc/index.html"
TARGET="_top"
>http://foldoc.doc.ic.ac.uk/foldoc/index.html</A
>.</P
><P
>[Forristal 2001]
Forristal, Jeff, and Greg Shipley.
January 8, 2001.
Vulnerability Assessment Scanners.
Network Computing.
<A
HREF="http://www.nwc.com/1201/1201f1b1.html"
TARGET="_top"
>http://www.nwc.com/1201/1201f1b1.html</A
></P
><P
>[FreeBSD 1999]
FreeBSD, Inc.
1999.
``Secure Programming Guidelines''.
<B
CLASS="EMPHASIS"
>FreeBSD Security Information</B
>.
<A
HREF="http://www.freebsd.org/security/security.html"
TARGET="_top"
>http://www.freebsd.org/security/security.html</A
></P
><P
>[FSF 1998]
Free Software Foundation.
December 17, 1999.
<B
CLASS="EMPHASIS"
>Overview of the GNU Project</B
>.
<A
HREF="http://www.gnu.ai.mit.edu/gnu/gnu-history.html"
TARGET="_top"
>http://www.gnu.ai.mit.edu/gnu/gnu-history.html</A
></P
><P
>[FSF 1999]
Free Software Foundation.
January 11, 1999.
<B
CLASS="EMPHASIS"
>The GNU C Library Reference Manual</B
>.
Edition 0.08 DRAFT, for Version 2.1 Beta of the GNU C Library. 
Available at, for example,
<A
HREF="http://www.netppl.fi/~pp/glibc21/libc_toc.html"
TARGET="_top"
>http://www.netppl.fi/~pp/glibc21/libc_toc.html</A
></P
><P
>Fu, Kevin, Emil Sit, Kendra Smith, and Nick Feamster.
August 2001.
``Dos and Don'ts of Client Authentication on the Web''.
Proceedings of the 10th USENIX Security Symposium,
Washington, D.C., August 2001.
<A
HREF="http://cookies.lcs.mit.edu/pubs/webauth.html"
TARGET="_top"
>http://cookies.lcs.mit.edu/pubs/webauth.html</A
>.
&#13;</P
><P
>[Galvin 1998a]
Galvin, Peter.
April 1998.
``Designing Secure Software''.
<B
CLASS="EMPHASIS"
>Sunworld</B
>.
<A
HREF="http://www.sunworld.com/swol-04-1998/swol-04-security.html"
TARGET="_top"
>http://www.sunworld.com/swol-04-1998/swol-04-security.html</A
>.</P
><P
>[Galvin 1998b]
Galvin, Peter.
August 1998.
``The Unix Secure Programming FAQ''.
<B
CLASS="EMPHASIS"
>Sunworld</B
>.
<A
HREF="http://www.sunworld.com/sunworldonline/swol-08-1998/swol-08-security.html"
TARGET="_top"
>http://www.sunworld.com/sunworldonline/swol-08-1998/swol-08-security.html</A
></P
><P
>[Garfinkel 1996]
Garfinkel, Simson and Gene Spafford.
April 1996.
<B
CLASS="EMPHASIS"
>Practical UNIX &#38; Internet Security, 2nd Edition</B
>.
ISBN 1-56592-148-8.
Sebastopol, CA: O'Reilly &#38; Associates, Inc. 
<A
HREF="http://www.oreilly.com/catalog/puis"
TARGET="_top"
>http://www.oreilly.com/catalog/puis</A
></P
><P
>[Garfinkle 1997]
Garfinkle, Simson.
August 8, 1997.
21 Rules for Writing Secure CGI Programs.
<A
HREF="http://webreview.com/wr/pub/97/08/08/bookshelf"
TARGET="_top"
>http://webreview.com/wr/pub/97/08/08/bookshelf</A
></P
><P
>[Gay 2000]
Gay, Warren W.
October 2000.
Advanced Unix Programming.
Indianapolis, Indiana: Sams Publishing.
ISBN 0-67231-990-X.</P
><P
>[Geodsoft 2001]
Geodsoft.
February 7, 2001.
Hardening OpenBSD Internet Servers.
<A
HREF="http://www.geodsoft.com/howto/harden"
TARGET="_top"
>http://www.geodsoft.com/howto/harden</A
>.</P
><P
>[Graham 1999]
Graham, Jeff.
May 4, 1999.
<B
CLASS="EMPHASIS"
>Security-Audit's Frequently Asked Questions (FAQ)</B
>.
<A
HREF="http://lsap.org/faq.txt"
TARGET="_top"
>http://lsap.org/faq.txt</A
></P
><P
>[Gong 1999]
Gong, Li.
June 1999.
<B
CLASS="EMPHASIS"
>Inside Java 2 Platform Security</B
>.
Reading, MA: Addison Wesley Longman, Inc.
ISBN 0-201-31000-7.</P
><P
>[Gundavaram Unknown]
Gundavaram, Shishir, and Tom Christiansen.
Date Unknown.
<B
CLASS="EMPHASIS"
>Perl CGI Programming FAQ</B
>.
<A
HREF="http://language.perl.com/CPAN/doc/FAQs/cgi/perl-cgi-faq.html"
TARGET="_top"
>http://language.perl.com/CPAN/doc/FAQs/cgi/perl-cgi-faq.html</A
></P
><P
>[Hall "Beej" 1999]
Hall, Brian "Beej".
Beej's Guide to Network Programming Using Internet Sockets.
13-Jan-1999.
Version 1.5.5.
<A
HREF="http://www.ecst.csuchico.edu/~beej/guide/net"
TARGET="_top"
>http://www.ecst.csuchico.edu/~beej/guide/net</A
></P
><P
>[ISO 12207]
International Organization for Standardization (ISO).
1995.
Information technology -- Software life cycle processes
ISO/IEC 12207:1995.</P
><P
>[ISO 13335]
International Organization for Standardization (ISO).
ISO/IEC TR 13335.
Guidelines for the Management of IT Security (GMITS).
Note that this is a five-part technical report (not a standard); see also
ISO/IEC 17799:2000.
It includes:
<P
></P
><UL
><LI
><P
>         ISO 13335-1: Concepts and Models for IT Security</P
></LI
><LI
><P
>         ISO 13335-2: Managing and Planning IT Security</P
></LI
><LI
><P
>         ISO 13335-3: Techniques for the Management of IT Security</P
></LI
><LI
><P
>         ISO 13335-4: Selection of Safeguards</P
></LI
><LI
><P
>         ISO 13335-5: Safeguards for External Connections</P
></LI
></UL
></P
><P
>[ISO 17799]
International Organization for Standardization (ISO).
December 2000.
Code of Practice for Information Security Management.
ISO/IEC 17799:2000.</P
><P
>[ISO 9000]
International Organization for Standardization (ISO).
2000.
Quality management systems - Fundamentals and vocabulary.
ISO 9000:2000.
See
<A
HREF="http://www.iso.ch/iso/en/iso9000-14000/iso9000/selection_use/iso9000family.html"
TARGET="_top"
>http://www.iso.ch/iso/en/iso9000-14000/iso9000/selection_use/iso9000family.html</A
></P
><P
>[ISO 9000]
International Organization for Standardization (ISO).
2000.
Quality management systems - Requirements
ISO 9001:2000</P
><P
>[Jones 2000]
Jones, Jennifer.
October 30, 2000.
``Banking on Privacy''.
InfoWorld, Volume 22, Issue 44.
San Mateo, CA: International Data Group (IDG).
pp. 1-12.</P
><P
>[Kelsey 1998]
Kelsey, J., B. Schneier, D. Wagner, and C. Hall.
March 1998.
"Cryptanalytic Attacks on Pseudorandom Number Generators."
Fast Software Encryption, Fifth International Workshop Proceedings
(March 1998), Springer-Verlag, 1998, pp. 168-188.
<A
HREF="http://www.counterpane.com/pseudorandom_number.html"
TARGET="_top"
>http://www.counterpane.com/pseudorandom_number.html</A
>.</P
><P
>[Kernighan 1988]
Kernighan, Brian W., and Dennis M. Ritchie.
1988.
<B
CLASS="EMPHASIS"
>The C Programming Language</B
>.
Second Edition.
Englewood Cliffs, NJ: Prentice-Hall.
ISBN 0-13-110362-8.</P
><P
>[Kim 1996]
Kim, Eugene Eric.
1996.
<B
CLASS="EMPHASIS"
>CGI Developer's Guide</B
>.
SAMS.net Publishing.
ISBN: 1-57521-087-8
<A
HREF="http://www.eekim.com/pubs/cgibook"
TARGET="_top"
>http://www.eekim.com/pubs/cgibook</A
></P
><P
>[Kuchling 2000].
Kuchling, A.M.
2000.
Restricted Execution HOWTO.
<A
HREF="http://www.python.org/doc/howto/rexec/rexec.html"
TARGET="_top"
>http://www.python.org/doc/howto/rexec/rexec.html</A
></P
><P
>[LSD 2001]
The Last Stage of Delirium.
July 4, 2001.
<B
CLASS="EMPHASIS"
>UNIX Assembly Codes Development
for Vulnerabilities Illustration Purposes.</B
>
<A
HREF="http://lsd-pl.net/papers.html#assembly"
TARGET="_top"
>http://lsd-pl.net/papers.html#assembly</A
>.</P
><P
>[McClure 1999]
McClure, Stuart, Joel Scambray, and George Kurtz.
1999.
<B
CLASS="EMPHASIS"
>Hacking Exposed: Network Security Secrets and Solutions</B
>.
Berkeley, CA: Osbourne/McGraw-Hill.
ISBN 0-07-212127-0.</P
><P
>[McKusick 1999]
McKusick, Marshall Kirk.
January 1999.
``Twenty Years of Berkeley Unix: From AT&#38;T-Owned to
Freely Redistributable.''
<B
CLASS="EMPHASIS"
>Open Sources: Voices from the Open Source Revolution</B
>.
<A
HREF="http://www.oreilly.com/catalog/opensources/book/kirkmck.html"
TARGET="_top"
>http://www.oreilly.com/catalog/opensources/book/kirkmck.html</A
>.</P
><P
>[McGraw 1999]
McGraw, Gary, and Edward W. Felten.
December 1998.
Twelve Rules for developing more secure Java code.
Javaworld.
<A
HREF="http://www.javaworld.com/javaworld/jw-12-1998/jw-12-securityrules.html"
TARGET="_top"
>http://www.javaworld.com/javaworld/jw-12-1998/jw-12-securityrules.html</A
>.</P
><P
>[McGraw 1999]
McGraw, Gary, and Edward W. Felten.
January 25, 1999.
Securing Java: Getting Down to Business with Mobile Code, 2nd Edition 
John Wiley &#38; Sons.
ISBN 047131952X.
<A
HREF="http://www.securingjava.com"
TARGET="_top"
>http://www.securingjava.com</A
>.</P
><P
>[McGraw 2000a]
McGraw, Gary and John Viega.
March 1, 2000.
Make Your Software Behave: Learning the Basics of Buffer Overflows.
<A
HREF="http://www-4.ibm.com/software/developer/library/overflows/index.html"
TARGET="_top"
>http://www-4.ibm.com/software/developer/library/overflows/index.html</A
>.</P
><P
>[McGraw 2000b]
McGraw, Gary and John Viega.
April 18, 2000.
Make Your Software Behave: Software strategies
In the absence of hardware,
you can devise a reasonably secure random number generator through software.
<A
HREF="http://www-106.ibm.com/developerworks/library/randomsoft/index.html?dwzone=security"
TARGET="_top"
>http://www-106.ibm.com/developerworks/library/randomsoft/index.html?dwzone=security</A
>.</P
><P
>[Miller 1995]
Miller, Barton P.,
David Koski, Cjin Pheow Lee, Vivekananda Maganty,
Ravi Murthy, Ajitkumar Natarajan, and Jeff Steidl.
1995.
Fuzz Revisited: A Re-examination of the Reliability of
UNIX Utilities and Services.
<A
HREF="ftp://grilled.cs.wisc.edu/technical_papers/fuzz-revisited.pdf"
TARGET="_top"
>ftp://grilled.cs.wisc.edu/technical_papers/fuzz-revisited.pdf</A
>.</P
><P
>[Miller 1999]
Miller, Todd C. and Theo de Raadt.
``strlcpy and strlcat -- Consistent, Safe, String Copy and Concatenation''
<B
CLASS="EMPHASIS"
>Proceedings of Usenix '99</B
>.
<A
HREF="http://www.usenix.org/events/usenix99/millert.html"
TARGET="_top"
>http://www.usenix.org/events/usenix99/millert.html</A
> and
<A
HREF="http://www.usenix.org/events/usenix99/full_papers/millert/PACKING_LIST"
TARGET="_top"
>http://www.usenix.org/events/usenix99/full_papers/millert/PACKING_LIST</A
></P
><P
>[Mudge 1995]
Mudge.
October 20, 1995.
<B
CLASS="EMPHASIS"
>How to write Buffer Overflows</B
>.
l0pht advisories.
<A
HREF="http://www.l0pht.com/advisories/bufero.html"
TARGET="_top"
>http://www.l0pht.com/advisories/bufero.html</A
>.</P
><P
>[Murhammer 1998]
Murhammer, Martin W., Orcun Atakan, Stefan Bretz,
Larry R. Pugh, Kazunari Suzuki, and David H. Wood.
October 1998.
TCP/IP Tutorial and Technical Overview
IBM International Technical Support Organization.
<A
HREF="http://www.redbooks.ibm.com/pubs/pdfs/redbooks/gg243376.pdf"
TARGET="_top"
>http://www.redbooks.ibm.com/pubs/pdfs/redbooks/gg243376.pdf</A
></P
><P
>[NCSA]
NCSA Secure Programming Guidelines.
<A
HREF="http://www.ncsa.uiuc.edu/General/Grid/ACES/security/programming"
TARGET="_top"
>http://www.ncsa.uiuc.edu/General/Grid/ACES/security/programming</A
>.</P
><P
>Neumann, Peter.
2000.
"Robust Nonproprietary Software."
Proceedings of the 2000 IEEE Symposium on Security and Privacy
(the ``Oakland Conference''), May 14-17, 2000, Berkeley, CA.
Los Alamitos, CA: IEEE Computer Society.
pp.122-123.</P
><P
>National Security Agency (NSA).
September 2000.
Information Assurance Technical Framework (IATF).
<A
HREF="http://www.iatf.net"
TARGET="_top"
>http://www.iatf.net</A
>.</P
><P
>[Open Group 1997]
The Open Group.
1997.
<B
CLASS="EMPHASIS"
>Single UNIX Specification, Version 2 (UNIX 98)</B
>.
<A
HREF="http://www.opengroup.org/online-pubs?DOC=007908799"
TARGET="_top"
>http://www.opengroup.org/online-pubs?DOC=007908799</A
>.</P
><P
>[OSI 1999].
Open Source Initiative.
1999.
<B
CLASS="EMPHASIS"
>The Open Source Definition</B
>.
<A
HREF="http://www.opensource.org/osd.html"
TARGET="_top"
>http://www.opensource.org/osd.html</A
>.</P
><P
>[Opplinger 1998]
Oppliger, Rolf.
1998.
Internet and Intranet Security.
Norwood, MA: Artech House.
ISBN 0-89006-829-1.</P
><P
>[Paulk 1993a]
Mark C. Paulk, Bill Curtis, Mary Beth Chrissis, and Charles V. Weber.
Capability Maturity Model for Software, Version 1.1.
Software Engineering Institute, CMU/SEI-93-TR-24.
DTIC Number ADA263403, February 1993. 
<A
HREF="http://www.sei.cmu.edu/activities/cmm/obtain.cmm.html"
TARGET="_top"
>http://www.sei.cmu.edu/activities/cmm/obtain.cmm.html</A
>.</P
><P
>[Paulk 1993b]
Mark C. Paulk, Charles V. Weber, Suzanne M. Garcia, Mary Beth Chrissis, and Marilyn W.  Bush.
Key Practices of the Capability Maturity Model, Version 1.1.
Software Engineering Institute.
CMU/SEI-93-TR-25, DTIC Number ADA263432, February 1993. </P
><P
>[Peteanu 2000]
Peteanu, Razvan.
July 18, 2000.
Best Practices for Secure Web Development.
<A
HREF="http://members.home.net/razvan.peteanu"
TARGET="_top"
>http://members.home.net/razvan.peteanu</A
></P
><P
>[Pfleeger 1997]
Pfleeger, Charles P.
1997.
<B
CLASS="EMPHASIS"
>Security in Computing.</B
>
Upper Saddle River, NJ: Prentice-Hall PTR.
ISBN 0-13-337486-6.</P
><P
>[Phillips 1995]
Phillips, Paul.
September 3, 1995.
<B
CLASS="EMPHASIS"
>Safe CGI Programming</B
>.
<A
HREF="http://www.go2net.com/people/paulp/cgi-security/safe-cgi.txt"
TARGET="_top"
>http://www.go2net.com/people/paulp/cgi-security/safe-cgi.txt</A
></P
><P
>[Quintero 1999]
Quintero, Federico Mena,
Miguel de Icaza, and Morten Welinder
GNOME Programming Guidelines
<A
HREF="http://developer.gnome.org/doc/guides/programming-guidelines/book1.html"
TARGET="_top"
>http://developer.gnome.org/doc/guides/programming-guidelines/book1.html</A
></P
><P
>[Raymond 1997]
Raymond, Eric.
1997.
<B
CLASS="EMPHASIS"
>The Cathedral and the Bazaar</B
>.
<A
HREF="http://www.tuxedo.org/~esr/writings/cathedral-bazaar"
TARGET="_top"
>http://www.tuxedo.org/~esr/writings/cathedral-bazaar</A
></P
><P
>[Raymond 1998]
Raymond, Eric.
April 1998.
<B
CLASS="EMPHASIS"
>Homesteading the Noosphere</B
>.
<A
HREF="http://www.tuxedo.org/~esr/writings/homesteading/homesteading.html"
TARGET="_top"
>http://www.tuxedo.org/~esr/writings/homesteading/homesteading.html</A
></P
><P
>[Ranum 1998]
Ranum, Marcus J.
1998.
<B
CLASS="EMPHASIS"
>Security-critical coding for programmers -
a C and UNIX-centric full-day tutorial</B
>.
<A
HREF="http://www.clark.net/pub/mjr/pubs/pdf/"
TARGET="_top"
>http://www.clark.net/pub/mjr/pubs/pdf/</A
>.</P
><P
>[RFC 822]
August 13, 1982
<B
CLASS="EMPHASIS"
>Standard for the Format of ARPA Internet Text Messages</B
>.
IETF RFC 822.
<A
HREF="http://www.ietf.org/rfc/rfc0822.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc0822.txt</A
>.</P
><P
>[rfp 1999]
rain.forest.puppy.
1999.
``Perl CGI problems''.
<B
CLASS="EMPHASIS"
>Phrack Magazine</B
>.
Issue 55, Article 07.
<A
HREF="http://www.phrack.com/search.phtml?view&#38;article=p55-7"
TARGET="_top"
>http://www.phrack.com/search.phtml?view&#38;article=p55-7</A
> or
<A
HREF="http://www.insecure.org/news/P55-07.txt"
TARGET="_top"
>http://www.insecure.org/news/P55-07.txt</A
>.</P
><P
>[Rijmen 2000]
Rijmen, Vincent.
"LinuxSecurity.com Speaks With AES Winner".
<A
HREF="http://www.linuxsecurity.com/feature_stories/interview-aes-3.html"
TARGET="_top"
>http://www.linuxsecurity.com/feature_stories/interview-aes-3.html</A
>.</P
><P
>[Rochkind 1985].
Rochkind, Marc J.
<B
CLASS="EMPHASIS"
>Advanced Unix Programming</B
>.
Englewood Cliffs, NJ: Prentice-Hall, Inc.
ISBN 0-13-011818-4.</P
><P
>[St. Laurent 2000]
St. Laurent, Simon.
February 2000.
<B
CLASS="EMPHASIS"
>XTech 2000 Conference Reports</B
>.
``When XML Gets Ugly''.
<A
HREF="http://www.xml.com/pub/2000/02/xtech/megginson.html"
TARGET="_top"
>http://www.xml.com/pub/2000/02/xtech/megginson.html</A
>.</P
><P
>[Saltzer 1974]
Saltzer, J.
July 1974.
``Protection and the Control of Information Sharing in MULTICS''.
<B
CLASS="EMPHASIS"
>Communications of the ACM</B
>.
v17 n7.
pp. 388-402.</P
><P
>[Saltzer 1975]
Saltzer, J., and M. Schroeder.
September 1975.
``The Protection of Information in Computing Systems''.
<B
CLASS="EMPHASIS"
>Proceedings of the IEEE</B
>.
v63 n9.
pp. 1278-1308.
<A
HREF="http://www.mediacity.com/~norm/CapTheory/ProtInf"
TARGET="_top"
>http://www.mediacity.com/~norm/CapTheory/ProtInf</A
>.
Summarized in [Pfleeger 1997, 286].</P
><P
>Schneider, Fred B.
2000.
"Open Source in Security: Visting the Bizarre."
Proceedings of the 2000 IEEE Symposium on Security and Privacy
(the ``Oakland Conference''), May 14-17, 2000, Berkeley, CA.
Los Alamitos, CA: IEEE Computer Society.
pp.126-127.</P
><P
>[Schneier 1996]
Schneier, Bruce.
1996.
<B
CLASS="EMPHASIS"
>Applied Cryptography, Second Edition:
Protocols, Algorithms, and Source Code in C</B
>.
New York: John Wiley and Sons.
ISBN 0-471-12845-7.</P
><P
>[Schneier 1998]
Schneier, Bruce and Mudge.
November 1998.
<B
CLASS="EMPHASIS"
>Cryptanalysis of Microsoft's Point-to-Point Tunneling Protocol (PPTP)</B
>
Proceedings of the 5th ACM Conference on Communications and Computer Security,
ACM Press.
<A
HREF="http://www.counterpane.com/pptp.html"
TARGET="_top"
>http://www.counterpane.com/pptp.html</A
>.</P
><P
>[Schneier 1999]
Schneier, Bruce.
September 15, 1999.
``Open Source and Security''.
<B
CLASS="EMPHASIS"
>Crypto-Gram</B
>.
Counterpane Internet Security, Inc.
<A
HREF="http://www.counterpane.com/crypto-gram-9909.html"
TARGET="_top"
>http://www.counterpane.com/crypto-gram-9909.html</A
></P
><P
>[Seifried 1999]
Seifried, Kurt.
October 9, 1999.
<B
CLASS="EMPHASIS"
>Linux Administrator's Security Guide</B
>.
<A
HREF="http://www.securityportal.com/lasg"
TARGET="_top"
>http://www.securityportal.com/lasg</A
>.</P
><P
>[Seifried 2001]
Seifried, Kurt.
September 2, 2001.
WWW Authentication
<A
HREF="http://www.seifried.org/security/www-auth/index.html"
TARGET="_top"
>http://www.seifried.org/security/www-auth/index.html</A
>.</P
><P
>[Shankland 2000]
Shankland, Stephen.
``Linux poses increasing threat to Windows 2000''.
CNET.
<A
HREF="http://news.cnet.com/news/0-1003-200-1549312.html"
TARGET="_top"
>http://news.cnet.com/news/0-1003-200-1549312.html</A
></P
><P
>[Shostack 1999]
Shostack, Adam.
June 1, 1999.
<B
CLASS="EMPHASIS"
>Security Code Review Guidelines</B
>.
<A
HREF="http://www.homeport.org/~adam/review.html"
TARGET="_top"
>http://www.homeport.org/~adam/review.html</A
>.</P
><P
>[Sibert 1996]
Sibert, W. Olin.
Malicious Data and Computer Security.
(NIST) NISSC '96.
<A
HREF="http://www.fish.com/security/maldata.html"
TARGET="_top"
>http://www.fish.com/security/maldata.html</A
></P
><P
>[Sitaker 1999]
Sitaker, Kragen.
Feb 26, 1999.
<B
CLASS="EMPHASIS"
>How to Find Security Holes</B
>
<A
HREF="http://www.pobox.com/~kragen/security-holes.html"
TARGET="_top"
>http://www.pobox.com/~kragen/security-holes.html</A
> and
<A
HREF="http://www.dnaco.net/~kragen/security-holes.html"
TARGET="_top"
>http://www.dnaco.net/~kragen/security-holes.html</A
></P
><P
>[SSE-CMM 1999]
SSE-CMM Project.
April 1999.
<B
CLASS="EMPHASIS"
>Systems Security Engineering Capability Maturity Model (SSE CMM)
Model Description Document</B
>.
Version 2.0.
<A
HREF="http://www.sse-cmm.org"
TARGET="_top"
>http://www.sse-cmm.org</A
></P
><P
>[Stallings 1996]
Stallings, William.
Practical Cryptography for Data Internetworks.
Los Alamitos, CA: IEEE Computer Society Press.
ISBN 0-8186-7140-8.</P
><P
>[Stein 1999].
Stein, Lincoln D.
September 13, 1999.
<B
CLASS="EMPHASIS"
>The World Wide Web Security FAQ</B
>.
Version 2.0.1
<A
HREF="http://www.w3.org/Security/Faq/www-security-faq.html"
TARGET="_top"
>http://www.w3.org/Security/Faq/www-security-faq.html</A
></P
><P
>[Swan 2001]
Swan, Daniel.
January 6, 2001. 
comp.os.linux.security FAQ.
Version 1.0.
<A
HREF="http://www.linuxsecurity.com/docs/colsfaq.html"
TARGET="_top"
>http://www.linuxsecurity.com/docs/colsfaq.html</A
>.</P
><P
>[Swanson 1996]
Swanson, Marianne, and Barbara Guttman.
September 1996.
Generally Accepted Principles and Practices for Securing
Information Technology Systems.
NIST Computer Security Special Publication (SP) 800-14.
<A
HREF="http://csrc.nist.gov/publications/nistpubs/index.html"
TARGET="_top"
>http://csrc.nist.gov/publications/nistpubs/index.html</A
>.</P
><P
>[Thompson 1974]
Thompson, K. and D.M. Richie.
July 1974.
``The UNIX Time-Sharing System''.
<B
CLASS="EMPHASIS"
>Communications of the ACM</B
>
Vol. 17, No. 7.
pp. 365-375.</P
><P
>[Torvalds 1999]
Torvalds, Linus.
February 1999.
``The Story of the Linux Kernel''.
<B
CLASS="EMPHASIS"
>Open Sources: Voices from the Open Source Revolution</B
>.
Edited by Chris Dibona, Mark Stone, and Sam Ockman.
O'Reilly and Associates.
ISBN 1565925823.
<A
HREF="http://www.oreilly.com/catalog/opensources/book/linus.html"
TARGET="_top"
>http://www.oreilly.com/catalog/opensources/book/linus.html</A
></P
><P
>[TruSecure 2001]
TruSecure.
August 2001.
Open Source Security: A Look at the Security Benefits of Source Code Access.
<A
HREF="http://www.trusecure.com/html/tspub/whitepapers/open_source_security5.pdf"
TARGET="_top"
>http://www.trusecure.com/html/tspub/whitepapers/open_source_security5.pdf</A
></P
><P
>[Unknown]
<B
CLASS="EMPHASIS"
>SETUID(7)</B
>
<A
HREF="http://www.homeport.org/~adam/setuid.7.html"
TARGET="_top"
>http://www.homeport.org/~adam/setuid.7.html</A
>.</P
><P
>[Van Biesbrouck 1996]
Van Biesbrouck, Michael.
April 19, 1996.
<A
HREF="http://www.csclub.uwaterloo.ca/u/mlvanbie/cgisec"
TARGET="_top"
>http://www.csclub.uwaterloo.ca/u/mlvanbie/cgisec</A
>.</P
><P
>[van Oorschot 1994]
van Oorschot, P. and M. Wiener.
November 1994.
``Parallel Collision Search with Applications to Hash Functions
and Discrete Logarithms.''
Proceedings of ACM Conference on Computer and Communications Security.</P
><P
>[Venema 1996]
Venema, Wietse.
1996.
Murphy's law and computer security.
<A
HREF="http://www.fish.com/security/murphy.html"
TARGET="_top"
>http://www.fish.com/security/murphy.html</A
></P
><P
>[Watters 1996]
Watters, Arron, Guido van Rossum, James C. Ahlstrom.
1996.
Internet Programming with Python.
NY, NY: Henry Hold and Company, Inc.</P
><P
>[Witten 2001]
September/October 2001.
Witten, Brian, Carl Landwehr, and Michael Caloyannides.
``Does Open Source Improve System Security?''
IEEE Software.
pp. 57-61.
<A
HREF="http://www.computer.org/software"
TARGET="_top"
>http://www.computer.org/software</A
>&#13;</P
><P
>[Wood 1985]
Wood, Patrick H. and Stephen G. Kochan.
1985.
<B
CLASS="EMPHASIS"
>Unix System Security</B
>.
Indianapolis, Indiana: Hayden Books.
ISBN 0-8104-6267-2.</P
><P
>[Wreski 1998]
Wreski, Dave.
August 22, 1998.
<B
CLASS="EMPHASIS"
>Linux Security Administrator's Guide</B
>.
Version 0.98.
<A
HREF="http://www.nic.com/~dave/SecurityAdminGuide/index.html"
TARGET="_top"
>http://www.nic.com/~dave/SecurityAdminGuide/index.html</A
></P
><P
>[Yoder 1998]
Yoder, Joseph and Jeffrey Barcalow.
1998.
Architectural Patterns for Enabling Application Security.
PLoP '97
<A
HREF="http://st-www.cs.uiuc.edu/~hanmer/PLoP-97/Proceedings/yoder.pdf"
TARGET="_top"
>http://st-www.cs.uiuc.edu/~hanmer/PLoP-97/Proceedings/yoder.pdf</A
></P
><P
>[Zalewski 2001]
Zalewski, Michael.
May 16-17, 2001.
Delivering Signals for Fun and Profit:
Understanding, exploiting and preventing signal-handling related
vulnerabilities.
Bindview Corporation.
<A
HREF="http://razor.bindview.com/publish/papers/signals.txt"
TARGET="_top"
>http://razor.bindview.com/publish/papers/signals.txt</A
></P
><P
>[Zoebelein 1999]
Zoebelein, Hans U.
April 1999.
The Internet Operating System Counter.
<A
HREF="http://www.leb.net/hzo/ioscount"
TARGET="_top"
>http://www.leb.net/hzo/ioscount</A
>.</P
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="DOCUMENT-HISTORY"
>&#48512;&#47197; A. 책 발표 기록</A
></H1
><P
>&#13; 다음은 이 책 개발에 있어 약간의 주요 사건을 가장 최근부터 설명한
것이다:

<P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>2001-01-01 David A. Wheeler</DT
><DD
><P
>버전 2.70 이 발표되었는데 교차 사이트의 악의있는 컨텐트, HTML/URI 
필터링 및 임시 파일 다루기에 관한 논의가 상당히 확장된 것과 같이 
상당한 양의 추가적인 자료가 추가되었다.</P
></DD
><DT
>2000-05-24 David A. Wheeler</DT
><DD
><P
>GNU 의 GFDL 라이센스로 변경되었으며 더욱 많은 내용이 추가되었다.</P
></DD
><DT
>2000-04-21 David A. Wheeler</DT
><DD
><P
>2000년 4월 21일 버전 2.00 이 발표되었는데 문서 내부 포맷이 Linuxdoc 
DTD 에서 DocBook DTD 로 변경되었다. 이 변환에 도움을 준 Jorge Godoy 
에게 감사드린다.</P
></DD
><DT
>2000-04-04 David A. Wheeler</DT
><DD
><P
>버전 1.60 이 발표되었으며 리눅스와 유닉스 둘 다를 다루기 위해 변경되었다. 
지침들의 대부분이 둘 다를 다루고 많은/대부분의 애플리케이션 개발자들이 
그들의 애플리케이션을 두 플랫폼 모두에서 작동시키길 원하기 때문에 이는 
합당한 것이었다.</P
></DD
><DT
>2000-02-09 David A. Wheeler</DT
><DD
><P
>문서가 리눅스 문서화 프로젝트 (Linux Documentation Project, LDP) 의 
부분임이 언급되었다.</P
></DD
><DT
>1999-11-29 David A. Wheeler</DT
><DD
><P
>최초 버전 1.0 이 완성되어 대중에게 발표되었다.</P
></DD
></DL
></DIV
></P
><P
>변경 사항에 대한 더욱 세부적인 설명은 ``ChangeLog" 파일에서 온라인으로 
얻을 수 있음을 주목해라.</P
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="ACKNOWLEDGEMENTS"
>&#48512;&#47197; B. 감사의 글 </A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>As iron sharpens iron, so one man sharpens another.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Proverbs 27:17 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><P
>My thanks to the following people who kept me honest by sending me emails
noting errors, suggesting areas to cover, asking questions, and so on.
Where email addresses are included, they've been
shrouded by prepending my ``thanks.'' so bulk emailers
won't easily get these addresses; inclusion of people in this list is
<B
CLASS="EMPHASIS"
>not</B
> an authorization to send
unsolicited bulk email to them.

<P
></P
><UL
><LI
><P
>Neil Brown (thanks.neilb@cse.unsw.edu.au)</P
></LI
><LI
><P
>Martin Douda (thanks.mad@students.zcu.cz)</P
></LI
><LI
><P
>Jorge Godoy</P
></LI
><LI
><P
>Scott Ingram (thanks.scott@silver.jhuapl.edu)</P
></LI
><LI
><P
>Michael Kerrisk</P
></LI
><LI
><P
>Doug Kilpatrick</P
></LI
><LI
><P
>John Levon (moz@compsoc.man.ac.uk)</P
></LI
><LI
><P
>Ryan McCabe (thanks.odin@numb.org)</P
></LI
><LI
><P
>Paul Millar (thanks.paulm@astro.gla.ac.uk)</P
></LI
><LI
><P
>Chuck Phillips (thanks.cdp@peakpeak.com)</P
></LI
><LI
><P
>Martin Pool (thanks.mbp@humbug.org.au)</P
></LI
><LI
><P
>Eric S. Raymond (thanks.esr@snark.thyrsus.com)</P
></LI
><LI
><P
>Marc Welz</P
></LI
><LI
><P
>Eric Werme (thanks.werme@alpha.zk3.dec.com)</P
></LI
></UL
>&#13;</P
><P
>If you want to be on this list, please send me a constructive suggestion at
<A
HREF="mailto:dwheeler@dwheeler.com"
TARGET="_top"
>dwheeler@dwheeler.com</A
>.
If you send me a constructive suggestion, but do <B
CLASS="EMPHASIS"
>not</B
> want credit,
please let me know that when you send your suggestion, comment, or
criticism; normally I expect that people want credit, and I want to give
them that credit.
My current process is to add contributor names to this list in the document,
with more detailed explanation of their comment in the ChangeLog for
this document (available on-line).
Note that although these people have sent in ideas, the actual text is my own,
so don't blame them for any errors that may remain.
Instead, please send me another constructive suggestion.</P
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="ABOUT-LICENSE"
>&#48512;&#47197; C. 문서의 라이센스 </A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>A copy of the text of the edict was to be issued as law
in every province and made known to the people of every
nationality so they would be ready for that day.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Esther 3:14 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><P
>This document is Copyright (C) 1999-2000 David A. Wheeler.
Permission is granted to copy, distribute and/or modify
this document under the terms of the GNU Free Documentation License (FDL),
Version 1.1 or any later version published by the Free Software Foundation;
with the invariant sections being ``About the Author'',
with no Front-Cover Texts, and no Back-Cover texts.
A copy of the license is included below in
<A
HREF="#FDL"
>&#48512;&#47197; D</A
>.</P
><P
>These terms do permit mirroring by other web sites,
but be <B
CLASS="EMPHASIS"
>sure</B
> to do the following:

<P
></P
><UL
><LI
><P
>make sure your mirrors automatically get upgrades from the master site,</P
></LI
><LI
><P
>clearly show the location of the master site
(<A
HREF="http://www.dwheeler.com/secure-programs"
TARGET="_top"
>http://www.dwheeler.com/secure-programs</A
>), with a hypertext link
to the master site, and</P
></LI
><LI
><P
>give me (David A. Wheeler) credit as the author.</P
></LI
></UL
>&#13;</P
><P
>The first two points primarily protect me from repeatedly hearing about
obsolete bugs.
I do not want to hear about bugs I fixed a year ago, just because you
are not properly mirroring the document.
By linking to the master site,
users can check and see if your mirror is up-to-date.
I'm sensitive to the problems of sites which have very
strong security requirements and therefore cannot risk normal
connections to the Internet; if that describes your situation,
at least try to meet the other points
and try to occasionally sneakernet updates into your environment.</P
><P
>By this license, you may modify the document,
but you can't claim that what you didn't write is yours (i.e., plagiarism)
nor can you pretend that a modified version is identical to
the original work.
Modifying the work does not transfer copyright of the entire work to you;
this is not a ``public domain'' work in terms of copyright law.
See the license in <A
HREF="#FDL"
>&#48512;&#47197; D</A
> for details.
If you have questions about what the license allows, please contact me.
In most cases, it's better if you send your changes to the master
integrator (currently David A. Wheeler), so that your changes will be
integrated with everyone else's changes into the master copy.</P
><P
>I am not a lawyer, nevertheless, it's my position as an author
and software developer that any code fragments
not explicitly marked otherwise are so small that their use fits under
the ``fair use'' doctrine in copyright law.
In other words, unless marked otherwise, you can use the code fragments
without any restriction at all.
Copyright law does not permit copyrighting absurdly small components
of a work
(e.g., ``I own all rights to B-flat and B-flat minor chords''), and
the fragments not marked otherwise are of the same kind of minuscule
size when compared to real programs.
I've done my best to give credit for specific pieces of code
written by others.
Some of you may still be concerned about the legal status of this code,
and I want make sure that it's clear
that you can use this code in your software.
Therefore, code fragments included directly in this document not otherwise
marked have also been released by me under the terms of the ``MIT license'',
to ensure you that there's no serious legal encumbrance:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  Source code in this book not otherwise identified is
  Copyright (c) 1999-2001 David A. Wheeler.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of the source code in this book not
  otherwise identified (the "Software"), to deal in the
  Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute,
  sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
  PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="FDL"
>&#48512;&#47197; D. GNU Free Documentation License</A
></H1
><P
>    Version 1.1, March 2000
  </P
><P
>    Copyright  2000 
    <P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Free&nbsp;Software&nbsp;Foundation,&nbsp;Inc.&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
CLASS="STREET"
>59 Temple Place, Suite 330</SPAN
>,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
CLASS="CITY"
>Boston</SPAN
>,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
CLASS="STATE"
>MA</SPAN
>&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
CLASS="POSTCODE"
>02111-1307</SPAN
>&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
CLASS="COUNTRY"
>USA</SPAN
><br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
> 
    Everyone is permitted to copy and distribute verbatim copies of this license
    document, but changing it is not allowed.
  </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="FDL-PREAMBLE"
></A
>0. PREAMBLE</DT
><DD
><P
>	  The purpose of this License is to make a manual, textbook, or other
	  written document "free" in the sense of freedom: to assure everyone
	  the effective freedom to copy and redistribute it, with or without
	  modifying it, either commercially or noncommercially. Secondarily,
	  this License preserves for the author and publisher a way to get
	  credit for their work, while not being considered responsible for
	  modifications made by others.
	</P
><P
>	  This License is a kind of "copyleft", which means that derivative
	  works of the document must themselves be free in the same sense. It
	  complements the GNU General Public License, which is a copyleft
	  license designed for free software.
	</P
><P
>	  We have designed this License in order to use it for manuals for free
	  software, because free software needs free documentation: a free
	  program should come with manuals providing the same freedoms that the
	  software does. But this License is not limited to software manuals; it
	  can be used for any textual work, regardless of subject matter or
	  whether it is published as a printed book. We recommend this License
	  principally for works whose purpose is instruction or reference.
	</P
></DD
><DT
><A
NAME="FDL-SECTION1"
></A
>1. APPLICABILITY AND DEFINITIONS</DT
><DD
><P
>	  This License applies to any manual or other work that contains a
	  notice placed by the copyright holder saying it can be distributed
	  under the terms of this License. The <A
HREF="#FDL-DOCUMENT"
>"Document" </A
>, below, refers to any such
	  manual or work. Any member of the public is a licensee, and is
	  addressed as "you".
	</P
><P
>	  A <A
HREF="#FDL-MODIFIED"
>"Modified Version"</A
> of the
	  Document means any work containing the Document or a portion of it,
	  either copied verbatim, or with modifications and/or translated into
	  another language.
	</P
><P
>	  A <A
HREF="#FDL-SECONDARY"
>"Secondary Section"</A
> is a named
	  appendix or a front-matter section of the <A
HREF="#FDL-DOCUMENT"
>Document</A
> that deals exclusively with the
	  relationship of the publishers or authors of the <A
HREF="#FDL-DOCUMENT"
> Document</A
> to the <A
HREF="#FDL-DOCUMENT"
> Document's</A
> overall subject (or to
	  related matters) and contains nothing that could fall directly within
	  that overall subject. (For example, if the <A
HREF="#FDL-DOCUMENT"
>Document</A
> is in part a textbook of
	  mathematics, a <A
HREF="#FDL-SECONDARY"
>Secondary Section</A
>
	  may not explain any mathematics.)  The relationship could be a matter
	  of historical connection with the subject or with related matters, or
	  of legal, commercial, philosophical, ethical or political position
	  regarding them.
	</P
><P
>	  The <A
HREF="#FDL-INVARIANT"
>"Invariant Sections"</A
> are
	  certain <A
HREF="#FDL-SECONDARY"
> Secondary Sections</A
> whose
	  titles are designated, as being those of <A
HREF="#FDL-INVARIANT"
>Invariant Sections</A
>, in the notice that
	  says that the <A
HREF="#FDL-DOCUMENT"
>Document</A
> is released
	  under this License.
	</P
><P
>	  The <A
HREF="#FDL-COVER-TEXTS"
>"Cover Texts"</A
> are certain
	  short passages of text that are listed, as <A
HREF="#FDL-COVER-TEXTS"
>Front-Cover Texts</A
> or <A
HREF="#FDL-COVER-TEXTS"
>Back-Cover Texts</A
>, in the notice that
	  says that the <A
HREF="#FDL-DOCUMENT"
>Document</A
> is released
	  under this License.
	</P
><P
>	  A <A
HREF="#FDL-TRANSPARENT"
>"Transparent"</A
> copy of the
	  <A
HREF="#FDL-DOCUMENT"
> Document</A
> means a machine-readable
	  copy, represented in a format whose specification is available to the
	  general public, whose contents can be viewed and edited directly and
	  straightforwardly with generic text editors or (for images composed of
	  pixels) generic paint programs or (for drawings) some widely available
	  drawing editor, and that is suitable for input to text formatters or
	  for automatic translation to a variety of formats suitable for input
	  to text formatters. A copy made in an otherwise <A
HREF="#FDL-TRANSPARENT"
> Transparent</A
> file format whose markup
	  has been designed to thwart or discourage subsequent modification by
	  readers is not <A
HREF="#FDL-TRANSPARENT"
>Transparent</A
>.  A
	  copy that is not <A
HREF="#FDL-TRANSPARENT"
>"Transparent"</A
>
	  is called "Opaque".
	</P
><P
>	  Examples of suitable formats for <A
HREF="#FDL-TRANSPARENT"
>Transparent</A
> copies include plain
	  ASCII without markup, Texinfo input format, LaTeX input format, SGML
	  or XML using a publicly available DTD, and standard-conforming simple
	  HTML designed for human modification. Opaque formats include
	  PostScript, PDF, proprietary formats that can be read and edited only
	  by proprietary word processors, SGML or XML for which the DTD and/or
	  processing tools are not generally available, and the
	  machine-generated HTML produced by some word processors for output
	  purposes only.
	</P
><P
>	  The <A
HREF="#FDL-TITLE-PAGE"
>"Title Page"</A
> means, for a
	  printed book, the title page itself, plus such following pages as are
	  needed to hold, legibly, the material this License requires to appear
	  in the title page. For works in formats which do not have any title
	  page as such, <A
HREF="#FDL-TITLE-PAGE"
> "Title Page"</A
>
	  means the text near the most prominent appearance of the work's title,
	  preceding the beginning of the body of the text.
	</P
></DD
><DT
><A
NAME="FDL-SECTION2"
></A
>2. VERBATIM COPYING</DT
><DD
><P
>	  You may copy and distribute the <A
HREF="#FDL-DOCUMENT"
>Document</A
> in any medium, either
	  commercially or noncommercially, provided that this License, the
	  copyright notices, and the license notice saying this License applies
	  to the <A
HREF="#FDL-DOCUMENT"
>Document</A
> are reproduced in
	  all copies, and that you add no other conditions whatsoever to those
	  of this License. You may not use technical measures to obstruct or
	  control the reading or further copying of the copies you make or
	  distribute. However, you may accept compensation in exchange for
	  copies. If you distribute a large enough number of copies you must
	  also follow the conditions in <A
HREF="#FDL-SECTION3"
>section
	  3</A
>.
	</P
><P
>	  You may also lend copies, under the same conditions stated above, and
	  you may publicly display copies.
	</P
></DD
><DT
><A
NAME="FDL-SECTION3"
></A
>3. COPYING IN QUANTITY</DT
><DD
><P
>	  If you publish printed copies of the <A
HREF="#FDL-DOCUMENT"
>Document</A
> numbering more than 100, and
	  the <A
HREF="#FDL-DOCUMENT"
>Document's</A
> license notice
	  requires <A
HREF="#FDL-COVER-TEXTS"
>Cover Texts</A
>, you must
	  enclose the copies in covers that carry, clearly and legibly, all
	  these <A
HREF="#FDL-COVER-TEXTS"
>Cover Texts</A
>:  Front-Cover
	  Texts on the front cover, and Back-Cover Texts on the back cover. Both
	  covers must also clearly and legibly identify you as the publisher of
	  these copies. The front cover must present the full title with all
	  words of the title equally prominent and visible. You may add other
	  material on the covers in addition. Copying with changes limited to
	  the covers, as long as they preserve the title of the <A
HREF="#FDL-DOCUMENT"
>Document</A
> and satisfy these conditions,
	  can be treated as verbatim copying in other respects.
	</P
><P
>	  If the required texts for either cover are too voluminous to fit
	  legibly, you should put the first ones listed (as many as fit
	  reasonably) on the actual cover, and continue the rest onto adjacent
	  pages.
	</P
><P
>	  If you publish or distribute <A
HREF="#FDL-TRANSPARENT"
>Opaque</A
> copies of the <A
HREF="#FDL-DOCUMENT"
>Document</A
> numbering more than 100, you
	  must either include a machine-readable <A
HREF="#FDL-TRANSPARENT"
>Transparent</A
> copy along with each
	  <A
HREF="#FDL-TRANSPARENT"
>Opaque</A
> copy, or state in or
	  with each <A
HREF="#FDL-TRANSPARENT"
>Opaque</A
> copy a
	  publicly-accessible computer-network location containing a complete
	  <A
HREF="#FDL-TRANSPARENT"
> Transparent</A
> copy of the <A
HREF="#FDL-DOCUMENT"
>Document</A
>, free of added material, which
	  the general network-using public has access to download anonymously at
	  no charge using public-standard network protocols. If you use the
	  latter option, you must take reasonably prudent steps, when you begin
	  distribution of <A
HREF="#FDL-TRANSPARENT"
>Opaque</A
> copies
	  in quantity, to ensure that this <A
HREF="#FDL-TRANSPARENT"
>Transparent</A
> copy will remain thus
	  accessible at the stated location until at least one year after the
	  last time you distribute an <A
HREF="#FDL-TRANSPARENT"
>Opaque</A
> copy (directly or through your
	  agents or retailers) of that edition to the public.
	</P
><P
>	  It is requested, but not required, that you contact the authors of the
	  <A
HREF="#FDL-DOCUMENT"
>Document</A
> well before
	  redistributing any large number of copies, to give them a chance to
	  provide you with an updated version of the <A
HREF="#FDL-DOCUMENT"
>Document</A
>.
	</P
></DD
><DT
><A
NAME="FDL-SECTION4"
></A
>4. MODIFICATIONS</DT
><DD
><P
>	  You may copy and distribute a <A
HREF="#FDL-MODIFIED"
>Modified
	  Version</A
> of the <A
HREF="#FDL-DOCUMENT"
>Document</A
>
	  under the conditions of sections <A
HREF="#FDL-SECTION2"
>2</A
>
	  and <A
HREF="#FDL-SECTION3"
>3</A
> above, provided that you
	  release the <A
HREF="#FDL-MODIFIED"
>Modified Version</A
> under
	  precisely this License, with the <A
HREF="#FDL-MODIFIED"
>Modified
	  Version</A
> filling the role of the <A
HREF="#FDL-DOCUMENT"
>Document</A
>, thus licensing distribution
	  and modification of the <A
HREF="#FDL-MODIFIED"
>Modified
	  Version</A
> to whoever possesses a copy of it. In addition, you
	  must do these things in the <A
HREF="#FDL-MODIFIED"
>Modified
	  Version</A
>:
	</P
><P
></P
><OL
TYPE="A"
><LI
><P
>		Use in the <A
HREF="#FDL-TITLE-PAGE"
>Title Page</A
> (and
		on the covers, if any) a title distinct from that of the <A
HREF="#FDL-DOCUMENT"
>Document</A
>, and from those of
		previous versions (which should, if there were any, be listed in
		the History section of the <A
HREF="#FDL-DOCUMENT"
>Document</A
>). You may use the same
		title as a previous version if the original publisher of that
		version gives permission.
	      </P
></LI
><LI
><P
>		List on the <A
HREF="#FDL-TITLE-PAGE"
>Title Page</A
>, as
		authors, one or more persons or entities responsible for
		authorship of the modifications in the <A
HREF="#FDL-MODIFIED"
>Modified Version</A
>, together with at
		least five of the principal authors of the <A
HREF="#FDL-DOCUMENT"
>Document</A
> (all of its principal
		authors, if it has less than five).
	      </P
></LI
><LI
><P
>		State on the <A
HREF="#FDL-TITLE-PAGE"
>Title Page</A
>
		the name of the publisher of the <A
HREF="#FDL-MODIFIED"
>Modified Version</A
>, as the
		publisher.
	      </P
></LI
><LI
><P
>		Preserve all the copyright notices of the <A
HREF="#FDL-DOCUMENT"
>Document</A
>.
	      </P
></LI
><LI
><P
>		Add an appropriate copyright notice for your modifications
		adjacent to the other copyright notices.
	      </P
></LI
><LI
><P
>		Include, immediately after the copyright notices, a license
		notice giving the public permission to use the <A
HREF="#FDL-MODIFIED"
>Modified Version</A
> under the terms
		of this License, in the form shown in the Addendum below.
	      </P
></LI
><LI
><P
>		Preserve in that license notice the full lists of <A
HREF="#FDL-INVARIANT"
> Invariant Sections</A
> and required
		<A
HREF="#FDL-COVER-TEXTS"
>Cover Texts</A
> given in the
		<A
HREF="#FDL-DOCUMENT"
>Document's</A
> license notice.
	      </P
></LI
><LI
><P
>		Include an unaltered copy of this License.
	      </P
></LI
><LI
><P
>		Preserve the section entitled "History", and its title, and add
		to it an item stating at least the title, year, new authors, and
		publisher of the <A
HREF="#FDL-MODIFIED"
>Modified Version
		</A
>as given on the <A
HREF="#FDL-TITLE-PAGE"
>Title
		Page</A
>.  If there is no section entitled "History" in the
		<A
HREF="#FDL-DOCUMENT"
>Document</A
>, create one stating
		the title, year, authors, and publisher of the <A
HREF="#FDL-DOCUMENT"
>Document</A
> as given on its <A
HREF="#FDL-TITLE-PAGE"
>Title Page</A
>, then add an item
		describing the <A
HREF="#FDL-MODIFIED"
>Modified
		Version</A
> as stated in the previous sentence.
	      </P
></LI
><LI
><P
>		Preserve the network location, if any, given in the <A
HREF="#FDL-DOCUMENT"
>Document</A
> for public access to a
		<A
HREF="#FDL-TRANSPARENT"
>Transparent</A
> copy of the
		<A
HREF="#FDL-DOCUMENT"
>Document</A
>, and likewise the
		network locations given in the <A
HREF="#FDL-DOCUMENT"
>Document</A
> for previous versions it
		was based on. These may be placed in the "History" section. You
		may omit a network location for a work that was published at
		least four years before the <A
HREF="#FDL-DOCUMENT"
>Document</A
> itself, or if the
		original publisher of the version it refers to gives permission.
	      </P
></LI
><LI
><P
>		In any section entitled "Acknowledgements" or "Dedications",
		preserve the section's title, and preserve in the section all
		the substance and tone of each of the contributor
		acknowledgements and/or dedications given therein.
	      </P
></LI
><LI
><P
>		Preserve all the <A
HREF="#FDL-INVARIANT"
>Invariant
		Sections</A
> of the <A
HREF="#FDL-DOCUMENT"
>Document</A
>, unaltered in their text
		and in their titles.  Section numbers or the equivalent are not
		considered part of the section titles.
	      </P
></LI
><LI
><P
>		Delete any section entitled "Endorsements". Such a section may
		not be included in the <A
HREF="#FDL-MODIFIED"
>Modified
		Version</A
>.
	      </P
></LI
><LI
><P
>		Do not retitle any existing section as "Endorsements" or to
		conflict in title with any <A
HREF="#FDL-INVARIANT"
>Invariant Section</A
>.
	      </P
></LI
></OL
><P
>	  If the <A
HREF="#FDL-MODIFIED"
>Modified Version</A
> includes
	  new front-matter sections or appendices that qualify as <A
HREF="#FDL-SECONDARY"
>Secondary Sections</A
> and contain no
	  material copied from the Document, you may at your option designate
	  some or all of these sections as invariant. To do this, add their
	  titles to the list of <A
HREF="#FDL-INVARIANT"
>Invariant
	  Sections</A
> in the <A
HREF="#FDL-MODIFIED"
>Modified
	  Version's</A
> license notice. These titles must be distinct from
	  any other section titles.
	</P
><P
>	  You may add a section entitled "Endorsements", provided it contains
	  nothing but endorsements of your <A
HREF="#FDL-MODIFIED"
>Modified
	  Version</A
> by various parties--for example, statements of peer
	  review or that the text has been approved by an organization as the
	  authoritative definition of a standard.
	</P
><P
>	  You may add a passage of up to five words as a <A
HREF="#FDL-COVER-TEXTS"
>Front-Cover Text</A
>, and a passage of up
	  to 25 words as a <A
HREF="#FDL-COVER-TEXTS"
>Back-Cover
	  Text</A
>, to the end of the list of <A
HREF="#FDL-COVER-TEXTS"
>Cover Texts</A
> in the <A
HREF="#FDL-MODIFIED"
>Modified Version</A
>.  Only one passage of
	  <A
HREF="#FDL-COVER-TEXTS"
>Front-Cover Text</A
> and one of
	  <A
HREF="#FDL-COVER-TEXTS"
>Back-Cover Text</A
> may be added by
	  (or through arrangements made by) any one entity. If the <A
HREF="#FDL-DOCUMENT"
>Document</A
> already includes a cover text
	  for the same cover, previously added by you or by arrangement made by
	  the same entity you are acting on behalf of, you may not add another;
	  but you may replace the old one, on explicit permission from the
	  previous publisher that added the old one.
	</P
><P
>	  The author(s) and publisher(s) of the <A
HREF="#FDL-DOCUMENT"
>Document</A
> do not by this License give
	  permission to use their names for publicity for or to assert or imply
	  endorsement of any <A
HREF="#FDL-MODIFIED"
>Modified Version
	  </A
>.
	</P
></DD
><DT
><A
NAME="FDL-SECTION5"
></A
>5. COMBINING DOCUMENTS</DT
><DD
><P
>	  You may combine the <A
HREF="#FDL-DOCUMENT"
>Document</A
> with
	  other documents released under this License, under the terms defined
	  in <A
HREF="#FDL-SECTION4"
>section 4</A
> above for modified
	  versions, provided that you include in the combination all of the
	  <A
HREF="#FDL-INVARIANT"
>Invariant Sections</A
> of all of the
	  original documents, unmodified, and list them all as <A
HREF="#FDL-INVARIANT"
>Invariant Sections</A
> of your combined
	  work in its license notice.
	</P
><P
>	  The combined work need only contain one copy of this License, and
	  multiple identical <A
HREF="#FDL-INVARIANT"
>Invariant
	  Sections</A
> may be replaced with a single copy. If there are
	  multiple <A
HREF="#FDL-INVARIANT"
> Invariant Sections</A
> with
	  the same name but different contents, make the title of each such
	  section unique by adding at the end of it, in parentheses, the name of
	  the original author or publisher of that section if known, or else a
	  unique number. Make the same adjustment to the section titles in the
	  list of <A
HREF="#FDL-INVARIANT"
>Invariant Sections</A
> in the
	  license notice of the combined work.
	</P
><P
>	  In the combination, you must combine any sections entitled "History"
	  in the various original documents, forming one section entitled
	  "History"; likewise combine any sections entitled "Acknowledgements",
	  and any sections entitled "Dedications". You must delete all sections
	  entitled "Endorsements."
	</P
></DD
><DT
><A
NAME="FDL-SECTION6"
></A
>6. COLLECTIONS OF DOCUMENTS</DT
><DD
><P
>	  You may make a collection consisting of the <A
HREF="#FDL-DOCUMENT"
>Document</A
> and other documents released
	  under this License, and replace the individual copies of this License
	  in the various documents with a single copy that is included in the
	  collection, provided that you follow the rules of this License for
	  verbatim copying of each of the documents in all other respects.
	</P
><P
>	  You may extract a single document from such a collection, and
	  distribute it individually under this License, provided you insert a
	  copy of this License into the extracted document, and follow this
	  License in all other respects regarding verbatim copying of that
	  document.
	</P
></DD
><DT
><A
NAME="FDL-SECTION7"
></A
>7. AGGREGATION WITH INDEPENDENT WORKS</DT
><DD
><P
>	  A compilation of the <A
HREF="#FDL-DOCUMENT"
>Document</A
> or
	  its derivatives with other separate and independent documents or
	  works, in or on a volume of a storage or distribution medium, does not
	  as a whole count as a <A
HREF="#FDL-MODIFIED"
>Modified
	  Version</A
> of the <A
HREF="#FDL-DOCUMENT"
> Document</A
>,
	  provided no compilation copyright is claimed for the compilation.
	  Such a compilation is called an "aggregate", and this License does not
	  apply to the other self-contained works thus compiled with the <A
HREF="#FDL-DOCUMENT"
>Document</A
> , on account of their being
	  thus compiled, if they are not themselves derivative works of the
	  <A
HREF="#FDL-DOCUMENT"
>Document</A
>.  If the <A
HREF="#FDL-COVER-TEXTS"
>Cover Text</A
> requirement of <A
HREF="#FDL-SECTION3"
>section 3</A
> is applicable to these copies
	  of the <A
HREF="#FDL-DOCUMENT"
>Document</A
>, then if the <A
HREF="#FDL-DOCUMENT"
>Document</A
> is less than one quarter of the
	  entire aggregate, the <A
HREF="#FDL-DOCUMENT"
>Document's</A
>
	  <A
HREF="#FDL-COVER-TEXTS"
>Cover Texts</A
> may be placed on
	  covers that surround only the <A
HREF="#FDL-DOCUMENT"
>Document</A
> within the aggregate. Otherwise
	  they must appear on covers around the whole aggregate.
	</P
></DD
><DT
><A
NAME="FDL-SECTION8"
></A
>8. TRANSLATION</DT
><DD
><P
>	  Translation is considered a kind of modification, so you may
	  distribute translations of the <A
HREF="#FDL-DOCUMENT"
>Document</A
> under the terms of <A
HREF="#FDL-SECTION4"
>section 4</A
>. Replacing <A
HREF="#FDL-INVARIANT"
> Invariant Sections</A
> with translations
	  requires special permission from their copyright holders, but you may
	  include translations of some or all <A
HREF="#FDL-INVARIANT"
>Invariant Sections</A
> in addition to the
	  original versions of these <A
HREF="#FDL-INVARIANT"
>Invariant
	  Sections</A
>. You may include a translation of this License
	  provided that you also include the original English version of this
	  License. In case of a disagreement between the translation and the
	  original English version of this License, the original English version
	  will prevail.
	</P
></DD
><DT
><A
NAME="FDL-SECTION9"
></A
>9. TERMINATION</DT
><DD
><P
>	  You may not copy, modify, sublicense, or distribute the <A
HREF="#FDL-DOCUMENT"
>Document</A
> except as expressly provided
	  for under this License. Any other attempt to copy, modify, sublicense
	  or distribute the <A
HREF="#FDL-DOCUMENT"
>Document</A
> is
	  void, and will automatically terminate your rights under this
	  License. However, parties who have received copies, or rights, from
	  you under this License will not have their licenses terminated so long
	  as such parties remain in full compliance.
	</P
></DD
><DT
><A
NAME="FDL-SECTION10"
></A
>10. FUTURE REVISIONS OF THIS LICENSE</DT
><DD
><P
>	  The <A
HREF="http://www.gnu.org/fsf/fsf.html"
TARGET="_top"
>Free
	  Software Foundation</A
> may publish new, revised versions of the
	  GNU Free Documentation License from time to time. Such new versions
	  will be similar in spirit to the present version, but may differ in
	  detail to address new problems or concerns. See <A
HREF="http://www.gnu.org/copyleft"
TARGET="_top"
>http://www.gnu.org/copyleft/</A
>.
	</P
><P
>	  Each version of the License is given a distinguishing version
	  number. If the <A
HREF="#FDL-DOCUMENT"
>Document</A
> specifies
	  that a particular numbered version of this License "or any later
	  version" applies to it, you have the option of following the terms and
	  conditions either of that specified version or of any later version
	  that has been published (not as a draft) by the Free Software
	  Foundation. If the <A
HREF="#FDL-DOCUMENT"
>Document</A
> does
	  not specify a version number of this License, you may choose any
	  version ever published (not as a draft) by the Free Software
	  Foundation.
	</P
></DD
><DT
><A
NAME="FDL-USING"
></A
>Addendum</DT
><DD
><P
>	  To use this License in a document you have written, include a copy of
	  the License in the document and put the following copyright and
	  license notices just after the title page:
	</P
><P
>	  Copyright  YEAR  YOUR NAME.
	</P
><P
>	  Permission is granted to copy, distribute and/or modify this document
	  under the terms of the GNU Free Documentation License, Version 1.1 or
	  any later version published by the Free Software Foundation; with the
	  <A
HREF="#FDL-INVARIANT"
>Invariant Sections</A
> being LIST
	  THEIR TITLES, with the <A
HREF="#FDL-COVER-TEXTS"
>Front-Cover
	  Texts</A
> being LIST, and with the <A
HREF="#FDL-COVER-TEXTS"
>Back-Cover Texts</A
> being LIST.  A copy
	  of the license is included in the section entitled <SPAN
CLASS="QUOTE"
>"GNU Free
	  Documentation License"</SPAN
>.
	</P
><P
>	  If you have no <A
HREF="#FDL-INVARIANT"
>Invariant
	  Sections</A
>, write "with no Invariant Sections" instead of saying
	  which ones are invariant.  If you have no <A
HREF="#FDL-COVER-TEXTS"
>Front-Cover Texts</A
>, write "no
	  Front-Cover Texts" instead of "Front-Cover Texts being LIST"; likewise
	  for <A
HREF="#FDL-COVER-TEXTS"
>Back-Cover Texts</A
>.
	</P
><P
>	  If your document contains nontrivial examples of program code, we
	  recommend releasing these examples in parallel under your choice of
	  free software license, such as the <A
HREF="http://www.gnu.org/copyleft/gpl.html"
TARGET="_top"
> GNU General Public
	  License</A
>, to permit their use in free software.
	</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="ENDORSEMENTS"
>&#48512;&#47197; E. 승인</A
></H1
><P
>This version of the document is endorsed by the
original author, David A. Wheeler, as a document that
should improve the security of programs.
when applied correctly.
Modifications (including translations) must remove this appendix
per the license agreement included above.</P
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="ABOUT-AUTHOR"
>&#48512;&#47197; F. 저자</A
></H1
><P
>David A. Wheeler is an expert in computer security and
has long specialized in development techniques for large and
high-risk software systems.
He has been involved in software development
since the mid-1970s,
and been involved with Unix and computer security since the early 1980s.
His areas of knowledge include computer security,
software safety, vulnerability analysis, inspections, Internet technologies,
software-related standards (including POSIX),
real-time software development techniques,
and numerous computer languages
(including Ada, C, C++, Perl, Python, and Java).</P
><P
>Mr. Wheeler is co-author and lead editor of the IEEE book
<B
CLASS="EMPHASIS"
>Software Inspection: An Industry Best Practice</B
>,
author of the book
<B
CLASS="EMPHASIS"
>Ada95: The Lovelace Tutorial</B
>,
and co-author of the
<B
CLASS="EMPHASIS"
>GNOME User's Guide</B
>.
He is also the author of many smaller papers and articles, including the
Linux <B
CLASS="EMPHASIS"
>Program Library HOWTO</B
>.</P
><P
>Mr. Wheeler hopes that, by making this document available, other
developers will make their software more secure.
You can reach him by email at dwheeler@dwheeler.com (no spam please),
and you can also see his web site at
<A
HREF="http://www.dwheeler.com"
TARGET="_top"
>http://www.dwheeler.com</A
>.</P
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>&#51452;&#49437;</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN815"
HREF="#AEN815"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>기술적으로 하이퍼텍스트
링크는 모든 "uniform resource identifier" (URI) 일 수 있다. "Uniform
Resource Locator" (URL) 은 이름 또는 자원의 어떤 다른 속성에 의해 자원을
식별한다기 보다는 URI 의 기본 접근 메카니즘 (예, 네트워크 "location") 의
표현을 통해 자원을 식별하는 URIs 의 부분 집합을 참조한다. 많은 사람들은
URLs 이 가장 널리 사용되고 있는 URI 의 유형이기 때문에 "URL" 을 "URI" 와 
동의어로서 사용하고 있다. 예를 들어 URIs 에서 사용된 인코딩은 실제로
"URL 인코딩" 이라고 부른다.</P
></TD
></TR
></TABLE
></BODY
></HTML
>
}}}
