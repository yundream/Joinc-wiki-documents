head	1.9;
access;
symbols;
locks
	root:1.9; strict;
comment	@# @;


1.9
date	2014.08.23.16.16.27;	author root;	state Exp;
branches;
next	1.8;

1.8
date	2014.08.23.14.03.23;	author root;	state Exp;
branches;
next	1.7;

1.7
date	2014.08.22.17.22.52;	author root;	state Exp;
branches;
next	1.6;

1.6
date	2014.08.19.14.38.14;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2014.08.18.04.08.36;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2014.08.18.03.56.25;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2014.08.18.02.00.53;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2014.08.17.16.18.09;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2014.08.17.15.50.39;	author root;	state Exp;
branches;
next	;


desc
@./data/text/man_2f12_2fgolang_2fnetworkProgramming_2fArchitecture
@


1.9
log
@119.64.102.68;;yundream;;
@
text
@#title Architecture

이번 장에서는 분산 시스템을 위한 주요 아키텍처에 대해서 다룬다. 

[[TableOfContents]]
== 소개 ==
소프트웨어적인 결과물을 만들기 위해서는 만들고자 하는 소프트웨어에 대한 아이디어를 가지고 있어야 한다. 아이디어 없는 결과물이란 있을 수 없다. 그리고 소프트웨어에 대한 아이디어를 만들기 위해서는 소프트웨어가 작동하는 환경에 대한 지식을 가지고 있어야 한다. GUI 프로그램과 batch 프로세싱 프로그램은 다른 방식으로 개발을 해야 한다. 게임 프로그램과 비지니스 프로그램 역시 다르다. 마찬가지로 stand along 프로그램과 분산 프로그램(distributed program)도 서로 다르다. 이들 프로그램은 해결해야 할 문제와 달성하고자 하는 목표가 다르며, 이에 따라서 프로그래밍에 사용하는 패턴, 개발방식, 테스트 방법등에 있어서 전혀 다른 접근방법을 사용해야 한다. 

이번 장에서는 '''분산 시스템'''을 구현하기 위해서는 어떤 설계방식으로 접근해야 하는지에 대해서 살펴 볼 것이다.

== 프로토콜 레이어 ==
분산 시스템은 "어렵다". 분산 시스템은 다양한 방식으로 연결되는 다양한 컴퓨터가 참여한다. 분산 시스템에 참여하는 이들 컴퓨터에서 실행되는 프로그램은 분산 작업을 완수하기 위해서 '''협력'''을 해야 하는데, 이 협력하는 과정이 분산시스템의 개발을 어렵게 한다.   

복잡한 문제를 처리하는 일반적인 방법은 문제를 작고 단순한 여러 부분으로 해체하는 거다. 이렇게 해체된 각각의 부분은 자신만의 독자적인 구조를 가지며 동시에 다른 연결된 부분과 통신을 하기 위한 수단들을 가지게 된다. 분산 시스템에서 이런 부분들은 "프로토콜 계층(protocol layer)"이라고 부른다. 각 계층은 자신들이 수행해야 할 작업에 대한 명확한 기능들을 가지고 있다. 이들 프로토콜 계층은 하나의 계층위에 또 다른 계층이 놓이는 stack 구조를 가진다. 물론 이렇게 해체된 프로토콜 계층은 서로 통합이 되야 한다. 이들 통합은 각 프로토콜 계층에서 다른 프로토콜 계층과 "통신"을 하는 방식으로 이루어진다. 이런 통신 방식은 프로토콜에 정의되어 있다. 

각각의 계층은 하위 계층의 구조를 "숨기는" 방식으로 구현을 한다. 저 아래 계층에 있는 복잡한 기능들을 숨김으로써, 프로그램 개발을 단순화 한다.  

현대 사회의 모든 기능들은 이러한 프로토콜 계층 방식으로 구현이 된다. 은행을 예로 들어보자. 은행은 굉장히 복잡한 업무 처리 프로세스를 가지고 있지만, 고객들은 창구에서 기다릴 줄 아는 약간의 에티켓과 입금 및 출금증을 작성하는 정도로 은행업무를 처리할 수 있다. 복잡한 처리 과정은 '''고객창구 / 지역 은행 전산실 / 중앙 전산망 / 데이터베이스 / 데이터베이스 처리 소프트웨어'''등의 계층에서 처리해준다.

=== ISO OSI 프로토콜 ===
분산 시스템 설계에 가장 큰 영향을 미치는 프로토콜로 OSI(Open Systems Interconnect)프로토콜이 있다. 이 프로토콜은 다음과 같이 묘사할 수 있다.

{{{#!html
<img src="https://docs.google.com/drawings/d/15qUamKZgG8lHjq2_rKNtFIDSRasvw9Bvd4KIcXlrj5c/pub?w=689&amp;h=456" width="482" height="319">
}}}

==== OSI Layers ====
주요 계층을 요약하자면 이렇다.
  * 네트워크(Network) 계층은 데이터를 스위칭하고 경로를 설정하기 위한 기능들을 제공한다.  
  * 전송(Transport) 계층은 시스템과 시스템(end-to-end) 사이에서 전송된 데이터를 복구하고 흐름을 조정하는 기능을 제공한다.  
  * 세션(session) 계층은 애플리케이션 간의 연결과 연결 유지 그리고 연결종료를 위한 기능을 제공한다. 
  * 애플리케이션(application) 계층은 유저 말든 프로세스와 애플리케이션을 지원하기 위한 기능을 제공한다. 
자세히 보자면 7개의 계층으로 구성됐는데, 이런 이유로 OSI7계층 이라고 부르기도 한다.

==== TCP/IP 프로토콜 ====
OSI 모델의 도입과 이에 대한 구현을 위해서 고군분투 하고 있을 때, DARPA 인터넷 연구소는 TCP/IP 프로토콜 구축을 위해서 바쁘게 움직이고 있었다. TCP/IP 프로토콜은 대단히 성공적이였으며, 지금의 인터넷을 있게한 핵심 주역으로 성장했다. TCP/IP는 OSI 계층보다 단순한 스택구조를 가지고 있다.     

{{{#!html
<img src="https://docs.google.com/drawings/d/1dvhWh3KGa9ERzAAkBWeL9wecwNq9LsZR4KrsAo9-Xa8/pub?w=666&amp;h=389" width="466" height="272">
}}}

==== 기타 관련 프로토콜들 ====
TCP/IP는 범용적인 프로토콜로 분산 컴퓨팅 환경에서의 네트워크 애플리케이션 개발을 위해서 널리 사용하고 있다. 하지만 TCP/IP 만으로 모든 것을 다 할 수 있는 것은 아니라서, 비슷한 계층에 다른 프로토콜들이 있다. 
  * Firewire
  * USB
  * Bluetooth
  * Wifi
이들 프로토콜은 "인터넷의 다른 공간"에서 중요하게 사용하고 있지만, 이 책에서는 TCP/IP로 이루어진 인터넷 공간만을 다룰 것이다. 

== 네트워킹 ==
네트워킹은 하나의 시스템에서 원격에 있는 다른 시스템에 정보를 전달하고 수신하기 위한 커뮤니케이션 시스템이다. 이들 시스템간의 연결은 구리선, 이더넷, 광섬유 혹은 무선 환경으로 연결되있다. 이중 '''LAN(Local Area Network)'''는 근접한 컴퓨터들로 구성된 네트워크로 가정(home), 소규모 사무실등의 좁은 영역에 구축된다. 이들 LAN은 다시 WAN(Wide Area Network)의 구성요소로 참여한다. 

WAN은 물리적으로 멀리 떨어진 컴퓨터들을 연결하기 위한 네트워크 시스템이다. 도시와 도시, 국가와 국가를 묶는 네트워크 시스템이다. LAN과 WAN외에 MANs(Metropolitan Area Network), PANs(Personal Are Networks), BANs(Body Are Network)등의 범위를 다루는 네트워크도 있다. PANs와 BANs는 최근 IoT 관련분야가 관심을 받으면서, 크게 부각되고 있다. MANs는 LAN 보다 큰 규모의 네트워크로, 도시의 여러 구획을 연결하는 네트워크 시스템이다. 도시의 규모가 거대해 지면서, 도시 자체를 독립된 네트워크로 묶어서 관리하려는 목적으로 만들었다.  

인터넷은 터넷은 두 개 이상의 LAN과 WAN이 서로 연결되는 네트워크로 "단일한 통합된 네트워크"다. 

인터넷과 비슷한 발음의 인트라넷이 있는데, 이 둘은 주요한 차이가 있다. 인트라넷은 일관된 하나의 정책세트로 중앙 조직의 관리통제를 받는다. 반면 인터넷은 전체를 관리하는 중앙조직이 없으며, 일체의 제어를 할 수 없다. 앞서 "단일한 통합된 네트워크"라고 했는데, 중앙조직의 관리를 받는 그런 네트워크는 아니다. 혼동하지는 말자.  

인트라넷은 중앙에서 관리하기 위해서, 표준화 작업을 거친다. 단일한 벤더의 표준화된 소프트웨어와 운영체제를 이용해서 관리하는게 보통이다. 반면 인터넷은 서로 다른 컴퓨터, 서로 다른 운영체제, 서로 다른 소프트웨어들로 구성된다. 운영체제와 벤더에 종속되지 않고 자유롭게 인터넷을 활용할 수 있지만, 다른 컴퓨터와 통신 하려면 애로사항이 꽃필 수 있다. 인터넷에서 다른 컴퓨터 시스템과의 통합은 오래된 과제다.

이 문서에서 괘하는 기술들은 인터넷 기반의 애플리케이션을 만드는데 도움을 줄 것이다. 또한 인트라넷 소프트웨어와 non-portable 시스템 애플리케이션 개발에도 도움을 줄 것이다.

== 게이트웨이 ==
두 개 이상의 네트워크를 연결 할 경우 연결점에서 데이터 흐름을 관리하는 컴퓨터 시스템이 필요하다. 이 컴퓨터 시스템은 데이터를 보고 어느 네트워크로 보낼지를 결정한다. 이 컴퓨터 시스템을 게이트웨이라고 한다. 

== 패킷 encapsulation ==
OSI나 TCP/IP 스택은 각 계층사이에 커뮤니케이션을 한다. 커뮤니케이션은 최상위 계층에서 만든 정보를 아래의 계층으로 단계적으로 보내고, 반대로 최하위 계층에 도착한 정보를 윗 계층으로 보내는 방식으로 진행된다. 

각 계층은 자신이 담당하는 정보들을 처리한다. 이 정보들은 각 계층에 전달하는 데이터 패킷의 헤더에 담겨있다. 계층은 패킷에서 자신이 처리할 헤더 정보를 읽어서 처리를 한 다음, 상위(혹은 하위) 계층으로 전달한다. 데이터를 인터넷으로 보낼 경우에는 최상위 계층에서 시작을 하는데, 각 계층이 자신의 정보를 헤더에 적어서 하위 계층으로 보낸다. 반대로 데이터를 받았을 경우에는 최하위 계층에서 시작을 한다. 각 계층은 자신의 헤더 정보를 읽어서 처리하고 윗 계층으로 보내는데, 이 헤더를 제거한 다음 보낸다. 

TFP(Trivial File Transfer Protocol)를 이용해서 하나의 컴퓨터에서 다른 컴퓨터로 파일을 전송하는 과정을 예로 들어보자. 이 프로토콜은 IP와 UDP 프로토콜을 이용한다.

{{{#!html
<img src="https://docs.google.com/drawings/d/1C3_xMfDglXctnNMvkCW-RNBf9i3sFUE72lVwIrPDsV8/pub?w=693&amp;h=401" width=485 height=280>
}}}

이렇게 각 스택을 거치면서 헤더를 떼고나면, 최종적으로 Data가 파일시스템에 저장된다. 
  1. 데이터가 하위 스택으로 흐를 경우에 데이터를 겹겹이 싸게 되는데, 이를 '''패킷 encapsulation''' 이라고 한다.
  1. 데이터가 상위 스택으로 흐를 경우 양파껍질 벗기듯 패킷을 제거하는데, 이를 '''패킷 decapulation'''이라고 한다.

== 연결 모델 ==
컴퓨터간 통신을 하게 되면, 최소한 하나 이상의 패킷을 주고 받게 된다. 이때 연결 방식에 따라서 두가지 모델로 나눌 수 있다. 
  * Connection oriented (연결지향)
  * Connectionless

=== 연결 지향 ===
컴퓨터간 세션을 만들어서(establish) 통신을 한다. 데이터는 이 세션을 따라서 흐르며, 데이터 통신이 끝날 때 세션도 파기된다. 전화를 이용한 데이터 통신을 생각하면 된다. 
  1. 서로 상대방을 확인 한 후
  1. 대화를 나누다가 
  1. 대화를 끝낸다. 이때 연결도 끊는다.
TCP가 연결지향 프로토콜이다.

=== Connectionless ===
연결을 맺지 않고 데이터를 주고 받는 시스템이다. 연결을 맺는 과정이 없기 때문에, 각각의 데이터는 서로에게 독립적이다. 메일을 주고 받는 것을 생각하면 되겠다. 데이터는 순서에 상관없이 도착할 수 있으며(나중에 보낸 데이터가 먼저 도착하는 등), 데이터 전송에 실패하더라도 확인할 수 있는 방법이 없다. IP가 connectionless 프로토콜이다. IP 기반으로 연결지향 통신을 원한다면, IP 위에 TCP를 올리면 된다. 

UDP는 connectionless 프로토콜이다. UCP/IP 통신을 한다면 connectionless 모델을 사용할 수 있다. 
== 커뮤니케이션 모델 ==
=== Message passing ===
객체지향(Object-oriented 프로그래밍)언어들은 '''message passing'''을 내장하고 있다. Concurrent 언어들은 종종 message passing 매커니즘을 이용하는데, 가장 잘 알려진 응용으로 Unix pipeline이 있다. 유닉스 파이프라인은 바이트를 대상으로 하지만 본질적인 제한이라고는 할 수 없다. 객체든 뭐든 어차피 바이트의 조합이기 때문이다. 물론 객체를 보낼 수 있는 마이크로소프트의 Powershell에 비교하면 사용하기가 까다롭다는 단점이 있긴 하다. 어떤 언어들은 메시지에 논리 데이터 구조를 함께 보낼 수도 있다. 

Message passing은 분산 컴퓨팅 모델 시스템 구현에 사용하는 기본 메커니즘(다른 말로 가장 널리 사용하는)이다. 연결을 만들고 나서, 데이터를 다른 컴퓨터로 보내면 상대편 컴퓨터는 이 데이터를 처리하고, 그에 대한 응답 메시지를 보내는 식으로 작동한다. 아래는 이 과정을 묘사한 그림이다.  

{{{#!html
<img src="https://docs.google.com/drawings/d/1FezDWZ0I4dDOu4c22AMi6Z1zFcOrJ9GurzhytTx-Uxg/pub?w=411&amp;h=338">
}}}

X Window System 같은 Low level 이벤트 드리븐 시스템들이 비슷한 방식으로 작동한다. 이 시스템은 유저로 부터 메시지를 기다리다가 메시지가 도착하면, 디코딩해서 그 결과를 화면에 출력한다. 

화면에서 버튼을 클릭하면 작동하는 GUI 시스템도 비슷한 방식으로 작동한다. 이런 시스템들은 버튼, 텍스트 입력 박스 등에서 발생하는 이벤트를 기다렸다가 처리하고 그 결과를 애플리케이션에 던진다. 전형적인 Send -> Receive 방식이다. 동일한 방식을 네트워크에도 적용할 수 있다. 한쪽에서 메시지를 전송하면, 메시지를 수신한 쪽에서 디코딩해서 처리한 다음, 그 결과를 리턴하면 된다. 

=== RPC (Remote procedure call) ===

== 분산 컴퓨팅 모델 ==
좀 더 높은 수준에서 몇 가지 분산 컴퓨터 모델을 정의할 수 있다. 이들 분산 컴퓨팅 모델은 위에서 설명한 커뮤니케이션 모델에 기반해서, 각각의 구성요소가 어떤 위상과 역할을 가지는지에 따라 결정된다.   

가장 일반적인 모델은 "Server/Client 모델"이다. 이것은 한쪽 컴퓨터가 정보를 제공하는 "Server"의 역할을 하고, 다른 한쪽 컴퓨터가 정보를 요청하는 "Client" 역할을 하는 모델이다. 이 모델을 따르는 시스템을 client-server 시스템이라고 부른다. 이 모델은 server, client라는 이름에서 알 수 있듯이, server가 상위가 되는 개념이다. 

분산 컴퓨팅에 참여하는 컴퓨터들이 동일한 역할과 위상을 가지는 모델이 있다. 서비스를 제공과 요청을 모두 가지는 그런 서비스로 "P2P(Peer-to-Peer)" 시스템이 대표적이다. P2P 모델을 따르는 대표적인 애플리케이션으로 비트토렌트가 있다.  

세번째로 '''filter''' 모델이 있다. 이 모델은 송신자와 수신자 사이에서 메시지를 중계하는 filter 역할을 하는 컴포넌트가 위치한다. 예를 들어, 유저가 어떤 정보를 요청하면, 이 요청은 중간(middle)에 있는 컴포넌트가 받은 다음에 SQL 로 변환해서 데이터베이스에 질의를 하고, 그 결과를 HTML 테이블로 출력한다. 즉 인터넷 게시판이 filter 모델의 한 예다.  

어떤 시스템은 두 개 이상의 모델을 함께 사용한다. 위에 인터넷 게시판이 filter 모델을 따른다고 했는데, 웹 브라우저와 웹 서버는 client-server 모델을 따른다. client-server 모델과 filter 모델을 함께 사용하는 예이다.  

{{{#!html
<img src="https://docs.google.com/drawings/d/1fICaqaOeZFC1HTX5QaGkd0-V6pFDmJ3dhemIWXv_PmQ/pub?w=854&amp;h=204" width=597 height=142>
}}}

== 클라이언트 서버 모델 ==
클라이언트 서버모델을 좀더 자세히 묘사했다.

{{{#!html
<img src="https://docs.google.com/drawings/d/1NoORyOMW5WaegBxXfoTw4Z3qbR3fr5WYe9tms-eC69Q/pub?w=585&amp;h=245">
}}}
  1. User : 클라이언트 프로그램을 이용하는 사람이다.  
  1. Client : 유저의 명령을 서버측에 전달하는 프로그램이다. 웹브라우저, FTP 접속 프로그램 등이 대표적인 클라이언트 프로그램이다.  
  1. Server : 클라이언트 프로그램의 명령을 받아서 처리하고, 그 결과를 돌려주는 프로그램이다. Apache 웹서버, vsftpd 등의 프로그램이 있다. 

그림을 보면 client - server 모델에서 데이터를 주고 받는 것은 컴퓨터가 아닌 컴퓨터에서 실행되는 애플리케이션 이라는 것을 알 수 있다. 실제로는 애플리케이션들이 데이터를 주고 받는 거다. 단지 애플리케이션끼리 네트워크를 구성한다고 묘사하는 것보다 컴퓨터들이 네트워크를 구성한다고 하는게 직관적이라서 그렇게 묘사하는 것일 뿐이다. 

== Component Distribution == 
응용 프로그램을 분석하는(혹은 개발하는) 간단하고 효율적인 방법은 그들을 3개 부분으로 나누는 것이다. 
  * Presentatio component 
  * Application logic
  * Data access
'''Presentation component'''는 유저와 상호작용하는 부분이다. 유저와의 상호작용은 키보드와 마우스를 이용해서 유저의 입력을 받는 입력부와  처리한 결과를 화면에 출력하는 출력부로 구성된다. GUI 프로그램이라면, 버튼, 메뉴, 리스트, 텍스트 박스등이 프리젠테이션 컴포넌트에 해당된다. 서버 프로그램에서는 거의 신경쓰지 않는 부분으로, 이 문서에서도 거의 언급하지 않을 것이다. 

'''Application logic'''은 유저의 요청을 읽고 분석, Data access 컴포넌트를 사용하기 위한 질의어를 만들고, 비지니스 로직을 적용해서 처리한다.  

'''Data access''' 컴포넌트는 데이터를 저장하고 꺼내는 일을 한다. 거의 대부분 데이터베이스 시스템을 이용한다. 

=== 가트너 분류 (Gartner Classification) ===
가트너는 애플리케이션을 구성하는 3가지 컴포넌트들을 기반으로 클라이언트와 서버 시스템을 구성하기 위한 5개의 모델을 제시했다.

{{{#!html
<img src="https://docs.google.com/drawings/d/1Ty4Bslm5ZNmdEj5DQItDnokBwXTBw7wVBdGnDY_8CuA/pub?w=951&amp;h=359" width="665" height="251">
}}}

==== Distributed Database ====
{{{#!html
<img src="https://docs.google.com/drawings/d/17oRZ_koSgHUzI-oHD7HFKg2Eu2lILOgOOnEERkFsFCk/pub?w=207&amp;h=287">
}}}

모바일 폰이 좋은 예다. 모바일 폰은 작은 메모리와 저장공간을 가지고 있다. 따라서 대부분의 데이터는 원격에 둘 수 밖에 없는데, 그렇게 되면 애플리케이션 반응속도가 느려진다. 그래서, 내부에 작은 크기의 데이터베이스를 유지한다. 이 데이터베이스는 일종의 캐쉬처럼 사용하는데, 유저가 요청하면 먼저 내부에 있는 데이터베이스를 조회하고, 찾을 수 없을 경우 원격 데이터베이스에 정보를 요청한다. 웹 브라우저도 비슷하게 작동한다. 

==== 네트워크 파일 시스템 ====
모든 정보가 원격지에 있다. NFS, FTP, Microsoft shares, DCE 등이 대표적인 서비스다. 가트너 분류 2에 해당하는 서비스. 

{{{#!html
<img src="https://docs.google.com/drawings/d/1C90zDPnDkSdZ6y3xaRQFk4oyEIQHQP7w42qS43v5QX8/pub?w=199&amp;h=348">
}}}

==== Web ====
{{{#!html
<img src="https://docs.google.com/drawings/d/18nWrIhZ94H91YADTs2B17LUgqmdlmwPrzAwiTFk2DuM/pub?w=268&amp;h=346">
}}}

웹은 가트너 분류 3에 해당하는 서비스다. 웹 브라우저는 실제 데이터를 가지고 있지 않다. 데이터는 서버가 가지고 있으며, 웹 브라우저의 요청을 받아서 처리하고 그 결과를 웹 브라우저에 반환한다. 웹 브라우저는 서버의 응답을 Javascript와 HTML을 이용해서 적당히 가공하고 그 결과를 랜더링해서 모니터에 출력한다.

==== 터미널 에뮬레이션 ====
{{{#!html
<img src="https://docs.google.com/drawings/d/1BBtYHNx2UEdFlz4Ip8ZVcjYpMsJzZ-rTp08LsWR3SO8/pub?w=182&amp;h=347">
}}}

터미널 애뮬레이션은 가트너 분류 4에 해당하는 대표적인 서비스다. gnome-terminal, konsole, xterm, putty 같은 애플리케이션이 여기에 해당한다. 이들은 서버에 요청을 하고 그 결과를 프리젠테이션 하는 것 외에 어떤 다른 일도 수행하지 않는다. 

==== X windows system ====
{{{#!html
<img src="https://docs.google.com/drawings/d/1bBHghLUy1G95msuls6Zcualheyxo4pYF2F2B-qGhXcw/pub?w=169&amp;h=344">
}}}

X windows 시스템은 가트너 분류 5에 해당한다. 

== Middleware model ==
미들웨어는 분산된 서로 다른 시스템을 연결하기 위해서 사용한다. 미들웨어 모델은 다음과 같다.   

{{{#!html
<img src="https://docs.google.com/drawings/d/1gem34wdELZUupE_djMiVbkfiSapURZHMtJolfFBz9z0/pub?w=638&amp;h=321">
}}}


=== Middleware ===
인터넷은 다양한 서버와 클라이언트 프로그램들이 있으며, 이들이 유연하게 통신이 가능하게 해야 한다. 첫번째 방법은 클라이언트와 서버가 서로 규약을 엄격하게 일치하도록 개발하는 건데, 이 경우 유연성이 떨어지게 된다. 두번째 방법은 미들웨어를 두는 거다. 이 미들웨어는 중간에서 서버와 클라이언트의 통신을 중계하는 역할을 하는데, 프로토콜이 다를 경우 프로토콜을 통역하는 역할까지 겸하게 된다.

== Points of Failure ==
분산 애플리케이션은 복잡한 환경에서 작동한다. 이는 단일 컴퓨터에서 실행되는 standalone 애플리케이션 보다 더 많은 실패를 겪을 수 있음을 의미한다. 이들 실패의 종류를 정리했다. 
  * 클라이언트 애플리케이션 충돌 
  * 클라이언트 하드웨어 문제
  * 클라이언트 네트워크 카드 문제
  * 네트워크 연결 타임 아웃
  * 네트워크 주소 충돌
  * 라우터등의 네트워크 요소들의 고장
  * 전송에러로 인한 메시지 유실 
  * 클라이언트와 서버간 버전 차이
  * 서버 네트워크 카드 고장
  * 서버의 하드웨어 시스템 고장
  * 서버 소프트웨어 충돌
  * 서버 데이터베이스 문제
애플리케이션은 이런 문제가 발생할 수도 있다는 것을 가정하고 개발해야 한다. 어느 한 컴포넌트에 문제가 생기더라도 작동해야 하며, 문제가 생겼을 때 복구할 수 있어야 한다. 이를 위해서 에러를 감지하고 모니터링하기 위한 시스템과 복구 시스템, single point failure를 방지하기 위한 시스템/네트워크 등을 준비해야 한다.   

== Acceptance Factors ==
분산 컴퓨팅 시스템은 아래의 기능들을 골해야 한다.
  * 신뢰성(reliability) 
  * 성능(Performance)
  * 확장성(Scalability) 
  * Capacity
  * 보안(Security)

== Eight fallacies of distributed computing ==
썬 마이크로 시스템즈는 "네트워크가 컴퓨터다"라는 기치아래 오랜 시간을 분산 컴퓨팅 환경에서 작업을 진행했던 회사다.  이런 다년간의 경험을 바탕으로 컴퓨터 엔지니어가 분산 컴퓨팅 시스템을 개발할 때 가질 수 있는 착오들에 대해서 정리를 했다. 
  * 네트워크는 안전하다. 
  * 네트워크 지연은 0이다.
  * 무한대의 대역폭을 가지고 있다.
  * 네트워크는 안전하다.
  * 토폴로지는 변하지 않는다.
  * 하나의 관리자만 있다.
  * 전송비용은 0이다.
  * 네트워크는 균일(homogeneous)하다.
위에 언급한 것들은 네트워크 프로그램의 완성도에 직접적인 영향을 미친다. 

"네트워크는 안전하다"라는 오류를 예로 들어보자. 하나의 컴퓨터에서 작동하는 애플리케이션이 있다고 가정해보자. 이들은 IPC를 이용해서 주변의 다른 애플리케이션과 통신을 할 것이다. IPC는 운영체제에서 제공하는 내부 통신 설비인데, 통신 설비 자체의 문제는 거의 생기지 않는다. 하지만 인터넷 상에서 통신을 할 경우에는 절대 그렇지 않다. 운영체제, 네트워크 카드, 스위치, 컴퓨터 고장, 전원 계통 문제, 게이트웨이, 광케이블, 도메인 서버, 라우터.. 다양한 곳에서 문제가 발생한다.   

만약 일년 365일 99.9999%의 가용성을 보장하는 서비스를 목적으로 한다면, 반드시 "안전하지 않은 네트워크 때문에 발생할 수 있는 문제"들에 대한 대비를 해야 한다.
  * 애플리케이션은 네트워크 문제에 대한 에러 핸들링을 해야 한다. 즉 네임서버를 사용할 수 없거나 연결실패, 데이터 송/수신의 실패등에 대한 예외처리를 해야 한다. 
  * Single point failure에 대비해야 한다. 
     * 두 대 이상의 컴퓨터로 시스템을 구성해야 한다.
	 * 두 대 이상의 데이터베이스 준비
	 * 두 대 이상의 네트워크 장비
	 * 분리된 전원 공급장치
	 * 가능하면 물리적으로 분리된 IDC에 분산해서 시스템을 배치.
  * 모니터링 시스템의 준비.  
  * 백업/복구 시스템
물론 이렇게 하려면 돈이 많이 들어간다. 서비스의 성격과 형편에 알맞게 구성을 해야 하겠다. 다행인 점은 cloud를 이용하면, 위에 언급한 장치들의 상당부분을 클라우드 업체에서 제공한다는 점이다. 

== 참고 ==
  * [http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing Fallacies of Distributed coumputing]
@


1.8
log
@119.64.102.68;;yundream;;
@
text
@a203 2
== Continuum of Processing ==

d205 14
a218 1
분산 애플리케이션은 복잡한 
d221 7
a227 1
== Transparency ==
d229 27
@


1.7
log
@119.64.102.68;;yundream;;
@
text
@d163 1
a163 1
모바일 폰이 좋은 예다. 
d165 27
d194 10
a203 1
== Middleware ==
d205 1
d207 2
@


1.6
log
@119.64.102.68;;yundream;;
@
text
@d141 24
a164 1
=== Gartner Classification ===
@


1.5
log
@119.64.102.68;;yundream;;
@
text
@d103 8
d114 14
d129 13
a141 2
== 클라이언트 서버 애플리케이션 ==
== Server distribution ==
d143 7
@


1.4
log
@119.64.102.68;;yundream;;
@
text
@d99 3
@


1.3
log
@119.64.102.68;;yundream;;
@
text
@d55 7
d64 1
d67 13
d82 4
d87 6
d94 1
d96 1
d98 2
@


1.2
log
@119.64.102.68;;yundream;;
@
text
@d5 1
d24 1
a24 1
<img src="https://docs.google.com/drawings/d/15qUamKZgG8lHjq2_rKNtFIDSRasvw9Bvd4KIcXlrj5c/pub?w=689&amp;h=456">
d28 6
a33 8
OSI는 분산 시스템 구성이라는 하나의 문제를 해결하기 위해서, 7개의 계층으로 나눴다. 그래서 OSI7계층 이라는 이름으로 부르기도 한다. 각각의 계층(Layer)들의 기능은 다음과 같다. 
  1. Pyhsical Layer : 
  1. Data Link Layer : 
  1. Network Layer :
  1. Transport Layer :
  1. Session Layer :
  1. Preentation Layer :
  1. Application Layer
d36 5
d43 6
d51 4
@


1.1
log
@119.64.102.68;;yundream;;
@
text
@d13 1
a13 1
복잡한 문제를 처리하는 일반적인 방법은 문제를 작고 단순한 여러 부분으로 해체하는 거다. 이렇게 해체된 각각의 부분은 자신만의 독자적인 구조를 가지며 동시에 다른 연결된 부분과 통신을 하기 위한 수단들을 가지게 된다. 분산 시스템에서 이런 부분들은 "프로토콜 계층(protocol layer)"이라고 부른다. 각 계층은 자신들이 수행해야 할 작업에 대한 명확한 기능들을 가지고 있다. 이들 프로토콜 계층은 하나의 계층위에 또 다른 계층이 놓이는 stack 구조를 가진다. 
d20 38
@
