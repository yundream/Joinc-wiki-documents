#title pthread_cond_wait(3)
[wiki:function_pthread_cond_wait(3) HTML 변환문서]

{{{#!plain
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<chapter lang=ko>
<!-- 작성자 : yundream             -->
<!-- 작성일 : 2004/04/01           -->
<!-- 연락처 : yundream@joinc.co.kr -->

<!-- 함수 이름을 입력합니다 -->
<title>pthread_cond_wait(3)</title>

<!-- 이건 함수에 대한 대략적인 설명이구요 -->
<para>
	조건변수 관련 연산
</para>
 
<!-- 여기에 함수의 간단한 사용법이 들어갑니다 -->
<section>
	<title>사용법</title>
	<para>
		<screen>
#include &lt;pthread.h&gt;

pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond, pthread_condattr_t *cond_attr);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
int pthread_cond_destroy(pthread_cond_t *cond);
		</screen>
	</para>
</section>

<!-- 여기엔 함수의 자세한 설명 이 들어갑니다 -->
<section>
	<title>설명</title>
	<para>
		조건변수는 쓰레드간 동기화를 위해서 사용하는 장치로써, 공유되는 
		데이터의 안정을 보장하기 위한 용도로 주로 사용된다. 조건변수의 
		기본적인 작동방식은 다음과 같다. 하나의 쓰레드는 조건변수에 
		시그널이 전달될 때까지 특정영역에서 대기 상태에 놓이게 된다. 만약 
		다른 쓰레드가 조건변수에 시그널을 보낸다면 대기 상태에서 풀리고 
		다음 코드로 넘어가게 된다.  
	</para>
	<para>
		조견변수는 race condition을 피해야하므로 반드시 뮤텍스(mutex)와 
		함께 사용되어야 한다. 
	</para>
	<para>
		pthread_cond_init()는 조건벼수 <emphasis>cond</emphasis>를 초기화하기
		위해서 사용되며, <emphasis>cond_attr</emphasis>를 이용해서 조건변수의
		특성을 결정할 수 있다. NULL을 사용하면 기본특성이 사용된다. 리눅스의
		경우 cond_attr은 무시된다.     
	</para>
	<para>
		<emphasis>pthread_cond_t</emphasis>는 상수 PTHREAD_COND_INITIALIZER을 
		이용해서 static하게 초기화 시킬 수 있다. 
	</para>
	<para>
		pthread_cond_signal()은 조건변수<emphasis>cond</emphasis>에 시그널을 
		보내어서 다른 (조건변수 cond에서 기다리는)쓰레드를 깨운다. 만약 
		cond에서 기다리는 쓰레드가 없다면 아무런 일도 일어나지 않게 된다. 
		만약 여러개의 쓰레드가 cond에서 기다리고 있다면 정확히 이중 하나가 
		깨어나게 된다. 그러나 어떤게 깨어날지는 알 수 없다. 
	</para>
	<para>
		pthread_cond_boradcast()는 조건변수<emphasis>cond</emphasis>에서 
		기다리는 모든 쓰레드를 깨운다. 기다리는 쓰레드가 없다면 아무런 일도 
		일어나지 않는다.    
	</para>
	<para>
		pthread_cond_wait()는 조건변수 <emphasis>cond</emphasis>로 시그널이 
		전달되기를 기다린다. 이 함수는 호출되면 자동적으로 
		<emphasis>mutex</emphasis>잠금을 되돌려준다 - 내부적으로 
		pthread_unlock_mutex()를 호출한다. -. 이 함수를 호출한 쓰레드는 
		조건변수에 시그널이 전달될 때까지 기다리며, 이때 CPU는 소비하지 
		않는다. 시그널을 전달받아서 쓰레드가 깨어나면 자동적으로 
		<emphasis>mutex</emphasis>잠금을 얻는다 - pthread_lock_mutex()를 사용-.
	</para>
	<para>
		pthread_cond_timedwait()는 pthread_cond_wait()의 시간제한 버젼으로 
		<emphasis>abstime</emphasis>를 이용해서 제한시간이 지날 때까지 시그널이
		전달되지 않았을경우 리턴된다는 것을 제외하고는 pthread_cond_wait()와 
		동일하게 작동한다. 제한시간이 지나서 리턴되었을 경우 errno로  
		<emphasis>ETIMEOUT</emphasis>을 설정한다. <emphasis>abstime</emphasis>에
		대해서는 time(2)와, gettimeofday(2)를 참고하기 바란다. 
	</para>
	<para>
		pthread_cond_destroy()는 조건변수를 삭제해서 자원을 되돌려준다.
	</para>
</section>
<section>
	<title>취소(CANCELLATITON)</title>
	<para>
		pthread_cond_wait()와 pthread_cond_timedwait()는 취소상태함수 이다. 
		이에 대한 자세한 내용은 
		<ulink url="http://www.joinc.co.kr/modules/moniwiki/wiki.php/article_thread_cancellation">Thread 취소와 종료</ulink>를 참고하기 바란다.
	</para>
</section>

<!-- 함수가 되돌려주는 값이구요 -->
<section>
	<title>반환값</title>
	<para>
		성공할경우 0을 실패했을경우에는 -1을 반환하며, 적당한 errno 값을 
		설정한다. 
	</para>
</section>

<!-- 에러가 발생했을때 되돌려주는 값들입니다 -->
<section>
	<title>에러</title>
	<para>
		pthread_cond_init(), pthread_cond_signal(), pthread_cond_broadcast(),
		pthread_cond_wait()는 에러코드를 리턴하지 않는다.
	</para>
	<para>
		pthread_cond_timewait()의 경우 다음과 같은 에러코드를 리턴한다.
		<variablelist>	
			<varlistentry>
			<term>ETIMEDOUT</term>	
			<listitem>
				<para>	
					시간초과 검사를 위해 지정된 <emphasis>abstime</emphasis>를
					초과해서 시그널이 발생하지 않았을 때.	
				</para>	
			</listitem>
			</varlistentry>

			<varlistentry>
			<term>EINTR</term>
			<listitem>
				<para>
					(유닉스 POSIX)시그널등에 의해서 인터럽트가 발생했을 때
				</para>
			</listitem>
			</varlistentry>
		</variablelist>	
	</para>
	<para>
		pthread_cond_destory()함수는 다음과 같은 에러코드를 리턴한다.
		<variablelist>	
			<varlistentry>
			<term>EBUSY</term>	
			<listitem>
				<para>	
					<emphasis>cond</emphasis>에 기다리고 있는 쓰레드가 남아있다.
				</para>	
			</listitem>
			</varlistentry>
		</variablelist>	
	</para>
</section>
<section>
	<title>예제</title>
	<para>
		<screen>
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;

void *ping(void *);
void *pong(void *);

pthread_mutex_t sync_mutex;
pthread_cond_t  sync_cond;

pthread_mutex_t gmutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  gcond  = PTHREAD_COND_INITIALIZER;
                                                   
int main()
{
    vector&lt;void *(*)(void *)&gt; thread_list;
    vector&lt;pthread_t&gt; tident(10);
    int thresult;
    int status;
    int i;
                                          
    pthread_mutex_init(&amp;sync_mutex, NULL);
    pthread_cond_init(&amp;sync_cond, NULL);

    thread_list.push_back(pong);
    thread_list.push_back(ping);

    for(i = 0; i &lt; thread_list.size(); i++ )
    {
        pthread_mutex_lock(&amp;sync_mutex);
        if (pthread_create(&amp;tident[i], NULL, thread_list[i], (void *)NULL) &lt;0)
        {
            perror("error:");
            exit(0);
        }
        pthread_cond_wait(&amp;sync_cond, &amp;sync_mutex);
        pthread_mutex_unlock(&amp;sync_mutex);
    }
    for (i = 0; i &lt; tident.size(); i++)
    {
        pthread_join(tident[i], (void **)&amp;status);
    }
}
                         
void *ping(void *data)
{
    int i=0;
    pthread_mutex_lock(&amp;sync_mutex);
    pthread_cond_signal(&amp;sync_cond);
    pthread_mutex_unlock(&amp;sync_mutex);
    while(1)
    {
        pthread_mutex_lock(&amp;gmutex);
        printf("%d : ping\n", i);
        pthread_cond_signal(&amp;gcond);
        pthread_cond_wait(&amp;gcond, &amp;gmutex);
        pthread_mutex_unlock(&amp;gmutex);
        usleep(random()%100);
        i++;
    }
}
                                                   
void *pong(void *data)
{
    int i = 0;
    pthread_mutex_lock(&amp;sync_mutex);
    sleep(1);
    pthread_cond_signal(&amp;sync_cond);
    pthread_mutex_unlock(&amp;sync_mutex);
    while(1)                              
    {
        pthread_mutex_lock(&amp;gmutex);
        pthread_cond_wait(&amp;gcond, &amp;gmutex);
        printf("%d : pong\n", i);
        pthread_cond_signal(&amp;gcond);
        pthread_mutex_unlock(&amp;gmutex);
        i++;
    }
}
		</screen>
		위의 예제는 ping&amp;pong 프로그램으로 ping 쓰레드와 pong쓰레드가 
		번갈아 가면서 "ping", "pong"를 날리는 프로그램이다. 쓰레드 동기화를 
		위해서 pthread_cond_wait()관련 함수들이 사용되고 있다. 	
	</para>
</section>
<section>
	<title>참고문헌</title>
	<para>
		<orderedlist>
		<listitem>
			<para>
			<ulink url="http://www.joinc.co.kr/modules/moniwiki/wiki.php/article_thread_cancellation">Thread 취소와 종료</ulink>
			</para>
		</listitem>
		<listitem>
			<para>
			<ulink url="http://www.joinc.co.kr/modules/moniwiki/wiki.php/article_Pthread_API_Reference">Pthread API</ulink>
			</para>
		</listitem>
		<listitem>
			<para>
			<ulink url="http://www.joinc.co.kr/modules/moniwiki/wiki.php/article_더_깊이">Pthread 더 깊이</ulink>
			</para>
		</listitem>
		</orderedlist>
	</para>
</section>

</chapter>
}}}
