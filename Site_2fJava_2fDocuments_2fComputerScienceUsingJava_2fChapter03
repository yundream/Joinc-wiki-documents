#title 컴퓨터 메모리

[[TableOfContents]]
원문 : http://chortle.ccsu.edu/java5/Notes/chap03/ch03_1.html

== 컴퓨터 메모리 ==
1장에서 우리는 컴퓨터 시스템의 하드웨어 컴포넌트(구성요소)에 대해서 간단히 알아보았다. 
 * 프로세서 
 * 메인 메모리
 * Secondary 메모리 장치
 * 입/출력 장치

이반 장에서는 메인 메모리와 Secondary 메모리에 대해서 자세히 알아보도록 할 것이다. 다음은 이번장에서 다룰 주제들이다.
 * Bits와 Byte(:12)s
 * Kilobytes, megabytes, gigabytes
 * 메인 메모리와 주소(address) 
 * Secondary 메모리
 * 파일

 '''질문 : '''
 당신이 컴퓨터를 구입할 때, 어느정도의 main 메모리를 가지고 있을 것이라고 예상하는가 ?
 (1Kbyte, 512Kbyte, 512Mega)

=== 메인 메모리의 특성 ===
메인 메모리는 컴퓨터 시스템의 필수적인 구성요소다. 빠르고 좋은 컴퓨터는 빠른 프로세서와 함께, 크고 빠른 메모리를 가지고 있어야 한다. 메인 메모리와 Secondary 메모리의 특징을 표로 정리했다. 
 || 특징											|| 메인 메모리		|| Secondary 메모리		||
 || 프로세서와 가까이 있는가. || Yes						|| NO									||
 || 프로세서가 작업을 할때 프로그램과 데이터가 위치하는가 || Yes	|| NO	||
 || 오랜시간 저장하는가				|| NO		|| Yes	||
 || 프로세서와 초당 수백만번 상호작용이 가능한가	|| Yes	|| NO	||
 || 내용을 쉽게 변경할 수 있는가	|| Yes	|| Yes	||
 || 큰용량을 지원하는가				|| NO		|| Yes	||
 || 빠른 접근이 가능한가			|| Yes	|| No		||
 || 메인 메모리와 연결되는가	|| --		|| Yes	||
 || 프로그램과 데이터를 가지고 있는가 || Yes	|| Yes	||
 || 내용을 유지하기 위해서 파일을 사용하는가	|| No	|| Yes	||

=== 비트 ===
메인 메모리와 Secondary 메모리 모두, 일련의 비트의 나열들이 저장된다. 앞장에서 '''bit'''는 On/Off의 두가지 값만을 가지고 있다는 것을 배워서 알고 있다.

이 두가지 값(혹은 상태)는 true/false, 1/0의 값을 가진다고 말하기도 한다. 인간이 익숙하게 사용하는 십진수에 비해서 단순할거 같지만 단순함이 강점이다. 단순하기 때문에 컴퓨터를 간단하게 만들 수 있고, 더 싼가격에 구입할 수 있다. 다음은 bit 값을 사용하는 여러가지 도구들이다.
 * 전자 스위치
 * 트랜지스터 
 * 마그네틱 디스크의 표면
 * 마그네틱 테이프의 표면 
 * 천공카드
 * CD의 표면
 * 라디오 신호

=== 정보 복사 ===
이러한 바이너리로 저장된 데이터는 다른 저장매체로 쉽고 완벽하게 복사할 수가 있다. 이러한 작업은 매우 빠르게 일어나며, 몇번의 복사가 반복되더라도 데이터가 훼손되거나 하는 일이 발생하지 않는다. 당연히 그래야 하지 않는가라고 생각할 수 있겠지만, 아날로그 데이터는 복사하기 어려우며, 복사하는 중에 데이터가 훼손되는일이 자주 발생한다. 여러분의 책상앞에 있는 책은 대표적인 아날로그 정보를 가진 매체다. 책을 복사한다고 생각해보라. 손으로 옮겨적을 경우 엄청난 시간이 소비될 것이다. 오타가 있을 수도 있다. 복사기를 사용한다고 해도, 복사기/복사지 의 성능에 따라서 품질이 떨이지며, 실수로 몇페이지를 빼먹는 일도 발생한다.   

반면 바이너리 데이터는 0과 1의 단순한 비트의 나열이므로 실수할 가능성이 거의 없다. 또한 하드디스크에 저장된 데이터는 아주 쉽게, CD, 테이프, USB(:12)저장장치 등으로 복사할 수 있다. 네트워크에 연결되어 있다면, 다른 컴퓨터로도 순식간에 복사할 수 있다. 만약 여러분의 컴퓨터가 네트워크에 연결되어 있고, 거기에 웹서버까지 설치되어 있다면, 전세계 수만명의 사용자에게 순식간에 데이터를 복사할 수도 있다.

게다가 중요한 점은 데이터가 인공위성을 타고 가던지, 구리선, 광섬유 혹은 자기 디스크를 통해 이동되든지 간에, 원본과의 차이점이 발생하지 않는 다는 점이다.

  '''문제 :'''
  LP나 오디오 테이프는 신호의 연속된 변화가 기억되는 '''아날로그 데이터'''를 가지고 있다. 이러한 매체에 있는 데이터를 다른 매체로 복사하면 데이터의 변화가 발생할까 ? 

=== Byte ===
1bit는 컴퓨터의 메모리가 사용하기에는 너무 작은 데이터 단위이기 때문에, 8개의 bit를 하나의 묶음으로 만들어서 사용한다. 이러한 8bit의 묶음을 byte(:12)라고 한다. 이렇게 8개의 bit를 최소단위로 함으로써, 데이터를 점더 쉽게 다를 수 있다. 예를 들어 1byte는 하나의 문자를 포함하기에 충분한 크기를 제공하는데, 문자를 통해서 정보를 전달을 하는 문명의 특성상 이는 매우 중요하다.

데이터가 커지다 보면, 더 많은 bit와 byte의 숫자가 계속 올라갈 것이다. 그래서 '''천''', '''백만'''.. 급에서 사용하기 위한 kilobyte, megabyte등의 단위를 사용하고 있다. 

=== Byte의 사용 ===
바로 앞절에서 '''byte'''에 대해서 알아보았다. 비록 bit가 컴퓨터에서 사용되는 최소단위이기는 하지만 실질적으로는 byte가 최소단위임을 알 수 있을 것이다. 예를들어 1Kbyte는 1024 bytes가 된다. 1024 bytes는 1024 * 7 == 8,192 bites가 된다. 

여기에서 bit의 연산에 대해서 알아보자. 이 연산은 앞으로도 유용하게 사용할 수 있을 것이다. 
{{{#!html
<big><big>2<sup>M</sup> &nbsp;*&nbsp; 2<sup>N</sup> &nbsp;=&nbsp; 2<sup>(M+N)</sup></big></big>
}}}


다음은 사용 예이다.
{{{#!html
<big><big></big></big><big><big>2<sup>6</sup> &nbsp;*&nbsp; 2<sup>10</sup> &nbsp;=&nbsp; 2<sup>16</sup></big></big>
}}}

=== 메인 메모리의 모습 ===
원문 : http://chortle.ccsu.edu/java5/Notes/chap03/ch03_7.html

[[Image(Figure3-1.gif,197,273,right)]]
메인 모메리는 매우 긴 연속된 바이트들의 집합이다. 현대적인 모든 컴퓨터들은 각각의 바이트단위로 address(주소)를 할당한다. 다음은 메인 메모리의 대략적인 모습을 보여주고 있다. 

각각의 상자는 1 byte 영역을 의미한다. 이들 각각의 바이트들에 '''주소'''가 부여되어 있음을 알 수 있다. 이들 주소는 컴퓨터의 종류에 관계없이 0번 부터 1씩증가하는 식으로 부여된다. 

각각의 바이트는 8개의 비트들을 포함하고 있다. 여러분이 컴퓨터가 켜져있는 상태라면, 모든 바이트에는 독특한 패턴을 가진 bit의 집합들을 가지게 된다. 설사 해당 주소의 바이트를 프로세스가 사용하지 않는다 하더라도, 나름대로의 값이 저장되어 있다.
  '''문제'''
  아래의 지문을 읽고 옳은지 확인하라. 
    * 메인 메모리의 각 바이트는 유일한 주소를 가지고 있다.
    * 4메가바이트크기의 메인 메모리는 4*2^20 주소를 가지고 있다.
이 주소정보는 프로세스가 데이터를 찾을 때, 정확한 위치를 알 수 있도록 해준다. 프로세스는 데이터가 저장된 주소를 알아내고, 주소를 이용해서 메모리의 해당 위치로 가서 byte 정보를 읽어오게 된다.

=== 메인메모리의 내용 ===
[[Image(Figure3-2.gif,197,273,right)]]
모든 컴퓨터의 메모리에는 비트의 패턴이 저장된다. 각각의 메모리 영역에는 "0" 혹은 "1" 둘중 하나의 값을 가진 8개의 bit값이 저장된다. 아래의 그림은 메인메모리에 데이터들이 어떻게 저장되는 지를 보여준다. 

하나의 메모리 영역에는 단지 8개의 비트값만 저장될 수 있는데, 각 메모리의 영역에 저장된 bit들을 ''contents''라고 한다. (데이터 혹은 값이라고 불러도 큰 상관 없을 것 같다)

보통 사람들은 각 메모리 영역에 8비트 바이너리 숫자가 저장된다고 말한다. 이것은 맞는 말이다. 그러나 이 8비트의 숫자는 문자로 표현될 수 있다는 것을 염두에 두고 있어야 한다. 

이렇게 메모리에 저장되어 있는 비트패턴이 어떻게 사용될지는 프로그램에 의해서 어떻게 해석되는지에 달려있다. '''1000 1101'''비트 패턴을 예로 들자면, 계산기에서 이 패턴은 '''141'''로 해석될 것이다. 그러나 문서프로그램에서는 '''a'''로 해석될 것이다. 또 다른 프로그램에서는 전혀 다르게 해석될 수도 있다.

=== 메모리에 읽고 쓰기 ===
메인 메모리에서 일어나는 가장 중요한 작업은 '''읽고''', '''쓰는''' 작업이다.
 1. 메모리 영역에 바이트를 쓴다.
   * 기존의 비트패턴을 제거한다.
   * 새로운 비트패턴을 저장한다.
 1. 메모리 영역에서 바이트를 읽어들인다.
   * 영역에 저장된 비트패턴을 읽어들인다.
   * 영역에 저장된 비트패턴의 변화는 발생하지 않는다.

예를 들어 (위 그림에서)프로세서가 5번영역에 저장된 바이트값을 필요로 한다면, 이것을 읽어들일 수 있다. 그러면 '''0110 1110'''데이터를 얻어오게 된다. (이때 5번영역의 바이트 값이 변경되지는 않는다)

  '''문제'''
  위의 메모리 그림에서 프로세서가 7번영역에 '''1111 1111'''을 저장하려고 한다. 메모리에 어떤 변화가 발생하는가. 
=== 프로그램과 메모리 ===
프로세서가 7번영역에 데이터를 쓸 것이다. 이 경우 7번위치에 있던 예전 데이터는 잃어 버리게 된다. 메인 메모리는 다음과 같이 보일 것이다. 

프로그램이 실행되면 데이터를 다루기 위한 메모리영역을 할당받게 된다. 프로그램은 필요할 때 마다. 메모리영역에 있는 데이터를 읽고 쓰는 작업을 할 수 있다. 예를 들어 여러분이 작성한 프로그램이 1부터 100까지 더하는 일을 한다고 하면, 더한 숫자를 메모리 영역에 저장할 것이다. 여기에 새로운 숫자를 더해야 한다면, 메모리영역에서 기존에 저장되었던 값을 읽어와서 새로운 숫자를 더한다음에 메모리에 다시 쓰면 된다. 

이와 달리 프로그램이 실행되는 동안, 메인메모리에서 변경할 수 없는 데이터영역도 존재한다. 가장 대표적인게 프로그램이 수행할 명령들이 저장된 데이터 영역으로 (일반적으로) 이 부분은 프로그램이 실행되는 동안 바뀌지 않는다. 이 부분이 바뀐다면, 명령이 뒤죽박죽 될 수 있을 것이다. 보통 이 영역에는 프로그램자체가 위치한다. (프로그램과 데이터는 Secondary 메모리에서, 메인 메모리로 복사된다는 사실을 상기하라)

이렇게 메모리를 제어하는 작업은 꽤나 복잡하긴 하지만, 걱정할 필요는 없다. 이러한 작업은 프로그램 언어가 알아서 자동으로 해주기 때문이다.

  '''문제'''
  오랜 시간 보존되어야 하는 프로그램과 데이터는 어디에 저장됩니까 ? 
=== 하드 디스크 ===
[[Image(Figure3-4.gif,415,261,right)]]
가정 널리 쓰이는 Secondary 메모리 장치인 하드디스크는 오디오 테이프와 같이 magnetic 코팅된 표면을 가지고 있으며, 이 표면에 데이터를 저장한다. 읽고 쓰는 작업역시 헤더를 이용하는 오디오테이프의 그것과 매우 비슷하다. 

오디오 테이프는 데이터를 읽고 쓰기 위한 헤더가 고정되어 있지만, 하드디스크는 헤더도 움직일 수 있다는 점에 차이가 있다. 때문에 데이터를 1차원적으로 검색할 수 밖에 없는 오디오 장치와 달리 하드디스크는 2차원 적으로 데이터를 검색할 수 있다는 장점을 가진다. 

옆의 그림은 (오디오의 헤더에 해당하는)arm을 통해서 어떻게 데이터에 접근할 수 있는지를 보여주고 있다. 끝에 헤더를 가지고 있는 '''arm'''이 디스크의 안쪽과 바깥쪽으로 움직이며, Disk는 회전을 한다. 이 Disk에는 데이터가 원형의 트랙을 따라서 저장이 된다. 그러므로 읽어야할 데이터가 있다면 arm을 이용해서 헤더를 데이터가 저장된 트랙으로 이동시킨 다음, Disk를 회전시키면 데이터가 저장된 위치를 찾을 수 있다. 이제 읽을 데이터의 길이만큼 디스크를 회전시키면된다. 오디오 테이프는 헤더가 고정되어 있기 때문에, 테이프를 끝까지 돌려서 데이터가 저장된 위치를 찾는 수 밖에 없다. 데이터를 저장하는 것 역시, 접근속도 자체가 빠르기 때문에 하드디스크가 오디오 테이프에 비해서 매우 유리하다.  

컴퓨터 시스템에서 하드디스크는 보통 읽기/쓰기가 가능한 헤더를 가진 여러개의 독립적인 디스크들의 모음으로 구성된다. 이들 디스크들은 양면 모두 마그네팅 코딩을 해서 저장할 용량을 크게 만드는 방법을 사용한다. 하드디스크는 고속으로 작동하는 정밀한 기계로 먼지등에 매우 민감함으로 금속케이스로 꼼꼼히 포장되어 있다. 하드디스크는 메인 메모리에 비교해서 데이터를 읽고 쓰는데 매우 느리지만, 다른 Secondary 메모리 장치들 보다는 빠른 속도를 보여준다.

  '''문제'''
  하드디스크의 헤더는 읽고,쓸때 왜 표면에 접촉하지 않는가.

=== Files ===
http://chortle.ccsu.edu/java5/Notes/chap03/ch03_12.html

하드디스크와 같은 Secondary 메모리 장치는 프로그램과 프로그램에서 사용하는 '''오랜 시간동안 저장해야 하는''' 정보를 저장하기 위해서 사용한다. 표계산 프로그램과 표계산에 사용된 가계부 데이터가 그 예가 될 것이다. 이러한 정보들은 '''file'''의 형태로 저장된다. 
  파일은 디지털 프로그램과 데이터가 저장된 객체다. 이들을 사용하기 위해서 각 파일에 이름을 붙이게 된다.

파일에 저장된 정보라고 해서, 특별할건 없다. 모두 비트의 8묶음으로 이루어진 바이트들의 나열들이다. 파일들은 보통 수 Kbyte에서 Mega Byte 정도의 큰 크기를 가지고 있다.

여러분은 어떤 프로그램을 실행하고자 할때, 해당 프로그램의 파일명을 '''프롬프트'''상에서 입력하고 엔터키를 누르면 된다. 예를 들어 웹 서핑을 위해서 firefox(:12)를 실행하고자 한다면, 도스 프롬프트 상에서 다음과 같이 파일이름을 입력할 것이다. 
{{{#!plain
C:\> firefox.exe
}}}

리눅스를 사용하고 있다면, 파일이름에 약간의 차이가 있을 것이다.
{{{#!plain
# firefox
}}}

이렇게 파일이름을 입력하고 엔터키를 누르면, 운영체제(:12)는 하드디스크에서 firefox(혹은 firefox.exe)를 찾게된다. 그 다음 하드디스크에 있는 내용을 메인 메모리로 카피하고 실행시키게 된다. 프로그램을 실행시키게 되면 다양한 데이터들이 생성되는데 - 이경우 방문한 웹페이지의 cache, cookie, 북마크 기록등 - 이들은 메인 메모리에서 파일로 다시 저장이 된다.

  '''문제'''
  일반적으로 프로그램이 실행된 (오랜시간 저장될 필요가 있는)결과 데이터들은 어디에 저장하는가.

=== 파일과 운영체제 ===
http://chortle.ccsu.edu/java5/Notes/chap03/ch03_13.html

일반적으로 메인 메모리바깥에 있는 모든 데이터들은 '''파일'''의 형태로 존재한다. 이렇게 파일의 형태로 존재하는 데이터를 관리하는 것은 운영체제가 담당하는 가장 중요한 일중의 하나다. 만약 컴퓨터가 네트워크 시스템에 포함되어 있다면, 이러한 일은 다수의 운영체제가 협력하는 가운데 수행되게 될것이다. 

응용 프로그램은 직접적으로 파일을 읽고, 생성하고 쓰는 일을 할 수 없다. 이러한 모든일은 운영체제에 요청하는 방식으로 이루어진다. 예를들어 계산기프로그램이 계산한 결과를 파일로 저장하고자 한다면, 다음과 같은 일이 발생한다. 
 * '''프로그램''' : 운영체제에게 ''RESULT.DAT''파일을 생성하겠다고 요청을 한다.
 * '''운영체제''' : 요청을 받은다음, 디스크에서 사용가능한 공간을 찾은 다음 빈파일을 생성한다. 작업의 완료후 프로그램에게 알려준다.
 * '''프로그램''' : 운영체제에게 결과숫자를 파일로 저장할 것을 요청한다.
 * '''운영체제''' : 프로그램의 메인 메모리로 부터 숫자를 받은다음, 파일로 쓴다. 작업을 완료하면 프로그램에게 알려준다.
 * '''프로그램''' : 다음일을 진행한다.

이렇게 응용 프로그램은 그 실행중에 끊임없이 파일관련 작업에 대한 요청을 하고 거기에 대한 응답을 받기 위해서 운영체제와 상호작용을 한다. 만약에 어떤이유로  손상된 파일 공간을 발견했다거나 하는등으로 파일 작업에 실패하게 되면, 운영체제는 요청에 대해서 '''거절''' 메시지를 보내게 된다.

   '''문제'''
   현대의 컴퓨터 시스템은 단지 운영체제만이 직접 디스크의 파일에 접근할 수 있도록 하고 있다. 이것이 의미하는 바에 대해서 생각해 보자.
     1. 시스템 보안의 측면
     1. 컴퓨터 게임을 하는 입장에서
     1. 프로그램을 작성하는 프로그래머의 입장

=== 파일의 종류 ===
http://chortle.ccsu.edu/java5/Notes/chap03/ch03_14.html

컴퓨터의 관점에서 보자면 모든 파일은 동일하다. 파일이 포함하는 내용이 프로그램이던지, 혹은 데이터 이던지간에 바이트의 나열 그 이상도 이하도 아니다. 그러나 이용하는 인간의 입장에서는 파일에 분명한 차이가 있다. 어떤 파일은 실행파일로 컴퓨터의 메인 메모리에 올라가서 실행이되고, 어떤 파일은 데이터파일로 메인메모리에 복사되거나 읽혀진다. 

비록 컴퓨터는 파일이 어떤 파일의 종류인지 알 수 없지만, 인간은 파일의 이름에 특정한 규칙을 줌으로써 파일의 종류를 구분하게 할 수 있으며, 또한 운영체제에 이것은 실행파일인지 아니면 데이터 파일인지 구분하도록 할 수 있다. 인간의 관점에서 파일의 종류를 쉽게 구분하기 위해서, 우리는 '''확장자'''라는 것을 사용한다. 예를 들어  '''mydata.txt'''라는 파일이 있다면 '''.txt'''가 확장자이다. 우리는 확장자를 보고 이게 일반 문서 정보를 저장하고 있는 파일이란 것을 알 수 있다. 마찬가지로 '''Firefox.exe'''는 실행가능한 파일, '''Fly.mp3'''는 음악파일, Hello.java는 자바소스파일  이라는 것을 알 수 있다. 그리고 Firefox.exe를 입력함으로써 운영체제가 해당 파일을 실행시키도록 할 수도 있다. 

윈도우 운영체제는 .exe .com의 확장자로 실행파일인지 아닌지를 구분할 수 있지만, 유닉스(:12) 계열의 운영체제는 확장자가 아닌 파일에 주어진 실행권한으로 실행가능한 파일인지 아닌지를 구분한다. 

[[category(20)]]
