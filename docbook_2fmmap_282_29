#title mmap(2)
[wiki:function_mmap(2) HTML 변환문서]

{{{#!title
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<chapter lang=ko>
<!-- 작성자 : yundream             -->
<!-- 작성일 : 2004/02/25           -->
<!-- 연락처 : yundream@joinc.co.kr -->

<!-- 함수 이름을 입력합니다 -->
<title>mmap(2)</title>

<!-- 이건 함수에 대한 대략적인 설명이구요 -->
<para>
	파일이나 장치를 메모리에 대응시키거나 푼다.
</para>
 
<!-- 여기에 함수의 간단한 사용법이 들어갑니다 -->
<section>
	<title>사용법</title>
	<para>
		<screen>
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;

#ifdef _POSIX_MAPPED_FILES
void * mmap(void *start, size_t length, int prot, int
        flags, int fd, off_t offset);
int munmap(void *start, size_t length);

#endif
		</screen>
	</para>
</section>

<!-- 여기엔 함수의 자세한 설명 이 들어갑니다 -->
<section>
	<title>설명</title>
	<para>
		mmap() 함수는 <emphasis>fd</emphasis>로 지정된 파일(혹은 다른 객체)에서
		<emphasis>offset</emphasis>을 시작으로 <emphasis>length</emphasis>바이트
		만큼을 <emphasis>start</emphasis>주소로 대응시키도록 한다. start주소는 
		단지 그 주소를 사용했으면 좋겠다는 정도로 보통 0을 지정한다. mmap는
 		지정된 영역이 대응된 실제 시작위치를 반환한다. 
		<emphasis>prot</emphasis>인자는 원하는 메모리 보호모드를 설정한다. 
		사용할 수 있는 비트는 다음과 같다. 
		<variablelist>	
			<varlistentry>
			<term>PROT_EXEC</term>	
			<listitem>
				<para>
					페이지는 실행가능하다.
				</para>	
			</listitem>
			</varlistentry>

			<varlistentry>
			<term>PROT_READ</term>	
			<listitem>
				<para>
					페이지는 읽을 수 있다. 
				</para>	
			</listitem>
			</varlistentry>

			<varlistentry>
			<term>PROT_WRITE</term>
			<listitem>
				<para>
					페이지는 쓰여질 수 있다. 
				</para>	
			</listitem>
			</varlistentry>

			<varlistentry>
			<term>PROT_NONE</term>
			<listitem>
				<para>
					페이지는 접근할 수 없다. 
				</para>	
			</listitem>
			</varlistentry>
		</variablelist>	
		<emphasis>flags</emphasis>는 대응된 객체의 타입, 대응 옵션, 대응된 
		페이지 복사본에 대한 수정이 그 프로세스에서만 보일 것인지 아니면, 
		다른 참조하는 프로세스와 공유할 것인지를 설정한다. 다음과 같은 비트들을
		사용할 수 있다. 
		<variablelist>	
			<varlistentry>
			<term>MAP_FIXED</term>	
			<listitem>
				<para>
					지정된 주소 이외의 다른 주소를 선택하지 않는다.
					지정된 주소가 사용될 수 없다면 mmap()는 실패한다. 
					만일 MAP_FIXED가 지정되면, <emphasis>start</emphasis>는
					페이지 크기의 배수이어야 한다. 이 옵션은 사용하지 않는 것이
					좋다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>MAP_FIXED</term>	
			<listitem>
				<para>
					지정된 주소 이외의 다른 주소를 선택하지 않는다.
					지정된 주소가 사용될 수 없다면 mmap()는 실패한다. 
					만일 MAP_FIXED가 지정되면, <emphasis>start</emphasis>는
					페이지 크기의 배수이어야 한다. 이 옵션은 사용하지 않는 것이
					좋다.
				</para>	
			</listitem>
			</varlistentry>

			<varlistentry>
			<term>MAP_SHARED</term>	
			<listitem>
				<para>
					대응된 객체를 다른 모든 프로세스와 공유한다.
				</para>	
			</listitem>
			</varlistentry>

			<varlistentry>
			<term>MAP_PRIVATE</term>	
			<listitem>
				<para>
					개별적인 copy-on-write 대응을 만든다.(다른 프로세스와 
					대응 영역을 공유하지 않는다).
				</para>	
			</listitem>
			</varlistentry>
		</variablelist>	
		위의 3개의 플래그는 POSIX.1b에 규정되어 있다. 리눅스는 MAP_DENYWRITE,
		MAP_EXECUTABLE, MAP_ANON(YMOUS)도 지원한다. 
	</para>
	<para>
		munmap() 는 지정된 주소 공간에 대한 대응을 푼다. 범위내의 주소에 대한
		참조 계수를 늘려서 유효하지 않은 메모리 참조로 만든다. 
	</para>
</section>

<!-- 함수가 되돌려주는 값이구요 -->
<section>
	<title>반환값</title>
	<para>
		성공시, mmap()는 내응된 영역의 포인터를 반환한다. 
		에러시에는 -1(MAP_FAILED)이 리턴되며, errno는 적당한 값으로 
		설정된다. munmap()는 0을 리턴하며, 실패시 -1이 리턴되며, errno가 
		설정된다. 
	</para>
</section>

<!-- 에러가 발생했을때 되돌려주는 값들입니다 -->
<section>
	<title>에러</title>
	<para>
		<variablelist>	
			<varlistentry>
			<term>EBADF</term>	
			<listitem>
				<para>	
					<emphasis>fd</emphasis>가 유효한 파일 기술자가 아니다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>EACCES</term>	
			<listitem>
				<para>	
					MAP_PRIVATE가 설정되어 있지만 fd가 읽을 수 있도록 열려
					있지 않다. 또는 MAP_SHARED와 RPOT_WRITE가 설정되어 있지만
					fd가 쓸 수 있도록 열려있지 않다. 
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>EINVAL</term>	
			<listitem>
				<para>	
					start나 length나 offset이 적당하지 않다. 보통 너무 크거나
					PAGESIZE 경계로 정렬되어 있지 않을 경우.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>ETXTBUSY</term>	
			<listitem>
				<para>	
					MAP_DENYWRITE가 설정되어 있으나 fd로 지정된 객체가 
					쓰기 위해 열려있다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>EAGAIN</term>	
			<listitem>
				<para>	
					파일이 잠겨 있다.
				</para>	
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>ENOMEM</term>	
			<listitem>
				<para>	
					사용할 수 있는 메모리가 없다.
				</para>	
			</listitem>
			</varlistentry>
		</variablelist>	
	</para>
</section>

<!-- 마지막으로 에제 입니다                                                 -->
<!-- 여기에는 완전한 예제가 들어가 있는데, 굳이 완전한 예제를 만들필요 없이 -->
<!-- 코드 일부분만 작성해서 올려주셔도 됩니다                               --> 
<!-- "<", ">", "&" 등은 변환해 주셔야 하는데, 귀찮으시면 :-) 변환 하지 않   -->
<!-- 아도 됩니다. 제가 검사 해서 올리겠습니다                               -->
<!-- 예제에 대한 간단한 설명을 적어주셔도 되구요                            -->
<section>
	<title>예제</title>
	<para>
		<screen>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main(int argc, char **argv)
{
    int fd;
    char *file = NULL;
    struct stat sb;
    char buf[80] ={0x00,};
    int flag = PROT_WRITE | PROT_READ;

    if (argc &lt; 2)
    {
        fprintf(stderr, "Usage: input\n");
        exit(1);
    }

    if ((fd = open(argv[1], O_RDWR|O_CREAT)) &lt; 0)
    {
        perror("File Open Error");
        exit(1);
    }

    if (fstat(fd, &amp;sb) &lt; 0)
    {
        perror("fstat error");
        exit(1);
    }

    file = (char *)malloc(40);

    // mmap를 이용해서 열린 파일을 메모리에 대응시킨다.
    // file은 대응된 주소를 가리키고, file을 이용해서 필요한 작업을
    // 하면 된다.
    if ((file =
        (char *) mmap(0, 40, flag, MAP_SHARED, fd, 0)) == -1)
    {
        perror("mmap error");
        exit(1);
    }
    printf("%s\n", file);
    memset(file, 0x00, 40);
    munmap(file);
    close(fd);
}
		</screen>
	</para>
</section>
<section>
	<title>참고문헌</title>
	<para>
		<orderedlist>
		<listitem>
			<para>
			<ulink url="http://www.joinc.co.kr/modules/moniwiki/wiki.php/mmap">mmap</ulink>
			</para>
		</listitem>
		</orderedlist>
	</para>
</section>
</chapter>

}}}
