[[TableOfContents]]

== 포인터 이야기 ==

'''작성자:''' mwyun([멍])

=== for문 예제 ===

{{{#!plain
char *str;
str = "hello";

for(; *str; str++)
     printf("%sn", str);
}
}}}

=== while문 예제 ===

{{{#!plain
/* *s는 char 형 포인터, 문자열이 들어있음 */
while (*s)
{
   /* 생략 */
   ++s;
}
}}}

=== 포인터 연산 ===

null('\0')은 문자열을 끝을 의미합니다.

결국for문 예제에서 조건식에 해당하는 코드 *str은 곧 str에 있는 들어있는 값(문자)이 null이 아닌 경우 계속 for문의 스텝을 진행합니다.

while문 예제도 마찬가지입니다.

str은 주소를 가지고 있으면 *str은 그 주소가 가리키는 메모리에 저장된 값이 됩니다.

또한 index(첨자)를 사용하여 str[i] <- 이렇게 배열의 원소를 참조할  수 있습니다.

i가 3일 때 &str[3]이나 (str+i)은 같은 주소를 가리키며, str[3]와 *(str+3)은 메모리의 내용(값)을 의미합니다.

즉 포인터 증감은 인덱스 증감하고도 같습니다.

또한 char형 배열이므로 str++이면 str주소+1바이트 주소를 나타내는 것(메모리 번지의 증가)이고,
str--이면 str주소-1바이트 주소를 나타내는 것(메모리 번지의 감소)입니다.

char 형은 저장공간이 1바이트를 차지하기 때문에  포인터는 1바이트씩 증감하게 됩니다.

만약 int 형 배열인 경우 저장 공간이 4바이트를 차지하기 때문에 포인터는 4바이트씩 증감하게 됩니다.

{{{#!plain
예) char *str="hello";
}}}

str = 0x80000000(32bit 주소 공간인 경우) 이면
str++은 char형 배열이므로 포인터는 str의 주소+1바이트
=> str = 0x80000001(0x80000000+1)

{{{#!plain
str++;
printf("%c\n", *str);
=> e
}}}

str--은 char형 배열이므로 포인터는 str의 주소-1바이트  
=> str = 0x80000000(0x80000001-1) 

{{{#!plain
str--;
printf("%c\n", *str);
=> h
}}}

gdb 같은 디버거로 str 변수의 메모리 내용을 덤프해시면 쉽게 할 수 있습니다.

str = 0x80000000 일 때

{{{#!plain
   +-----+-----+-----+-----+-----+-----+ 
   |  h  |  e  |  l  |  l  |  o  |  \0 |
   +-----+-----+-----+-----+-----+-----+
   ^     ^     ^     ^     ^     ^     ^ 
   |     |     |     |     |     |     |  
str+0 str+1 str+2 str+3 str+4 str+5 str+6 
}}}

각 원소의 주소 계산은 다음과 같습니다.

{{{#!plain
  index   시작 주소        실제 주소
    |         |              |
    V         V              V
str+0 = 0x80000000 + 0 = 0x80000000
str+1 = 0x80000000 + 1 = 0x80000001
str+2 = 0x80000000 + 2 = 0x80000002
str+3 = 0x80000000 + 3 = 0x80000003
str+4 = 0x80000000 + 4 = 0x80000004
str+5 = 0x80000000 + 5 = 0x80000005
}}}

 * index: 배열 첨자 또는 옵셋

=== 참 고 ===
참고로 str+6은 쓰레기값이 들어있던지 아니면 다른 변수가 그 메모리 영역을 쓰고 있을 수 있습니다.

그러기 때문에 잘못 접근하면 오버플로우 에러가 발생합니다.

이렇듯 항상 남의 메모리를 침범하지 않는 정확한 포인터 연산 및 메모리 관리를 해야합니다. 

메모리 릭도 메모리 관리를 잘못해서 발생한 문제중 하나입니다.
