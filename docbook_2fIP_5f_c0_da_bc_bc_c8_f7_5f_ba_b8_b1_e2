#title IP 자세히 보기
[wiki:article_IP_자세히_보기 HTML 변환문서]

{{{#!plain
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<article lang="ko">

<!--           -->
<!-- 문서 정보 -->
<!--           -->
<articleinfo>
	<title>IP (Internet Protocol)</title>

	<author>
		<surname>윤 상배</surname>

		<affiliation>
			<address>
				<email>dreamyun@yahoo.co.kr</email>
			</address>
		</affiliation>
	</author>
	<revhistory>
		<revision>
			<revnumber>0.8</revnumber>
			<date>2003년 3월 19일 23시</date>
			<revremark>이미지추가</revremark>
		</revision>
	</revhistory>
</articleinfo>

<!--                                                                 -->
<!-- 섹션 시작                                                       -->
<!--                                                                 -->
<section>
	<title>소개</title>
	<para>	
		우리는 그동안 몇번의 기사를 통해서 IP에 대해서 이미 알아보았다. 
		이번에는 IP에 대한 좀더 자세한 내용을 알아보도록 하겠다. 
	</para>	
	<para>	
		이문서는 여러분이 TCP/IP 에 대한 기본적인 이해를 하고 있다고 가정할것이다. 
		이 문서를 읽기전에 
		<ulink url=http://www.joinc.co.kr/article.php?sid=29>TCP/IP 개요</ulink>, 
		<ulink url=http://www.joinc.co.kr/article.php?sid=33>TCP/IP 개요(2)</ulink>, 
		<ulink url=http://www.joinc.co.kr/article.php?sid=36>TCP/IP 개요(3)</ulink> 
		에 대한 문서를 먼저 읽어서 TCP/IP 에 대한 어느 정도의 이해를 해놓길 바란다. 
	</para>	
</section>

<section>
	<title>IP (Internet Protocol)</title>
	<section>
		<title>IP 란</title>
		<para>
			IP 는 인터넷으로 연결된 호스트 사이에 bit 패키지(인터넷 데이타 그램)의 교환을 
			가능하도록 하기 위해 만들어진 프로토콜이다. IP는 인터넷 환경에서 host 간 데이타 
			그램의 교환을 목적으로 하므로 host-to-host 프로토콜이라고 불리우기도 한다. 
		</para>
		<para>
			IP는 addressing(주소지정) 과 데이타 그램의 단편화를 통해서 데이타 그램을 
			교환한다. 일단 보내고자 하는 크기의 데이타가 있다면, IP는 이 데이타를 
			한꺼번에 보내지 않고, 여러개의 조그만 데이타 그램으로 단편화 (fragmentation) 작업을 
			수행하게 된다. 그리고 이러한 단편화된 데이타 앞에 목적지로 찾아갈수 있도록 하기 위한 
			여러가지 정보 들을 채워 넣게 된다(이것을 IP Header 이라고 한다). 
			<figure>
				<title>단편화된 데이타들</title>
				<graphic fileref=http://www.joinc.co.kr/albums/album01/acb.gif>
			</figure>
			위의 그림을 보면 하나의 Internet Data 를 보내기 위해서 3개의 조그만 
			데이타로 쪼개고 이앞에 IP Header 을 붙였음을 알수 있다.   
		</para>
		<para>
			IP 프로토콜은 다음과 같은 몇가지 특징을 가지고 있다. 
			<variablelist>
				<varlistentry>
					<term>비신뢰성(unreliable)</term>
					<listitem>
						<para>
							IP 는 데이타 그램이 목적지로 전달될 것이라는 것을 보증하지 않는다. 
							IP 데이타 그램은 목적지로 가는 도중 여러가지 원인에 의해서 손실될수도 
							있는데, IP 헤더에는 이러한 손실을 복구하기 위한 어떠한 장치도 마련되어 
							있지 않다. 대신에 TCP 에 이러한 데이타 손실을 복구하기 위한 장치를 마련한다.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>비연결지향성(connectionless)</term>
					<listitem>
						<para>
							호스트와 호스트간에 데이타 그램을 전달하기 위하여서 세션을 
							개설하지 않는다. 모든 데이타 그램은 각각 독립적으로 
							전달되게 된다. 받는 호스트에서는 해당 데이타 그램간의 연관성에 대해서 
							전혀 알지 못한다. 만약 A와 B 데이타가 호스트로 전달되고, 
							A가 첫번째 데이타 B가 두번째 데이타라고 한다면, 받은측에서는 
							어느 데이타가 첫번째 데이타인지 알지 못한다. 또한 B데이타가 A데이타 
							보다 먼저 전달될수도 있는데, IP는 이를 교정할수 있는 장치를  
							가지지 않는다. 
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</para>
	</section>
	<section>
		<title>IP 헤더</title>
		<para>
			이번장에서는 IP 프로토콜의 헤더 포맷에 대해서 알아보도록하겠다. 
			<figure>
				<title>IP 헤더</title>
				<graphic fileref=http://www.joinc.co.kr/albums/album01/aaz.gif>
			</figure>
			<variablelist>
				<varlistentry>
					<term>Version: 4bits</term>
					<listitem>
						<para>
							IP 포맷의 버젼을 나타낸다. 현재는 주로 IPv4 가 가장 널리 쓰이며, 
							차세대 포맷으로 IPv6 가 제안되어서 조금씩 사용범위가 늘어나고 있는 추세이다. 
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>IHL(Internet Header Length): 4bits</term>
					<listitem>
						<para>
							IP 헤더의 길이다. 보통은 32bit 크기를 가지는 5개의 열로 이루어진다. 
							나마지 하나의 열은(Options, Padding)는 옵션사항이다.  
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Type of Service: 8 bits</term>
					<listitem>
						<para>
							인터넷에는 다양한 종류의 데이타 그램이 돌아다닌다. 이중 어떤것은 
							상대적으로 중요한 데이터 그램이라서 데이타 전송에 있어서 다른 
							데이타 그램보다 전송에 있어서 우선순위를 두어야 하는 그런경우가 있을것이다. 
							이럴때 Type of Service 를 이용함으로써, 데이타 그램의 전송에 대한 우선순위 
							등을 제어할수 있다. 간단한 형태의 QOS(Quality of service) 라고 볼수 있다. 
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Total Length: 16 bits</term>
					<listitem>
						<para>
							IP 헤더와 실제 데이타의 크기를 모두 합친 크기이다. 
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Identification: 16 bits</term>
					<listitem>
						<para>
							보내고자 하는 데이타 그램에 단편화(fragmentation)가 일어났을경우 
						 	단편화된 각 데이타 그램을 구분할수 있는 일련의 번호이다. 
							이 값을 이용해서 이 데이타 그램이 어떤 데이타 그램에서 단편화 된것인지를 
							알수 있다. 
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Flags: 3bits</term>
					<listitem>
						<para>
							데이타 그램의 단편화에 대한 정보를 알려주기 위해서 사용된다. 
							첫번째 비트는 예비로 사용되며, 0으로 세팅된다. 
							두번째 비트와 세번째 비트는 단편화된 데이타그램의 정보를 세팅하기 
							위해서 사용된다. 두번째 비트가 0으로 세팅되었을경우 단편화된 데이타임을
							의미하며, 1일경우 단편화 되지 않은 데이타를 의미한다. 3번째 비트가 0일경우 
							마지막 단편화 데이타 임을 나타내며, 1일경우에는 단편화된 데이타가 
							더 있다는것 나타낸다. 
							<table>
								<title>Flags 세팅</title>
								<tgroup cols=2>
								<tbody>
									<row>
										<entry>0</entry>
										<entry>예비 : 반드시 0</entry>
									</row>
									<row>
										<entry>1</entry>
										<entry>(DF) 0 = 단편화되었음, 1 = 단편화되지 않았음</entry>
									</row>
									<row>
										<entry>2</entry>
										<entry>(MF) 0 = 마지막 단편화 데이타, 1 = 단편화 데이타 더 있음</entry>
									</row>
								</tbody>
								</tgroup>
							</table>
						</para>
						<para>
							<screen>
     0   1   2
   +---+---+---+
   |   | D | M |
   | 0 | F | F |
   +---+---+---+
						</screen>
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Fragment Offset: 13bits</term>
					<listitem>
						<para>
							데이타그램에 대한 단편화가 일어났을경우 현재 데이타 그램이 원래 데이타 그램의 
							몇번째 위치부터 단편화가 이루어 졌는지를 나타낸다. 
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Time To Live: 8bits</term>
					<listitem>
						<para>
							흔히 TTL 이라고 불리우는 값으로 데이타 그램이 살아있을 시간을 지정한다. 
							시간 이라고 해서 1시간 2시간 하는 시간이 아닌, 몇개의 라우터를 이동할수 있는지를 
							명시함으로써 데이타 그램의 생존기간을 명시한다. IP 데이타 그램이 라우터를 경유하게 
							되면 라우터는 TTL 필드를 조사해서 TTL의 값에 1을 빼준다. 만약 TTL 에 16의 값이 
							세팅되어 있다면 16번째 라우터를 지날때 TTL 값은 0이 될것이며, 라우터는 이 데이타 
							그램을 전달하지 않고 drop 시켜버린다. TTL 값을 명시하는 이유는 데이타 그램이 
							라우터 상에서 무한 순환 하는 사태가 발생할수 있기 때문이다.  
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Header Checksum: 16bits</term>
					<listitem>
						<para>
							Header 정보는 고정된게 아니고 필요에 따라 바뀌게 된다(TTL 과 같은정보). 
							그러므로 헤더를 체크할수 있는 장치를 필요로 한다.  
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Source Address: 32bits</term>
					<listitem>
						<para>
							데이타그램을 보내는 측의 IP 주소이다.  
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
						<term>Destination Address: 32bits</term>
					<listitem>
						<para>
							데이타그램을 받는측의 IP 주소이다. 
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Options: 크기변화</term>
					<listitem>
						<para>
							프로그램의 특성에 의해서 특정한 기능을 추가하기 위해서 사용된다. 
							이 필드는 필수적인 것이 아니다. 데이타 그램에 보안기능을 추가하거나, 
							QOS 와 같은 기능, 혹은 라우팅관련된 부가적인 여러 기능을 추가하기 위해서 
							사용된다. 
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Padding: 크기변화</term>
					<listitem>
						<para>
							특별한 사용용도는 없다. 단지 32bit 크기를 맞추기 위해서 사용되며, 0으로 세팅된다. 		
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
			
		</para>
	</section>
	<section>
		<title>경로배정(routing)</title>
		<para>
			IP 데이타 그램의 목적지까지의 경로 배정은 Destination Address 필드에 세팅되어 
			있는 IP 주소를 통하여서 이루어진다. 일단 데이타 그램이 보내질 목적지가 LAN 상에 
		 	존재하면, 데이타 그램은 곧바로 해당 목적지 호스트로 보내어진다. 그렇지 않을경우 
			데이타 그램은 설정되어 있는 default gateway(router) 로 보내어진다. 이것은 
			router 의 ip routing table 에 의해서 목적지까지 경우되어서 최종 호스트로 
			도착하게 된다. 여기에 대한 내용들은 이미 다른 기사에서 자세히 언급되어 있음으로 
			이정도에서 끝내도록 하겠다. 
		</para>
	</section>
	<section>
		<title>데이타 단편화 (fragmentation)</title>
		<para>
			위에서 IP 헤더 필드를 설명하면서 "데이타 단편화" 에 대한 언급을 했었다. 
			이번장에서는 이러한 데이타 단편화가 일어나는 원인과 어떻게 단편화된 데이타를 
			재조합 할수 있는지에 대해서 알아보도록 하겠다. 
		</para>
		<section>
			<title>MTU(Maximum Transmission Unit)</title>
			<para>
				MTU 란 다음 호스트에 한번에 보낼수 있는 데이타 그램의 크기이다.  
				어쨋든 데이타를 한번에 몽땅 보낼수는 없으므로 호스트에서는 
				이것을 적당한 크기로 잘라내야 할것이다. 그런데 이 적당한 크기라는게 
				말그대로 적당한 크기로 망에 따라서 약간씩 그 크기가 다르며, 각 망에서 
				통신하기에 가장 최적화된 크기의 MTU를 가지고 있다. MTU 사이즈는 
				헤더를 제외한 data 만의 크기이다. 
			</para>
			<para>
				이러한 MTU 사이즈는 여러번의 테스트를 걸쳐서 각망에 최적화된다라고 생각되는 
				실험적인 크기로 정해진다. 우리가 보통 사용하는 이더넷 망의 경우 1500,  
				ATM 망의 경우 9600 의 사이즈를 가지며, SLIP 의 경우 576 의 크기를 가진다. 또한 
				이 값은 망 상태에 따라서 네트웍 관리자에 의해서 임의로 조정될수 있다. 
				<screen>
[root@localhost root]# ifconfig
eth0      Link encap:Ethernet  HWaddr 00:50:BF:2C:7B:B2  
          inet addr:192.168.0.4  Bcast:192.168.0.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:355481 errors:1 dropped:0 overruns:0 frame:0
          TX packets:360573 errors:0 dropped:0 overruns:0 carrier:0
          collisions:5023 
          RX bytes:369176288 (352.0 Mb)  TX bytes:33374363 (31.8 Mb)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:68 errors:0 dropped:0 overruns:0 frame:0
          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 
          RX bytes:3400 (3.3 Kb)  TX bytes:3400 (3.3 Kb)
				</screen>
				이러한 MTU 의 크기는 ifconfig 를 통해서 확인 가능하며, 변경도 가능하다. 위의 ifconfig 정보는 
				필자의 리눅스박스에서 측정한 크기이다. 필자의 리눅스 박스는 보통의 이더넷카드를 이용하므로 
				MTU 1500 으로 세팅되어 있다. 
			</para>
		</section>
		<section>
			<title>단편화및 재조립</title>
			<para>
				인터넷은 다양한 환경을 가지는 망으로 서로 연결되어 있음으로, 데이타 그램이 목적지로 
				이동하는 동안 다양한 MTU 크기를 가지는 망을 통과하게 된다. 만약 1500 의 MTU 크기를 가지는 
				호스트에서 만들어진 데이타 그램이 576 MTU 크기를 가지는 SLIP 를 통과하게 되면 어떻게 될까 ?
				1500 의 크기로는 576 크기를 통과할수 없음으로, 576 크기에 맞도록 데이타가 단편화 되게 된다. 
				<screen>
   IPH : IP Header
   +-----+------------------------+
   | IPH | 1500                   | 
   +-----+------------------------+
  
   +-----+-----+  +-----+-----+  +-----+-----+
   | IPH | 576 |  | IPH | 576 |  | IPH | 348 |
   +-----+-----+  +-----+-----+  +-----+-----+
				</screen>
				위의 그림처럼 1500 데이타는 2개의 576크기를 가지는 데이타 그램과 348 크기를 가지는 데이타 
				그램으로 단편화 되게 될것이다. 또한 이 데이타 그램은 단편화 된다고 하더라도, IP 데이타 그램의 
				특성을 가져야 함으로 각각 IP 헤더를 가지는 완전한 IP 데이타 그램의 형태가 될것이다.   
			</para>
			<para>
				이렇게 단편화 되어서 전송되는 데이타 그램의 경우 목적지에 서로 다른 순서로 도달할수가 있을것이다. 
				그러므로 단편화 작업을 수행할때, 각각의 단편화된 데이타 그램이 원래의 데이타그램의 어떤 위치에서 
				단편화 되었는지등의 정보를 넣어둠으로써 최종도착지점에서 단편화된 데이타를 
				다시 조립할수 있도록 만들어줘야 할것이다. 이러한 작업은 
				커널의 IP를 담당하는 모듈에서 자동적으로 수행하며, IP 테이블의 Flags 와 Fragment Offset 
				필드를 수정함으로써 단편화 정보를 유지하게 된다. 여기에는 현재의 데이타 그램의 단편화가 되어있는지 
				단편화가 되어 있다면, 어떤 데이타그램에서 단편화 된것인지,  
				몇번째 단편화 데이타 인지, 마지막 단편화 데이타 인지, 원래 데이타 그램에서 
				offset 은 어느정도가 되는지등의 정보가 들어가게 된다. 최종적으로 목적지에서는 
				데이타 그램의 Identification 과 Flag, Fragment Offset 을 이용해서 단편화된 데이타를 
				재조립하게 될것이다. 
			</para>
		</section>
	</section>
	<section>
		<title>IP 헤더의 예</title>
		<para>
			다음은 IP 헤더의 가장간단한 예로 단편화가 일어나지 않은 데이타 그램의 IP 헤더의 형태이다. 
			<screen>
    0                   1                   2                   3  
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 5 |Type of Service|        Total Length = 168     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Identification = 111     |Flg=0|   Fragment Offset = 0   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Time = 123  |  Protocol = 1 |        header checksum        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         source address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      destination address                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     data      |                                               
   +-+-+-+-+-+-+-+-+                                               
			</screen>
			데이타 그램의 총 크기는 168bit 이고, 이중 헤더의 크기가 160bit 데이타의 크기가 8bit 임을 
			알수 있다. IPv4 버전이며, 단편화가 일어나지 않았(Flg=0)음을 알수 있다. 
		</para>
		<para>
			이번에는 좀더 복잡한 예로, 단편화가 일어난 데이타 그램의 경우이다. MTU 사이즈는 2048 이며, 
			보내고자 하는데이타의 크기는 2500 이라고 가정하겠다.  
		</para>
		<para>
			이것은 첫번째 데이타 그램이다. 
			<screen>
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 5 |Type of Service|       Total Length = 2208     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Identification = 112      |Flg=1|     Fragment Offset = 0 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Time = 119  | Protocol = 6  |        Header Checksum        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         source address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      destination address                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   \                                                               \
   \                                                               \
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			</screen>
			데이타 그램의 총크기는 2048 + (32*5) = 2208 이 될것이다. 
			데이타 그램의 단편화가 이루어졌음으로 Flg = 1 이 세팅된다. 
			그리고 단편화된 데이타 중 첫번째 데이타 그램이므로 Fragment Offset 는 0이 
			될것이다.  
		</para>
		<para>
			다음은 두번째 데이타 그램이다. 
			<screen>
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 5 |Type of Service|       Total Length = 612      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Identification = 112      |Flg=0|  Fragment Offset = 2048 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Time = 119  | Protocol = 6  |        Header Checksum        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         source address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      destination address                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   \                                                               \
   \                                                               \
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             data              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			</screen>
			Identification 이 112 임을 주목하라. 마지막 단편화 데이타 이므로 
			(더이상 단편화된 데이타가 없음) Flg 가 0으로 세팅되어있다. 
			이 데이타 그램의 Total Length 는 (32 * 5) + (2500 - 2048) = 612 
			가 될것이다. 그리고 이 단편화된 데이타 그램이 원래 데이타 그램에서 
			단편화된 위치는 2048 이 될것임으로 Fragment Offset 는 2048 이 
			될것이다.  
		</para>
	</section>
</section>
<section>
	<title>결론</title> 
	<para>
		이상 IP 프로토콜에 대한 좀더 자세한 내용들을 알아보았습니다. 
		이러한 내용들에 대한 좀더 자세한 내용을 원한다면 
		<ulink url=http://rfc.sunsite.dk/rfc/rfc791.html>RFC791</ulink> 와 
		W. Richard Stevens 의 TCP/IP Illustrated Volume 1 을 참고하기 바랍니다. 
	</para>
</section>
</article>
}}}
