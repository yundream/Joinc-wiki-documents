#title HTTP 프로토콜 분석

== HTTP 프로토콜의 성공 ==
'''H'''yper'''T'''ext '''T'''ransfer '''P'''rotocol 프로토콜은 TCP/IP와 함께 지금의 웹이 있게한 일등공신이라고 해도 과언이 아닐게다.   

대략 1994년 쯤을 분기점으로 해서 인터넷 사용이 폭발적으로 증가하기 시작 했는데, 그 중에 웹이 있었으며 그 웹이 HTTP를 기반으로 하고 있었기 때문이다. 1992년인가 1993년인가 모자익 브라우저로 야후 사이트를 보면서 신기해 했던 기억이 새록새록 하다. 지금이야 인터넷에 연결하겠다고 마음만 먹으면 장소 불문하고 접근할 수 있지만, 당시만 해도 다이얼업 소프트웨어를 이용해서 메뉴를 한참이나 뒤적뒤적 한다음에 겨우겨우 인터넷에 연결할 수 있었다.

그로부터 대략 17년 정도가 지난 지금 인터넷 사용자가 20억이 넘었다고 한다. 하긴 페이스 북 사용자만 대략 5억 정도라고 하니 할말이 없다. 

그리고 거의 20년이 지난 지금도 여전히 HTTP(:12)은 중요한 프로토콜로 사용되고 있다. 하루가 멀다하고 새로운 기술이 나오고 폐기되고 있는 와중에 말이다!!! 아 HTTP만 말하려고 하니 좀 그렇긴 하다. TCP(:12), IP(:12)를 쌍으로 다루는 것처럼, HTTP와 HTML(:12)도 쌍으로 다루어야 할 듯 싶다.

이쯤에서 HTTP와 HTML의 차이를 분명히 하고 넘어갈 필요가 있을 것 같다. HTTP는 인터넷 상에서 파일을 주고받기 위한 규약이다. 텍스트 문서 뿐만 아니라 이미지, 사운드, 비디오, 스트리밍 데이터등 파일로 취급할 수 있는 모든 데이터를 주고 받을 수 있다. 

HTML은 HTTP로 주고 받을 수 있는 텍스트 데이터 중 하나로, 포함된 텍스트 데이터를 프리젠테이션 하기 위한 규약을 포함하고 있다. 예컨데 <Table> 태그는 표 형식으로 출력하고, <img> 태그로 가리키는 객체는 이미지 형태로 화면에 뿌려라 뭐 이런 내용을 담고 있는 언어다. 프리젠테이션 언어라고 하면 될 것 같다. 

HTTP/HTML이 성공한 이유는 다음과 같다. 
  * 투명하게 공개 됐다.
  * 매우 단순하다.
  * 텍스트 정보이기 때문에 응용 애플리케이션을 만들기가 수월하다. 

== 여전히 사용하는 프로토콜 그리고 앞으로도 ==
20년 가까이 지난 지금까지도 HTTP/HTML은 여전히 널리 사용하고 있다. 성공의 이유로 들었던 투명함, 단순함, 사용성이 여전히 인터넷시대에 유효하기 때문이다.

인터넷은 문화와 정보가 통합되며 장소와 시간을 불문한다. 그러므로 장소와 시간, 언어와 문화에 관계없이 사용할 수 있는 툴이 필요하다. HTTP와 HTML의 특징은 이러한 인터넷의 특징에 딱 들어맞는 도구다.

한때 이들 기술은 이제 역사의 뒤안길로 사라질거라고 이야기 하던 때가 있엇다. 인터넷 환경이 개선되고, HTML 같은 경우 유저 인터페이스에 대해 높아진 일반 사용자의 기대를 만족할 수 없다고 내다봤기 때문이다.  

안타깝게도 그 기대를 져버리고 앞으로도 이들 기술은 널리 사용될 것 같다. 그 근거는 이렇다.
  1. 어디에서든지 사용할 수 있다. 
    웹 브라우저면 있으면 어디에서든지 인터넷에 접속 정보활동을 할 수 있다. 웹 브라우저가 깔리지 않은 운영체제는 없다고 볼 수 있으니, 결국 기기에 상관없는 접근성을 보장해 준다는 얘기가 되겠다. 모바일 시대에 매우 중요하죠. "웹이여 안녕 이제 앱이다"라고 주장하는 사람들도 있지만, HTTP/HTML 기반의 웹은 여전히 널리 사용될 겁니다. 요즘 가상화(:12)기술이 뜨고 있죠 ? 우리는 이미 웹 브라우저라는 가상화 기술을 가지고 있습니다. 
  1. 간단한 응용 개발 
    개발자 입장에서도 HTTP/HTML은 버릴 수 없는 기술입니다. '''안심하고 사용할 수 있는 수많은 라이브러리'''와 '''지원 프로그램'''이 있기 때문입니다. 클라이언트의 시스템 정보를 주기적으로 수집하는 시스템관리 소프트웨어를 만들어야 한다고 가정해 보겠습니다. 복잡하게 생각할 필요 없이 그냥 웹 서버 설치하고, 클라이언트도 애써 만들 필요 없이 wget(:12)같은 프로그램 주기적으로 돌려서 데이터 수집하면 됩니다. 웹 서버가 무겁다구요 ? lighttpd같은 가벼운 웹서버도 있습니다. 굳이 모든 기능을 포함하는 웹 서버가 싫다면 '''grizzly''' 같은 프레임 워크 사용해서 개발하면 됩니다. 
    그것도 싫다. 하면 용도에 맞게 만들어서 사용하면 됩니다. 저 같은 경우 예전에 내부 자원을 제어하기 위해서 REST를 지원하는 간단한 웹 서버를 만들어서 사용하기도 했습니다. 어떤식으로 만들었는지는 문서 말미에 소개할까 합니다.

== HTTP 프로토콜 ==
=== 요청 헤더 ===
HTTP 프로토콜은 응답과 요청으로 나뉩니다. 이들 정보는 RFC에 자세히 명시돼 있기는 합니다. 있기는한데 눈에 들어오지 않더군요. 그래서 쉽게 실제 헤더 예를 가지고 정리를 하려고 합니다. 이 문서로는 빠르게 프로토타입을 확인하기 위한 용도로 활용하고, 자세한 내용은 RFC문서를 참고하면 되지 싶습니다.

먼저 '''요청'''입니다. 요청은 웹 브라우저가 웹 서버에 작업을 요청하기 위해서 사용합니다. 앞에 숫자는 설명을 위해서 제가 추가한 겁니다.
{{{#!plain
1 GET /cgi-bin/http_trace.pl HTTP/1.1\r\n
2 ACCEPT_ENCODING: gzip,deflate,sdch\r\n
3 CONNECTION: keep-alive\r\n
4 ACCEPT: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n
5 ACCEPT_CHARSET: windows-949,utf-8;q=0.7,*;q=0.3\r\n
6 USER_AGENT: Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.24\r\n 
7 ACCEPT_LANGUAGE: ko-KR,ko;q=0.8,en-US;q=0.6,en;q=0.4\rn
8 HOST: www.joinc.co.kr\r\n
9 \r\n
}}}
HTTP 헤더는 라인피드와 캐리지 리턴을 함께 사용합니다. HTTP 헤더를 파싱할 때 주의해야 겠지요.
  1. 필수 요소로 요청의 제일 처음에 와야 합니다. 3개의 필드로 이루어져 있습니다. 
     1. 요청 메서드 : GET, PUT, POST, PUSH, OPTIONS 등의 요청 방식이 옵니다.  
     1. 요청 URI : 요청하는 자원의 위치를 명시합니다. 웹 페이지, 이미지 등이되겠죠. 
     1. HTTP 프로토콜 : 웹 브라우저가 사용하는 프로토콜 버전입니다. (2011년 7월)현재 HTTP 최신 버전은 1.1입니다. 웹 브라우저의 프로토콜 버전에 따라서 서버의 지원기능이 달라집니다. 대부분의 웹 서버가 1.1을 지원하고 있으니, 1.1만 사용한다고 봐도 큰 무리는 없습니다. 1.1은 1.0에 '''keep-alive''', '''데이터 압축'''등의 기능을 추가 지원합니다. 
  1. 지원 인코딩 : HTTP 1.1부터 웹 서버는 네트워크 대역폭을 아끼기 위해서 데이터 압축 기능을 제공합니다. 웹 브라우저가 지원하는 인코딩을 적어보내면, 웹 서버는 이 중 지정된 방식으로 데이터를 인코딩 합니다. 만약 Proxy 서버를 개발한다면, 인코딩 부분을 삭제하는게 좋을 겁니다. Proxy 서버는 웹 문서의 본문을 수정해야 하는 경우가 있을 수 있는데, 문서가 압축돼 오면 압축을 풀어야 하기 때문입니다.  
  1. 연결 방식 : HTTP 1.1은 연결유지 (persistent connection)기능을 지원합니다. 기본적으로 웹은 하나의 요청당 하나의 연결을 맺는 방식입니다. 하나의 웹 페이지에 이미지를 포함해서 10여개의 객체가 있지만 10번 연결을 맺었다 끊어야 하는 거죠. 비효율적인 방식인데요. keep-alive를 사용하면 하나의 연결에 여러 요청을 보낼 수 있습니다. 
  1. ACCEPT : 클라이언트가 지원하는 미디어 타입
  1. ACCEPT_CHARSET : 클라이언트가 지원하는 문자 셋
  1. USER_AGENT : 클라이언트의 버전, 운영체제 등을 명시합니다. 웹 서버는 이 정보를 읽어서 클라이언트와 운영체제에 맞게 정보를 조정할 수 있습니다. 스마트폰으로 접속하면, 모바일 전용 페이지를 보여주기 위한 용도로 요즘 많이 사용하고 있죠.  
  1. ACCEPT_LANGUAGE 
  1. HOST : 정보를 요청하는 서버의 주소를 적습니다. 하나의 서버가 여러 도메인을 가지고 서비스 할 수 있기 때문에 필요한 필드죠. HTTP 1.1에는 반드시 필요합니다. 웹 서버에 따라서는 HOST가 없을 경우 기본 도메인 서버를 연결해 주기도 합니다만 원할한 서비스를 위해서는 꼭 필요합니다. 
  1. 헤더 종료 : 줄 처음에 \r\n을 명시해서, 헤더가 끝났다는 것을 서버에게 알려줍니다. POST와 같이 따로 보낼 정보가 있다면 이 후에 명시를 합니다. 
 
=== 응답 헤더 ===
응답 헤더입니다. 응답 헤더는 서버의 여러 상태 정보를 포함하기 때문에, 꽤 복잡해질 수 있죠. wget(:12)을 이용하면 헤더 정보를 가져올 수 있습니다.
{{{#!plain
1  # wget -S http://www.test.co.kr
2  HTTP/1.1 200 OK\r\n
3  Date: Fri, 08 Jul 2011 00:59:41 GMT\r\n
4  Server: Apache/2.2.4 (Unix) PHP/5.2.0\r\n
5  X-Powered-By: PHP/5.2.0\r\n
6  Expires: Mon, 26 Jul 1997 05:00:00 GMT\r\n
7  Last-Modified: Fri, 08 Jul 2011 00:59:41 GMT\r\n
8  Cache-Control: no-store, no-cache, must-revalidate\r\n
9  Content-Length: 102\r\n
10 Keep-Alive: timeout=15, max=100\r\n
11 Connection: Keep-Alive\r\n
12 Content-Type: text/html\r\n
13 \r\n
}}}
  1. wget으로 헤더 정보를 출력했습니다.
  1. 반드시 첫줄에 와야 한다. 3개의 필드로 구성돼 있습니다. 
     1. 응답 프로토콜과 버전입니다.
     2. 에러 코드죠. 
     3. 응답 메시지 입니다. 404 Not Found, 501 Internal Server Error 등의 메시지 경험해 보셨을 겁니다.
  1. 날짜죠. 
  1. 서버 프로그램및 스크립트 정보입니다.
  1. 응답헤더에는 다양한 정보를 추가할 수가 있습니다. 어떤 정보를 추가할지는 사실 사용자 마음이지요. HTTP 기반의 서버/클라이언트 제품을 만든다면, 헤더에 애플리케이션 정보를 추가해서 사용하면 됩니다.
  1. 컨텐츠의 마지막 수정일 
  1. 캐쉬 제어 방식입니다. 
  1. 컨텐츠 길이입니다.
  1. Keep Alive기능 설정입니다. 
     keep alive는 클라이언트측에 연결을 유지하라는 신호를 보내기 위해서 사용합니다. 그러면 클라이언트는 최대 timeout에 지정된 시간동안 연결을 유지합니다. 이 시간동안 클라이언트는 이미 맺어진 연결로 요청을 계속 보낼 수 있습니다. Keep Alive는 따로 자세히 설명하도록 하겠습니다. 
  1. 컨텐츠 타입이죠. 응답에 실어 보내는 컨텐츠가 HTML 문서인지, 이미지인지, CSS, JavaScript인지 혹은 다른 애플리케이션 형태인지를 알려줍니다. 

=== Keep Alive ===

=== 세션 관리 ===

=== 컨텐츠 크기 ===


{{{#!comment
작성일 : 2011/7/5일 화요일
}}}
