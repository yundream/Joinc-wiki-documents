head	1.3;
access;
symbols;
locks
	root:1.3; strict;
comment	@# @;


1.3
date	2013.04.16.04.25.34;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2013.04.16.04.03.21;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2013.04.14.13.24.32;	author root;	state Exp;
branches;
next	;


desc
@./data/text/Site_2fNetwork_5fPrograming_2fAdvancedComm_2fHTTP
@


1.3
log
@106.240.8.228;;yundream;;
@
text
@#title HTTP 프로토콜 분석

== HTTP 프로토콜 ==
=== HTTP에 대하여 === 
HTTP(Hypertext Transfer Protocol)는 인터넷상에서 데이터를 주고 받기 위한 서버/클라이언트 프로토콜이다. 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다.   

지금의 인터넷이 있게한, 가장 성공한 프로토콜 중 하나다.
=== 작동 방식 ===
서버/클라이언트 모델을 따른다. 클라이언트에서 요청(request)를 보내면 서버는 요청을 처리해서 응답(response)한다.  

{{{#!html
<img src="https://docs.google.com/drawings/d/1O6w7drXt5aw6vogI8-PRR7xA5g3ay0UmEy67fenyQ54/pub?w=831&amp;h=324">
}}}

=== URI === 
HTTP 프로토콜은 URI를 이용해서 자원의 위치를 찾는다.

[[include(man/12/URI)]]

=== 메서드 ===
메서드는 요청이 어떤 종류인지를 서버에게 알려주기 위해서 사용한다. 다음은 요청에 사용할 수 있는 메서드들이다.
  * GET : 정보를 요청하기 위해서 사용한다. (SELECT) 
  * POST : 정보를 밀어넣기 위해서 사용한다. (INSERT)
  * PUT : 정보를 업데이트하기 위해서 사용한다. (UPDATE)
  * DELETE : 정보를 삭제하기 위해서 사용한다. (DELETE)
  * HEAD : (HTTP)헤더 정보만 요청한다. 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인하기 위해서 사용한다. 
  * OPTIONS : 웹서버가 지원하는 메서드의 종류를 요청한다.
  * TRACE : 클라이언트의 요청을 그대로 반환한다. 예컨데 echo 서비스로 서버 상태를 확인하기 위한 목적으로 주로 사용한다.

보통 '''GET'''과 '''POST'''만을 이용해서 웹 서비스를 개발한다. DELETE나 PUT등이 필요한 요청에도 GET과 POST를 사용하는데, 예를들어 게시판에서 특정 레코드를 삭제 할때도 GET 으로 표현한다. 예) http://www.sample.com/bbs?id=1234&action=delete 

GET과 POST만으로도 모든 종류의 요청을 표현할 수 있기 때문이다. 반면 Restful API 서버의 경우에는 GET, POST, DELETE, PUT을 명시적으로 구분한다. 유저에게 링크가 제공되는 일반적인 웹 서비스와 달리 API의 경우에는 개발자가 직접 URI를 이용해서 애플리케이션을 개발해야 하기 때문에, 메서드의 의미가 명확하게 전달될 필요가 있기 때문이다.

=== 요청 데이터 포멧 ===
요청은 웹 브라우저가 웹 서버에 작업을 요청하기 위해서 사용한다.
{{{#!plain
1 GET /cgi-bin/http_trace.pl HTTP/1.1\r\n
2 ACCEPT_ENCODING: gzip,deflate,sdch\r\n
3 CONNECTION: keep-alive\r\n
4 ACCEPT: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n
5 ACCEPT_CHARSET: windows-949,utf-8;q=0.7,*;q=0.3\r\n
6 USER_AGENT: Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.24\r\n 
7 ACCEPT_LANGUAGE: ko-KR,ko;q=0.8,en-US;q=0.6,en;q=0.4\rn
8 HOST: www.joinc.co.kr\r\n
9 \r\n
}}}
HTTP 헤더는 라인피드와 캐리지 리턴을 함께 사용합니다. HTTP 헤더를 파싱할 때 주의해야 겠지요.
  1. 필수 요소로 요청의 제일 처음에 와야 합니다. 3개의 필드로 이루어져 있습니다. 
     1. 요청 메서드 : GET, PUT, POST, PUSH, OPTIONS 등의 요청 방식이 옵니다.  
     1. 요청 URI : 요청하는 자원의 위치를 명시합니다. 웹 페이지, 이미지 등이되겠죠. 
     1. HTTP 프로토콜 : 웹 브라우저가 사용하는 프로토콜 버전입니다. (2011년 7월)현재 HTTP 최신 버전은 1.1입니다. 웹 브라우저의 프로토콜 버전에 따라서 서버의 지원기능이 달라집니다. 대부분의 웹 서버가 1.1을 지원하고 있으니, 1.1만 사용한다고 봐도 큰 무리는 없습니다. 1.1은 1.0에 '''keep-alive''', '''데이터 압축'''등의 기능을 추가 지원합니다. 
  1. 지원 인코딩 : HTTP 1.1부터 웹 서버는 네트워크 대역폭을 아끼기 위해서 데이터 압축 기능을 제공합니다. 웹 브라우저가 지원하는 인코딩을 적어보내면, 웹 서버는 이 중 지정된 방식으로 데이터를 인코딩 합니다. 만약 Proxy 서버를 개발한다면, 인코딩 부분을 삭제하는게 좋을 겁니다. Proxy 서버는 웹 문서의 본문을 수정해야 하는 경우가 있을 수 있는데, 문서가 압축돼 오면 압축을 풀어야 하기 때문입니다.  
  1. 연결 방식 : HTTP 1.1은 연결유지 (persistent connection)기능을 지원합니다. 기본적으로 웹은 하나의 요청당 하나의 연결을 맺는 방식입니다. 하나의 웹 페이지에 이미지를 포함해서 10여개의 객체가 있지만 10번 연결을 맺었다 끊어야 하는 거죠. 비효율적인 방식인데요. keep-alive를 사용하면 하나의 연결에 여러 요청을 보낼 수 있습니다. 
  1. ACCEPT : 클라이언트가 지원하는 미디어 타입
  1. ACCEPT_CHARSET : 클라이언트가 지원하는 문자 셋
  1. USER_AGENT : 클라이언트의 버전, 운영체제 등을 명시합니다. 웹 서버는 이 정보를 읽어서 클라이언트와 운영체제에 맞게 정보를 조정할 수 있습니다. 스마트폰으로 접속하면, 모바일 전용 페이지를 보여주기 위한 용도로 요즘 많이 사용하고 있죠.  
  1. ACCEPT_LANGUAGE 
  1. HOST : 정보를 요청하는 서버의 주소를 적습니다. 하나의 서버가 여러 도메인을 가지고 서비스 할 수 있기 때문에 필요한 필드죠. HTTP 1.1에는 반드시 필요합니다. 웹 서버에 따라서는 HOST가 없을 경우 기본 도메인 서버를 연결해 주기도 합니다만 원할한 서비스를 위해서는 꼭 필요합니다. 
  1. 헤더 종료 : 줄 처음에 \r\n을 명시해서, 헤더가 끝났다는 것을 서버에게 알려줍니다. POST와 같이 따로 보낼 정보가 있다면 이 후에 명시를 합니다. 
 
=== 응답 헤더 포멧 ===
응답 헤더입니다. 응답 헤더는 서버의 여러 상태 정보를 포함하기 때문에, 꽤 복잡해질 수 있죠. wget(:12)을 이용하면 헤더 정보를 가져올 수 있습니다.
{{{#!plain
1  # wget -S http://www.test.co.kr
2  HTTP/1.1 200 OK\r\n
3  Date: Fri, 08 Jul 2011 00:59:41 GMT\r\n
4  Server: Apache/2.2.4 (Unix) PHP/5.2.0\r\n
5  X-Powered-By: PHP/5.2.0\r\n
6  Expires: Mon, 26 Jul 1997 05:00:00 GMT\r\n
7  Last-Modified: Fri, 08 Jul 2011 00:59:41 GMT\r\n
8  Cache-Control: no-store, no-cache, must-revalidate\r\n
9  Content-Length: 102\r\n
10 Keep-Alive: timeout=15, max=100\r\n
11 Connection: Keep-Alive\r\n
12 Content-Type: text/html\r\n
13 \r\n
}}}
  1. wget으로 헤더 정보를 출력했습니다.
  1. 반드시 첫줄에 와야 한다. 3개의 필드로 구성돼 있습니다. 
     1. 응답 프로토콜과 버전입니다.
     2. 에러 코드죠. 
     3. 응답 메시지 입니다. 404 Not Found, 501 Internal Server Error 등의 메시지 경험해 보셨을 겁니다.
  1. 날짜죠. 
  1. 서버 프로그램및 스크립트 정보입니다.
  1. 응답헤더에는 다양한 정보를 추가할 수가 있습니다. 어떤 정보를 추가할지는 사실 사용자 마음이지요. HTTP 기반의 서버/클라이언트 제품을 만든다면, 헤더에 애플리케이션 정보를 추가해서 사용하면 됩니다.
  1. 컨텐츠의 마지막 수정일 
  1. 캐쉬 제어 방식입니다. 
  1. 컨텐츠 길이입니다.
  1. Keep Alive기능 설정입니다. 
     keep alive는 클라이언트측에 연결을 유지하라는 신호를 보내기 위해서 사용합니다. 그러면 클라이언트는 최대 timeout에 지정된 시간동안 연결을 유지합니다. 이 시간동안 클라이언트는 이미 맺어진 연결로 요청을 계속 보낼 수 있습니다. Keep Alive는 따로 자세히 설명하도록 하겠습니다. 
  1. 컨텐츠 타입이죠. 응답에 실어 보내는 컨텐츠가 HTML 문서인지, 이미지인지, CSS, JavaScript인지 혹은 다른 애플리케이션 형태인지를 알려줍니다. 
==== 응답 코드 ====

=== Keep Alive ===

=== 세션 관리 ===

=== 컨텐츠 크기 ===


{{{#!comment
작성일 : 2011/7/5일 화요일
}}}
@


1.2
log
@106.240.8.228;;yundream;;
@
text
@d16 2
d21 10
d32 1
a32 2
=== 요청 헤더 포멧 ===
HTTP 프로토콜은 응답과 요청으로 나뉩니다. 이들 정보는 RFC에 자세히 명시돼 있기는 합니다. 있기는한데 눈에 들어오지 않더군요. 그래서 쉽게 실제 헤더 예를 가지고 정리를 하려고 합니다. 이 문서로는 빠르게 프로토타입을 확인하기 위한 용도로 활용하고, 자세한 내용은 RFC문서를 참고하면 되지 싶습니다.
d34 2
a35 1
먼저 '''요청'''입니다. 요청은 웹 브라우저가 웹 서버에 작업을 요청하기 위해서 사용합니다. 앞에 숫자는 설명을 위해서 제가 추가한 겁니다.
@


1.1
log
@106.240.8.228;;yundream;;
@
text
@d6 2
d9 9
a17 1
미완성
a18 1
미완성
@
