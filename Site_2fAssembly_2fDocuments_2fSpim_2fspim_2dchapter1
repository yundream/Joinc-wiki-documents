#title 컴퓨터 구조 와 어셈블리 언어

== Chapter 1 &#8212; 컴퓨터 구조 와 어셈블리 언어.  Computer Architecture and Assembly Language.  ==
[[TableOfContents]]

{{{#!textbox
이 노트는 미국의 중부 코넷티컷 주립대학(Central Connecticut State University)의 Bradley Kjell 교수님의 강좌노트를 번역하고 있습니다.

이 강좌는 MIPS 프로세서 에뮬레이터인 SPIM을 사용해서 밉스 어셈블리를 배우는 과정을 통해 컴퓨터 공학의 입문을 하도록 구성되어 있습니다.

추천하는 공부방법은 먼저 링크 되어 있는 원문을 읽으시고 번역을 참조하시면 영어공부와 함께 컴퓨터 공부도 하실 수 있을겁니다.

의도는 대학노트를 사용함으로써 체계적인 컴퓨터 과학의 학문적 입문을 도움과 동시에  프겔러&#54973;들의 실질적 경험적인 지식에 대한 충고를 같이 얻음으로써

프로그램밍 시작하는사람에게 기초를 제공 하고자 합니다.  원문 글들은 학문성과 정보성 그리고 원문의 의도를 유지하도록 최대한 노력해 주셨으면 하고

실질적 지식은 재미있고 전달하기 쉽게 설명하시거나 격식에 신경쓰지 않고 남겨주셨으면합니다.  

이 글을 가지고 공부하는 사람들한테 바라는것은 의문점이 있을때 이해가 가지 않는 부분이 있을때

프갤이나 다른곳을 통해 물어보고 자기가 해답을 발견했으면 그것에 대한 위키를 만들어서 이해안되는것에 문맥을 제공했으면 합니다. 

프갤이나 이곳에 글을 남기시면 누군가가 반드시 도와주는 &#54973;들이 있을겁니다.

yundream 형의 작업들을 보면서 뭔가 도움이 되었으면 하기에 이런걸 시작 해 보게되었습니다.  

꿈꾸는 사람이 있어 즐겁고 꿈이 모이면 비전이 되죠.

}}}

=== CHAPTER 1 &#8212;소개  Introduction  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_1.html

어셈블리는 프로세서를 운용하기 위한 프로그램의 작성을 위해서 만들어진 언어다. 흔히 저급언어라고 불리우는데, 이는 프로세서가 이해할 수 있는 가장 단순한 몇개의 명령의 조합을 통해서, 컴퓨터가 이해하고 실행가능한 프로그램을 만들어내기 위한 언어이기 때문이다. 이 문서는 여러가지 종류의 프로세서중 MIPS R2000 프로세서에서 실행되는 프로그램의 작성을 돕기 위한 문서이다. 일반적으로 이러한 문서는 실질적인 하드웨어를 사용해서 설명을 하는게 가장 좋은 방법이겠지만, 하드웨어를 장만하고 필요한 개발 환경을 구축하는데 어려움이 있을 수 있기 때문에, 이의 시뮬레이터인 SPIM을 사용한다. SPIM은  http://www.cs.wisc.edu/~larus/spim.html 에서 다운받아서 사용할 수 있다.

컴퓨터는 주어진 일을 실행하기 위한 기계이다. 모든 기계는 주어진 일을 효율적으로 실행하기 위한 구조(아키텍처)를 가지고 있는데, 컴퓨터는 각 구성요소의 논리적연결과 이들 구성요소를 다루기 위한 기본수행명령의 구조를 가진다.

순수한 관점에서 어셈블리 언어는 각 기본명령과 일대일로 대응할 수 있는 "인간의 관점에서 해석가능한" 명령을 제공하게 된다. 예를들어 프로세스에게 "더하라"라는 명령을 내리려고 한다면, 이진수로 이루어진(0110 과 같은) 명령을 전달해야 하는데, 이진수는 인간이 이해하기에 매우 어렵다. 그래서 0110과 바로 대응되는 '''add''' 와 같은 명령어를 제공하는 것이다.

이처럼 어셈블리어는 프로세서 이해한는 기계어와 일대일로 대응이 되며, 프로세서에 직접적으로 명령을 내리는 것이기 때문에, 어셈블리어를 제대로 이용할려면 프로세서의 작동방식에 대한 이해를 반드시 하고 있어야 한다. 우리가 영어를 제대로 구사하기 위해서는 영어문화권의 문화와 사회를 제대로 이해하고 있어야만 하는 것과 마찬가지이다. 

어셈블리어는 프로세서에 직접 명령을 내리는 방식이기 때문에, 자기가 원하는 바를 매우 섬세하게 프로세서에 전달할 수 있다는 장점을 가지지만, 프로세서의 작동방식을 명확히 이해하고 있어야만 한다는 단점을 가지고 있다. 또한 프로세서마다 작동방식이 다르기 때문에, 다른 프로세스가 나올때 마다, 이에 대한 별도의 학습이 필요하다는 단점을 가진고 있다. 때문에 최근에는 어셈블리어와 같은 언어보다는 C나 C++과 같은 고급언어를 이용해서 프로그램을 작성하는 경우가 많다. 또한 어셈블리어 역시 인간이 좀더 다루기 쉬운 향상된 형태로 제공되는 경우가 많다. 

이와 같이 향상된 어셈블리어는 인간이 좀더 다루기 쉽도록 도와주기 위한 다양한 명령과 기능을 제공하고 있다. MIPS의 어셈도 마찬가지로 확장된 어셈블리어를 제공하기 때문에, 좀더 사용하기 쉽기는 하겠지만.. 여전히 프로세서의 세부적인 작동방식을 이해하고 있어야만 한다. 위에서 C(:12)/C++같은 고급언어의 경우에는 프로세서의 세부적인 작동방식을 이해하고 있을 필요는 없다. 왜냐하면, 인간이 이해하기 쉬운 코드를 만들어내면, 이것을 c혹은 c++ 컴파일러가 해당 프로세서가 이해할 수 있는 어셈블리어로 '''변환''' 시켜주기 때문이다. 때문에 Intel 계열 프로세서에서 작동하도록 만들어진 C프로그램은 거의 코드의 변환 없이 Sparc 프로세서에서도 작동을 한다. 단지 컴파일만 새로 해주면 Sparc 프로세서가 이해가능한 어셈블리어로 변환시켜준다.


최근에는 java처럼 아예 가상의 머신위에서 작동하는 프로그램을 만들기도 한다. java가 작동할 수 있게끔 제공되는 가상 머신을 jvm이라고 하는데, 가상머신위에서 작동하기 때문에, C/C++과 같이 다시 컴파일할 필요조차 없이, 모든 플렛폼에서(물론 jvm은 설치되어 있어야 하겠지만)동일하게 작동되는 프로그램을 만들 수 있다. 

어셈블리어에 대한 기본적인 소개를 마치고, 이제 어셈블리어에서 사용되는 기본적인 용어에 대해서 알아보고 넘어가도록 하겠다.

질문: 모든 프로세서 칩이 같은 구조를 가지고 있습니까?

{{{#!comment
HLA
확장된 Assembly중에는 고수준 언어처럼 사용할 수 있게끔 만들어 진것들도 있다. 
관심이 있다면 http://webster.cs.ucr.edu/AsmTools/HLA/index.html 를 참고하기 바란다.
}}}

=== 다양한 프로세서 구조들 Different Processor Architectures ===
[http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_2.html]
답:아니오. MIPS,PIC,SPARC,Alpha,Motorola,Intel과같이 각기 다른 프로세서 family는 독자적인 구조를 가지고 있습니다. 
[[Image(levels.jpg,0,0,right,)]]
칩의 기본적인 구성요소들(components)과 기본적인 연산(operations)을 설명하는것이 곧 컴퓨터의 구조를 설명하는것이라고 할 수 있다.

각각의 프로세서군에는 그들만의 독자적인 구조가 있다. 어셈블리로 프로그래밍 한다는말은 바꿔말해 특정한 프로세서의 구조에서 작동하는 프로그램을 작성하것이라 할 수 있다. 프로세서군마다 각기 독자적인 어셈블리 언어를 가지고 있다. 여러분이 어셈블리 언어를 공부한다는 말은 다시말해 특정한 프로세서의 구조를 공부하는 것이다. 

프로세서의 종류만큼 어셈블리어를 공부해야 하는게 아닌가라고 걱정할 수 있을 것이다. 여러분이 어떤 한종류의 어셈블리 언어공부하게 되면 어셈블리를 통해 컴퓨터 구조를 이해하고 전문성을 높일 수 있게된다. 이러한 전문성은 다른 종류의 프로세스에도 거의 그대로 적용되므로, 하나를 제대로 익혀두기만 하면, 다른 프로세스로의 적용이 큰 문제가 되지는 않는다. 

프로세서의 이름이 틀려도 근본적인 구조는 동일하며, 그 위에서 사용되는 어셈블러라는 언어도 공통적인 것이기 때문이다.

이 문서는 컴퓨터공학의 관점에서 어셈블리언어를 설명하며 또한 어셈블리어를 통해서 어떻게 컴퓨터가 작동하는지를 설명할 것이다.  이 것은 그림에서 보듯이 컴퓨터의 전기회로적인 영역과 그리고 오퍼레이팅 시스템의 영역의 관점에서 컴퓨터를 살펴보는 보는 것이 될 것이다. 이렇게 해서 여러분은 컴퓨터 과학자들이 그러하듯이 좀더 다양한 시각에서 컴퓨터를 이해하고, 컴퓨터를 이루는 여러 영역들이 어떻게 상호작용하는 지도 이해하게 될 것것이다. 그림에서와 같이 여러가지 컴퓨터 분야들이 모여서 컴퓨터 공학이라는 하나의 학문을 이루고 있다.
  * 프로그램 언어 Programming Language 
  * 응용 프로그래밍 인터페이스(API) Application Programming Interface 
  * 운영 체제 Operating System  
  * 어셈블리 언어 Assembly Language 
  * 컴퓨터 구조 Computer Architecture 
  * 전자 회로 Digital Electronics 

질문: 컴퓨터를 이해하기 위해서 꼭 특정한 어셈블리를 공부할 필요가 있습니까?

프겔러들의 수다
{{{#!textbox
안방거사  	아련한 기억이 나오 360, 8080, Z80, VAX, 그리고 더 이상 볼일이 없어졌소.
}}}

===  기초들 Fundamentals ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_3.html
답:아니오. 현대적으로 좋은 디자인을 갖춘 어셈블리어라면 어떤 어셈블리어라도 좋습니다.

MIPS의 구조는 현대적이면서도 디자인이 아주 잘 된 구조이다. MIPS 칩은 1985년에 구 디자인의 기초가 만들어졌다. MIPS의 디자인은 컴퓨터 구조에 있어 최상의 아이디어들을 담고 있다.

어셈블리로 짜진 프로그램은 기계가 단계적으로 해야 하는 일을 기계적인 측면에서 그대로 설명한다. C 나 자바와 같은 고급언어에서는 프로그래머는 컴퓨터의 구조가 어떤지 상관하지 않고 프로그램 할 수 있다. 고급언어에서는 프로세서의 종류가 어떠하든지 프로그램을 컴파일만 한 뒤에 실행시킬 수 있다.

이 노트들은 기초적인 어셈블리 수준에서 컴퓨터 구조를 공부하기 위한 것이다. 

효과적으로 컴퓨터 구조를 논하고 공부하기 위에서는 본인이 생각하기에는 어셈블리언어를 배우고 그리고 특정한 프로세서의 세세한 점도 배우고 그리고 직접적으로 프로그램들을 짜보는 것이다. 이런 게 마치 고등학교 화학 시간에 실험을 해보는 것과 같다. 고등학교에서의 화학실험은 그것이 액체의 색깔만 그럴듯하게 만드는 일처럼 보일런지도 모른다. 

그렇지만 진정한 의도는 화학의 기본을 가르치고자 하는 것이다. 만약에 여러분이 고등학교 때 그런 실험을 안 해보았다면 해보았던 사람들에 비해 화학에 대한 이해가 추상적이고 모호할 수 밖에 없을 것이다. 그리고 그런 지식은 금방 잊어버리기 쉽다.

=== 기본적인 기계 사이클 Basic Machine Cycle  ===
[[Image(machinecycle.gif,0,0,right,)]]
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_4.html

대부분의 프로세서가 3단계의 기초과정을 끝없이 반복한다.  하나의 기계 사이클(machine cycle)은 하나의 명령을 실행한다. 현대적인 프로세서에서는 초당 수십만의 기계 사이클이 가능하다. 그래서 초당 수십만의 명령을 수행하는 것이 가능하다.  

기계 명령이라는 것은 "2 개의 32-bit 정수들(integers)을 더하라"라는 명령 같은 것일 수 도 있고. 또는 "값이 0 인지 아닌지를 테스트해봐라"라는 명령 같은 것일 수 도 있다.

같은 프로세서군 들 사이에서도 기계명령의 세부적인 명령들은 다를 수 가 있다.

 1. '''명령을 불러온다.'''  명령은 메모리로부터 가져온다. 프로그램 카운터(PC)는 프로세서의 일부분이다. 프로그램 카운터(PC)는 불려온 명령이 메모리 어느 장소에 있는지를 보여준다.
 1. '''프로그램 카운터를 증가시킨다.''' 프로그램의 카운터(PC)는 이제 다음 명령을 가리킨다.
 1. '''명령을 실행한다.''' 기계명령이 지시한 연산(operation)을 실행한다. 

질문. 기본적인 머신 사이클에 의거해서 어떤 순서로 기계명령이  실행 되는가?

프겔러들의 수다
{{{#!textbox
스미골행 : 	참 고로 일반적으로 PC라고 일컬어지는 레지스터는 인텔 아키텍쳐에서는 IP(Instruction Pointer)로 불린다. 참고해라. 즉, 인텔 관련 메뉴얼 볼때 IP 얘기가 나오면.. 이게 PC랑 같은 역할이구나..이렇게 생각하면 된다. 혹시 그런거 가지고 헷갈려하는 사람 있을까봐 노파심에 적는다.
}}}
{{{#!textbox
zf : 	왜 저것밖에 없는거지? 다음 명령을 가리킵니다... 명령을 수행합니다... 더 더 더
}}}

=== 기계 명령어들 Machine Instructions ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_5.html

답: 순서대로, 하나씩 하나씩.

명령들은 정상적인 상황에서는 차례차례 순서대로 실행된다. 한번에 한명령이 실행될 때마다 메모리를 가리키는 프로그램 카운터(pc)는 증가한다 . 명령이 수행될 때마다, 다음 명령을 실행하기 위해서 프로그램 카운터는 증가되고 다음번 명령이 있는 위치를 가리키게 된다.

메모리에서 명령을 불러오고 다음 명령을 가리키고 불러온 명령을 수행하는 하나의 사이클에서 프로세서는 두 개의 인티저(Integer)들을 더 한다거나 또는 두 개의 인티저들을 비교 한다 같은 연산을 실행할 수 있다. while문 같은 반복문이나(Loops) If문 같은 제어문 또다른 표현으로 분기문(branches)같은 것은 연산 순서를 바꾼다.

하나의 기계명령이 하나의 연산을 실행 시킨다. 그리고 그 명령은 0과 1이 나열된 형태로 표현 되어있다.

이것은 MIPS프로세서가 2개의 32-bit 레지스터들을 더하도록 지시하는 기계명령이다. 레지스터는 프로세서의 일부분이고 MIPS 프로세서가 가진 레지스터는 한 개의 32bit 기계명령을 저장할 수 있다.

{{{#!plain
0000 0001 0010 1011 1000 0000 0010 0000
}}}
이 명령은 32bits의 길이 이고 각각의 빗은 0이 아니면 1 이다. 0과1의 나열인 비트 형태(bit pattern)들을 책에서 보여줄 때는 보통 이와 같이 4개씩 묵어서 보여준다. 당연히 그룹 사이에 보여주는 공백은 보기 쉽게 하기 위한 관례이지 그것이 비트 형태(bit pattern)의 일부분은 아니다.
이 32bit 명령은 더하기 하기와 두 개의 레지스터를 지정하는 것과 그 결과를 어디에 저장 할 지에대한 정보를 빗들안에 담고 있다.

질문 : 위에 있는 32bit 명령을 주목해서 보십시요. 명령의 각자리의 비트들이 무엇을 의미하는지 명확히 아시겠습니까?

=== 어셈블리 언어의 명령문 Assembly Language Statement ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_6.html
해답: 어렵다.

기계명령의 형식은 칩 설계 당시부터 고려된다. 여러분이 기계어 명령이 어떤 형식으로 구성되었는지를 모른다면 도저히 그 기계어 명령이 무엇을 의미하는지 인지 알 수 없다. 혹 기계어 명령 형식을 여러분이 알고 빗형태를 일일이 다 기억하더라도 기계 명령어를 직접 쓰면서 프로그램 하는 것은 아주 어려운일이다.

순수 어셈블리 언어에서 하나의 어셈블리 명령문은 하나의 기계어 명령이다. 일대일로 대응한다. 그래서 명령을 사용하는데 기계어 명령보다 어셈블리 어를 쓰는 것이 훨씬 쉽다. 이것은 전에 본 기계명령과 그 기계명령에 해당되는 어셈블리 명령어이다.
{{{#!plain
기계 명령                                        어셈블리 명령문

0000 0001 0010 1011 1000 0000 0010 0000         add $t0,$t1,$t2
}}}
이 명령이 의미하는 것은: $t1과 $t2 레지스터에 있는 두 정수들(integers)을 더하고  그 결과를 $t0 레지스터에 집어넣어라 이다. 어셈블리 명령문으로부터 기계명령을 만들기 위해서는 어셈블러(assembler)라는 번역 프로그램이 사용된다.

다음 사항은 어셈블리어가 기계명령어 보다 쓰기 쉬운 점을 열거해본것이다.
    * 사람이 1들과 0들의 나열들을 이해하고 기억 하고 직접 프로그램 한다는 것은 어려운 일이다.
    * 심벌(symbol) 즉 상징적인 표현을 사용함으로써 계산하는데 변수를 사용하는 것처럼 편리하다.
    * 어셈블리언어는 간결하다.

향상된 어셈블리언어는 더 많은 장점들을 가지고 있다. 예를들어  향상된 어셈블리어는 하나의 어셈블리 명령문이 하나의 기계어 명령인 일대일 명령어 뿐 만 아니라 하나의 어셈블리 명령문으로 여러 기계어 명령에 해당하는 연산을 할 수 있게하는 명령들을 포함한다. 이러한 명령들을 의사명령(pseudoinstruction)이라 한다.

질문: 여러분이 어셈블리어를 배운 뒤에 어셈블리 명령문을 작성하는 것이 어렵겠습니까?
=== 프로그램의 번역 Program Translation  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_7.html
답: 어렵지 않다.

영어로 안녕이 "hello" 이듯이 어셈블리어의 명령문이 곧 기계언어의 명령이다. 그렇지만 어셈블리어의 명령문이 실행되어지기전에 어셈블리어의 명령문은 0과1로 나열된 비트 형태(bit pattern) 즉 기계언어로 번역되어져야 한다.

어셈블리 언어의 프로그램은 어셈블리어의 명령문과 데이타를 정의하는 명령문과 번역을 돕는 추가적인 정보들로 구성 되어있다. 여기에 있는것은 어셈블리 프로그램의 일부분이고 기계언어인 0과1로 나열된 비트 형태(bit pattern)로 번역된것이다.

{{{#!plain
기계 명령                                         어셈블리 명령문
0011 0100 0000 0001 0000 0000 0000 1001          ori  $1, $0, 9
0000 0000 0100 0001 0000 0000 0001 1000          mult $2, $1
0000 0000 0000 0000 0100 0000 0001 0010          mflo $8 
0011 0100 0000 0001 0000 0000 0000 1001          ori  $1, $0, 5
0000 0000 0100 0000 0000 0000 0100 1000          div  $8, $1
}}}

옛날에는 포트란(:12)으로 쓰여진 프로그램을 실행시키기 위해선 먼저 포트란 프로그램을 어셈블리어로 해석해주는 컴파일러를 사용해야 했다. 그런 뒤에 어셈블러(assembler)가  어셈블리어를 기계언어로 번역을 해야 했고 최종적으로 그 기계언어를 컴퓨터 메모리에 올려서 프로그램을 실행했다. 현대의 컴파일러들은 소스파일을 이른바 오브젝트 모듈(object module)이라는 파일에 담겨진 기계어로 직접 번역시킨다. 오브젝트 모듈에 대해선 나중에 더 자세히 보겠다. 

일단은 포트란이 어셈블리어로 번역된다는 사실만 생각해 보자. 포트란은 일종의 고급언어다. 포트란은 컴퓨터의 구조와 상관없이 다양한 종류의 컴퓨터에서 작동된다. 포트란의 명령문은 컴퓨터의 구조에 대한 지식없이도 쓰여질 수 있다. 그리고 번역후에는 어떤 종류의 컴퓨터에서도 수행될 수 있다. 이유는 해당 컴퓨터에 맞는 어셈블리어로 번역되기 때문이다.

질문: 여러분은 코블이나 C나 파스칼이 포트란도 같은 번역과정을 거친다고 생각하십니까?

=== 다양한 번역들 Several Translations ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_8.html
답: 그렇다.

기계언어를 제외한 모든 프로그램밍언어들은 실행전에 반드시 기계어로 번역되야만 한다. 고급언어는 컴퓨터 구조에 영향을 받지 않는다. 이는 고급언어로 만들어진 코드를 각각의 컴퓨터의 구조에 맞춘 어셈블리어로 번역시키는 과정을 거치기 때문이다. 이런 이유로 고급언어는 각각의 컴퓨터 구조에 맞춰 제작된 컴파일러(compiler)가 필요하다. 언어가 현대적일수록 기계어로부터 소스코드는 더 멀어지며, 인간어에 더 가까워진다. 40년된 포트란은 최근의 언어들보다 기계어에 더 가깝다. 다음은 포트란의 명령문이다.
{{{#!plain
result = 6*alpha+beta
}}}

밑에 있는 것은 MIPS 어셈블리 언어로 그 명령문이 번역되어진 것이다.
{{{#!plain
lw  $t0,alpha           #alpha를 레지스터 $t0에 복사하라
lw  $t1,beta            #beta를 레지스터 $t1에 복사하라
mul $t2,$t0,6           #$t0 에 6 곱하고 그결과를 $2에 둬라.
add $t2,$t2,$t1       #$t2 와  $t1을 더해서 결과를 $t1에 둬라
sw  $t2,result          #답을 result에 복사해라.
}}}

밑에것은 DEC의 Vax 어셈블리어로 번역된 명령문이다.
{{{#!plain
MULL3   #6,ALPHA,R5
ADDL3   R5,BETA,RESULT
}}}

질문: VAX와 MIPS의 구조는 비슷합니까?

프겔러들의 수다
{{{#!textbox
Anonymous  	MIPS는 RISC 프로세서 답게 명령어가 조낸 제한되어 있네. VAX는 걍 메모리에서 직접 읽어와서 곱하고 더하는데 MIPS는 꼭 레지스터로 읽어와야 계산이 되잖아?
}}}

=== 기계어 Machine Language  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_9.html

[[Image(machinecycle.gif,0,0,right,)]]
답: 전혀 다르다.

어셈블리어는 "한가지의 어셈블리어"로 존재할 수 없다. C와 같은 고수준의 언어는 컴파일러가 프로세서에 맞는 코드를 알아서 만들어 주기 때문에 하나의 C언어만 존재하지만, 어셈블리는 인텔/벡스/밉스등.. 다양한 프로세서의 구조적 차이 때문에, 프로세서마다 다른 어셈블리어가 존재할 수 밖에 없다. 마치 미국에서는 영어를 사용해야 하고 일본에서는 일본어를 사용해야 어떤 일을 할 수 있는 것과 마찬가지다. VAX 프로세스에 명령을 내리기 위해서는 VAX를 위한 어셈블리어를, INTEL 프로세스에 명령을 내리기 위해서는 INTEL을 위한 어셈블리어를 사용해야 한다. 아이비엠의 메인 프레임 컴퓨터들을 위해서는 또 다른 어셈블리어가 있고 인텔 컴퓨터들을 위해선 그것에 맞는 또 다른 어셈블리어가 있다. 모든 프로세서들은 그림과 같은 기본적인 머신 사이클을 따라 간다. 

프로세서들 사이에 차이라는것은 연산상에서 세부사항에 있어서의 차이일 뿐 이다.

그림 설명
 1. 명령을 불러온다.                                    (Fetch the Instruction)  
 1. 프로그램 카운터를 증가시킨다                  (Increment the Program Counter) 
 1. 명령을 수행한다                                     (Execute the Instruction)  

어셈블리어는 특정 프로세서를 기계적 측면에서프로세서의 연산을 묘사한 것이다. 고급 컴퓨터 언어는 문제해결(problem-solving) 차원에서 연산을 묘사한다. 세상에는 복잡하고 다양한 종류의 문제와 과제들이 있다. 그렇기 때문에 그런 복잡하고 특정한 문제를 해결하기 위해서 만들어진 여러 종류의 고급언어 들이 있다.

예들들어 객체지향언어(object-oriented language)는 문제를 오브젝트를 통해 오브젝트의 차원에서 해결하려고 한다. 그렇기 때문에 연산도 오브젝트의 차원에서 묘사 된다. 만약에 주어진 문제나 과제가 고급언어에 부합한다면 고급언어에서 프로그램을 하는것이 어셈블리에서 프로그램하는 것보다 훨씬 편하다. 세상에는 다양하고 복잡한 문제들이 있고 어느 특정한 언어가 항상 최선의 해결책을 제시할 수 는 없다. 그렇기 때문에 만병통치약같이 뭐든지 쉽게 해결할 수 있는 공통된 프로그램언어란 존재하지 않는다.

어려운 질문: 어떤 종류의 문제에 어셈블리를 쓰는게 적합할까요?

프겔러들의 수다
{{{#!textbox
푼내기 : 	어셈블리어는 "한가지의 어셈블리어"로 존재할 수 없다. (번역자 주석) 기계어가 칩 설계 당시부터 고려되고 기계어와 1:1 대응하는 어셈블리어도 칩에 종속적이기 때문에 각 프로세서마다 고유한 어셈블리어를 가지게 된다.
}}}

=== 주저장 장치  Main Storage ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_10.html

[[Image(IMSAI.jpg,0,0,right,)]]
답: 문제가 특정 컴퓨터의 구조와 연관된 문제일때.... 

어셈블리는 문제가 컴퓨터 시스템의 연산에 관한 것을때 그 문제를 잘풀어줄 수 있다  어셈블리어는 운영체제,컴파일러,통신,하위 영역의 그래픽스와 프로세서의 구조와 밀접한 관련이 있는 프로그램들에 사용된다. 

대부분 이런 구조와 관련된 부분들에 어셈블리가 쓰여졌고 나머지는 주로 C와 같은 고급언어로 쓰여진다. 가장 흔한 어셈블리어의 사용의 예는 임베디드 시스템을 프로그램 할때다. 임베디드 시스템이란  마이크로 웨이프 오븐들이나, 통신 인공위성들,DVD 플레이어들,로보트들,자동차 연료시스템들,스마트 폭탄들 그리고 게임 콘솔같이 프로세서칩이 특정한 목적으로 만들어진것이다. MIPS 칩은 보통 이런 분야에 사용되고 그래서 매년 다른 프로세서들보다 더 많이 생산 된다.

이제 컴퓨터 시스템의 메모리고 관심을 옮겨본다. 8개의 비트들(bits)이 하나의 바이트(byte)를 구성한다. 하나의 비트(bit)라는 것은 하나의 켜짐/꺼짐(on/off)의 정보를 가질 수 있다. 그림에서처럼 초기의 컴퓨터들은 주메모리에 비트들의 값을 설정하는데 사용되는 일렬의 껏다 켰다하는 토클 스위치라는 것을 가지고 있었다. 사람들은 그런 토글 스위치로 부터 각각의 기계 명령 빗들을 입력합으로써 컴퓨터를 프로그램 할 수 있었다. 각각의 스위치 위에 있는 전구는 그것이 켜졌다(on)이나 꺼쪘다(off)를 보여줌으로써 값이 1 인지 0인지를 보여주었다.

현대의 컴퓨터들은 0과 1의 나열인 비트 형태들(bit patterns)을 메모리로 이동시키는데 더 편리한 방법을 가지고 있다. 프로그램의 기계명령들을 구성하는 바이트들(bytes)은 주메모리에 저장되어지고 필요에따라 프로세서로 불리어(fetch) 진다. 데이터(data) 또한 주메모리(main memory)에 저장된다. 주메모리에 데이터와 지시명령(instructions)을 함께 저장하는 것은, 현대 컴퓨터들의 기본적인  디자인이라고 할 수 있는 폰노이먼(von neumann) 기계 특징 중에 하나다.

대부분의 컴퓨터에서처럼 MIPS에서도, 주저장장치(main memory)에 올려진 각각의 바이트(byte)는 각자가 어드레스(address) 즉 주소를 가지고 있다.  주소(address)는 바이트(byte)들이 어디에 위치 했는지를 가리켜주고 정수(integer)로써 표현된다. 주소들은 0부터 약 40억 즉 4빌리온(billion)까지 사용될 수 있다. 그렇지만 MIPS의 경우에 사용자 프로그램(user program)과 데이터(data)는 처음 20억 즉 2 빌리온(billion) 주소(address)로 제한된다.

질문: 프로그램을 하기위해서 40억 바이트의 RAM 전체를 MIPS컴퓨터에 장착할 필요가 있겠습니까? (힌트: Pentium 컴퓨터 경우처럼 생각해보세요)

프겔러들의 수다
{{{#!textbox
안방거사  	임사이 사진이 돌아다니네요. 엄청 오랜만에 보오. 내 대학 2학년땐가 본 것 같은데. 1 사이클씩 연산하던 물건이었는데.
}}}

=== 구조 VS 구현 Architecture vs. Implementation  ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_11.html

답:
둘 다 40억 바이트의 RAM (4 기가 바이트)이라는 논리주소(logical address)의 범위는 같지만, 그만큼의 메모리(RAM)가 꼭 다 필요한 것은 아니다.


컴퓨터의 구조란 컴퓨터의 컴포넌트(component) 와 컴퓨터의 기본적인 연산을 설명한 것이다. MIPS 계열의 컴퓨터들은 모두 같은 어셈블리어 구조를 가진다. 그렇기 때문에 모든 MIPS 계열의 컴퓨터들에서 똑같은 어셈블리어를 사용해 프로그램 할 수 있다. 컴퓨터의 구조를 실질적으로 구현(implementation)한 전기회로(electronics)는 프로세서 칩(chip)의 버전(version)들 사이에서도 크게 차이날  수 있다.

자동차의 구조로 비유해서 생각해 보자. 운전자는 2대의 (년도가 서로다른)제규어를 놓고 볼때 2대 모두 겉으로 보기엔 외형이나 조정장치나 운전하는 방식들이 똑같은 차로 보일 수 있다. 그렇지만 두 차의 두껑을 열고 내부를 보면 전혀 다른 부품(component)를 가지고 있을 수 있다.

여기서 강조하고 싶은 말은 자동차 설계도면처럼 컴퓨터의 구조란것은 같을 수 있지만 그 구조를 구현한 것, 즉 설계에 따라 만든 실제 자동차와 같은 실질적인 구현물과 구현물의 성능은 각자 다를 수 있다는 점이다. 여러분이 실리콘 벨리에 있는 중고차 상을 방문할때 이런 점을 유념하라.

MIPS와 Pentium의 구조가 서로 다르긴 하지만, 기본적으로 폰노이만 방식의 설계를 따르기 때문에 많은 구조적 측면에서 공통점을 찾을 수 있다. (재큐어나 티코나 기본구조는 비슷하듯이)모든 자동차의 기본적 구조가 동일한 것과 마찬가지다.

그렇지만 연산(operation)의 세부사항은 완전히 다르다. MIPS나 Pentium의 구조가 다르기 때문에 서로 다른 기계어를 가지고 있고 그래서 서로 다른 어셈블리어를 가지고 있다.

어려운 질문: 기계어란게 꼭 구조가 같은 프로세서가 있어야만 실행 시킬 수 있습니까? 다시말해 구조가 서로 다른 기계어 프로그램을 구조가 서로 다른 프로세서에서 실행 할 방법이 있겠습니까? (힌트: 자바의 경우를 생각해보십시요)

프겔러들의 수다
{{{#!textbox
 졸려.  	한 명령을 excution하면서 동시에 다음 명령의 fetch등을 수행하는 형태를 Pipeline이라고 표현한다. 그래서 instruction하나만 봤을때는 1clock에 cycle이 완성되는 것은 아니지만 excution은 1clock에 하나씩 작동하는 것처럼 보인다.  	
}}}
{{{#!textbox
 푼내기  	사이클이 fetch, point to next, execute 으로만 이루어져 있고 각 1 clock에 1 excution이면 4개 이상의 파이프라인은 의미 없는 거 같은데 말입니다. 자답. 각 단계 내부 명령을 미칠듯이 쪼개놨네.. 그럼 어차피 clock은 정해져있고 단계가 늘어나는 셈이니 사이클당 clock이 늘어나도 파이프라인 갯수가 늘면 이득이란 말인가
}}}
=== 에뮬레이션 Emulation ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_12.html
[[Image(machinecycle.gif,0,0,right,)]]

답: 구조가 같은 실제 프로세서가 없어도 가능하다. 자바의 가공 머신(java virtual machine)이 자바의 .class 파일을 해석하여 실행하는것처럼 소프트웨어가 기계명령을 해석할 수 도있다.

만약에 애플컴퓨터에 인텔프로세서 에뮬레이터(emulator) 프로그램이 있다면 애플 컴퓨터에서 컴퓨터 구조가 전혀다른 인텔 컴퓨터들을 위해 만든 마이크로 소프트 윈도들의 ".exe" 같은 실행파일을 에뮬레이터 안에서 실행시킬 수 있다.

프로세서의 구조는 프로세서의 컴포넌트들 (component)과 프로세서의 기본 연산을 논리적으로 서술한 것이다. 이것은 연산을 하기위한 구조가 어떻게 구현(implemetation) 되었느냐 와는 상관이 없다. 꼭 전기회로(electronics)차원에서의 연산을 구현할 필요는 없다. 

소프트웨어적인 논리적 연산으로 구현할 수 도 있다. 소프트웨어가 프로세서의 구조를 구현하나 하드웨어로 구현하나 논리적으론 동일한 것이다. 우리는 이와같이 프로세서의 구조를 구현한 프로그램을 에뮬레이터(emulator)라고 한다. 에뮬레이터를 만드는게 힘들어서 그렇지 누군가가 다른 구조의 컴퓨터 에뮬레이터를 만들기만 한다면 어느 컴퓨터도 구조가 다른 컴퓨터의 프로그램을 애뮬레이터에서 실행 할 수 있다.

에뮬레이터는 프로세서가 기계사이클에서 하는일을 모방하고 하드웨어가 아닌 소프트웨어가 기계 사이클을 구현한다. 에뮬레이터에서  프로그래머는 하나의 기계 사이클을 모방하기위해 몇천줄의 프로그램 명령문을 써야할 지도 모르고 주인(host) 프로세서(processor)는 모방하는 기계사이클을 구현 하기위해 수많은 명령을 수행해야 한다. 그런 이유로 에뮬레이터는 에뮬레이터가 모방(emulation)하는 프로세서보다 훨씬 느리게 돌아간다.

이 수업은 MIPS의 구조를 모방하는 에뮬레이터(emulator)를 사용한다. 실질적인 기계를 사용하는것 보다 에뮬레이터(emulator)를 사용하는 대에는 여러가지 장점이 있다. 가장 큰 장점은 에뮬레이터에의해 구현된 구조가 정확하게 이 노트들에서 설명하는 구조랑 일치한다는 점이다.

여러분이 이노트들을 따라하기위해서 필요한것을 다운로드 하라. 에뮬레이터(emulator)는 PC, MAC, MIPS, LINUX등이 설치된 대부분의 데스크텁에서 실행된다. 

http://www.cs.wisc.edu/~larus/spim.html

질문: MIPS 프로세서를 위해 만들어진 MIPS 에뮬레이터를 실제 MIPS 프로세서에서 실행하는게 가능합니까?
 
=== 컴파일 따로하기 Separate Translation ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_13.html

답: 물론이다. C로 에뮬레이터를 프로그램했다고 가정하자. 그렇다면 에뮬레이터를 MIPS 컴퓨터에서 C 컴파일러로 컴파일만 한다면 MIPS 컴퓨터에서 실행 시킬 수 있다. 이러한 생각이 바로 컴퓨터 과학에서 해보는 생각들이다.

attachment:sourceTOobject.gif

프로그래머는 에뮬레이터를 주로 프로세서를 디버깅(debugging)하는데 사용했다. 에뮬레이터로 작업하는게 직접 기계로 작업하는 것 보다 쉽다. 여러분이 진정한 의미의 해커라면 MIPS에서 작동하는 인텔머신의 에뮬레이터를 가지고, 어떻게 그 인텔 에뮬레이터에서 애플 에뮬레이터를 작동시키는게 가능할까 같은것을 궁금해 해야 할 것이다. 그러한 에뮬레이터들이 존재하는 한 가능한 일이다. 

컴퓨터 세월로 따지자면 오랜 기간 동안 어셈블리는 기업용의 거대한 프로그램을 만드는데 사용되어왔다. 어셈블러(assembler)가 소스파일(source file)을 개별적으로  컴파일할 수 있다는 단한가지 이유 때문이었다. 링커(linker)는 개별적으로 컴파일한 실행물들을 나중에 결합 컴퓨터용어로는 링킹(linking)할 수 있다. 어셈블러(assember)는 하나의 소스파일(source file)을 하나의 오프젝트 모듈(object module)로 컴파일 한다. 이것을 개별 컴파일(separate translation) 또는 개별 어셈블리(separate assembly)라고 한다.

오브젝트 모듈은 기계언어프로그램을 담고 있지만 아직 실행될 준비가 안된 파일이다. 

다음과 같은 몇가지 이유때문에 아직 실행 준비가 안된 것이다. 
 1. 소스 코드가 완전히 번역되어 지지 않았을 수 있다.그렇기 때문에 더 많은 정보가 필요하다.
 1. 코드를 위한 메모리 위치나 데이터가 지정되지 않았을 수 도 있다. 
 1. 프로그램이 끝나기전에 다른 코드가 필요할 수 도 있다. 

어셈블러(assembler)는 어셈블리어로 쓰여진 하나의 소스파일을 하나(source file)의 오브젝트 모듈(object module)로 컴파일한다.

그림설명.
{{{#!plain
어셈블리 소스 코드 => 어셈블러 => 오브젝트 모듈
}}}

소프트웨어 공학적인 질문: 왜 개별적으로 소스파일들을 번역했을까요? 왜 하나의 거대한고 완전한 프로그램을 만들어서 그것을 하나의 거대한 실행물로 컴파일하지 않았을까요?

=== 올림 모듈(적재 모듈)  Load Modules   ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_14.html

답: 기업용의 거대한 프로그램은 몇백만줄일 수 도 있고 만들기 위해 몇백명의 프로그래머와 관리하는사람들이 필요하다. 모든사람이 동시에 하나의 거대한 프로그램 소스를 가지고 동시에 일한다는 것은 불가능한 일이었다.

attachment:objectTOload.gif

어셈블리어로는 큰 응용프로그램을 만들기 위해서 응용프로그램의 각 부분들을 따로 소스파일(source file)로 분리하여 작성한다. 어셈블러(assembler)는 분리된 소스파일(source file)을 오브젝트 모듈(object module)로 컴파일 시킨다. 링커(linker)가 이렇게 개별적으로 컴파일된 오브젝트 모듈을 하나의 올림모듈(load module) 즉 실행 파일로 결합 시킨다.

이것이 어느정도 큰 소프트웨어들을 짜는 방법이다. 오브젝트 모듈들은 꼭 어셈블리 소스로부터만 만들어 질 필요는 없다. C와 같은 고급언어의 컴파일러는 어셈블러(assembler)에서 나온것과 똑같은 오브젝트 모듈(object module)들을 만들어 낸다. 그림에서와 같이 오브젝트 모듈 A 는 어셈블리어에서 나온것일 수 도 있고. 오브젝트 모듈 B는 포트란에서 나온것일 수 도 있고. 오브젝트 모듈 C는 코블 프로그램에서 나온것일 수 도 있다.

예전부터 분리 번역을 지원했던 일반적인 언어는 어셈블러,포트란,코블 이었다. 예전부터, 실제에서 사용되어진 일상적 언어도 어셈블러,포트란,코블 이었다.

    * 베이직은 분리 컴파일레이션을 지원하지 않았습다
    * 그렇기 때문에 베이직은 큰 프로그램을 짜는곳에는 사용되지 않았다.

    * 파스칼도 분리 컴파일레이션을 지원하지 않았다.
    * 그래서 파스칼은 큰 프로그램을 짜는 곳에는 사용되지 않았다.

    * C는 분리 컴파일레이션을 지원한다
    * C는 이제 응용프로그램을 짜는데 주된 언어 이다.

질문: C 컴파일러에는 쓸만한 함수 라이브러리(function library)가 많다. 표준 수학함수 라이브러리(standar math library)는 sin,cos,rand같은 함수를 가지고 있다. 여러분이 생각하기에 그 라이브러리(library)라는게 뭐라고 생각하십니까?

 
=== 1장 끝  End of the Chapter ===
http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_15.html

답: 라이브러리는 오브젝트 모듈(object module)의 집합체이다. 여러분은 여러분이 직접 쓰고 컴파일 시킨 여러분의 오브젝트 모듈(object module)을 이 라이브러리(library)의 오브젝트 모듈(object module)과 링킹(linking) 시킬 수 있다.  

요약 사항
컴퓨터의 구조                           Computer architecture 
기본적인 기계 사이클과 기계명령 The basic machine cycle, and machine instructions 
어셈블리어                               Assembly language
의사명령                                  Pseudoinstructions 
프로그램의 번역                        Program translation 
주메모리                                  Main Memory
어셈블리어를 사용하는것            Uses of assembly language 
프로세서 에뮬레이션                  Emulation of a processor 
오프젝트 모듈과 컴파일 따로하기 Object modules and separate assembly 
올림 모듈(로드 모듈)                  Load modules 

1장에 대한 퀴즈를 꼭풀어보세요. http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01quiz.html

=== 프갤러들의 수다 ===
==== 그런데 스미골행형  MIPS를 많이 쓰긴 써요? ====
 1. '''eKFR'''    플스에도 MIPS CPU를 쓰지요. 	
 1. '''스미골'''ㅤㅎㅐㅎ 많 이 쓰지. PC만 컴이 아니니까. 임베디드 컴퓨터를 다 고려했을 때, PC(Personal Computer)가 차지하는 비율은 그다지 크지 않아. 컴퓨터 과학 혹은 컴퓨터 엔지니어링을 하는 사람으로서, 컴퓨터를 추상적으로 바라보아야지, 꼭 책상위에 있는 것만 컴퓨터라고 봐서는 안돼. 	
 1. '''스미골'''ㅤㅎㅐㅎ 	그 런데 어셈블리어 처음 시작할 거면, 인텔 기반에서 시작하는 게 그나마 자료를 많이 구할 수 있어서 좋지 않나 생각된다. 한번 그 개념을 익히면, 다른 플랫폼에서도, high level language로 프로그래밍을 할 때에도 다 그 지식을 써먹을 수가 있어. 직접적이든, 간접적이든.. 	
 1. '''자바하는넘''' 	그 런데 좀 인텔로 쓴게 부담스러운 것 같에서요. 이 교수가 쓴 접근이 좀 첨배우는 사람들이나 컴퓨터 입문하는사람들을 위해서 쓴글이래서 좀 쉽게 접근하는것 같습니다. 어셈배운다고 첨에 맨땅에 헤딩하는것보다. 에뮬레이터로 감이래도 잡고 들어가면 컴기초도 되고 맨땅에 헤딩해서 대갈빡 터지는일은 면할것 같에서요. 행님들이 한마디 툭툭던져주시면 그 내용 그대로 올립니다. 보태거나 더하시고 싶으시면 위키에서 수정하세요. 	
 1. 푼내기 	인텔이 부담스러우면 그나마 덜 부담스러운 ARM으로 시작하세염 최신 x86은 레지스터도 조낸 압박이고 벼라별 기술 다 들어가서 기반지식 없이 무작정 들이댈라니 머리 아프던데 ARM은 그런거 없지 말입니다. 낄낄 	
 1. '''자바하는넘''' 	푼내기 엉아도 임베디드여요. 얼라들 위해 한마디씩 다덜 혀줘요. 내가 역겨서 삽질하는데. 뭐 이런삽질은 해도 된다 생각하니까. 	
 1. '''푼내기''' 	근 데 사실 arm 같은건 막상 할라고 해도 arm에서 직접 cpu를 만드는게 아니라서 삼성 s3c 계열로 많이 공부하는데 일단 진입장벽은 arm 계열에서는 ARM7 core 쪽이 인스트럭션도 적고 레지스터도 적고 해서 시작하기 좋고 x86 계열이면 일단 자료는 arm에 비하면 개없지만 80386 부터 시작. 글고 가능하면 reference guide나 text물은 어디서 구하든 구해서 개발하기 전에 읽어보는 것을 강추. 요즘 arm 관련 책 많으니까 대형서점가서 휘휘 둘러보다가 자신한테 알맞는 책 사서 보면 되겠지 말입니다. 	
 1. '''푼내기''' 	솔 직히 임베디드는 장비 없으면 연구, 개발 자체가 개삽질이지 말입니다. s3c2410이나 s3c2420, 2440, 24a0 kit 가지고 뭐든지 삽질해보는 수 밖에 없지 말입니다. 첨부터 eLinux 올릴라다가는 가랭이 째지지 말입니다. Line LCD에 자기 이름 찍는거부터 시작 거거 	
 1. '''푼내기''' 	s3c 킷 가격 부담되면 임베디드 개기초라고 하는 8bit 프로세서 8051로 직접 뚝딱거려가며 땜질하고 만들어서 차근차근하는 것도 좋지 말입니다. 
 1. '''푼내기''' 	참 SD메모리에도 arm7 core 들어간다는데 확인된 바는 없지 말입니다. arm은 내가 봤을 때 소프트웨어 개발회사로 거듭나겠다던가 하는 개삽질하지 않는 이상 최소한 10년동안은 망할테니 임베디드 관심있는 사람은 arm core 공부해두면 임베디드 분야에서도 떠오르고 있는 신예니 나쁘지는 않을거지 말입니다. 	
 1. '''푼내기''' 	참 고로 초거대 반도체 회사 TI가 생산하는 DSP 전부 arm core로 되어있지 말입니다. 언어는 C 쓰는데도 있고 C++쓰는데도 있지 말입니다. 임베디드 운영체제는 Nucleus Plus나 psos, PrOS였던가 그런거랑 QUALCOMM이 뚝딱거리는 REX 등이 있지 말입니다. 임베디드 리눅스 쓰는건 내가 놀고 있는 동네가 그래서 그런지 딱 한번 봤지 말입니다. 그것도 선행연구과제로. 	
 1. '''대학원생''' 	MIPS 나 ARM이나 같은 RISC니까 ISA는 비슷할걸요? 인텔은 GG -_- 그리고 전 연구실에서 어셈으로 코딩도 많이하고 했는데 진짜 실력은 아키텍처 매뉴얼보고 디테일한 부분들을 이해할 수 있는 능력이지 어셈으로 코딩을 할 수 있느냐 아니냐의 문제는 아닌 것 같아요. 어셈 코딩은 ISA만 알면 누구나 하거든요. 	
 1. '''zf''' 	"컴터 이래 돌아간다" 를 알고싶다. 그럼 Assembly 바라. 끝. 	
 1. '''푼내기''' 	사 실상 임베디드라고 해도 보통은 부트스트랩 코드만 빼면 어셈블리어는 별로 나오지도 않으니까 임베디드 시스템을 얼마나 잘 이해하느냐가 관건이 되겠고 대학원생ㅎㅛㅇ이 말한 아키텍쳐 메뉴얼보고 이해해한다는 거도 저 시스템의 이해라는 거에 포함된다고 보고 말입니다. 어쨌든 Non-OS based든 OS based 분명한거는 임베디드 시장 쥐젖같아 보여도 기본기만 다져두면 써먹을데는 천지삐까리라는 거지 말입니다. USB 허브에도 쓰이고 하튼 안쓰이는데는 없으니 임베디드 시스템 기본이라고 할 수 있는 RISC CPU 기본 개념은 알고 있어야지 말입니다. 보통 필드에서는 core 하나만 따로는 잘 안쓰고 DSP나 Add-on해서 쓰지 말입니다.

==== 진정한 프로그래머가 되고 싶어서 왔어요. 어떻게 시작해야 할지.. ====
읽기 좋게 공백 많이 넣었으니까 관심있는 사람만 봐.
프갤에는 장차 프로그래머가 되고 싶어하는 &#54973;아들이 참 많아.
그런데 그런 &#54973;아들 대부분이 막연하게 프로그래머가 되고 싶어하는 &#54973;들이야.
근데 일단 프로그래머가 되고 싶다고 마음 먹었으면 가고자 하는 방향을 뚜렷이 잡을 필요가 있어.
프로그래머라는 직업이 언어 통달한다고 되는게 아니거든. 이런건 회사에서도 얼마든지 배울 수 있어.
정작 중요한건 프로그래밍을 하기 위한 밑바탕이야.

그럼 밑바탕이 뭐냐고 묻고 싶겠지? 짧게 말해서 인생이야. 조낸 어이없지.
그럴 수 밖에 없어. 컴퓨터는 도구거든. 뭔가를 하기 위한 도구지 목적이 아니야.
이 뭔가를 중요하게 생각하고 공부를 해야지 언어에만 매달린다고 되는게 아니거든.
사회, 정치, 문화, 산업, 경제 기타 등등 사회 전반에서 일어나는 모든 일들이 프로그래머의 영역이야.
프로그래머라는 직업을 좀 더 좁혀서 내가 하고 있는 임베디드 프로그래밍이라는 거에 눈을 돌려보자고.

임베디드 프로그래밍도 수만가지야. PDA, 휴대폰, DMB, 와이파이, 블루투스, 카메라, MP3, TV, 엘리베이터, RFID, 산업용 로봇, 자동차 CAN, 오디오, 네트웍 서버
너무 많아서 더 생각도 안난다. 하튼 세상에 전자가 움직이는 곳이라면 다 포함되는게 임베디드야.
이제 감이 좀 와? 와 시밤 뭘 해야되지? 생각 드는 &#54973;있지? 없을리가 없어.
왜? 아직 내가 가야할 길을 못잡았거든. 막막하지?
그래서 일단 내가 가고 싶은 길을 먼저 정해. 그래야 길이 트여도 트이는 거 아니겠어.

막상 이렇게 방향 잡고 갈라니까 걱정되지? 길을 너무 좁게 잡는거 같아서.
근데 반대로 생각해보자. 시간은 흘러흘러 학교 공부 마치고 취업을 할 때가 왔어.
A라는 &#54973;은 &#54973;들처럼 목표를 뚜렷이 못 세우고 학교공부 충실히 해서 일단 졸업했어.
B라는 &#54973;은 학교 공부도 충실히 하면서 예전에 가진 꿈을 위해서 책도 보고 자료도 뒤져보고 심심할 때마다 관련된 프로그래밍도 해봤어.
집합 관계 설정 돼? 응 맞어. B가 A보다 최소한 한 부분은 똑똑해. 이게 취업할 때는 별로 크게 안보여.
직장다녀보면 신입 면접 볼 때 다 거기서 거기 같거든. 별로 차이도 없어.
근데 일단 취직해서 배워나가는 속도는 B 쪽이 빨러. 물론 B가 꿈꿔온 분야라는 가정하에 말이지.
그럼 이제 B가 꿈꿔온 분야가 아니라고 가정해보자. A랑 B랑 차이가 있을 꺼 같어? 똑똑하네. 맞어. 없어.
같이 수업 듣고 같이 졸업했는데 차이 날게 없지. 대신 B는 A와 색다른 시각을 가지게 돼.
B는 B가 공부해온 분야랑 스리슬적 짬뽕되기 시작하거든. 그럼 아이디어 뱅크로도 앞설 수 있지.

그렇다고 학교공부 등한시 하라는 건 아냐. 그건 프로그래머로써의 기본자질이니까.
이제 &#54973;아들이 뭐 공부하면 좋을까요? 하는 질문에 약간 답이 됐을라나 몰라.
그리고 가능하면 인문계열 수업 도강을 해서라도 두어과목 듣는거 매우 추천해. 도강하더라도 숙제는 하고.
왜냐면 말이야 공돌이는 1+1=2라고 고정관념이 생기거든. 처음에도 말했지만 사회 전반에 일어나는 일을 프로그래밍 하는 거잖아.
그럼 사회에도 관심을 가지고 넓은 사고를 할 필요가 있지. 신문이랑 저널 많이 봐둬. 회사가면 보고 싶어도 많이 못 봐. 일에 치여서 말이야.
다들 잘하고 있겠지만 난 학교다닐 때 인문계열 수업 안 들은게 뼈저리게 후회되거든. 보고서 작성할 때 눈물나. 조낸 뻐덩뻐덩한 공돌이라서 글도 잘 안써져.
거기다 목표를 못 세우고 중구난방 공부한게 너무 아까워.

그리고 마지막으로 언어는 하나 제대로 할 때까지 확실히 하고 다른 언어는 개념만 잡아놔.
추천하는 언어는 C랑 VB. Java나 C#이나 C++이나 C 문법에서 크게 벗어나는게 없어. VB는 파워빌더같은 복병이 있기 때문이지.
그리고 컴퓨터의 입장에서 생각하는 버릇은 꼭 들여.

한줄요약) 자세한 건 생략한다. 쓸데없는 찌질이글 읽어줘서 땡큐 	

==== 어셈블리어 공부하겠다는 사람들 봐라 --- 스미골행이 ====
근데 문제는... 어셈블리어에 대해 오해(?)를 하는 사람들이 많다는 거다. 혹시 어셈블리어 하겠다는 사람 중에 그런 오해를 가진 사람이 있다면 빨리 개념을 탑재할 수 있기 바란다.

[오해 1] 일반 언어(씨, 비베, 씨샵 등)로 안되는 것도 어셈블리어로는 다~ 된다.
혹시 이런 생각 가지고 있다면 버리기 바란다. 어셈블리어도 그냥 언어일 뿐이다. 물론 부트 로더나 커널의 초기 코드를 만들겠다면 부득이하게 어셈블리어를 써야 하는 상황도 있긴 한 건 사실이지만(예를 들면 8086 리얼 모드에서 32bit protected mode로 전환하고 페이징 비트를 켜는 것 등), 그나마 그것도 기껏해야 몇백줄 안된다. 범용적 OS 상에서 실행되는 일반 응용 프로그램을 만드는 것이라면, 씨로 할 수 있는 거나 어셈블리어로 할 수 있는 거나 별반 차이 없다. 어차피 어셈블리어를 써도 다 시스템 콜(or Win32 API) 호출하는 수밖에 없다.

[오해 2] 아래 사람이 리플로 달아 줄 거다.

다음은 내가 예전에 올렸던 리플이다.

 1. '''스미골행''''  NASM을 다루는 PC Assembly Language (Dr. Paul) 한번 인터넷에서 찾아봐. 저자가 PDF로 무료 공개한 책인데, 아주 괜찮아. 처음 보는 사람 용으로 말야. 그리고 Programming Ground Up 이것도 저자가 무료로 PDF 공개한 건데, 이건 GAS(GNU Assembler) 위주야. 그리고 Introduction to 80x86 Assembly Language and Computer Architecture라는 책은 원래 책으로 나온 건데 .CHM으로 구할 수 있어. 이 책은 MASM 위주인데, 괜찮아. 이 3권 모두 32bit protected mode에서의 어셈블리어 프로그래밍을 다뤄. 하여간 내가 이야기한 순서대로 3권만 보면 괜찮을 거야. 

 1. ''''스미골행''''  그리고 이 3권을 보면서 항상 참고해야 하는게, 바로 인텔 메뉴얼이야. 흔히 IA-32 IASDM이라고 하는 총 3권짜리 책이 있어. 이건 인텔 홈페이지에서 받을 수 있어. 

 1. ''''스미골행''''  http://www.drpaulcarter.com/pcasm/ 이 주소가 Dr. Paul Carter의 PC Assembly Language 홈페이지야. 거기가서 받아봐. 

 1. ''''스미골행''''  그리고 참고로 내가 이야기한 3권의 책에서 다루는 어셈블러는 각각 NASM, GAS, MASM인데, 약간씩 문법이나 semantic이 달라. 근데 상관 없어.. 주로 directive나 operand 순서가 다른 정도니까. 

 1. ''''스미골행''''  그리고 위에 행이 추천한 AOA(Art Of Assembly)는 HLA(High Level Assembly)라는 걸 다루는데, 내 소견으로는 그건 초보용은 아니다. 

==== 프로그램밍 카운터에 대한 질문 - gyubi22 ====

 가장 이해가 안되는 부분이 있슴다.

바로 'Program Counter를 증가시킨다'는 부분인데요.

Question1. 숫자처럼 1,2,3 이런식으로 증가하는 개념인가요?

Question2. 증가하는 단위는 일정한가요?

Question3. PC증가시 다음 명령을 가리킨다고 하는데요 그렇다면 가리키고 바로 실행되나요?        
                  바로 실행된다면 뭔가 멈추게해야할 조건도 있을거 같구요.. 아니라면 어떤
                  특수한 조건에서 실행되나요?


 1.  ''''자바하는넘''''  	어 그게 말이지... 풋네기ㅎㅛㅇ이 설명해 줄거야.  	
 1.  ''''gyubi22'''' 	-_ㅠ 일단 그럼 아침까진 책과 구글을 최대한 디비봐야겠네요 -_- 	
 1.  ''''자바하는넘'''' 	아놔 수업했었으면 이해가 되야지 ㅋㅋ. 이 형 강의 노트 보고 시뮬레이터 돌려봐. http://sjlee.sch.ac.kr/lecture/arch/05-2-arch.htm 그래도 이해안되나.
gyubi22 	흠. 네 해보겠슴다! -_- 	
 1.  ''''자바하는넘'''' 	굳이 내가 구라를 친다면... q1 바이너리도 숫자지 숫자가 증가하는거겠지.
 1.  ''''자바하는넘'''' 	그 숫자가 저장되는게 메모리에 어떤의미있는 단위로 저장되겠지. 넘어렵게 생각하지말고. 이 사람도 말하는게 원론적인걸 말하는거니까. ㅎㅛㅇ아가 ㅎㅛㅇ컴퓨터를 십진수 짜리로 만든다고 생각하고 테이블을 그려봐. 	
 1.  ''''자바하는넘'''' 	q3. 그게 좀 컴맹가는 사람 마음인데.. 임풀리멘테이션에 따라 PC가 무었을 가르치고 무엇을 실행하는지는 다를 수 있다고 봐. 물론 구라지. 보통... fetch를 하자마자 프로그램카운터가 증가되고 그게 다음 인스트럭션을 가르치지 이미 불러들인(fetched) 명령이 실행되고. 	
 1.  ''''대학원생'''' 	컴퓨터구조 수업을 어떻게 들었으면 듣고도 모르는거죠. OTL
 1.  ''''대학원생'''' 	프로그램이 수행될 때 code가 메모리에 load됩니다. 보통 기계어코드 하나가 4byte(32bit)니까 기계어코드 20개 짜리 프로그램이라면 80byte만큼 메모리가 할당된후에 여기에 프로그램이 code가 load되죠. 	
 1.  ''''대학원생'''' 	그 리고 프로그램이 시작할 때 PC값은 위에서 할당받은 메모리의 맨 앞을 가리킵니다. 그 후 기계어코드 하나 수행하고 PC값을 4만큼 증가시키고 또 하나 수행하고 PC값을 4만큼 증가시키고 그렇게 되는 겁니다. 4인 이유는 기계어코드 하나가 4byte니까요. 
 1.  ''''대학원생'''' 	PC 값이 증가한다고 바로 수행되는건 아니고 다음 cycle에 instruction을 fetch할 때 그 효과가 나타나겠죠. branch같은게 있으면 PC값을 바꿔줘서 다음 싸이클에서 branch target에 있는 instruction을 fetch하게 됩니다. 	
 1.  ''''대학원생'''' 	요약:PC값은 일종의 포인터 변수라고 생각하시면 됩니다. 가리키고 있는 대상은 메모리에 위치한 code영역. 	
 1.  ''''푼내기'''' 	a1. 32비트 머신에서는 일반적으로 16진수 2씩 증가. 	
 1.  ''''푼내기''''	a2. 일반적으로는 일정하지 말입니다. 
 1.  ''''푼내기'''' 	a3. 이 질문이 헤깔린다는 건 컴퓨터의 입장에서 생각하고 있지 못하고 있다는 것인데 컴퓨터는 한 번에 하나의 명령만 처리하잖아. fetch, increase pc, excution 이 3과정이 1사이클라고 해도 순서대로 일어나게 되는거니까 fetch를 해서 메모리에 있는 code를 가져오고 (아직 실행은 안하고) pc 값을 적절히 증가시키고 아까 불러온 명령만 수행하는 거지. 멈추게 하는거? 그런거 없어. 멈춘다는 건 cpu가 halt 된다는 소리야. cpu가 halt 되면 reset 외에는 다시 깨울 수 있는 방법이 없어. 	
 1.  ''''푼내기'''' 	오 해할까봐 하는 말인데 pc를 적절히 증가시킨다는 건 임의대로 막 증가시킨다는 말이 아니고 정해진 값만큼만 바꿔. 32bit 시스템이면 2만 증가. if나 while이나 for나 goto 같은 게 나와서 순서대로 증가하지 않는 경우에는 pc값을 바꾸는 명령을 쓰게 되는거지. q1, q2, q3 이건 차차 어셈블리 배워가면서 이해하게 될꺼야. 지금 당장은 이해가 안되도 좀만 진행하다 보면 지금 한 말인지 아~~ 시밤 이런거였구만. 조또 별거 아니네. 프겔ㅎㅛㅇ들 개구라장이들. 하는 날이 올꺼야.
 1. ''''안방거사''''  	보통은 PC와 AR이나 index register와 같이 사용하오.


=== SPIM 에뮬레이터 ===
아마도 이글을 읽고 있는 대부분이 Intel 기반의 CPU가 장착된 PC를 사용하고 있을 것이다. 이러한 사용자를 위한 SPIM 에뮬레이터가 있으니, 에뮬레이터를 다운 받아서 학습을 하면 많은 도움이 될 것이다.
 * http://www.linux-mips.org/wiki/Emulators
{{{#!comment
yundream
개인 Linux박스에 Spim 에뮬레이터 설치해서 테스트 해봐야 겠네요. 완성되면 사용기 올리겠습니다.
}}}


=== 프겔&#54973;들이 수집한 링크들 ===
 1.  [http://weekly.chosun.com/wdata/html/news/200602/20060215000037.html 컴퓨터역사]
 1.  [http://webster.cs.ucr.edu/ 어셈공부서모음]
 1.  [http://64.233.179.104/search?q=cache:aZuj_gAit60J:krcogsci.snu.ac.kr/journal/db/7-2-3.hwp+%ED%94%BC%EB%8F%99%ED%98%95+%EC%A0%91%EB%AF%B8%EC%82%AC&hl=ko&gl=kr&ct=clnk&cd=4&lr=lang_ko&client=firefox 번역을위해]
 1.  [http://cs.sungshin.ac.kr/~dkim/team1.html 전자계산일반1] [http://cs.sungshin.ac.kr/~dkim/team2.html 전자계산일반2]
 1.  [http://www.terms.co.kr/ 컴퓨터용어사전]
 1.  [http://cse.stanford.edu/class/sophomore-college/projects-00/risc/ RISC_ARCITECTURE]

=== 번역관련 의견 게시판 ===
 [wiki:Site/Assembly/Documents/Spim/spim-chapter1/board 게시판]
=== 디렉토리 검색 ===
[[subindex(Site/Assembly/Documents/Spim/spim-chapter1,1)]]

----
CategoryLanguage
