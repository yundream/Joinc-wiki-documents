== 11장 고수준 언어 ==
이번 장에서 우리는 실제 응용되는 다양한 프로그래밍 언어에 대해서 토론해보도록 할 것이다. 우리가 지금까지 배운 어셈블리 언어는 기계수준의 언어이다. 기계수준의 언어이니 만큼, 언어를 배우는 자체만으로도 기계를 이해하는데 많은 도움을 주며 또한 섬세하게 기계를 다룰 수 있도록 도와주지만 반면, 사용하기에 너무 번거롭고 어렵다는걸 발견하게 될것이다. 사람은 기계와 다르기 때문이다. 그래서 좀더 인간이 사용하기 쉬운 다양한 언어가 만들어 지게 되었다. 당신은 아래와 같은 잇점을 얻을 수 있기 때문에, 어셈블리외의 다양한 언어에 대해서 알아볼 필요가 있다. 

 * 여러 가지 프로그래밍 언어들은 다른 개념에 기초를 두고 있고, 이는 프로그래밍 방법과 아이디어를 배우는데 도움이 된다.
 * 여러 가지 프로그래밍 언어들은 다양한 프로젝트를 수행하기에 용이하다.
 * 회사들 마다 사용하는 주 개발 언어가 다르다. 따라서 다양한 프로그래밍 언어를 아는 개발자는 좋은 조건으로 취직할 수 있는 더 많은 가능성을 가지게 된다. 
 * 프로그래밍언어를 많이 알면 알수록 새로운 언어를 익히기 수월하다.

보통 프로그래머처럼, 당신도 때때로 새로운 프로그래밍 언어를 익혀야할것이다. 숙련된 프로그래머는 보통 새로운 언어를 익히는데 대략 일주일 정도의 시간이 걸린다. 프로그래밍언어들은 단순한 도구이다. 그래서 새로운 툴을 사용하기 위한 배움은 실제로 당신이 컴퓨터 컨설팅 업무를 하고 있다면 계속 일을 하기 위해서 끊임없이 새로운 프로그래밍 언어를 배워야 할 것이다. 왜냐하면 종종 어떤 개발 언어를 사용해야 하는지 결정하는 것이 당신보다 고객에 의해서 결정되어지기도 하기 때문이다. 예를 들어 당신이 기업환경에서 이미 만들어진 시스템에 추가되는 프로그램을 만든다면, 자바를 이용해서 프로그램을 만들도록 강요당할 수도 있다. 이번 장에서 몇몇의 유용한 언어들을 소개할 것이다. 나는 당신이 흥미를 느끼는 한 많은 언어를 접해보기를 권장한다. 본인도 꾸준히 새로운 언어를 배우기 위해 노력하고 있다.

=== Compiled and Interpreted Languages ===
많은 언어들이 컴파일 되는 언어들이다. 어셈블리를 사용할 경우 각각의 명령어들은 프로세스당 하나의 명령어로 변환된다. 컴파일러를 통하면 하나의 문장은 하나에서 많게는 수백 개의 기계어로 실제로 사용하는 컴파일러가 지능적일수록 더 나은 성능을 위해 부분적으로 재구성되기도 한다. 어셈블리의 경우, 쓰는 코드가 곧 결과물이다. 

한편으로 인터프리터 방식의 언어가 있는데, 사용자가 프로그램을 실행시키기 위해서는 해석기 interpreter라고 불리는 프로그램이 필요하다. 이것은 해석기가 코드를 읽고 해석해야 하기 때문에 보통 컴파일 된 프로그램보다 느리다. 잘 만들어진 해석기 일지라도 컴파일된 프로그램보다 더 느릴 수 밖에 없다. 그렇지만 잘만들어진 인터프리터라면 그리 큰 문제가 되지 않을 수도 있다. 또한, (자바와 같은) 하이브리드 언어가 있는데 이러한 언어는 byte-code로 실행되기 전에 부분적으로 컴파일된 코드를 만들기도 한다. 해석기가 일반언어를 읽는 것보다 byte-code를 읽는 것이 훨씬 빠르기 때문이다.

어떤 방식의 언어를 선택할런지 결정하기 위해서는 서로의 장단점에 대해서 생각을 해봐야 한다. 우선 컴파일 된 프로그램은 사용자의 컴퓨터에 해석기를 설치하지 않아도 되기 때문에 편리하다. 프로그래머는 (실행파일을 만들기 위해) 컴파일러가 필요하지만 프로그램을 사용하는 사람은 프로그램만 제공되어지면 된다. 반면 인터프리터 언어의 경우는 당신이 작성한 프로그램을 사용자가 사용할 수 있도록 하기 위해 해석기가 설치되어 있는지 확인해야 하고, 작동되는 컴퓨터는 어떤 해석기로 프로그램을 실행해야 하는지 알고 있어야 한다. 대신 인터프리터 언어의 경우 해석기만 설치되어 있다면, 어느 운영체제하에서든지 동일하게 작동 될 것을 보장할 수 있다. 컴파일러 방식의 언어의 경우 완성된 기계어 프로그램이 만들어짐으로, 반드시 해당 운영체제에서 컴파일된 프로그램을 다시 생성해 내야만 한다. Linux, Solaris, HPUX, AIX에서 작동하는 컴파일된 프로그램을 만들기를 원한다면, 여러분은 각 운영체제환경에서 일일이 컴파일을 해주어야 한다. 이 작업은 때때로 매우 힘든 작업이 될 수 있다.  

이상에서 인터프리터 언어가 유연한 반면, 컴파일언어는 다소 엄격하다는 것을 알 수 있을 것이다. 개발 언어의 선택은 컴파일 또는 인터 프리터 방식인지보다는 프로그래밍에 유용한 툴과 개발방법에 따라 결정된다.
실제로 많은 고수준의 언어들이 둘중하나의 방식을 취하고 있다. 

컴파일방식이든, 인터프리터 방식이든간에, 고수준언어는 기계가 아닌 프로그래머를 위해 만들어진것이다.  다시말해, 아래와 같은 다양한 기능들이 가능하다는 것이다.  
 1. 단일식에서 복수연산자 조합
 1. "큰 값"의 사용가능 : 컴퓨터가 취급하는 4byte의 데이터외에 추상적인 데이터 구조를 만들어서 사용할 수 있다. 
 1. 단순 jump 분기보다 향상된 분기제어 구조들
 1. 컴파일러는 여러가지 타입을 체크해준다. 
 1. 자동으로 관리되는 메모리
 1. 주어진 문제를 가장 잘 해결할 수 있는 언어를 선택해서 사용할 수 있다. (어떤 언어는 수치연산을 하는데 최적화 된 반면, 어떤 언어는 업무 프로세스를 수월하게 처리할 수 있다.) 

예를 들면, 많은 개발자들이 대부분의 프로토콜과 데이터 타입을 핸들링 할 수 있다는 이유로 펄을 선택한다.  파이썬은 깔끔한 문법을 가지고 있고 보다 직접적인 솔루션을 제공한다. wxpytone 과 같은 훌륭한 cross-platform GUI 제작 툴도 제공한다. PHP의 경우 웹어플리케이션을 단순하게 작성할수 있게 한다. Common Lisp은 배우려하는 사람에게 뛰어난 기능을 제공한다. Scheme는 단순함과 강력함의 모델이고 C언어는 다른 언어들과 인터페이싱하기 쉽다.

각 언어들은 차이를 가지고 있다. 따라서 당신이 더 많은 언어를 알수록 더 나은 프로그래머가 될것이다.
언어들간의 차이점을 안다는 것은 프로그래밍에 많은 도움이 될것이다. 해결해야할 문제들에 적절한 언어를 적용할수 있기 때문이다. 

이러한 이유로 당신은 작업을 위한 많은 종류의 도구를 가지고 있을 필요가 있다. 그렇게 되면 설사 어떤 언어에서 몇몇의 기능이 지원되지 않더라도 그런 기능들의 대안을  쉽게 마련할수 있다. 간단한 예로 C언어는 강력하지만 문자열을 처리하는데에는 취약하다. 이경우 여러분은 Perl을 이용해서 문자열을 처리하는 부분을 작성해서 C와 연결할 수도 있다.  

=== Your First C Program ===
여기 당신의 첫번째 C 프로그램이 있다. 이 프로그램은 화면에 "Hello world"라는 내용을 출력하고 종료된다.

{{{#!plain
#include <stdio.h>
/* PURPOSE: This program is mean to show a basic */
/* C program. All it does is print */
/* "Hello World!" to the screen and */
/* exit. */
/* Main Program */
int main(int argc, char **argv)
{
	/* Print our string to standard output */
	puts("Hello World!\n");
	/* Exit with status 0 */
	return 0;
}
}}}

보는 바와 같이 , 정말 단순한 프로그램이다. 
"gcc -o HelloWorld Hello-World.c" 명령으로 컴파일하고 "./HelloWorld" 로 실행한다.
코드의 내용을 자세히 살펴보자.

{{{#!plain
/* ~ */
}}}
"/*"로 시작 해서 "*/" 로 끝마치는 것은 주석이다. 이 주석은 여러라인에 걸쳐 쓸수 있다.
그러나 대부분은 보기 편하도록 한 줄에 기록하는 편이다.

{{{#!plain
#include <stdio.h> 
}}}
위의 코드는 프로그램의 첫 부분으로 "전처리기(또는 선행처리기)"라고 한다. C 컴파일러는 두단계로 나뉘어 컴파일을 진행하는데, 이때 동작하는 것이 전처리기와 메인 컴파일러다. 이 지시어는 전처리기에게 stdio.h 파일을 찾아서 당신의 프로그램에 추가하게 되는데 이 역할을 전처리기가 하게 된다. 다른 파일과 연결하고 매크로를 실행하는 등의 일을 진행한다. 전처리기가 텍스트를 편집한뒤에, 다음의 작업을 위해 메인 컴파일러가 실행된다.

위의 작업으로 사용자가 Stdio.h 을 직접 입력한것처럼 취급된다. 파일이름을 감싸고 있는 각진 괄호(< >)는 컴파일러에게 이것이 표준경로라는 것을 알려준다. (일반적으로, /usr/include and /usr/local/include )
만약 각진 괄호 대신 쌍따옴표(" ")가 오게 되면 컴파일러는 파일을 찾기위해 현재의 디렉토리를 검색한다.  결과적으로 Stdio.h는 표준입/출력함수를 선언하고 이 선언은 컴파일러에게 입력과 출력이 가능하다는 것을 알려준다.  Include 다음에 프로그램에 대한 간단한 코멘트가 나오고 실질적인 코드가 나온다.

{{{#!plain
int main(int argc, char **argv)
}}}
위의 코드는 함수의 시작점이다. C언어에서 함수는 함수의 이름, 아규먼트, 반환값으로 구성되어 있다. 위의 코드를 보면 함수의 이름은 "main"이고 int형의 반환값을 가지며, 두가지의 아규먼트를 가진다는 것을 알수 있다. C언어의 경우 사용자의 입장에서 이러한 아규먼트가 어떻게 스택에 쌓이는지에 대해서 신경쓸 필요가 없는데, 이는 C 컴파일러가 대신 관리 해주기 때문이다. 또한 CPU 레지스터의 입력과 출력 또한 신경쓸 필요가 없다 Main함수를 C언어에서는 특별하게 취급하는데, 이는 프로그램의 시작위치가 되기 때문이다. (어셈블리의 _start 를 생각하면 이해가 쉽다.) 이 함수는 늘 두개의 파라미터를 가지는데 첫번째 파라미터는 아규먼트의 개수를 지정하고 두번째 파라미터는 해당 아규먼트의 리스트를 말한다.

다음라인은 함수 호출 부분이다. 어셈블리의 경우 함수를 사용하기 위해서는 사용자가 직접 스택에 아규먼트를 넣어준뒤 함수를 호출해야 한다. 하지만 C언어에서는 사용자가 이런것을 신경쓸 필요가 없다. 단지 괄호안에 파라미터를 넣고 함수를 호출하면된다. 위의 코드에서 사용되는 put함수의 경우는 하나의 파라미터 만을 필요로 하는데 출력하려는 문자열이다. 사용자는 단지 상따옴표안에 출력하고자 하는 글자만 넣어주면된다. 그러면 컴파일러는 스택저장소를 확보하고 그 저장소의 포인터를 함수가 호출될때 스택에 지정하게 된다.  한결 간편함을 알 수 있다.

최종적으로 함수는 숫자 0을 반환한다. 어셈블리의 경우 사용자는 반환값을 레지스트리 exa에 저장한다. 그러나 C언어에서는 사용자는 단지 "return" 명령어면 사용하면된다. Main 함수의 반환값은 프로그램 종료시 사용된다. 이처럼, 고수준 언어는 프로그램 작업이 한결 수월하다. 또한 다른 플랫폼으로 이식될때도 어셈블리보다 상대적으로 수월하게 이식할수 있다. 어셈블리로 작성된 프로그램의 경우 운영체제와 하드웨어에 밀접하게 묶여있다. 반면 컴파일언어와 인터프리터 언어는 이러한 제약에서 한결 자유롭다. 예를들면, 위의 프로그램은 x86기반의 대부분의 운영체제에서 동작한다.

C프로그램 언어에 대해서 더 알고자 한다면 Appendix E를 참고 하기 바란다.
 
=== Perl ===
펄은 리눅스와 유닉스운영체제의 대부분에 포함되어 있는 인터프린터 언어이다. 거의 모든 플랫폼에서 작동하고 당신도 리눅스와 유닉스 환경에서 그것을 가장 빈번히 찾게될것이다. 여기 펄로 작성되고 Hello-World.pl이라고 이름지어진 프로그램이 있다. 

{{{#!plain
#!/usr/bin/perl
print("Hello world!\n");
}}}

Perl은 인터프리터방식의 프로그램이므로 이 코드를 컴파일 하거나 링크 할 필요가 없다. 단지, 아래처럼 명령행에 입력하기만 하면 된다.

{{{#!plain
perl Hello-World.pl
}}}

보는바와 같이, 동일한 작용을 하는 프로그램임에도 불구하고 Perl버전은 C언어버전보다 짧다. C처럼 어떤 함수를 선언하거나 프로그램의 시작 지점을 지정할 필요가 없는 것이다. 단지 당신은, 명령어를 치면되고 인터프리터는 이에 따라 실행을 하게된다. 이 프로그램은 단지 두줄이지만 그중에 한줄은 옵션이다.

코드의 첫라인은 유닉스환경에서 인터프리터에게 프로그램 실행에 필요한 환경정보를 알려주는 라인이다. "#!"는 컴퓨터에게 '이것은 인터프리터 프로그램이다.'라는 것을 말해주고, '/usr/bin/perl'은 프로그램을 실행하기 위해서 컴퓨터에게 해당경로를 알려준다. 

우리가 'perl Hello-World.pl'이라고 입력해서 실행하였기 때문에 우리는 이미 perl 인터프리터를 사용할것이라고 알린것이다. 다음 줄은  Perl의 내장 함수인 'print' 호출하는 코드이다. 이 함수는 문자열로된 한 개의 파라미터를 필요로한다. 그리고 이전의 C언어와는 달리 명시적으로 'return'문장을 쓰지 않는다. 단순히 코드의 끝부분에 이르면 프로그램이 종료된것으로 안다. 실행한 프로그램이 아무 오류없이 종료되었다면 반환값이 0인것으로 간주한다. 인터프리터 언어를 사용하다보면 사용자에게 많은 잡다한 작업 없이 빠르게 코드를 쓸수 있도록 한다는 것을 알수 있다.

이 함수에서 알수 있는 Perl에 관한 한가지 사실은 Perl이 단일값을 스트링으로 다루는 것이 그다지 명확하지 않다는 것이다. 어셈블리의 경우 작업하는 컴퓨터의 메모리 아키텍쳐에 종속되어서 프로그래밍을 해야 한다.  이말은 문자열은 첫문자가  포인터로 지정된 여러값의 순서의 묶음이라는 것이다. 반면에, Perl은 그 값을 마치 저장된 단일값처럼 취급해서 사용자에게 문자열 조작의 복잡함을 감춘다. 실제로, Perl의 강점중 하나가 문자열 처리의 편리함과 신속함이기도 하다.

=== 파이썬 ===
파이썬의 코드는 펄과 무척 비슷하지만 실제로는 상당히 다른 언어다. (하지만 아래의 예제에서 그런 부분을 많이 확인하기는 힘들다.) Hello-World.py 의 이름으로 아래와 같은 코드를 작성해보아라
{{{#!plain
#!/usr/bin/python
print "Hello World"
}}}
당신은 프로그램코드가 어떻게 틀린지 말할수 있어야 한다.

=== 복습하기 ===

컨셉을 알아라
인터프리터 방식과 컴파일 방식 프로그램 언어의 차이는 무엇인가?
당신이 새로운 언어를 배워야하는 필요는 무엇때문인가?

컨셉을 사용하라
새로운 언어의 문법을 배워라 이책의 프로그램을 다시 작성해보아라
??? In the program you wrote in the question above, what specific things were automated in the programming language you chose?
어셈블리와 당신이 아는 다른 새로운 언어를 써서 한 줄당 10,000번을 실행시켜라. 그 후, time 명령어를 통해 어떤것이 더 빠른지 보아라 어떤게 더 빠른가? 왜 그렇다고 생각하는가?
프로그램언어의 입/출력 메서드는 리눅스의 시스템 콜과 어떻게 다른가?

Going Further
당신은 Perl 같은 단순 명료한 언어들을 두고 왜 어셈블리같은 장황한 언어를 배우려고 하는가?
당신은 고수준 언어가 프로그래밍 하는 과정에 어떤 영향을 준다고 생각하는가?
당신은 왜 많은 언어들이 존재 한다고 생각하는가?
2개 이상의 고수준 언어를 배워보고, 각기 다른 점을 비교해보라. 그것들은 어떻게 유사한가? 각자 어떻게 문제를 처리하는가?
