Describe docbook_fcntl(2) here
 * 미완성
{{{#!plain
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<chapter lang=ko>
<!-- 작성자 : yundream             -->
<!-- 작성일 : 2004/01/14           -->
<!-- 연락처 : yundream@joinc.co.kr -->

<!-- 함수 이름을 입력합니다 -->
<title>fcntl(2)</title>

<!-- 이건 함수에 대한 대략적인 설명이구요 -->
<para>
	파일 지정자의 조작
</para>
 
<!-- 여기에 함수의 간단한 사용법이 들어갑니다 -->
<section>
	<title>사용법</title>
	<para>
		<screen>
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int fcntl(int fd, int cmd);
int fcntl(int fd, int cmd, long arg);
int fcntl(int fd, int cmd, struct flock * lock);
		</screen>
	</para>
</section>

<!-- 여기엔 함수의 자세한 설명 이 들어갑니다 -->
<section>
	<title>설명</title>
	<para>
		fcntl()은 인자로 주어진 파일 기술자<emphasis>fd</emphasis>에 대해서 
		여러가지 연산을 수행한다. 연산의 종류는 <emphasis>cmd</emphasis>에 
		의해서 결정된다.
	</para>
	<para>
		다음은 가능한 연산 <emphasis>cmd</emphasis>의 종류다.
		<variablelist>	
			<varlistentry>
			<term>F_DUPFD</term>	
			<listitem>
				<para>	
					dup(2)와 매우 비슷한데  파일이 복사될 때 
					<emphasis>arg</emphasis>보다 
					크거나 동일한 가장 낮은 숫자를 파일 지정번호로 하고, 그것을
					<emphasis>fd</emphasis>의 복사본이 되도록 한다. dup2(2)의 
					경우 엄밀하게 지정된 기술자를 사용한다.  
				</para>
				<para>
					오래된 그리고 새로운 기술자들은 교대적으로 사용될 수 
					있다. 이들은 잠금(lock), 파일 위치 포인터 그리고 플래그를 
					공유한다. 예를 들면 기술자중 하나에서 파일 위치가 lseek(2)를
					통해서 변경되었다면 다른 것도 변경될 수 있다. 
				</para>
				<para>
					두 기술자들은 close-on-exec 플래그를 공유하지 않는다. 그러나
					복제본의 close-on-exec 플래그는 기본적으로 off 상태가 된다. 
				</para>
				<para>
					성공하면 새로운 기술자가 리턴된다.	
				</para>
			</listitem>
			</varlistentry>
			<varlistentry>
			<term>F_GETFD</term>
			<listitem>	
				<para>
					close-on-exec를 읽는다. 만일 <emphasis>FD_CLOEXEC</emphasis>비트가 0이면, 
					파일은 exec를 통해 열린 상태로 남겨지고 그렇지 않으면 닫힌다.
				</para>
			</listitem>	
			</varlistentry>
			<varlistentry>
			<term>F_SETFD</term>
			<listitem>	
				<para>
					close-on-exec 플래그를 <emphasis>arg</emphasis>의 FD_CLOEXEC비트에 의해 
					지정된 값으로 설정한다. 
				</para>
			</listitem>	
			</varlistentry>
			<varlistentry>
			<term>F_GETFL</term>	
			<listitem>	
				<para>	
					파일 지정자의 플래그를 읽는다. open(2)의 의해 설정된 모든 
					플래그들도 리턴된다.
				</para>
			</listitem>	
			</varlistentry>
			<varlistentry>
			<term>F_SETFL</term>	
			<listitem>	
				<para>	
					<emphasis>arg</emphasis>에 의해 지정된 값을 파일 지정자의 플래그로 
					설정한다. 단지 <emphasis>O_APPEND</emphasis>,<emphasis>O_NONBLOCK</emphasis>
					<emphasis>O_ASYNC</emphasis>만이 설정에 사용될 수 있다. 다른 플래그들은 
					영향을 받지 않는다. 
				</para>
				<para>
					플래그들은 dup(2), fork(2)로 만들어진 파일 기술자의 복사본들 사이에
					공유된다.
				</para>
				<para>
					플래그의 자세한 설명은 open(2)를 참고하기 바란다.
				</para>
			</listitem>	
			</varlistentry>
		</variablelist>	
	</para>
	<para>
		F_GETLK, F_SETLK, F_SETLKW 들은 파일의 (권고)잠금을 관리하기 위한 
		목적으로 사용된다.	
		세번째 인자 <emphasis>lock</emphasis>는 구조체 flock에 대한 포인터다. 잠금은 
		레코드단위로 이루어질 수 있다.  flock구조체는 다음과 같다.
		<screen>
struct flock {
    ...
    short l_type;    /* Type of lock: F_RDLCK,
                        F_WRLCK, F_UNLCK */
    short l_whence;  /* How to interpret l_start:
                        SEEK_SET, SEEK_CUR, SEEK_END */
    off_t l_start;   /* Starting offset for lock */
    off_t l_len;     /* Number of bytes to lock */
    pid_t l_pid;     /* PID of process blocking our lock
                        (F_GETLK only) */
    ...
};
		</screen>
		<emphasis>l_whence</emphasis>, <emphasis>l_start</emphasis>, 
		<emphasis>l_len</emphasis> 필드는 파일에서 잠글 레코드의 범위를 지정하기 위해서 
		사용된다. 자세한 내용은
		<ulink url=http://www.joinc.co.kr/modules/moniwiki/wiki.php/article_fcntl을_이용한_파일_레코드잠금>fcntl을 이용한 파일 레코드 잠금</ulink>을
		참고하기 바란다. 
		<variablelist>	
			<varlistentry>
			<term>F_GETLK</term>	
			<listitem>	
				<para>	
					잠금이 있는 지를 알아낸다. 잠금이 있다면 flock구조체를 리턴하고 
					잠금을 얻을 수 있다면 잠금의 <emphasis>l_type</emphasis>필드를 
					F_UNLCK 으로 설정한다.  
				</para>
			</listitem>	
			</varlistentry>
			<varlistentry>
			<term>F_SETLK</term>
			<listitem>
				<para>
					<emphasis>l_type</emphasis>이 F_RDLCK 나  F_WRLCK 일 경우 사용가능하며  
					잠금을 요청하기 위해서 사용한다. 만약 다른 프로세스가 이미 잠금을 
					사용하고 있다면 -1을 리턴한다. <emphasis>errno</emphasis>는 
					EACCES 나 EAGAIN 이 설정된다.  
				</para>
			</listitem>
			</varlistentry>

			<varlistentry>
			<term>F_SETLKW</term>
			<listitem>
				<para>
					F_SETLK 와 마찬가지로 잠금을 요청하기 위해서 사용한다. 그러다 
					다른 프로세스가 잠금을 가지고 있더라도 에러를 리턴하지는 않고 
					얻을 수 있을 때까지 기다린다. 기다리는 중에 시그널과 같은 
					인터럽트(interrupted)가 발생하면 즉시 리턴한다. 
					이경우 -1이 리턴되고 <emphasis>errno</emphasis>로 EINTR이 설정된다. 
				</para>
			</listitem>
			</varlistentry>
		</variablelist>	
	</para>
	<para>
		fcntl()은 또한 시그널 관리를 위해서 F_GETOWN, F_SETOWN, F_GETSIG, F_SETSIG를 
		제공한다. 이들 명령을 이용해서 입출력과 관련된 시그널을 제어할 수 있다.  	
		<variablelist>	
			<varlistentry>
			<term>F_GETOWN/term>	
			<listitem>	
				<para>	
					파일 지정자<emphasis>fd</emphasis>에서 발생하는 
					SIGIO와 SIGURG 시그널을 받을 프로세스의 ID나 그룹 ID를 얻어온다. 
					프로세스 그룹일 경우 0보다 작은 수가 리턴된다.	   
				</para>
			</listitem>	
			</varlistentry>

			<varlistentry>
			<term>F_SETOWN/term>	
			<listitem>	
				<para>	
					파일 지정자<emphasis>fd</emphasis>에서 발생하는 이벤트인 SIGIO와 
					SIGURG를 받을 프로세스 ID나 그룹 ID를 지정한다. 프로세스 그룹으로 
					지정하길 원한다면 0보다 작은 수를 이용하면 된다. 
				</para>
				<para>
					만약 파일지정자에 O_ASYNC 플래그가 설정되어 있다면 
					(open(2)시 지정하거나 fcntl()을 통해 지정가능 하다.) 파일 지정자에 
					입출력 이벤트가 있을 때 SIGIO가 발생한다.
				</para>
			</listitem>	
			</varlistentry>

			<varlistentry>
			<term>F_GETSIG/term>	
			<listitem>	
				<para>	
					입출력 이벤트가 발생했을 때 시그널을 정송하도록 한다. 0은 SIGIO가 
					전송됨을 의미한다. 다른 값이 들어간다면 다른 시그널이 전송될 것이다.
					이런 경우 SA_SIGINFO가 시그널 핸들러에 설정되어 있다면 추가적인 
					정보를 사용할 수 있다. 
				</para>
			</listitem>	
			</varlistentry>
			<varlistentry>
			<term>F_SETSIG/term>	
			<listitem>	
				<para>	
					입출력 이벤트가 발생했을 때 시그널을 정송하도록 한다. 0은 SIGIO가 
					전송됨을 의미한다. (SIGIO를 포함한) 다른 값이 설정되었다면 해당 
					시그널이 전송된다. SA_SIGINFO가 시그널 핸들러에 설정되어 있다면 
					추가적인 정보를 사용할 수 있다.  
				</para>
				<para>
					F_SETSIG가 0이 아닌 값으로 설정되고 SA_SIGINFO가 시그널 핸들러에 
					적용되어 있다면(sigaction(2)참고) 입출력에 대한 부가적인 정보를 
					<emphasis>siginfo_t</emphasis>구조체를 통해서 받아 볼 수 있다. 
					다음은 siginfo_t 구조체의 구조다. 
					<screen>
typedef struct siginfo {
   int si_signo;     /* Signal number */
   int si_errno;     /* Error code */
   int si_code;
   pid_t si_pid;
   uid_t si_uid;
   void *si_addr; 
   union sigval si_value;
   union {
      /* Skipping other fields */
      struct {
         int _band;  /* Socket event flags (similar to poll) */
         int _fd;    /* Socket fd where event occurred */
      } _sigpoll;
   } _sifields;
}  siginfo_t;
					</screen>
				</para>
				<para>
					POSIX.1b Real Time Signal (value가 SIGRTMIN보다 클경우)이 
					선택되었다면, 다중의 입출력 이벤트를 큐(queue)에 담아서 
					관리할 수 있다. RTS에 대한 자세한 내용은 <xref linkend="refer">를 
					참고하기 바란다.
				</para>
			</listitem>	
			</varlistentry>
		</variablelist>	
	</para>
	<para>
		여기에서 제공하는 명령들을 이용하면 select(2)나 poll(2)의 사용없이 비동기적으로 
		입출력을 다룰 수 있다.  	
	</para>
	<para>
		O_ASYNC, F_GETOWN, F_SETOWN 은 BSD와 Linux에섬 사용가능하다. F_GETSIG와 F_SETSIG는 
		리눅스에서만 사용가능하다. 
		POSIX는 asynchronous I/O와 <emphasis>aio_sigevent</emphasis>
		구조체를 이용해서 fcntl(2)과 비슷한 구현을 만들 수 있다. 
		최근들어 리눅스도 이들을 지원하게 되었다.
	</para>
</section>

<!-- 함수가 되돌려주는 값이구요 -->
<section>
	<title>반환값</title>
	<para>
	</para>
</section>

<!-- 에러가 발생했을때 되돌려주는 값들입니다 -->
<section>
	<title>에러</title>
	<para>
		에러가 발생하면 (struct utmp *)0 을 되돌려준다.
	</para>
</section>

<!-- 마지막으로 에제 입니다                                                 -->
<!-- 여기에는 완전한 예제가 들어가 있는데, 굳이 완전한 예제를 만들필요 없이 -->
<!-- 코드 일부분만 작성해서 올려주셔도 됩니다                               --> 
<!-- "<", ">", "&" 등은 변환해 주셔야 하는데, 귀찮으시면 :-) 변환 하지 않   -->
<!-- 아도 됩니다. 제가 검사 해서 올리겠습니다                               -->
<!-- 예제에 대한 간단한 설명을 적어주셔도 되구요                            -->
<section>
	<title>예제</title>
	<para>
	</para>
</section>

<!-- 각종 참고문헌                      -->
<section id="refer">
	<title>참고문헌</title>
	<para>
	</para>
</section>
</chapter>

}}}
