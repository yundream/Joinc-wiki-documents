#title Basic Assembly Language   

|| 만든날 	|| 2003/12/20 						||<|4> http://www.joinc.co.kr/images/myavata/2.gif	||
|| 관리자 	|| yundream							||
|| 홈페이지	|| http://www.joinc.co.kr			||
|| 이메일	|| [mailto:yundream@joinc.co.kr]	||

[[TableOfContents]]

=== 교정 과정 ===
 1. 2003/12/10 문서작성 시작 

=== 토론및 잡담 ===

=== 소개 ===
[http://www.joinc.co.kr/modules.php?name=News&file=article&sid=150 어셈블리 소개]와 [http://www.joinc.co.kr/modules.php?name=News&file=article&sid=151]에 이은 3번째 어셈블리 스터디 문서로 어셈블리에서의 연산과 구조체 다루기(Control Structures)등에 대한 내용을 다룬다.     

==== 정수(Integer)에 대해서 ====
정수는 '''unsigned'''와 '''singned'''의 2가지가 있다. unsigned는 부호가 없는 정수를 말한다. 여기에서 부호란 (-)를 뜻하는 것으로 이를테면 양의 정수를 뜻한다. signed는 부호가 있는 정수로 양의 정수와 음의 정수 모두를 표현할 수 있다.   

Signed는 unsigned형 보다 좀더 복잡한 형태를 가진다. 컴퓨터의 입장에서 볼때 -56이나 +56이나 00111000으로 동일하게 표현이 된다. 단지 종이에 포현할 때 -56 -111000으로 표현될 뿐으로 컴퓨터 메모리의 입장에서는 같은 값이다. 그럼 어떻게 해당 값이 '''-'''인지를 알 수 있을까 ? 

컴퓨터는 '''-'''값을 구분하기 위해서 메모리에 signed int를 표현하기 위한 비트영역을 가진다. 이러한 비트를 sign bit라고 한다. 만약 이 비트 값이 0이라면 이 수는 양의 정수가 1이라면 음의 정수가 된다.  

이외에도 -값을 표현하기 위한 2가지 방법이 더 있고, 결국 -값을 표현하기 위한 3가지의 방법이 존재하는데 이들 방법에 대해서 알아보도록 하겠다.  

===== Signed magnitude(부호화 절대치) =====
일단 가장 간단하다고 생각되는 '''signed magnitude'''방법에 대해서 알아 보겠다. 이 방법에서는 int를 2영역으로 나눈다. 첫번째 영역은 sing bit영역이고 두번째 영역은 magnitude int영역이다. 이 방법을 이용하면 56은 '''0'''0111000 로 표시되고 -56은 '''1'''0111000 으로 표시된다. 가장 앞의 sing bit의 값을 이용해서 음의 정수와 양의 정수를 구분하고 있음을 알 수 있다. 이 방법을 이용한다면 가장 큰 양의 정수의 값은 '''0'''1111111(+127)이고, 가장 작은 값은 '''1'''1111111(-127)이 된다. 0의 경우도 '''0'''0000000(+0), '''1'''0000000(-0)로 표현할 수 있다. 뭐 그렇다고 해서 이게 코드 상에서 특별한 의미를 지니는 것은 아니다. 다만 이런 식의 표현이 가능하다는 정도로 알아두고 있으면 된다. 이 방식은 간단하긴 하지만 CPU입장에서 보면 논리적으로 복잡한 연산을 수행해야한다는 단점이 있다.     


===== One's complement(1의 보수) =====
이름에서 알수 있듯이 음수 표현시 0을 1로 1은 0으로 바꾸는 방법을 사용한다. 1의 보수에 의하면 '''0'''0111000(+56)의 음의 수는 '''1'''1000111(-56)이 된다. 1의 보수방벱의 경우 sign bit가 자동적으로 바뀐다는 점을 주목하기 바란다. 1의 보수를 이용해서 +0과 -0을 표현하면 각각 '''0'''0000000, '''1'''1111111이 된다. 

===== Two's complement(2의 보수) =====
기본적으로 1의 보수를 이용하는데, 여기에 +1을 더해주는 것으로 음수를 표현한다.
왜 굳이 복잡하게 1의 보수에 1을 더해주는지 궁금할 수 있을것 같다. 이렇게 하는 이유는 1의 보수의 경우 +0과 -0이 사실은 같은 값임에도 불구하고 서로 전혀 다른 바이너리 데이터를 가지는 문제를 해결하기 위함이다. 2의 보수법에 의하면 -0은 000000이 된다. 

'''0'''0111000(56)을 예로 들어서 설명해 보도록하자. 이 값의의 1의 보수의 값은 '''1'''1000111 인데, 여기에 다시 1을 더하면 2의보수 방식의 표현이 된다.  
{{{#!plain
 11000111
 +      1
---------
 11001000
}}}
다음은 2의 보수방식을 나타낸 표다. 
|| 숫자			|| Hex 값			||
|| 0			|| 00				||
|| 1			|| 01				||
|| 127			|| 7F				||
|| -128			|| 80				||
|| -127			|| 81				||		
|| -2			|| FE				||
|| -1			|| FF				||

=== 참고문헌 ===
 1. [http://www.joinc.co.kr/modules.php?name=Downloads&d_op=getit&lid=24 어셈블리 하우투]
